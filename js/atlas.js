/*!
MICROSOFT SOFTWARE LICENSE TERMS
MICROSOFT AZURE MAPS WEB SDK
These license terms are an agreement between you and Microsoft Corporation (or one of its affiliates). They apply to the software named above and any Microsoft services or software updates (except to the extent such services or updates are accompanied by new or additional terms, in which case those different terms apply prospectively and do not alter your or Microsoft’s rights relating to pre-updated software or services). IF YOU COMPLY WITH THESE LICENSE TERMS, YOU HAVE THE RIGHTS BELOW.  BY USING THE SOFTWARE, YOU ACCEPT THESE TERMS.
1. INSTALLATION AND USE RIGHTS.
  a) General. You may install and use any number of copies of the software to develop and test your applications.
  b) User Region Parameters. The software will allow you to select from a View list to set the map view within your application for a given customer. By default the View parameter (also referred to as “user region parameter” is set to “Unified”.  Countries/Regions that are not on the View list will default to the “Unified” View. It is your responsibility to determine the location of your users, and then set the View parameter correctly for that location. The View parameter must be used in compliance with applicable laws, including those regarding mapping, of the country where maps, images and other data and third party content that You are authorized to access via the software is made available. 
  c) Third Party Software. The software may include third party applications that Microsoft, not the third party, licenses to you under this agreement. Any included notices for third party applications are for your information only.
  d) Microsoft Online Subscription Agreement. Some features of the software provide access to, or rely on, Microsoft Azure Services. The use of those services (but not the software) is governed by the separate terms and privacy policies associated with your Microsoft Azure subscription. The services may not be available in all regions. For more information see https://go.microsoft.com/fwLink/?LinkID=522330&amp;clcid=0x9.
2. DISTRIBUTABLE CODE. The software is comprised of “Distributable Code”. “Distributable Code” is code that you are permitted to distribute in applications you develop if you comply with the terms below and otherwise set forth in these license terms. 
  a) Distribution Rights. 
    i. You may copy and distribute the object code form of the software.
    i. Third Party Distribution. You may permit distributors of your applications to copy and distribute any of this distributable code you elect to distribute with your applications.
  b) Distribution Requirements. For any code you distribute, you must:
    i. add significant primary functionality to it in your applications;
    ii. require distributors and external end users to agree to terms that protect it and Microsoft at least as much as this agreement; and
    iii. indemnify, defend, and hold harmless Microsoft from any claims, including attorneys’ fees, related to the distribution or use of your applications, except to the extent that any claim is based solely on the unmodified distributable code.
  c) Distribution Restrictions. You may not:
    i. use Microsoft’s trademarks or trade dress in your application in any way that suggests your application comes from or is endorsed by Microsoft; or
    ii. modify or distribute the source code of any distributable code so that any part of it becomes subject to any license that requires that the distributable code, any other part of the software, or any of Microsoft’s other intellectual property be disclosed or distributed in source code form, or that others have the right to modify it.
3. DATA COLLECTION. The software may collect information about you and your use of the software and send that to Microsoft. Microsoft may use this information to provide services and improve Microsoft’s products and services. Your opt-out rights, if any, are described in the product documentation. Some features in the software may enable collection of data from users of your applications that access or use the software. If you use these features to enable data collection in your applications, you must comply with applicable law, including getting any required user consent, and maintain a prominent privacy policy that accurately informs users about how you use, collect, and share their data. You can learn more about Microsoft’s data collection and use in the product documentation and the Microsoft Privacy Statement at https://go.microsoft.com/fwlink/?LinkId=512132. You agree to comply with all applicable provisions of the Microsoft Privacy Statement.
4. SCOPE OF LICENSE. The software is licensed, not sold. Microsoft reserves all other rights. Unless applicable law gives you more rights despite this limitation, you will not (and have no right to):
  a) work around any technical limitations in the software that only allow you to use it in certain ways;
  b) reverse engineer, decompile, or disassemble the software, or attempt to do so, except and only to the extent permitted by licensing terms governing the use of open-source components that may be included with the software;
  c) remove, minimize, block, or modify any notices of Microsoft or its suppliers in the software;
  d) use the software in any way that is against the law or to create or propagate malware; or
  e) share, publish, distribute, or lend the software (except for any distributable code, subject to the terms above), provide the software as a stand-alone hosted solution for others to use, or transfer the software or this agreement to any third party.
5. EXPORT RESTRICTIONS. You must comply with all domestic and international export laws and regulations that apply to the software, which include restrictions on destinations, end users, and end use. For further information on export restrictions, visit http://aka.ms/exporting.
6. SUPPORT SERVICES. Microsoft is not obligated under this agreement to provide any support services for the software. Any support provided is “as is”, “with all faults”, and without warranty of any kind.
7. UPDATES. The software may periodically check for updates, and download and install them for you. You may obtain updates only from Microsoft or authorized sources. Microsoft may need to update your system to provide you with updates. You agree to receive these automatic updates without any additional notice. Updates may not include or support all existing software features, services, or peripheral devices.
8. ENTIRE AGREEMENT. This agreement, and any other terms Microsoft may provide for supplements, updates, or third-party applications, is the entire agreement for the software.
9. APPLICABLE LAW AND PLACE TO RESOLVE DISPUTES. If you acquired the software in the United States or Canada, the laws of the state or province where you live (or, if a business, where your principal place of business is located) govern the interpretation of this agreement, claims for its breach, and all other claims (including consumer protection, unfair competition, and tort claims), regardless of conflict of laws principles. If you acquired the software in any other country, its laws apply. If U.S. federal jurisdiction exists, you and Microsoft consent to exclusive jurisdiction and venue in the federal court in King County, Washington for all disputes heard in court. If not, you and Microsoft consent to exclusive jurisdiction and venue in the Superior Court of King County, Washington for all disputes heard in court.
10. CONSUMER RIGHTS; REGIONAL VARIATIONS. This agreement describes certain legal rights. You may have other rights, including consumer rights, under the laws of your state or country. Separate and apart from your relationship with Microsoft, you may also have rights with respect to the party from which you acquired the software. This agreement does not change those other rights if the laws of your state or country do not permit it to do so. For example, if you acquired the software in one of the below regions, or mandatory country law applies, then the following provisions apply to you:
  a) Australia. You have statutory guarantees under the Australian Consumer Law and nothing in this agreement is intended to affect those rights.
  b) Canada. If you acquired this software in Canada, you may stop receiving updates by turning off the automatic update feature, disconnecting your device from the Internet (if and when you re-connect to the Internet, however, the software will resume checking for and installing updates), or uninstalling the software. The product documentation, if any, may also specify how to turn off updates for your specific device or software.
  c) Germany and Austria.
    i. Warranty. The properly licensed software will perform substantially as described in any Microsoft materials that accompany the software. However, Microsoft gives no contractual guarantee in relation to the licensed software.
    ii. Limitation of Liability. In case of intentional conduct, gross negligence, claims based on the Product Liability Act, as well as, in case of death or personal or physical injury, Microsoft is liable according to the statutory law.
  Subject to the foregoing clause ii., Microsoft will only be liable for slight negligence if Microsoft is in breach of such material contractual obligations, the fulfillment of which facilitate the due performance of this agreement, the breach of which would endanger the purpose of this agreement and the compliance with which a party may constantly trust in (so-called "cardinal obligations"). In other cases of slight negligence, Microsoft will not be liable for slight negligence.
11. DISCLAIMER OF WARRANTY. THE SOFTWARE IS LICENSED “AS IS.” YOU BEAR THE RISK OF USING IT. MICROSOFT GIVES NO EXPRESS WARRANTIES, GUARANTEES, OR CONDITIONS. TO THE EXTENT PERMITTED UNDER APPLICABLE LAWS, MICROSOFT EXCLUDES ALL IMPLIED WARRANTIES, INCLUDING MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
12. LIMITATION ON AND EXCLUSION OF DAMAGES. IF YOU HAVE ANY BASIS FOR RECOVERING DAMAGES DESPITE THE PRECEDING DISCLAIMER OF WARRANTY, YOU CAN RECOVER FROM MICROSOFT AND ITS SUPPLIERS ONLY DIRECT DAMAGES UP TO U.S. $5.00. YOU CANNOT RECOVER ANY OTHER DAMAGES, INCLUDING CONSEQUENTIAL, LOST PROFITS, SPECIAL, INDIRECT, OR INCIDENTAL DAMAGES.
This limitation applies to (a) anything related to the software, services, content (including code) on third party Internet sites, or third party applications; and (b) claims for breach of contract, warranty, guarantee, or condition; strict liability, negligence, or other tort; or any other claim; in each case to the extent permitted by applicable law.
It also applies even if Microsoft knew or should have known about the possibility of the damages. The above limitation or exclusion may not apply to you because your state, province, or country may not allow the exclusion or limitation of incidental, consequential, or other damages.
Please note: As this software is distributed in Canada, some of the clauses in this agreement are provided below in French.
Remarque: Ce logiciel étant distribué au Canada, certaines des clauses dans ce contrat sont fournies ci-dessous en français.
EXONÉRATION DE GARANTIE. Le logiciel visé par une licence est offert « tel quel ». Toute utilisation de ce logiciel est à votre seule risque et péril. Microsoft n’accorde aucune autre garantie expresse. Vous pouvez bénéficier de droits additionnels en vertu du droit local sur la protection des consommateurs, que ce contrat ne peut modifier. La ou elles sont permises par le droit locale, les garanties implicites de qualité marchande, d’adéquation à un usage particulier et d’absence de contrefaçon sont exclues.
LIMITATION DES DOMMAGES-INTÉRÊTS ET EXCLUSION DE RESPONSABILITÉ POUR LES DOMMAGES. Vous pouvez obtenir de Microsoft et de ses fournisseurs une indemnisation en cas de dommages directs uniquement à hauteur de 5,00 $ US. Vous ne pouvez prétendre à aucune indemnisation pour les autres dommages, y compris les dommages spéciaux, indirects ou accessoires et pertes de bénéfices.
Cette limitation concerne:
• tout ce qui est relié au logiciel, aux services ou au contenu (y compris le code) figurant sur des sites Internet tiers ou dans des programmes tiers; et
• les réclamations au titre de violation de contrat ou de garantie, ou au titre de responsabilité stricte, de négligence ou d’une autre faute dans la limite autorisée par la loi en vigueur.
Elle s’applique également, même si Microsoft connaissait ou devrait connaître l’éventualité d’un tel dommage. Si votre pays n’autorise pas l’exclusion ou la limitation de responsabilité pour les dommages indirects, accessoires ou de quelque nature que ce soit, il se peut que la limitation ou l’exclusion ci-dessus ne s’appliquera pas à votre égard.
EFFET JURIDIQUE. Le présent contrat décrit certains droits juridiques. Vous pourriez avoir d’autres droits prévus par les lois de votre pays. Le présent contrat ne modifie pas les droits que vous confèrent les lois de votre pays si celles-ci ne le permettent pas.
*/

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.atlas = global.atlas || {}));
}(this, (function (exports) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
	}

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var azuremapsMaplibreGlUnminified = createCommonjsModule(function (module, exports) {
	/* The Azure Maps fork of MapLibre GL JS is licensed under the 3-Clause BSD License. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v1.14.0-rc3/LICENSE.txt */
	(function (global, factory) {
	 module.exports = factory() ;
	}(commonjsGlobal, (function () {
	/* eslint-disable */

	var shared, worker, maplibregl;
	// define gets called three times: one for each chunk. we rely on the order
	// they're imported to know which is which
	function define(_, chunk) {
	if (!shared) {
	    shared = chunk;
	} else if (!worker) {
	    worker = chunk;
	} else {
	    var workerBundleString = 'var sharedChunk = {}; (' + shared + ')(sharedChunk); (' + worker + ')(sharedChunk);';

	    var sharedChunk = {};
	    shared(sharedChunk);
	    maplibregl = chunk(sharedChunk);
	    if (typeof window !== 'undefined') {
	        maplibregl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: 'text/javascript' }));
	    }
	}
	}


	define(['exports'], function (exports) {
	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var version = "1.14.0-rc3";

	var unitbezier = UnitBezier;
	function UnitBezier(p1x, p1y, p2x, p2y) {
	    this.cx = 3 * p1x;
	    this.bx = 3 * (p2x - p1x) - this.cx;
	    this.ax = 1 - this.cx - this.bx;
	    this.cy = 3 * p1y;
	    this.by = 3 * (p2y - p1y) - this.cy;
	    this.ay = 1 - this.cy - this.by;
	    this.p1x = p1x;
	    this.p1y = p2y;
	    this.p2x = p2x;
	    this.p2y = p2y;
	}
	UnitBezier.prototype.sampleCurveX = function (t) {
	    return ((this.ax * t + this.bx) * t + this.cx) * t;
	};
	UnitBezier.prototype.sampleCurveY = function (t) {
	    return ((this.ay * t + this.by) * t + this.cy) * t;
	};
	UnitBezier.prototype.sampleCurveDerivativeX = function (t) {
	    return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
	};
	UnitBezier.prototype.solveCurveX = function (x, epsilon) {
	    if (typeof epsilon === 'undefined') {
	        epsilon = 0.000001;
	    }
	    var t0, t1, t2, x2, i;
	    for (t2 = x, i = 0; i < 8; i++) {
	        x2 = this.sampleCurveX(t2) - x;
	        if (Math.abs(x2) < epsilon) {
	            return t2;
	        }
	        var d2 = this.sampleCurveDerivativeX(t2);
	        if (Math.abs(d2) < 0.000001) {
	            break;
	        }
	        t2 = t2 - x2 / d2;
	    }
	    t0 = 0;
	    t1 = 1;
	    t2 = x;
	    if (t2 < t0) {
	        return t0;
	    }
	    if (t2 > t1) {
	        return t1;
	    }
	    while (t0 < t1) {
	        x2 = this.sampleCurveX(t2);
	        if (Math.abs(x2 - x) < epsilon) {
	            return t2;
	        }
	        if (x > x2) {
	            t0 = t2;
	        } else {
	            t1 = t2;
	        }
	        t2 = (t1 - t0) * 0.5 + t0;
	    }
	    return t2;
	};
	UnitBezier.prototype.solve = function (x, epsilon) {
	    return this.sampleCurveY(this.solveCurveX(x, epsilon));
	};

	var pointGeometry = Point;
	function Point(x, y) {
	    this.x = x;
	    this.y = y;
	}
	Point.prototype = {
	    clone: function () {
	        return new Point(this.x, this.y);
	    },
	    add: function (p) {
	        return this.clone()._add(p);
	    },
	    sub: function (p) {
	        return this.clone()._sub(p);
	    },
	    multByPoint: function (p) {
	        return this.clone()._multByPoint(p);
	    },
	    divByPoint: function (p) {
	        return this.clone()._divByPoint(p);
	    },
	    mult: function (k) {
	        return this.clone()._mult(k);
	    },
	    div: function (k) {
	        return this.clone()._div(k);
	    },
	    rotate: function (a) {
	        return this.clone()._rotate(a);
	    },
	    rotateAround: function (a, p) {
	        return this.clone()._rotateAround(a, p);
	    },
	    matMult: function (m) {
	        return this.clone()._matMult(m);
	    },
	    unit: function () {
	        return this.clone()._unit();
	    },
	    perp: function () {
	        return this.clone()._perp();
	    },
	    round: function () {
	        return this.clone()._round();
	    },
	    mag: function () {
	        return Math.sqrt(this.x * this.x + this.y * this.y);
	    },
	    equals: function (other) {
	        return this.x === other.x && this.y === other.y;
	    },
	    dist: function (p) {
	        return Math.sqrt(this.distSqr(p));
	    },
	    distSqr: function (p) {
	        var dx = p.x - this.x, dy = p.y - this.y;
	        return dx * dx + dy * dy;
	    },
	    angle: function () {
	        return Math.atan2(this.y, this.x);
	    },
	    angleTo: function (b) {
	        return Math.atan2(this.y - b.y, this.x - b.x);
	    },
	    angleWith: function (b) {
	        return this.angleWithSep(b.x, b.y);
	    },
	    angleWithSep: function (x, y) {
	        return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);
	    },
	    _matMult: function (m) {
	        var x = m[0] * this.x + m[1] * this.y, y = m[2] * this.x + m[3] * this.y;
	        this.x = x;
	        this.y = y;
	        return this;
	    },
	    _add: function (p) {
	        this.x += p.x;
	        this.y += p.y;
	        return this;
	    },
	    _sub: function (p) {
	        this.x -= p.x;
	        this.y -= p.y;
	        return this;
	    },
	    _mult: function (k) {
	        this.x *= k;
	        this.y *= k;
	        return this;
	    },
	    _div: function (k) {
	        this.x /= k;
	        this.y /= k;
	        return this;
	    },
	    _multByPoint: function (p) {
	        this.x *= p.x;
	        this.y *= p.y;
	        return this;
	    },
	    _divByPoint: function (p) {
	        this.x /= p.x;
	        this.y /= p.y;
	        return this;
	    },
	    _unit: function () {
	        this._div(this.mag());
	        return this;
	    },
	    _perp: function () {
	        var y = this.y;
	        this.y = this.x;
	        this.x = -y;
	        return this;
	    },
	    _rotate: function (angle) {
	        var cos = Math.cos(angle), sin = Math.sin(angle), x = cos * this.x - sin * this.y, y = sin * this.x + cos * this.y;
	        this.x = x;
	        this.y = y;
	        return this;
	    },
	    _rotateAround: function (angle, p) {
	        var cos = Math.cos(angle), sin = Math.sin(angle), x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y), y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);
	        this.x = x;
	        this.y = y;
	        return this;
	    },
	    _round: function () {
	        this.x = Math.round(this.x);
	        this.y = Math.round(this.y);
	        return this;
	    }
	};
	Point.convert = function (a) {
	    if (a instanceof Point) {
	        return a;
	    }
	    if (Array.isArray(a)) {
	        return new Point(a[0], a[1]);
	    }
	    return a;
	};

	var window$1 = typeof self !== 'undefined' ? self : {};

	function deepEqual(a, b) {
	    if (Array.isArray(a)) {
	        if (!Array.isArray(b) || a.length !== b.length) {
	            return false;
	        }
	        for (var i = 0; i < a.length; i++) {
	            if (!deepEqual(a[i], b[i])) {
	                return false;
	            }
	        }
	        return true;
	    }
	    if (typeof a === 'object' && a !== null && b !== null) {
	        if (!(typeof b === 'object')) {
	            return false;
	        }
	        var keys = Object.keys(a);
	        if (keys.length !== Object.keys(b).length) {
	            return false;
	        }
	        for (var key in a) {
	            if (!deepEqual(a[key], b[key])) {
	                return false;
	            }
	        }
	        return true;
	    }
	    return a === b;
	}

	var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
	function easeCubicInOut(t) {
	    if (t <= 0) {
	        return 0;
	    }
	    if (t >= 1) {
	        return 1;
	    }
	    var t2 = t * t, t3 = t2 * t;
	    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
	}
	function bezier(p1x, p1y, p2x, p2y) {
	    var bezier = new unitbezier(p1x, p1y, p2x, p2y);
	    return function (t) {
	        return bezier.solve(t);
	    };
	}
	var ease = bezier(0.25, 0.1, 0.25, 1);
	function clamp(n, min, max) {
	    return Math.min(max, Math.max(min, n));
	}
	function wrap(n, min, max) {
	    var d = max - min;
	    var w = ((n - min) % d + d) % d + min;
	    return w === min ? max : w;
	}
	function asyncAll(array, fn, callback) {
	    if (!array.length) {
	        return callback(null, []);
	    }
	    var remaining = array.length;
	    var results = new Array(array.length);
	    var error = null;
	    array.forEach(function (item, i) {
	        fn(item, function (err, result) {
	            if (err) {
	                error = err;
	            }
	            results[i] = result;
	            if (--remaining === 0) {
	                callback(error, results);
	            }
	        });
	    });
	}
	function values(obj) {
	    var result = [];
	    for (var k in obj) {
	        result.push(obj[k]);
	    }
	    return result;
	}
	function keysDifference(obj, other) {
	    var difference = [];
	    for (var i in obj) {
	        if (!(i in other)) {
	            difference.push(i);
	        }
	    }
	    return difference;
	}
	function extend(dest) {
	    var sources = [], len = arguments.length - 1;
	    while (len-- > 0)
	        sources[len] = arguments[len + 1];
	    for (var i = 0, list = sources; i < list.length; i += 1) {
	        var src = list[i];
	        for (var k in src) {
	            dest[k] = src[k];
	        }
	    }
	    return dest;
	}
	function pick(src, properties) {
	    var result = {};
	    for (var i = 0; i < properties.length; i++) {
	        var k = properties[i];
	        if (k in src) {
	            result[k] = src[k];
	        }
	    }
	    return result;
	}
	var id = 1;
	function uniqueId() {
	    return id++;
	}
	function uuid() {
	    function b(a) {
	        return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([10000000] + -[1000] + -4000 + -8000 + -100000000000).replace(/[018]/g, b);
	    }
	    return b();
	}
	function nextPowerOfTwo(value) {
	    if (value <= 1) {
	        return 1;
	    }
	    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
	}
	function validateUuid(str) {
	    return str ? /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(str) : false;
	}
	function bindAll(fns, context) {
	    fns.forEach(function (fn) {
	        if (!context[fn]) {
	            return;
	        }
	        context[fn] = context[fn].bind(context);
	    });
	}
	function endsWith(string, suffix) {
	    return string.indexOf(suffix, string.length - suffix.length) !== -1;
	}
	function mapObject(input, iterator, context) {
	    var output = {};
	    for (var key in input) {
	        output[key] = iterator.call(context || this, input[key], key, input);
	    }
	    return output;
	}
	function filterObject(input, iterator, context) {
	    var output = {};
	    for (var key in input) {
	        if (iterator.call(context || this, input[key], key, input)) {
	            output[key] = input[key];
	        }
	    }
	    return output;
	}
	function clone(input) {
	    if (Array.isArray(input)) {
	        return input.map(clone);
	    } else if (typeof input === 'object' && input) {
	        return mapObject(input, clone);
	    } else {
	        return input;
	    }
	}
	function arraysIntersect(a, b) {
	    for (var l = 0; l < a.length; l++) {
	        if (b.indexOf(a[l]) >= 0) {
	            return true;
	        }
	    }
	    return false;
	}
	var warnOnceHistory = {};
	function warnOnce(message) {
	    if (!warnOnceHistory[message]) {
	        if (typeof console !== 'undefined') {
	            console.warn(message);
	        }
	        warnOnceHistory[message] = true;
	    }
	}
	function isCounterClockwise(a, b, c) {
	    return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);
	}
	function calculateSignedArea(ring) {
	    var sum = 0;
	    for (var i = 0, len = ring.length, j = len - 1, p1 = void 0, p2 = void 0; i < len; j = i++) {
	        p1 = ring[i];
	        p2 = ring[j];
	        sum += (p2.x - p1.x) * (p1.y + p2.y);
	    }
	    return sum;
	}
	function sphericalToCartesian(ref) {
	    var r = ref[0];
	    var azimuthal = ref[1];
	    var polar = ref[2];
	    azimuthal += 90;
	    azimuthal *= Math.PI / 180;
	    polar *= Math.PI / 180;
	    return {
	        x: r * Math.cos(azimuthal) * Math.sin(polar),
	        y: r * Math.sin(azimuthal) * Math.sin(polar),
	        z: r * Math.cos(polar)
	    };
	}
	function isWorker() {
	    return typeof WorkerGlobalScope !== 'undefined' && typeof self !== 'undefined' && self instanceof WorkerGlobalScope;
	}
	function parseCacheControl(cacheControl) {
	    var re = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g;
	    var header = {};
	    cacheControl.replace(re, function ($0, $1, $2, $3) {
	        var value = $2 || $3;
	        header[$1] = value ? value.toLowerCase() : true;
	        return '';
	    });
	    if (header['max-age']) {
	        var maxAge = parseInt(header['max-age'], 10);
	        if (isNaN(maxAge)) {
	            delete header['max-age'];
	        } else {
	            header['max-age'] = maxAge;
	        }
	    }
	    return header;
	}
	var _isSafari = null;
	function isSafari(scope) {
	    if (_isSafari == null) {
	        var userAgent = scope.navigator ? scope.navigator.userAgent : null;
	        _isSafari = !!scope.safari || !!(userAgent && (/\b(iPad|iPhone|iPod)\b/.test(userAgent) || !!userAgent.match('Safari') && !userAgent.match('Chrome')));
	    }
	    return _isSafari;
	}
	function storageAvailable(type) {
	    try {
	        var storage = window$1[type];
	        storage.setItem('_mapbox_test_', 1);
	        storage.removeItem('_mapbox_test_');
	        return true;
	    } catch (e) {
	        return false;
	    }
	}
	function b64EncodeUnicode(str) {
	    return window$1.btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p1) {
	        return String.fromCharCode(Number('0x' + p1));
	    }));
	}
	function b64DecodeUnicode(str) {
	    return decodeURIComponent(window$1.atob(str).split('').map(function (c) {
	        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
	    }).join(''));
	}

	var now = window$1.performance && window$1.performance.now ? window$1.performance.now.bind(window$1.performance) : Date.now.bind(Date);
	var raf = window$1.requestAnimationFrame || window$1.mozRequestAnimationFrame || window$1.webkitRequestAnimationFrame || window$1.msRequestAnimationFrame;
	var cancel = window$1.cancelAnimationFrame || window$1.mozCancelAnimationFrame || window$1.webkitCancelAnimationFrame || window$1.msCancelAnimationFrame;
	var linkEl;
	var reducedMotionQuery;
	var exported = {
	    now: now,
	    frame: function frame(fn) {
	        var frame = raf(fn);
	        return {
	            cancel: function () {
	                return cancel(frame);
	            }
	        };
	    },
	    getImageData: function getImageData(img, padding) {
	        if (padding === void 0)
	            padding = 0;
	        var canvas = window$1.document.createElement('canvas');
	        var context = canvas.getContext('2d');
	        if (!context) {
	            throw new Error('failed to create canvas 2d context');
	        }
	        canvas.width = img.width;
	        canvas.height = img.height;
	        context.drawImage(img, 0, 0, img.width, img.height);
	        return context.getImageData(-padding, -padding, img.width + 2 * padding, img.height + 2 * padding);
	    },
	    resolveURL: function resolveURL(path) {
	        if (!linkEl) {
	            linkEl = window$1.document.createElement('a');
	        }
	        linkEl.href = path;
	        return linkEl.href;
	    },
	    hardwareConcurrency: window$1.navigator && window$1.navigator.hardwareConcurrency || 4,
	    get devicePixelRatio() {
	        return window$1.devicePixelRatio;
	    },
	    get prefersReducedMotion() {
	        if (!window$1.matchMedia) {
	            return false;
	        }
	        if (reducedMotionQuery == null) {
	            reducedMotionQuery = window$1.matchMedia('(prefers-reduced-motion: reduce)');
	        }
	        return reducedMotionQuery.matches;
	    }
	};

	var config = {
	    API_URL: 'https://api.mapbox.com',
	    get EVENTS_URL() {
	        if (!this.API_URL) {
	            return null;
	        }
	        if (this.API_URL.indexOf('https://api.mapbox.cn') === 0) {
	            return 'https://events.mapbox.cn/events/v2';
	        } else if (this.API_URL.indexOf('https://api.mapbox.com') === 0) {
	            return 'https://events.mapbox.com/events/v2';
	        } else {
	            return null;
	        }
	    },
	    FEEDBACK_URL: 'https://apps.mapbox.com/feedback',
	    REQUIRE_ACCESS_TOKEN: true,
	    ACCESS_TOKEN: null,
	    MAX_PARALLEL_IMAGE_REQUESTS: 16
	};

	var exported$1 = {
	    supported: false,
	    testSupport: testSupport
	};
	var glForTesting;
	var webpCheckComplete = false;
	var webpImgTest;
	var webpImgTestOnloadComplete = false;
	if (window$1.document) {
	    webpImgTest = window$1.document.createElement('img');
	    webpImgTest.onload = function () {
	        if (glForTesting) {
	            testWebpTextureUpload(glForTesting);
	        }
	        glForTesting = null;
	        webpImgTestOnloadComplete = true;
	    };
	    webpImgTest.onerror = function () {
	        webpCheckComplete = true;
	        glForTesting = null;
	    };
	    webpImgTest.src = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=';
	}
	function testSupport(gl) {
	    if (webpCheckComplete || !webpImgTest) {
	        return;
	    }
	    if (webpImgTestOnloadComplete) {
	        testWebpTextureUpload(gl);
	    } else {
	        glForTesting = gl;
	    }
	}
	function testWebpTextureUpload(gl) {
	    var texture = gl.createTexture();
	    gl.bindTexture(gl.TEXTURE_2D, texture);
	    try {
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, webpImgTest);
	        if (gl.isContextLost()) {
	            return;
	        }
	        exported$1.supported = true;
	    } catch (e) {
	    }
	    gl.deleteTexture(texture);
	    webpCheckComplete = true;
	}

	var SKU_ID = '01';
	function createSkuToken() {
	    var TOKEN_VERSION = '1';
	    var base62chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
	    var sessionRandomizer = '';
	    for (var i = 0; i < 10; i++) {
	        sessionRandomizer += base62chars[Math.floor(Math.random() * 62)];
	    }
	    var expiration = 12 * 60 * 60 * 1000;
	    var token = [
	        TOKEN_VERSION,
	        SKU_ID,
	        sessionRandomizer
	    ].join('');
	    var tokenExpiresAt = Date.now() + expiration;
	    return {
	        token: token,
	        tokenExpiresAt: tokenExpiresAt
	    };
	}

	var RequestManager = function RequestManager(transformRequestFn, customAccessToken) {
	    this._transformRequestFn = transformRequestFn;
	    this._customAccessToken = customAccessToken;
	    this._createSkuToken();
	};
	RequestManager.prototype._createSkuToken = function _createSkuToken() {
	    var skuToken = createSkuToken();
	    this._skuToken = skuToken.token;
	    this._skuTokenExpiresAt = skuToken.tokenExpiresAt;
	};
	RequestManager.prototype._isSkuTokenExpired = function _isSkuTokenExpired() {
	    return Date.now() > this._skuTokenExpiresAt;
	};
	RequestManager.prototype.transformRequest = function transformRequest(url, type) {
	    if (this._transformRequestFn) {
	        return this._transformRequestFn(url, type) || { url: url };
	    }
	    return { url: url };
	};
	RequestManager.prototype.normalizeStyleURL = function normalizeStyleURL(url, accessToken) {
	    if (!isMapboxURL(url)) {
	        return url;
	    }
	    var urlObject = parseUrl(url);
	    urlObject.path = '/styles/v1' + urlObject.path;
	    return this._makeAPIURL(urlObject, this._customAccessToken || accessToken);
	};
	RequestManager.prototype.normalizeGlyphsURL = function normalizeGlyphsURL(url, accessToken) {
	    if (!isMapboxURL(url)) {
	        return url;
	    }
	    var urlObject = parseUrl(url);
	    urlObject.path = '/fonts/v1' + urlObject.path;
	    return this._makeAPIURL(urlObject, this._customAccessToken || accessToken);
	};
	RequestManager.prototype.normalizeSourceURL = function normalizeSourceURL(url, accessToken) {
	    if (!isMapboxURL(url)) {
	        return url;
	    }
	    var urlObject = parseUrl(url);
	    urlObject.path = '/v4/' + urlObject.authority + '.json';
	    urlObject.params.push('secure');
	    return this._makeAPIURL(urlObject, this._customAccessToken || accessToken);
	};
	RequestManager.prototype.normalizeSpriteURL = function normalizeSpriteURL(url, format, extension, accessToken) {
	    var urlObject = parseUrl(url);
	    if (!isMapboxURL(url)) {
	        urlObject.path += '' + format + extension;
	        return formatUrl(urlObject);
	    }
	    urlObject.path = '/styles/v1' + urlObject.path + '/sprite' + format + extension;
	    return this._makeAPIURL(urlObject, this._customAccessToken || accessToken);
	};
	RequestManager.prototype.normalizeTileURL = function normalizeTileURL(tileURL, tileSize) {
	    if (this._isSkuTokenExpired()) {
	        this._createSkuToken();
	    }
	    if (tileURL && !isMapboxURL(tileURL)) {
	        return tileURL;
	    }
	    var urlObject = parseUrl(tileURL);
	    var imageExtensionRe = /(\.(png|jpg)\d*)(?=$)/;
	    var tileURLAPIPrefixRe = /^.+\/v4\//;
	    var suffix = exported.devicePixelRatio >= 2 || tileSize === 512 ? '@2x' : '';
	    var extension = exported$1.supported ? '.webp' : '$1';
	    urlObject.path = urlObject.path.replace(imageExtensionRe, '' + suffix + extension);
	    urlObject.path = urlObject.path.replace(tileURLAPIPrefixRe, '/');
	    urlObject.path = '/v4' + urlObject.path;
	    var accessToken = this._customAccessToken || getAccessToken(urlObject.params) || config.ACCESS_TOKEN;
	    if (config.REQUIRE_ACCESS_TOKEN && accessToken && this._skuToken) {
	        urlObject.params.push('sku=' + this._skuToken);
	    }
	    return this._makeAPIURL(urlObject, accessToken);
	};
	RequestManager.prototype.canonicalizeTileURL = function canonicalizeTileURL(url, removeAccessToken) {
	    var version = '/v4/';
	    var extensionRe = /\.[\w]+$/;
	    var urlObject = parseUrl(url);
	    if (!urlObject.path.match(/(^\/v4\/)/) || !urlObject.path.match(extensionRe)) {
	        return url;
	    }
	    var result = 'mapbox://tiles/';
	    result += urlObject.path.replace(version, '');
	    var params = urlObject.params;
	    if (removeAccessToken) {
	        params = params.filter(function (p) {
	            return !p.match(/^access_token=/);
	        });
	    }
	    if (params.length) {
	        result += '?' + params.join('&');
	    }
	    return result;
	};
	RequestManager.prototype.canonicalizeTileset = function canonicalizeTileset(tileJSON, sourceURL) {
	    var removeAccessToken = sourceURL ? isMapboxURL(sourceURL) : false;
	    var canonical = [];
	    for (var i = 0, list = tileJSON.tiles || []; i < list.length; i += 1) {
	        var url = list[i];
	        if (isMapboxHTTPURL(url)) {
	            canonical.push(this.canonicalizeTileURL(url, removeAccessToken));
	        } else {
	            canonical.push(url);
	        }
	    }
	    return canonical;
	};
	RequestManager.prototype._makeAPIURL = function _makeAPIURL(urlObject, accessToken) {
	    var help = 'See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes';
	    var apiUrlObject = parseUrl(config.API_URL);
	    urlObject.protocol = apiUrlObject.protocol;
	    urlObject.authority = apiUrlObject.authority;
	    if (urlObject.protocol === 'http') {
	        var i = urlObject.params.indexOf('secure');
	        if (i >= 0) {
	            urlObject.params.splice(i, 1);
	        }
	    }
	    if (apiUrlObject.path !== '/') {
	        urlObject.path = '' + apiUrlObject.path + urlObject.path;
	    }
	    if (!config.REQUIRE_ACCESS_TOKEN) {
	        return formatUrl(urlObject);
	    }
	    accessToken = accessToken || config.ACCESS_TOKEN;
	    if (!accessToken) {
	        throw new Error('An API access token is required to use Mapbox GL. ' + help);
	    }
	    if (accessToken[0] === 's') {
	        throw new Error('Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ' + help);
	    }
	    urlObject.params = urlObject.params.filter(function (d) {
	        return d.indexOf('access_token') === -1;
	    });
	    urlObject.params.push('access_token=' + accessToken);
	    return formatUrl(urlObject);
	};
	function isMapboxURL(url) {
	    return url.indexOf('mapbox:') === 0;
	}
	var mapboxHTTPURLRe = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
	function isMapboxHTTPURL(url) {
	    return mapboxHTTPURLRe.test(url);
	}
	function hasCacheDefeatingSku(url) {
	    return url.indexOf('sku=') > 0 && isMapboxHTTPURL(url);
	}
	function getAccessToken(params) {
	    for (var i = 0, list = params; i < list.length; i += 1) {
	        var param = list[i];
	        var match = param.match(/^access_token=(.*)$/);
	        if (match) {
	            return match[1];
	        }
	    }
	    return null;
	}
	var urlRe = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
	function parseUrl(url) {
	    var parts = url.match(urlRe);
	    if (!parts) {
	        throw new Error('Unable to parse URL object');
	    }
	    return {
	        protocol: parts[1],
	        authority: parts[2],
	        path: parts[3] || '/',
	        params: parts[4] ? parts[4].split('&') : []
	    };
	}
	function formatUrl(obj) {
	    var params = obj.params.length ? '?' + obj.params.join('&') : '';
	    return obj.protocol + '://' + obj.authority + obj.path + params;
	}
	var telemEventKey = 'mapbox.eventData';
	function parseAccessToken(accessToken) {
	    if (!accessToken) {
	        return null;
	    }
	    var parts = accessToken.split('.');
	    if (!parts || parts.length !== 3) {
	        return null;
	    }
	    try {
	        var jsonData = JSON.parse(b64DecodeUnicode(parts[1]));
	        return jsonData;
	    } catch (e) {
	        return null;
	    }
	}
	var TelemetryEvent = function TelemetryEvent(type) {
	    this.type = type;
	    this.anonId = null;
	    this.eventData = {};
	    this.queue = [];
	    this.pendingRequest = null;
	};
	TelemetryEvent.prototype.getStorageKey = function getStorageKey(domain) {
	    var tokenData = parseAccessToken(config.ACCESS_TOKEN);
	    var u = '';
	    if (tokenData && tokenData['u']) {
	        u = b64EncodeUnicode(tokenData['u']);
	    } else {
	        u = config.ACCESS_TOKEN || '';
	    }
	    return domain ? telemEventKey + '.' + domain + ':' + u : telemEventKey + ':' + u;
	};
	TelemetryEvent.prototype.fetchEventData = function fetchEventData() {
	    var isLocalStorageAvailable = storageAvailable('localStorage');
	    var storageKey = this.getStorageKey();
	    var uuidKey = this.getStorageKey('uuid');
	    if (isLocalStorageAvailable) {
	        try {
	            var data = window$1.localStorage.getItem(storageKey);
	            if (data) {
	                this.eventData = JSON.parse(data);
	            }
	            var uuid = window$1.localStorage.getItem(uuidKey);
	            if (uuid) {
	                this.anonId = uuid;
	            }
	        } catch (e) {
	            warnOnce('Unable to read from LocalStorage');
	        }
	    }
	};
	TelemetryEvent.prototype.saveEventData = function saveEventData() {
	    var isLocalStorageAvailable = storageAvailable('localStorage');
	    var storageKey = this.getStorageKey();
	    var uuidKey = this.getStorageKey('uuid');
	    if (isLocalStorageAvailable) {
	        try {
	            window$1.localStorage.setItem(uuidKey, this.anonId);
	            if (Object.keys(this.eventData).length >= 1) {
	                window$1.localStorage.setItem(storageKey, JSON.stringify(this.eventData));
	            }
	        } catch (e) {
	            warnOnce('Unable to write to LocalStorage');
	        }
	    }
	};
	TelemetryEvent.prototype.processRequests = function processRequests(_) {
	};
	TelemetryEvent.prototype.postEvent = function postEvent(timestamp, additionalPayload, callback, customAccessToken) {
	    var this$1 = this;
	    if (!config.EVENTS_URL) {
	        return;
	    }
	    var eventsUrlObject = parseUrl(config.EVENTS_URL);
	    eventsUrlObject.params.push('access_token=' + (customAccessToken || config.ACCESS_TOKEN || ''));
	    var payload = {
	        event: this.type,
	        created: new Date(timestamp).toISOString(),
	        sdkIdentifier: 'mapbox-gl-js',
	        sdkVersion: version,
	        skuId: SKU_ID,
	        userId: this.anonId
	    };
	    var finalPayload = additionalPayload ? extend(payload, additionalPayload) : payload;
	    var request = {
	        url: formatUrl(eventsUrlObject),
	        headers: { 'Content-Type': 'text/plain' },
	        body: JSON.stringify([finalPayload])
	    };
	    this.pendingRequest = postData(request, function (error) {
	        this$1.pendingRequest = null;
	        callback(error);
	        this$1.saveEventData();
	        this$1.processRequests(customAccessToken);
	    });
	};
	TelemetryEvent.prototype.queueRequest = function queueRequest(event, customAccessToken) {
	    this.queue.push(event);
	    this.processRequests(customAccessToken);
	};
	var MapLoadEvent = function (TelemetryEvent) {
	    function MapLoadEvent() {
	        TelemetryEvent.call(this, 'map.load');
	        this.success = {};
	        this.skuToken = '';
	    }
	    if (TelemetryEvent)
	        MapLoadEvent.__proto__ = TelemetryEvent;
	    MapLoadEvent.prototype = Object.create(TelemetryEvent && TelemetryEvent.prototype);
	    MapLoadEvent.prototype.constructor = MapLoadEvent;
	    MapLoadEvent.prototype.postMapLoadEvent = function postMapLoadEvent(tileUrls, mapId, skuToken, customAccessToken) {
	        this.skuToken = skuToken;
	        if (config.EVENTS_URL && customAccessToken || config.ACCESS_TOKEN && Array.isArray(tileUrls) && tileUrls.some(function (url) {
	                return isMapboxURL(url) || isMapboxHTTPURL(url);
	            })) {
	            this.queueRequest({
	                id: mapId,
	                timestamp: Date.now()
	            }, customAccessToken);
	        }
	    };
	    MapLoadEvent.prototype.processRequests = function processRequests(customAccessToken) {
	        var this$1 = this;
	        if (this.pendingRequest || this.queue.length === 0) {
	            return;
	        }
	        var ref = this.queue.shift();
	        var id = ref.id;
	        var timestamp = ref.timestamp;
	        if (id && this.success[id]) {
	            return;
	        }
	        if (!this.anonId) {
	            this.fetchEventData();
	        }
	        if (!validateUuid(this.anonId)) {
	            this.anonId = uuid();
	        }
	        this.postEvent(timestamp, { skuToken: this.skuToken }, function (err) {
	            if (!err) {
	                if (id) {
	                    this$1.success[id] = true;
	                }
	            }
	        }, customAccessToken);
	    };
	    return MapLoadEvent;
	}(TelemetryEvent);
	var TurnstileEvent = function (TelemetryEvent) {
	    function TurnstileEvent(customAccessToken) {
	        TelemetryEvent.call(this, 'appUserTurnstile');
	        this._customAccessToken = customAccessToken;
	    }
	    if (TelemetryEvent)
	        TurnstileEvent.__proto__ = TelemetryEvent;
	    TurnstileEvent.prototype = Object.create(TelemetryEvent && TelemetryEvent.prototype);
	    TurnstileEvent.prototype.constructor = TurnstileEvent;
	    TurnstileEvent.prototype.postTurnstileEvent = function postTurnstileEvent(tileUrls, customAccessToken) {
	        if (config.EVENTS_URL && config.ACCESS_TOKEN && Array.isArray(tileUrls) && tileUrls.some(function (url) {
	                return isMapboxURL(url) || isMapboxHTTPURL(url);
	            })) {
	            this.queueRequest(Date.now(), customAccessToken);
	        }
	    };
	    TurnstileEvent.prototype.processRequests = function processRequests(customAccessToken) {
	        var this$1 = this;
	        if (this.pendingRequest || this.queue.length === 0) {
	            return;
	        }
	        if (!this.anonId || !this.eventData.lastSuccess || !this.eventData.tokenU) {
	            this.fetchEventData();
	        }
	        var tokenData = parseAccessToken(config.ACCESS_TOKEN);
	        var tokenU = tokenData ? tokenData['u'] : config.ACCESS_TOKEN;
	        var dueForEvent = tokenU !== this.eventData.tokenU;
	        if (!validateUuid(this.anonId)) {
	            this.anonId = uuid();
	            dueForEvent = true;
	        }
	        var nextUpdate = this.queue.shift();
	        if (this.eventData.lastSuccess) {
	            var lastUpdate = new Date(this.eventData.lastSuccess);
	            var nextDate = new Date(nextUpdate);
	            var daysElapsed = (nextUpdate - this.eventData.lastSuccess) / (24 * 60 * 60 * 1000);
	            dueForEvent = dueForEvent || daysElapsed >= 1 || daysElapsed < -1 || lastUpdate.getDate() !== nextDate.getDate();
	        } else {
	            dueForEvent = true;
	        }
	        if (!dueForEvent) {
	            return this.processRequests();
	        }
	        this.postEvent(nextUpdate, { 'enabled.telemetry': false }, function (err) {
	            if (!err) {
	                this$1.eventData.lastSuccess = nextUpdate;
	                this$1.eventData.tokenU = tokenU;
	            }
	        }, customAccessToken);
	    };
	    return TurnstileEvent;
	}(TelemetryEvent);
	var turnstileEvent_ = new TurnstileEvent();
	var postTurnstileEvent = turnstileEvent_.postTurnstileEvent.bind(turnstileEvent_);
	var mapLoadEvent_ = new MapLoadEvent();
	var postMapLoadEvent = mapLoadEvent_.postMapLoadEvent.bind(mapLoadEvent_);

	var CACHE_NAME = 'mapbox-tiles';
	var cacheLimit = 500;
	var cacheCheckThreshold = 50;
	var MIN_TIME_UNTIL_EXPIRY = 1000 * 60 * 7;
	var sharedCache;
	function cacheOpen() {
	    if (window$1.caches && !sharedCache) {
	        sharedCache = window$1.caches.open(CACHE_NAME);
	    }
	}
	var responseConstructorSupportsReadableStream;
	function prepareBody(response, callback) {
	    if (responseConstructorSupportsReadableStream === undefined) {
	        try {
	            new Response(new ReadableStream());
	            responseConstructorSupportsReadableStream = true;
	        } catch (e) {
	            responseConstructorSupportsReadableStream = false;
	        }
	    }
	    if (responseConstructorSupportsReadableStream) {
	        callback(response.body);
	    } else {
	        response.blob().then(callback);
	    }
	}
	function cachePut(request, response, requestTime) {
	    cacheOpen();
	    if (!sharedCache) {
	        return;
	    }
	    var options = {
	        status: response.status,
	        statusText: response.statusText,
	        headers: new window$1.Headers()
	    };
	    response.headers.forEach(function (v, k) {
	        return options.headers.set(k, v);
	    });
	    var cacheControl = parseCacheControl(response.headers.get('Cache-Control') || '');
	    if (cacheControl['no-store']) {
	        return;
	    }
	    if (cacheControl['max-age']) {
	        options.headers.set('Expires', new Date(requestTime + cacheControl['max-age'] * 1000).toUTCString());
	    }
	    var timeUntilExpiry = new Date(options.headers.get('Expires')).getTime() - requestTime;
	    if (timeUntilExpiry < MIN_TIME_UNTIL_EXPIRY) {
	        return;
	    }
	    prepareBody(response, function (body) {
	        var clonedResponse = new window$1.Response(body, options);
	        cacheOpen();
	        if (!sharedCache) {
	            return;
	        }
	        sharedCache.then(function (cache) {
	            return cache.put(stripQueryParameters(request.url), clonedResponse);
	        }).catch(function (e) {
	            return warnOnce(e.message);
	        });
	    });
	}
	function stripQueryParameters(url) {
	    var start = url.indexOf('?');
	    return start < 0 ? url : url.slice(0, start);
	}
	function cacheGet(request, callback) {
	    cacheOpen();
	    if (!sharedCache) {
	        return callback(null);
	    }
	    var strippedURL = stripQueryParameters(request.url);
	    sharedCache.then(function (cache) {
	        cache.match(strippedURL).then(function (response) {
	            var fresh = isFresh(response);
	            cache.delete(strippedURL);
	            if (fresh) {
	                cache.put(strippedURL, response.clone());
	            }
	            callback(null, response, fresh);
	        }).catch(callback);
	    }).catch(callback);
	}
	function isFresh(response) {
	    if (!response) {
	        return false;
	    }
	    var expires = new Date(response.headers.get('Expires') || 0);
	    var cacheControl = parseCacheControl(response.headers.get('Cache-Control') || '');
	    return expires > Date.now() && !cacheControl['no-cache'];
	}
	var globalEntryCounter = Infinity;
	function cacheEntryPossiblyAdded(dispatcher) {
	    globalEntryCounter++;
	    if (globalEntryCounter > cacheCheckThreshold) {
	        dispatcher.getActor().send('enforceCacheSizeLimit', cacheLimit);
	        globalEntryCounter = 0;
	    }
	}
	function enforceCacheSizeLimit(limit) {
	    cacheOpen();
	    if (!sharedCache) {
	        return;
	    }
	    sharedCache.then(function (cache) {
	        cache.keys().then(function (keys) {
	            for (var i = 0; i < keys.length - limit; i++) {
	                cache.delete(keys[i]);
	            }
	        });
	    });
	}
	function clearTileCache(callback) {
	    var promise = window$1.caches.delete(CACHE_NAME);
	    if (callback) {
	        promise.catch(callback).then(function () {
	            return callback();
	        });
	    }
	}
	function setCacheLimits(limit, checkThreshold) {
	    cacheLimit = limit;
	    cacheCheckThreshold = checkThreshold;
	}

	var supportsOffscreenCanvas;
	function offscreenCanvasSupported() {
	    if (supportsOffscreenCanvas == null) {
	        supportsOffscreenCanvas = window$1.OffscreenCanvas && new window$1.OffscreenCanvas(1, 1).getContext('2d') && typeof window$1.createImageBitmap === 'function';
	    }
	    return supportsOffscreenCanvas;
	}

	var ResourceType = {
	    Unknown: 'Unknown',
	    Style: 'Style',
	    Source: 'Source',
	    Tile: 'Tile',
	    Glyphs: 'Glyphs',
	    SpriteImage: 'SpriteImage',
	    SpriteJSON: 'SpriteJSON',
	    Image: 'Image'
	};
	if (typeof Object.freeze == 'function') {
	    Object.freeze(ResourceType);
	}
	var AJAXError = function (Error) {
	    function AJAXError(message, status, url) {
	        if (status === 401 && isMapboxHTTPURL(url)) {
	            message += ': you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes';
	        }
	        Error.call(this, message);
	        this.status = status;
	        this.url = url;
	        this.name = this.constructor.name;
	        this.message = message;
	    }
	    if (Error)
	        AJAXError.__proto__ = Error;
	    AJAXError.prototype = Object.create(Error && Error.prototype);
	    AJAXError.prototype.constructor = AJAXError;
	    AJAXError.prototype.toString = function toString() {
	        return this.name + ': ' + this.message + ' (' + this.status + '): ' + this.url;
	    };
	    return AJAXError;
	}(Error);
	var getReferrer = isWorker() ? function () {
	    return self.worker && self.worker.referrer;
	} : function () {
	    return (window$1.location.protocol === 'blob:' ? window$1.parent : window$1).location.href;
	};
	var isFileURL = function (url) {
	    return /^file:/.test(url) || /^file:/.test(getReferrer()) && !/^\w+:/.test(url);
	};
	function makeFetchRequest(requestParameters, callback) {
	    var controller = new window$1.AbortController();
	    var request = new window$1.Request(requestParameters.url, {
	        method: requestParameters.method || 'GET',
	        body: requestParameters.body,
	        credentials: requestParameters.credentials,
	        headers: requestParameters.headers,
	        referrer: getReferrer(),
	        signal: controller.signal
	    });
	    var complete = false;
	    var aborted = false;
	    var cacheIgnoringSearch = hasCacheDefeatingSku(request.url);
	    if (requestParameters.type === 'json') {
	        request.headers.set('Accept', 'application/json');
	    }
	    var validateOrFetch = function (err, cachedResponse, responseIsFresh) {
	        if (aborted) {
	            return;
	        }
	        if (err) {
	            if (err.message !== 'SecurityError') {
	                warnOnce(err);
	            }
	        }
	        if (cachedResponse && responseIsFresh) {
	            return finishRequest(cachedResponse);
	        }
	        var requestTime = Date.now();
	        window$1.fetch(request).then(function (response) {
	            if (response.ok) {
	                var cacheableResponse = cacheIgnoringSearch ? response.clone() : null;
	                return finishRequest(response, cacheableResponse, requestTime);
	            } else {
	                return callback(new AJAXError(response.statusText, response.status, requestParameters.url));
	            }
	        }).catch(function (error) {
	            if (error.code === 20) {
	                return;
	            }
	            callback(new Error(error.message));
	        });
	    };
	    var finishRequest = function (response, cacheableResponse, requestTime) {
	        (requestParameters.type === 'arrayBuffer' ? response.arrayBuffer() : requestParameters.type === 'json' ? response.json() : response.text()).then(function (result) {
	            if (aborted) {
	                return;
	            }
	            if (cacheableResponse && requestTime) {
	                cachePut(request, cacheableResponse, requestTime);
	            }
	            complete = true;
	            callback(null, result, response.headers.get('Cache-Control'), response.headers.get('Expires'));
	        }).catch(function (err) {
	            if (!aborted) {
	                callback(new Error(err.message));
	            }
	        });
	    };
	    if (cacheIgnoringSearch) {
	        cacheGet(request, validateOrFetch);
	    } else {
	        validateOrFetch(null, null);
	    }
	    return {
	        cancel: function () {
	            aborted = true;
	            if (!complete) {
	                controller.abort();
	            }
	        }
	    };
	}
	function makeXMLHttpRequest(requestParameters, callback) {
	    var xhr = new window$1.XMLHttpRequest();
	    xhr.open(requestParameters.method || 'GET', requestParameters.url, true);
	    if (requestParameters.type === 'arrayBuffer') {
	        xhr.responseType = 'arraybuffer';
	    }
	    for (var k in requestParameters.headers) {
	        xhr.setRequestHeader(k, requestParameters.headers[k]);
	    }
	    if (requestParameters.type === 'json') {
	        xhr.responseType = 'text';
	        xhr.setRequestHeader('Accept', 'application/json');
	    }
	    xhr.withCredentials = requestParameters.credentials === 'include';
	    xhr.onerror = function () {
	        callback(new Error(xhr.statusText));
	    };
	    xhr.onload = function () {
	        if ((xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) && xhr.response !== null) {
	            var data = xhr.response;
	            if (requestParameters.type === 'json') {
	                try {
	                    data = JSON.parse(xhr.response);
	                } catch (err) {
	                    return callback(err);
	                }
	            }
	            callback(null, data, xhr.getResponseHeader('Cache-Control'), xhr.getResponseHeader('Expires'));
	        } else {
	            callback(new AJAXError(xhr.statusText, xhr.status, requestParameters.url));
	        }
	    };
	    xhr.send(requestParameters.body);
	    return {
	        cancel: function () {
	            return xhr.abort();
	        }
	    };
	}
	var makeRequest = function (requestParameters, callback) {
	    if (!isFileURL(requestParameters.url)) {
	        if (window$1.fetch && window$1.Request && window$1.AbortController && window$1.Request.prototype.hasOwnProperty('signal')) {
	            return makeFetchRequest(requestParameters, callback);
	        }
	        if (isWorker() && self.worker && self.worker.actor) {
	            var queueOnMainThread = true;
	            return self.worker.actor.send('getResource', requestParameters, callback, undefined, queueOnMainThread);
	        }
	    }
	    return makeXMLHttpRequest(requestParameters, callback);
	};
	var getJSON = function (requestParameters, callback) {
	    return makeRequest(extend(requestParameters, { type: 'json' }), callback);
	};
	var getArrayBuffer = function (requestParameters, callback) {
	    return makeRequest(extend(requestParameters, { type: 'arrayBuffer' }), callback);
	};
	var postData = function (requestParameters, callback) {
	    return makeRequest(extend(requestParameters, { method: 'POST' }), callback);
	};
	function sameOrigin(url) {
	    var a = window$1.document.createElement('a');
	    a.href = url;
	    return a.protocol === window$1.document.location.protocol && a.host === window$1.document.location.host;
	}
	var transparentPngUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=';
	function arrayBufferToImage(data, callback, cacheControl, expires) {
	    var img = new window$1.Image();
	    var URL = window$1.URL;
	    img.onload = function () {
	        callback(null, img);
	        URL.revokeObjectURL(img.src);
	        img.onload = null;
	        window$1.requestAnimationFrame(function () {
	            img.src = transparentPngUrl;
	        });
	    };
	    img.onerror = function () {
	        return callback(new Error('Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.'));
	    };
	    var blob = new window$1.Blob([new Uint8Array(data)], { type: 'image/png' });
	    img.cacheControl = cacheControl;
	    img.expires = expires;
	    img.src = data.byteLength ? URL.createObjectURL(blob) : transparentPngUrl;
	}
	function arrayBufferToImageBitmap(data, callback) {
	    var blob = new window$1.Blob([new Uint8Array(data)], { type: 'image/png' });
	    window$1.createImageBitmap(blob).then(function (imgBitmap) {
	        callback(null, imgBitmap);
	    }).catch(function (e) {
	        callback(new Error('Could not load image because of ' + e.message + '. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.'));
	    });
	}
	var imageQueue, numImageRequests;
	var resetImageRequestQueue = function () {
	    imageQueue = [];
	    numImageRequests = 0;
	};
	resetImageRequestQueue();
	var getImage = function (requestParameters, callback) {
	    if (exported$1.supported) {
	        if (!requestParameters.headers) {
	            requestParameters.headers = {};
	        }
	        requestParameters.headers.accept = 'image/webp,*/*';
	    }
	    if (numImageRequests >= config.MAX_PARALLEL_IMAGE_REQUESTS) {
	        var queued = {
	            requestParameters: requestParameters,
	            callback: callback,
	            cancelled: false,
	            cancel: function cancel() {
	                this.cancelled = true;
	            }
	        };
	        imageQueue.push(queued);
	        return queued;
	    }
	    numImageRequests++;
	    var advanced = false;
	    var advanceImageRequestQueue = function () {
	        if (advanced) {
	            return;
	        }
	        advanced = true;
	        numImageRequests--;
	        while (imageQueue.length && numImageRequests < config.MAX_PARALLEL_IMAGE_REQUESTS) {
	            var request = imageQueue.shift();
	            var requestParameters = request.requestParameters;
	            var callback = request.callback;
	            var cancelled = request.cancelled;
	            if (!cancelled) {
	                request.cancel = getImage(requestParameters, callback).cancel;
	            }
	        }
	    };
	    var request = getArrayBuffer(requestParameters, function (err, data, cacheControl, expires) {
	        advanceImageRequestQueue();
	        if (err) {
	            callback(err);
	        } else if (data) {
	            if (offscreenCanvasSupported()) {
	                arrayBufferToImageBitmap(data, callback);
	            } else {
	                arrayBufferToImage(data, callback, cacheControl, expires);
	            }
	        }
	    });
	    return {
	        cancel: function () {
	            request.cancel();
	            advanceImageRequestQueue();
	        }
	    };
	};
	var getVideo = function (urls, callback) {
	    var video = window$1.document.createElement('video');
	    video.muted = true;
	    video.onloadstart = function () {
	        callback(null, video);
	    };
	    for (var i = 0; i < urls.length; i++) {
	        var s = window$1.document.createElement('source');
	        if (!sameOrigin(urls[i])) {
	            video.crossOrigin = 'Anonymous';
	        }
	        s.src = urls[i];
	        video.appendChild(s);
	    }
	    return {
	        cancel: function () {
	        }
	    };
	};

	function _addEventListener(type, listener, listenerList) {
	    var listenerExists = listenerList[type] && listenerList[type].indexOf(listener) !== -1;
	    if (!listenerExists) {
	        listenerList[type] = listenerList[type] || [];
	        listenerList[type].push(listener);
	    }
	}
	function _removeEventListener(type, listener, listenerList) {
	    if (listenerList && listenerList[type]) {
	        var index = listenerList[type].indexOf(listener);
	        if (index !== -1) {
	            listenerList[type].splice(index, 1);
	        }
	    }
	}
	var Event = function Event(type, data) {
	    if (data === void 0)
	        data = {};
	    extend(this, data);
	    this.type = type;
	};
	var ErrorEvent = function (Event) {
	    function ErrorEvent(error, data) {
	        if (data === void 0)
	            data = {};
	        Event.call(this, 'error', extend({ error: error }, data));
	    }
	    if (Event)
	        ErrorEvent.__proto__ = Event;
	    ErrorEvent.prototype = Object.create(Event && Event.prototype);
	    ErrorEvent.prototype.constructor = ErrorEvent;
	    return ErrorEvent;
	}(Event);
	var Evented = function Evented() {
	};
	Evented.prototype.on = function on(type, listener) {
	    this._listeners = this._listeners || {};
	    _addEventListener(type, listener, this._listeners);
	    return this;
	};
	Evented.prototype.off = function off(type, listener) {
	    _removeEventListener(type, listener, this._listeners);
	    _removeEventListener(type, listener, this._oneTimeListeners);
	    return this;
	};
	Evented.prototype.once = function once(type, listener) {
	    this._oneTimeListeners = this._oneTimeListeners || {};
	    _addEventListener(type, listener, this._oneTimeListeners);
	    return this;
	};
	Evented.prototype.fire = function fire(event, properties) {
	    if (typeof event === 'string') {
	        event = new Event(event, properties || {});
	    }
	    var type = event.type;
	    if (this.listens(type)) {
	        event.target = this;
	        var listeners = this._listeners && this._listeners[type] ? this._listeners[type].slice() : [];
	        for (var i = 0, list = listeners; i < list.length; i += 1) {
	            var listener = list[i];
	            listener.call(this, event);
	        }
	        var oneTimeListeners = this._oneTimeListeners && this._oneTimeListeners[type] ? this._oneTimeListeners[type].slice() : [];
	        for (var i$1 = 0, list$1 = oneTimeListeners; i$1 < list$1.length; i$1 += 1) {
	            var listener$1 = list$1[i$1];
	            _removeEventListener(type, listener$1, this._oneTimeListeners);
	            listener$1.call(this, event);
	        }
	        var parent = this._eventedParent;
	        if (parent) {
	            extend(event, typeof this._eventedParentData === 'function' ? this._eventedParentData() : this._eventedParentData);
	            parent.fire(event);
	        }
	    } else if (event instanceof ErrorEvent) {
	        console.error(event.error);
	    }
	    return this;
	};
	Evented.prototype.listens = function listens(type) {
	    return this._listeners && this._listeners[type] && this._listeners[type].length > 0 || this._oneTimeListeners && this._oneTimeListeners[type] && this._oneTimeListeners[type].length > 0 || this._eventedParent && this._eventedParent.listens(type);
	};
	Evented.prototype.setEventedParent = function setEventedParent(parent, data) {
	    this._eventedParent = parent;
	    this._eventedParentData = data;
	    return this;
	};

	var $version = 8;
	var $root = {
		version: {
			required: true,
			type: "enum",
			values: [
				8
			]
		},
		name: {
			type: "string"
		},
		metadata: {
			type: "*"
		},
		center: {
			type: "array",
			value: "number"
		},
		zoom: {
			type: "number"
		},
		bearing: {
			type: "number",
			"default": 0,
			period: 360,
			units: "degrees"
		},
		pitch: {
			type: "number",
			"default": 0,
			units: "degrees"
		},
		light: {
			type: "light"
		},
		sources: {
			required: true,
			type: "sources"
		},
		sprite: {
			type: "string"
		},
		glyphs: {
			type: "string"
		},
		transition: {
			type: "transition"
		},
		layers: {
			required: true,
			type: "array",
			value: "layer"
		}
	};
	var sources = {
		"*": {
			type: "source"
		}
	};
	var source = [
		"source_vector",
		"source_raster",
		"source_raster_dem",
		"source_geojson",
		"source_video",
		"source_image"
	];
	var source_vector = {
		type: {
			required: true,
			type: "enum",
			values: {
				vector: {
				}
			}
		},
		url: {
			type: "string"
		},
		tiles: {
			type: "array",
			value: "string"
		},
		bounds: {
			type: "array",
			value: "number",
			length: 4,
			"default": [
				-180,
				-85.051129,
				180,
				85.051129
			]
		},
		scheme: {
			type: "enum",
			values: {
				xyz: {
				},
				tms: {
				}
			},
			"default": "xyz"
		},
		minzoom: {
			type: "number",
			"default": 0
		},
		maxzoom: {
			type: "number",
			"default": 22
		},
		attribution: {
			type: "string"
		},
		promoteId: {
			type: "promoteId"
		},
		volatile: {
			type: "boolean",
			"default": false
		},
		"*": {
			type: "*"
		}
	};
	var source_raster = {
		type: {
			required: true,
			type: "enum",
			values: {
				raster: {
				}
			}
		},
		url: {
			type: "string"
		},
		tiles: {
			type: "array",
			value: "string"
		},
		bounds: {
			type: "array",
			value: "number",
			length: 4,
			"default": [
				-180,
				-85.051129,
				180,
				85.051129
			]
		},
		minzoom: {
			type: "number",
			"default": 0
		},
		maxzoom: {
			type: "number",
			"default": 22
		},
		tileSize: {
			type: "number",
			"default": 512,
			units: "pixels"
		},
		scheme: {
			type: "enum",
			values: {
				xyz: {
				},
				tms: {
				}
			},
			"default": "xyz"
		},
		attribution: {
			type: "string"
		},
		volatile: {
			type: "boolean",
			"default": false
		},
		"*": {
			type: "*"
		}
	};
	var source_raster_dem = {
		type: {
			required: true,
			type: "enum",
			values: {
				"raster-dem": {
				}
			}
		},
		url: {
			type: "string"
		},
		tiles: {
			type: "array",
			value: "string"
		},
		bounds: {
			type: "array",
			value: "number",
			length: 4,
			"default": [
				-180,
				-85.051129,
				180,
				85.051129
			]
		},
		minzoom: {
			type: "number",
			"default": 0
		},
		maxzoom: {
			type: "number",
			"default": 22
		},
		tileSize: {
			type: "number",
			"default": 512,
			units: "pixels"
		},
		attribution: {
			type: "string"
		},
		encoding: {
			type: "enum",
			values: {
				terrarium: {
				},
				mapbox: {
				}
			},
			"default": "mapbox"
		},
		volatile: {
			type: "boolean",
			"default": false
		},
		"*": {
			type: "*"
		}
	};
	var source_geojson = {
		type: {
			required: true,
			type: "enum",
			values: {
				geojson: {
				}
			}
		},
		data: {
			type: "*"
		},
		maxzoom: {
			type: "number",
			"default": 18
		},
		attribution: {
			type: "string"
		},
		buffer: {
			type: "number",
			"default": 128,
			maximum: 512,
			minimum: 0
		},
		filter: {
			type: "*"
		},
		tolerance: {
			type: "number",
			"default": 0.375
		},
		cluster: {
			type: "boolean",
			"default": false
		},
		clusterRadius: {
			type: "number",
			"default": 50,
			minimum: 0
		},
		clusterMaxZoom: {
			type: "number"
		},
		clusterMinPoints: {
			type: "number"
		},
		clusterProperties: {
			type: "*"
		},
		lineMetrics: {
			type: "boolean",
			"default": false
		},
		generateId: {
			type: "boolean",
			"default": false
		},
		promoteId: {
			type: "promoteId"
		}
	};
	var source_video = {
		type: {
			required: true,
			type: "enum",
			values: {
				video: {
				}
			}
		},
		urls: {
			required: true,
			type: "array",
			value: "string"
		},
		coordinates: {
			required: true,
			type: "array",
			length: 4,
			value: {
				type: "array",
				length: 2,
				value: "number"
			}
		}
	};
	var source_image = {
		type: {
			required: true,
			type: "enum",
			values: {
				image: {
				}
			}
		},
		url: {
			required: true,
			type: "string"
		},
		coordinates: {
			required: true,
			type: "array",
			length: 4,
			value: {
				type: "array",
				length: 2,
				value: "number"
			}
		}
	};
	var layer = {
		id: {
			type: "string",
			required: true
		},
		type: {
			type: "enum",
			values: {
				fill: {
				},
				line: {
				},
				symbol: {
				},
				circle: {
				},
				heatmap: {
				},
				"fill-extrusion": {
				},
				raster: {
				},
				hillshade: {
				},
				background: {
				}
			},
			required: true
		},
		metadata: {
			type: "*"
		},
		source: {
			type: "string"
		},
		"source-layer": {
			type: "string"
		},
		minzoom: {
			type: "number",
			minimum: 0,
			maximum: 24
		},
		maxzoom: {
			type: "number",
			minimum: 0,
			maximum: 24
		},
		filter: {
			type: "filter"
		},
		layout: {
			type: "layout"
		},
		paint: {
			type: "paint"
		}
	};
	var layout = [
		"layout_fill",
		"layout_line",
		"layout_circle",
		"layout_heatmap",
		"layout_fill-extrusion",
		"layout_symbol",
		"layout_raster",
		"layout_hillshade",
		"layout_background"
	];
	var layout_background = {
		visibility: {
			type: "enum",
			values: {
				visible: {
				},
				none: {
				}
			},
			"default": "visible",
			"property-type": "constant"
		}
	};
	var layout_fill = {
		"fill-sort-key": {
			type: "number",
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		visibility: {
			type: "enum",
			values: {
				visible: {
				},
				none: {
				}
			},
			"default": "visible",
			"property-type": "constant"
		}
	};
	var layout_circle = {
		"circle-sort-key": {
			type: "number",
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		visibility: {
			type: "enum",
			values: {
				visible: {
				},
				none: {
				}
			},
			"default": "visible",
			"property-type": "constant"
		}
	};
	var layout_heatmap = {
		visibility: {
			type: "enum",
			values: {
				visible: {
				},
				none: {
				}
			},
			"default": "visible",
			"property-type": "constant"
		}
	};
	var layout_line = {
		"line-cap": {
			type: "enum",
			values: {
				butt: {
				},
				round: {
				},
				square: {
				}
			},
			"default": "butt",
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"line-join": {
			type: "enum",
			values: {
				bevel: {
				},
				round: {
				},
				miter: {
				}
			},
			"default": "miter",
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"line-miter-limit": {
			type: "number",
			"default": 2,
			requires: [
				{
					"line-join": "miter"
				}
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"line-round-limit": {
			type: "number",
			"default": 1.05,
			requires: [
				{
					"line-join": "round"
				}
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"line-sort-key": {
			type: "number",
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		visibility: {
			type: "enum",
			values: {
				visible: {
				},
				none: {
				}
			},
			"default": "visible",
			"property-type": "constant"
		}
	};
	var layout_symbol = {
		"symbol-placement": {
			type: "enum",
			values: {
				point: {
				},
				line: {
				},
				"line-center": {
				}
			},
			"default": "point",
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"symbol-spacing": {
			type: "number",
			"default": 250,
			minimum: 1,
			units: "pixels",
			requires: [
				{
					"symbol-placement": "line"
				}
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"symbol-avoid-edges": {
			type: "boolean",
			"default": false,
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"symbol-sort-key": {
			type: "number",
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"symbol-z-order": {
			type: "enum",
			values: {
				auto: {
				},
				"viewport-y": {
				},
				source: {
				}
			},
			"default": "auto",
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"icon-allow-overlap": {
			type: "boolean",
			"default": false,
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"icon-ignore-placement": {
			type: "boolean",
			"default": false,
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"icon-optional": {
			type: "boolean",
			"default": false,
			requires: [
				"icon-image",
				"text-field"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"icon-rotation-alignment": {
			type: "enum",
			values: {
				map: {
				},
				viewport: {
				},
				auto: {
				}
			},
			"default": "auto",
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"icon-size": {
			type: "number",
			"default": 1,
			minimum: 0,
			units: "factor of the original icon size",
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"icon-text-fit": {
			type: "enum",
			values: {
				none: {
				},
				width: {
				},
				height: {
				},
				both: {
				}
			},
			"default": "none",
			requires: [
				"icon-image",
				"text-field"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"icon-text-fit-padding": {
			type: "array",
			value: "number",
			length: 4,
			"default": [
				0,
				0,
				0,
				0
			],
			units: "pixels",
			requires: [
				"icon-image",
				"text-field",
				{
					"icon-text-fit": [
						"both",
						"width",
						"height"
					]
				}
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"icon-image": {
			type: "resolvedImage",
			tokens: true,
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"icon-rotate": {
			type: "number",
			"default": 0,
			period: 360,
			units: "degrees",
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"icon-padding": {
			type: "number",
			"default": 2,
			minimum: 0,
			units: "pixels",
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"icon-keep-upright": {
			type: "boolean",
			"default": false,
			requires: [
				"icon-image",
				{
					"icon-rotation-alignment": "map"
				},
				{
					"symbol-placement": [
						"line",
						"line-center"
					]
				}
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"icon-offset": {
			type: "array",
			value: "number",
			length: 2,
			"default": [
				0,
				0
			],
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"icon-anchor": {
			type: "enum",
			values: {
				center: {
				},
				left: {
				},
				right: {
				},
				top: {
				},
				bottom: {
				},
				"top-left": {
				},
				"top-right": {
				},
				"bottom-left": {
				},
				"bottom-right": {
				}
			},
			"default": "center",
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"icon-pitch-alignment": {
			type: "enum",
			values: {
				map: {
				},
				viewport: {
				},
				auto: {
				}
			},
			"default": "auto",
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"text-pitch-alignment": {
			type: "enum",
			values: {
				map: {
				},
				viewport: {
				},
				auto: {
				}
			},
			"default": "auto",
			requires: [
				"text-field"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"text-rotation-alignment": {
			type: "enum",
			values: {
				map: {
				},
				viewport: {
				},
				auto: {
				}
			},
			"default": "auto",
			requires: [
				"text-field"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"text-field": {
			type: "formatted",
			"default": "",
			tokens: true,
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"text-font": {
			type: "array",
			value: "string",
			"default": [
				"Open Sans Regular",
				"Arial Unicode MS Regular"
			],
			requires: [
				"text-field"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"text-size": {
			type: "number",
			"default": 16,
			minimum: 0,
			units: "pixels",
			requires: [
				"text-field"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"text-max-width": {
			type: "number",
			"default": 10,
			minimum: 0,
			units: "ems",
			requires: [
				"text-field"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"text-line-height": {
			type: "number",
			"default": 1.2,
			units: "ems",
			requires: [
				"text-field"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"text-letter-spacing": {
			type: "number",
			"default": 0,
			units: "ems",
			requires: [
				"text-field"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"text-justify": {
			type: "enum",
			values: {
				auto: {
				},
				left: {
				},
				center: {
				},
				right: {
				}
			},
			"default": "center",
			requires: [
				"text-field"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"text-radial-offset": {
			type: "number",
			units: "ems",
			"default": 0,
			requires: [
				"text-field"
			],
			"property-type": "data-driven",
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature"
				]
			}
		},
		"text-variable-anchor": {
			type: "array",
			value: "enum",
			values: {
				center: {
				},
				left: {
				},
				right: {
				},
				top: {
				},
				bottom: {
				},
				"top-left": {
				},
				"top-right": {
				},
				"bottom-left": {
				},
				"bottom-right": {
				}
			},
			requires: [
				"text-field",
				{
					"symbol-placement": [
						"point"
					]
				}
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"text-anchor": {
			type: "enum",
			values: {
				center: {
				},
				left: {
				},
				right: {
				},
				top: {
				},
				bottom: {
				},
				"top-left": {
				},
				"top-right": {
				},
				"bottom-left": {
				},
				"bottom-right": {
				}
			},
			"default": "center",
			requires: [
				"text-field",
				{
					"!": "text-variable-anchor"
				}
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"text-max-angle": {
			type: "number",
			"default": 45,
			units: "degrees",
			requires: [
				"text-field",
				{
					"symbol-placement": [
						"line",
						"line-center"
					]
				}
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"text-writing-mode": {
			type: "array",
			value: "enum",
			values: {
				horizontal: {
				},
				vertical: {
				}
			},
			requires: [
				"text-field",
				{
					"symbol-placement": [
						"point"
					]
				}
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"text-rotate": {
			type: "number",
			"default": 0,
			period: 360,
			units: "degrees",
			requires: [
				"text-field"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"text-padding": {
			type: "number",
			"default": 2,
			minimum: 0,
			units: "pixels",
			requires: [
				"text-field"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"text-keep-upright": {
			type: "boolean",
			"default": true,
			requires: [
				"text-field",
				{
					"text-rotation-alignment": "map"
				},
				{
					"symbol-placement": [
						"line",
						"line-center"
					]
				}
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"text-transform": {
			type: "enum",
			values: {
				none: {
				},
				uppercase: {
				},
				lowercase: {
				}
			},
			"default": "none",
			requires: [
				"text-field"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"text-offset": {
			type: "array",
			value: "number",
			units: "ems",
			length: 2,
			"default": [
				0,
				0
			],
			requires: [
				"text-field",
				{
					"!": "text-radial-offset"
				}
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "data-driven"
		},
		"text-allow-overlap": {
			type: "boolean",
			"default": false,
			requires: [
				"text-field"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"text-ignore-placement": {
			type: "boolean",
			"default": false,
			requires: [
				"text-field"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"text-optional": {
			type: "boolean",
			"default": false,
			requires: [
				"text-field",
				"icon-image"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		visibility: {
			type: "enum",
			values: {
				visible: {
				},
				none: {
				}
			},
			"default": "visible",
			"property-type": "constant"
		}
	};
	var layout_raster = {
		visibility: {
			type: "enum",
			values: {
				visible: {
				},
				none: {
				}
			},
			"default": "visible",
			"property-type": "constant"
		}
	};
	var layout_hillshade = {
		visibility: {
			type: "enum",
			values: {
				visible: {
				},
				none: {
				}
			},
			"default": "visible",
			"property-type": "constant"
		}
	};
	var filter = {
		type: "array",
		value: "*"
	};
	var filter_operator = {
		type: "enum",
		values: {
			"==": {
			},
			"!=": {
			},
			">": {
			},
			">=": {
			},
			"<": {
			},
			"<=": {
			},
			"in": {
			},
			"!in": {
			},
			all: {
			},
			any: {
			},
			none: {
			},
			has: {
			},
			"!has": {
			},
			within: {
			}
		}
	};
	var geometry_type = {
		type: "enum",
		values: {
			Point: {
			},
			LineString: {
			},
			Polygon: {
			}
		}
	};
	var function_stop = {
		type: "array",
		minimum: 0,
		maximum: 24,
		value: [
			"number",
			"color"
		],
		length: 2
	};
	var expression = {
		type: "array",
		value: "*",
		minimum: 1
	};
	var light = {
		anchor: {
			type: "enum",
			"default": "viewport",
			values: {
				map: {
				},
				viewport: {
				}
			},
			"property-type": "data-constant",
			transition: false,
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			}
		},
		position: {
			type: "array",
			"default": [
				1.15,
				210,
				30
			],
			length: 3,
			value: "number",
			"property-type": "data-constant",
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			}
		},
		color: {
			type: "color",
			"property-type": "data-constant",
			"default": "#ffffff",
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			transition: true
		},
		intensity: {
			type: "number",
			"property-type": "data-constant",
			"default": 0.5,
			minimum: 0,
			maximum: 1,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			transition: true
		}
	};
	var paint = [
		"paint_fill",
		"paint_line",
		"paint_circle",
		"paint_heatmap",
		"paint_fill-extrusion",
		"paint_symbol",
		"paint_raster",
		"paint_hillshade",
		"paint_background"
	];
	var paint_fill = {
		"fill-antialias": {
			type: "boolean",
			"default": true,
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"fill-opacity": {
			type: "number",
			"default": 1,
			minimum: 0,
			maximum: 1,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"fill-color": {
			type: "color",
			"default": "#000000",
			transition: true,
			requires: [
				{
					"!": "fill-pattern"
				}
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"fill-outline-color": {
			type: "color",
			transition: true,
			requires: [
				{
					"!": "fill-pattern"
				},
				{
					"fill-antialias": true
				}
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"fill-translate": {
			type: "array",
			value: "number",
			length: 2,
			"default": [
				0,
				0
			],
			transition: true,
			units: "pixels",
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"fill-translate-anchor": {
			type: "enum",
			values: {
				map: {
				},
				viewport: {
				}
			},
			"default": "map",
			requires: [
				"fill-translate"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"fill-pattern": {
			type: "resolvedImage",
			transition: true,
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "cross-faded-data-driven"
		}
	};
	var paint_line = {
		"line-opacity": {
			type: "number",
			"default": 1,
			minimum: 0,
			maximum: 1,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"line-color": {
			type: "color",
			"default": "#000000",
			transition: true,
			requires: [
				{
					"!": "line-pattern"
				}
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"line-translate": {
			type: "array",
			value: "number",
			length: 2,
			"default": [
				0,
				0
			],
			transition: true,
			units: "pixels",
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"line-translate-anchor": {
			type: "enum",
			values: {
				map: {
				},
				viewport: {
				}
			},
			"default": "map",
			requires: [
				"line-translate"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"line-width": {
			type: "number",
			"default": 1,
			minimum: 0,
			transition: true,
			units: "pixels",
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"line-gap-width": {
			type: "number",
			"default": 0,
			minimum: 0,
			transition: true,
			units: "pixels",
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"line-offset": {
			type: "number",
			"default": 0,
			transition: true,
			units: "pixels",
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"line-blur": {
			type: "number",
			"default": 0,
			minimum: 0,
			transition: true,
			units: "pixels",
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"line-dasharray": {
			type: "array",
			value: "number",
			minimum: 0,
			transition: true,
			units: "line widths",
			requires: [
				{
					"!": "line-pattern"
				}
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "cross-faded"
		},
		"line-pattern": {
			type: "resolvedImage",
			transition: true,
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "cross-faded-data-driven"
		},
		"line-gradient": {
			type: "color",
			transition: false,
			requires: [
				{
					"!": "line-dasharray"
				},
				{
					"!": "line-pattern"
				},
				{
					source: "geojson",
					has: {
						lineMetrics: true
					}
				}
			],
			expression: {
				interpolated: true,
				parameters: [
					"line-progress"
				]
			},
			"property-type": "color-ramp"
		}
	};
	var paint_circle = {
		"circle-radius": {
			type: "number",
			"default": 5,
			minimum: 0,
			transition: true,
			units: "pixels",
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"circle-color": {
			type: "color",
			"default": "#000000",
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"circle-blur": {
			type: "number",
			"default": 0,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"circle-opacity": {
			type: "number",
			"default": 1,
			minimum: 0,
			maximum: 1,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"circle-translate": {
			type: "array",
			value: "number",
			length: 2,
			"default": [
				0,
				0
			],
			transition: true,
			units: "pixels",
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"circle-translate-anchor": {
			type: "enum",
			values: {
				map: {
				},
				viewport: {
				}
			},
			"default": "map",
			requires: [
				"circle-translate"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"circle-pitch-scale": {
			type: "enum",
			values: {
				map: {
				},
				viewport: {
				}
			},
			"default": "map",
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"circle-pitch-alignment": {
			type: "enum",
			values: {
				map: {
				},
				viewport: {
				}
			},
			"default": "viewport",
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"circle-stroke-width": {
			type: "number",
			"default": 0,
			minimum: 0,
			transition: true,
			units: "pixels",
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"circle-stroke-color": {
			type: "color",
			"default": "#000000",
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"circle-stroke-opacity": {
			type: "number",
			"default": 1,
			minimum: 0,
			maximum: 1,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		}
	};
	var paint_heatmap = {
		"heatmap-radius": {
			type: "number",
			"default": 30,
			minimum: 1,
			transition: true,
			units: "pixels",
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"heatmap-weight": {
			type: "number",
			"default": 1,
			minimum: 0,
			transition: false,
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"heatmap-intensity": {
			type: "number",
			"default": 1,
			minimum: 0,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"heatmap-color": {
			type: "color",
			"default": [
				"interpolate",
				[
					"linear"
				],
				[
					"heatmap-density"
				],
				0,
				"rgba(0, 0, 255, 0)",
				0.1,
				"royalblue",
				0.3,
				"cyan",
				0.5,
				"lime",
				0.7,
				"yellow",
				1,
				"red"
			],
			transition: false,
			expression: {
				interpolated: true,
				parameters: [
					"heatmap-density"
				]
			},
			"property-type": "color-ramp"
		},
		"heatmap-opacity": {
			type: "number",
			"default": 1,
			minimum: 0,
			maximum: 1,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		}
	};
	var paint_symbol = {
		"icon-opacity": {
			type: "number",
			"default": 1,
			minimum: 0,
			maximum: 1,
			transition: true,
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"icon-color": {
			type: "color",
			"default": "#000000",
			transition: true,
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"icon-halo-color": {
			type: "color",
			"default": "rgba(0, 0, 0, 0)",
			transition: true,
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"icon-halo-width": {
			type: "number",
			"default": 0,
			minimum: 0,
			transition: true,
			units: "pixels",
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"icon-halo-blur": {
			type: "number",
			"default": 0,
			minimum: 0,
			transition: true,
			units: "pixels",
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"icon-translate": {
			type: "array",
			value: "number",
			length: 2,
			"default": [
				0,
				0
			],
			transition: true,
			units: "pixels",
			requires: [
				"icon-image"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"icon-translate-anchor": {
			type: "enum",
			values: {
				map: {
				},
				viewport: {
				}
			},
			"default": "map",
			requires: [
				"icon-image",
				"icon-translate"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"text-opacity": {
			type: "number",
			"default": 1,
			minimum: 0,
			maximum: 1,
			transition: true,
			requires: [
				"text-field"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"text-color": {
			type: "color",
			"default": "#000000",
			transition: true,
			overridable: true,
			requires: [
				"text-field"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"text-halo-color": {
			type: "color",
			"default": "rgba(0, 0, 0, 0)",
			transition: true,
			requires: [
				"text-field"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"text-halo-width": {
			type: "number",
			"default": 0,
			minimum: 0,
			transition: true,
			units: "pixels",
			requires: [
				"text-field"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"text-halo-blur": {
			type: "number",
			"default": 0,
			minimum: 0,
			transition: true,
			units: "pixels",
			requires: [
				"text-field"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"text-translate": {
			type: "array",
			value: "number",
			length: 2,
			"default": [
				0,
				0
			],
			transition: true,
			units: "pixels",
			requires: [
				"text-field"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"text-translate-anchor": {
			type: "enum",
			values: {
				map: {
				},
				viewport: {
				}
			},
			"default": "map",
			requires: [
				"text-field",
				"text-translate"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		}
	};
	var paint_raster = {
		"raster-opacity": {
			type: "number",
			"default": 1,
			minimum: 0,
			maximum: 1,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"raster-hue-rotate": {
			type: "number",
			"default": 0,
			period: 360,
			transition: true,
			units: "degrees",
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"raster-brightness-min": {
			type: "number",
			"default": 0,
			minimum: 0,
			maximum: 1,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"raster-brightness-max": {
			type: "number",
			"default": 1,
			minimum: 0,
			maximum: 1,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"raster-saturation": {
			type: "number",
			"default": 0,
			minimum: -1,
			maximum: 1,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"raster-contrast": {
			type: "number",
			"default": 0,
			minimum: -1,
			maximum: 1,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"raster-resampling": {
			type: "enum",
			values: {
				linear: {
				},
				nearest: {
				}
			},
			"default": "linear",
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"raster-fade-duration": {
			type: "number",
			"default": 300,
			minimum: 0,
			transition: false,
			units: "milliseconds",
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		}
	};
	var paint_hillshade = {
		"hillshade-illumination-direction": {
			type: "number",
			"default": 335,
			minimum: 0,
			maximum: 359,
			transition: false,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"hillshade-illumination-anchor": {
			type: "enum",
			values: {
				map: {
				},
				viewport: {
				}
			},
			"default": "viewport",
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"hillshade-exaggeration": {
			type: "number",
			"default": 0.5,
			minimum: 0,
			maximum: 1,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"hillshade-shadow-color": {
			type: "color",
			"default": "#000000",
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"hillshade-highlight-color": {
			type: "color",
			"default": "#FFFFFF",
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"hillshade-accent-color": {
			type: "color",
			"default": "#000000",
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		}
	};
	var paint_background = {
		"background-color": {
			type: "color",
			"default": "#000000",
			transition: true,
			requires: [
				{
					"!": "background-pattern"
				}
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"background-pattern": {
			type: "resolvedImage",
			transition: true,
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "cross-faded"
		},
		"background-opacity": {
			type: "number",
			"default": 1,
			minimum: 0,
			maximum: 1,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		}
	};
	var transition = {
		duration: {
			type: "number",
			"default": 300,
			minimum: 0,
			units: "milliseconds"
		},
		delay: {
			type: "number",
			"default": 0,
			minimum: 0,
			units: "milliseconds"
		}
	};
	var promoteId = {
		"*": {
			type: "string"
		}
	};
	var spec = {
		$version: $version,
		$root: $root,
		sources: sources,
		source: source,
		source_vector: source_vector,
		source_raster: source_raster,
		source_raster_dem: source_raster_dem,
		source_geojson: source_geojson,
		source_video: source_video,
		source_image: source_image,
		layer: layer,
		layout: layout,
		layout_background: layout_background,
		layout_fill: layout_fill,
		layout_circle: layout_circle,
		layout_heatmap: layout_heatmap,
		"layout_fill-extrusion": {
		visibility: {
			type: "enum",
			values: {
				visible: {
				},
				none: {
				}
			},
			"default": "visible",
			"property-type": "constant"
		}
	},
		layout_line: layout_line,
		layout_symbol: layout_symbol,
		layout_raster: layout_raster,
		layout_hillshade: layout_hillshade,
		filter: filter,
		filter_operator: filter_operator,
		geometry_type: geometry_type,
		"function": {
		expression: {
			type: "expression"
		},
		stops: {
			type: "array",
			value: "function_stop"
		},
		base: {
			type: "number",
			"default": 1,
			minimum: 0
		},
		property: {
			type: "string",
			"default": "$zoom"
		},
		type: {
			type: "enum",
			values: {
				identity: {
				},
				exponential: {
				},
				interval: {
				},
				categorical: {
				}
			},
			"default": "exponential"
		},
		colorSpace: {
			type: "enum",
			values: {
				rgb: {
				},
				lab: {
				},
				hcl: {
				}
			},
			"default": "rgb"
		},
		"default": {
			type: "*",
			required: false
		}
	},
		function_stop: function_stop,
		expression: expression,
		light: light,
		paint: paint,
		paint_fill: paint_fill,
		"paint_fill-extrusion": {
		"fill-extrusion-opacity": {
			type: "number",
			"default": 1,
			minimum: 0,
			maximum: 1,
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"fill-extrusion-color": {
			type: "color",
			"default": "#000000",
			transition: true,
			requires: [
				{
					"!": "fill-extrusion-pattern"
				}
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"fill-extrusion-translate": {
			type: "array",
			value: "number",
			length: 2,
			"default": [
				0,
				0
			],
			transition: true,
			units: "pixels",
			expression: {
				interpolated: true,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"fill-extrusion-translate-anchor": {
			type: "enum",
			values: {
				map: {
				},
				viewport: {
				}
			},
			"default": "map",
			requires: [
				"fill-extrusion-translate"
			],
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		},
		"fill-extrusion-pattern": {
			type: "resolvedImage",
			transition: true,
			expression: {
				interpolated: false,
				parameters: [
					"zoom",
					"feature"
				]
			},
			"property-type": "cross-faded-data-driven"
		},
		"fill-extrusion-height": {
			type: "number",
			"default": 0,
			minimum: 0,
			units: "meters",
			transition: true,
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"fill-extrusion-base": {
			type: "number",
			"default": 0,
			minimum: 0,
			units: "meters",
			transition: true,
			requires: [
				"fill-extrusion-height"
			],
			expression: {
				interpolated: true,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"fill-extrusion-vertical-gradient": {
			type: "boolean",
			"default": true,
			transition: false,
			expression: {
				interpolated: false,
				parameters: [
					"zoom"
				]
			},
			"property-type": "data-constant"
		}
	},
		paint_line: paint_line,
		paint_circle: paint_circle,
		paint_heatmap: paint_heatmap,
		paint_symbol: paint_symbol,
		paint_raster: paint_raster,
		paint_hillshade: paint_hillshade,
		paint_background: paint_background,
		transition: transition,
		"property-type": {
		"data-driven": {
			type: "property-type"
		},
		"cross-faded": {
			type: "property-type"
		},
		"cross-faded-data-driven": {
			type: "property-type"
		},
		"color-ramp": {
			type: "property-type"
		},
		"data-constant": {
			type: "property-type"
		},
		constant: {
			type: "property-type"
		}
	},
		promoteId: promoteId
	};

	var ValidationError = function ValidationError(key, value, message, identifier) {
	    this.message = (key ? key + ': ' : '') + message;
	    if (identifier) {
	        this.identifier = identifier;
	    }
	    if (value !== null && value !== undefined && value.__line__) {
	        this.line = value.__line__;
	    }
	};

	function validateConstants(options) {
	    var key = options.key;
	    var constants = options.value;
	    if (constants) {
	        return [new ValidationError(key, constants, 'constants have been deprecated as of v8')];
	    } else {
	        return [];
	    }
	}

	function extend$1 (output) {
	    var inputs = [], len = arguments.length - 1;
	    while (len-- > 0)
	        inputs[len] = arguments[len + 1];
	    for (var i = 0, list = inputs; i < list.length; i += 1) {
	        var input = list[i];
	        for (var k in input) {
	            output[k] = input[k];
	        }
	    }
	    return output;
	}

	function unbundle(value) {
	    if (value instanceof Number || value instanceof String || value instanceof Boolean) {
	        return value.valueOf();
	    } else {
	        return value;
	    }
	}
	function deepUnbundle(value) {
	    if (Array.isArray(value)) {
	        return value.map(deepUnbundle);
	    } else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {
	        var unbundledValue = {};
	        for (var key in value) {
	            unbundledValue[key] = deepUnbundle(value[key]);
	        }
	        return unbundledValue;
	    }
	    return unbundle(value);
	}

	var ParsingError = function (Error) {
	    function ParsingError(key, message) {
	        Error.call(this, message);
	        this.message = message;
	        this.key = key;
	    }
	    if (Error)
	        ParsingError.__proto__ = Error;
	    ParsingError.prototype = Object.create(Error && Error.prototype);
	    ParsingError.prototype.constructor = ParsingError;
	    return ParsingError;
	}(Error);

	var Scope = function Scope(parent, bindings) {
	    if (bindings === void 0)
	        bindings = [];
	    this.parent = parent;
	    this.bindings = {};
	    for (var i = 0, list = bindings; i < list.length; i += 1) {
	        var ref = list[i];
	        var name = ref[0];
	        var expression = ref[1];
	        this.bindings[name] = expression;
	    }
	};
	Scope.prototype.concat = function concat(bindings) {
	    return new Scope(this, bindings);
	};
	Scope.prototype.get = function get(name) {
	    if (this.bindings[name]) {
	        return this.bindings[name];
	    }
	    if (this.parent) {
	        return this.parent.get(name);
	    }
	    throw new Error(name + ' not found in scope.');
	};
	Scope.prototype.has = function has(name) {
	    if (this.bindings[name]) {
	        return true;
	    }
	    return this.parent ? this.parent.has(name) : false;
	};

	var NullType = { kind: 'null' };
	var NumberType = { kind: 'number' };
	var StringType = { kind: 'string' };
	var BooleanType = { kind: 'boolean' };
	var ColorType = { kind: 'color' };
	var ObjectType = { kind: 'object' };
	var ValueType = { kind: 'value' };
	var ErrorType = { kind: 'error' };
	var CollatorType = { kind: 'collator' };
	var FormattedType = { kind: 'formatted' };
	var ResolvedImageType = { kind: 'resolvedImage' };
	function array(itemType, N) {
	    return {
	        kind: 'array',
	        itemType: itemType,
	        N: N
	    };
	}
	function toString(type) {
	    if (type.kind === 'array') {
	        var itemType = toString(type.itemType);
	        return typeof type.N === 'number' ? 'array<' + itemType + ', ' + type.N + '>' : type.itemType.kind === 'value' ? 'array' : 'array<' + itemType + '>';
	    } else {
	        return type.kind;
	    }
	}
	var valueMemberTypes = [
	    NullType,
	    NumberType,
	    StringType,
	    BooleanType,
	    ColorType,
	    FormattedType,
	    ObjectType,
	    array(ValueType),
	    ResolvedImageType
	];
	function checkSubtype(expected, t) {
	    if (t.kind === 'error') {
	        return null;
	    } else if (expected.kind === 'array') {
	        if (t.kind === 'array' && (t.N === 0 && t.itemType.kind === 'value' || !checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== 'number' || expected.N === t.N)) {
	            return null;
	        }
	    } else if (expected.kind === t.kind) {
	        return null;
	    } else if (expected.kind === 'value') {
	        for (var i = 0, list = valueMemberTypes; i < list.length; i += 1) {
	            var memberType = list[i];
	            if (!checkSubtype(memberType, t)) {
	                return null;
	            }
	        }
	    }
	    return 'Expected ' + toString(expected) + ' but found ' + toString(t) + ' instead.';
	}
	function isValidType(provided, allowedTypes) {
	    return allowedTypes.some(function (t) {
	        return t.kind === provided.kind;
	    });
	}
	function isValidNativeType(provided, allowedTypes) {
	    return allowedTypes.some(function (t) {
	        if (t === 'null') {
	            return provided === null;
	        } else if (t === 'array') {
	            return Array.isArray(provided);
	        } else if (t === 'object') {
	            return provided && !Array.isArray(provided) && typeof provided === 'object';
	        } else {
	            return t === typeof provided;
	        }
	    });
	}

	var csscolorparser = createCommonjsModule(function (module, exports) {
	var kCSSColorTable = {
	    'transparent': [
	        0,
	        0,
	        0,
	        0
	    ],
	    'aliceblue': [
	        240,
	        248,
	        255,
	        1
	    ],
	    'antiquewhite': [
	        250,
	        235,
	        215,
	        1
	    ],
	    'aqua': [
	        0,
	        255,
	        255,
	        1
	    ],
	    'aquamarine': [
	        127,
	        255,
	        212,
	        1
	    ],
	    'azure': [
	        240,
	        255,
	        255,
	        1
	    ],
	    'beige': [
	        245,
	        245,
	        220,
	        1
	    ],
	    'bisque': [
	        255,
	        228,
	        196,
	        1
	    ],
	    'black': [
	        0,
	        0,
	        0,
	        1
	    ],
	    'blanchedalmond': [
	        255,
	        235,
	        205,
	        1
	    ],
	    'blue': [
	        0,
	        0,
	        255,
	        1
	    ],
	    'blueviolet': [
	        138,
	        43,
	        226,
	        1
	    ],
	    'brown': [
	        165,
	        42,
	        42,
	        1
	    ],
	    'burlywood': [
	        222,
	        184,
	        135,
	        1
	    ],
	    'cadetblue': [
	        95,
	        158,
	        160,
	        1
	    ],
	    'chartreuse': [
	        127,
	        255,
	        0,
	        1
	    ],
	    'chocolate': [
	        210,
	        105,
	        30,
	        1
	    ],
	    'coral': [
	        255,
	        127,
	        80,
	        1
	    ],
	    'cornflowerblue': [
	        100,
	        149,
	        237,
	        1
	    ],
	    'cornsilk': [
	        255,
	        248,
	        220,
	        1
	    ],
	    'crimson': [
	        220,
	        20,
	        60,
	        1
	    ],
	    'cyan': [
	        0,
	        255,
	        255,
	        1
	    ],
	    'darkblue': [
	        0,
	        0,
	        139,
	        1
	    ],
	    'darkcyan': [
	        0,
	        139,
	        139,
	        1
	    ],
	    'darkgoldenrod': [
	        184,
	        134,
	        11,
	        1
	    ],
	    'darkgray': [
	        169,
	        169,
	        169,
	        1
	    ],
	    'darkgreen': [
	        0,
	        100,
	        0,
	        1
	    ],
	    'darkgrey': [
	        169,
	        169,
	        169,
	        1
	    ],
	    'darkkhaki': [
	        189,
	        183,
	        107,
	        1
	    ],
	    'darkmagenta': [
	        139,
	        0,
	        139,
	        1
	    ],
	    'darkolivegreen': [
	        85,
	        107,
	        47,
	        1
	    ],
	    'darkorange': [
	        255,
	        140,
	        0,
	        1
	    ],
	    'darkorchid': [
	        153,
	        50,
	        204,
	        1
	    ],
	    'darkred': [
	        139,
	        0,
	        0,
	        1
	    ],
	    'darksalmon': [
	        233,
	        150,
	        122,
	        1
	    ],
	    'darkseagreen': [
	        143,
	        188,
	        143,
	        1
	    ],
	    'darkslateblue': [
	        72,
	        61,
	        139,
	        1
	    ],
	    'darkslategray': [
	        47,
	        79,
	        79,
	        1
	    ],
	    'darkslategrey': [
	        47,
	        79,
	        79,
	        1
	    ],
	    'darkturquoise': [
	        0,
	        206,
	        209,
	        1
	    ],
	    'darkviolet': [
	        148,
	        0,
	        211,
	        1
	    ],
	    'deeppink': [
	        255,
	        20,
	        147,
	        1
	    ],
	    'deepskyblue': [
	        0,
	        191,
	        255,
	        1
	    ],
	    'dimgray': [
	        105,
	        105,
	        105,
	        1
	    ],
	    'dimgrey': [
	        105,
	        105,
	        105,
	        1
	    ],
	    'dodgerblue': [
	        30,
	        144,
	        255,
	        1
	    ],
	    'firebrick': [
	        178,
	        34,
	        34,
	        1
	    ],
	    'floralwhite': [
	        255,
	        250,
	        240,
	        1
	    ],
	    'forestgreen': [
	        34,
	        139,
	        34,
	        1
	    ],
	    'fuchsia': [
	        255,
	        0,
	        255,
	        1
	    ],
	    'gainsboro': [
	        220,
	        220,
	        220,
	        1
	    ],
	    'ghostwhite': [
	        248,
	        248,
	        255,
	        1
	    ],
	    'gold': [
	        255,
	        215,
	        0,
	        1
	    ],
	    'goldenrod': [
	        218,
	        165,
	        32,
	        1
	    ],
	    'gray': [
	        128,
	        128,
	        128,
	        1
	    ],
	    'green': [
	        0,
	        128,
	        0,
	        1
	    ],
	    'greenyellow': [
	        173,
	        255,
	        47,
	        1
	    ],
	    'grey': [
	        128,
	        128,
	        128,
	        1
	    ],
	    'honeydew': [
	        240,
	        255,
	        240,
	        1
	    ],
	    'hotpink': [
	        255,
	        105,
	        180,
	        1
	    ],
	    'indianred': [
	        205,
	        92,
	        92,
	        1
	    ],
	    'indigo': [
	        75,
	        0,
	        130,
	        1
	    ],
	    'ivory': [
	        255,
	        255,
	        240,
	        1
	    ],
	    'khaki': [
	        240,
	        230,
	        140,
	        1
	    ],
	    'lavender': [
	        230,
	        230,
	        250,
	        1
	    ],
	    'lavenderblush': [
	        255,
	        240,
	        245,
	        1
	    ],
	    'lawngreen': [
	        124,
	        252,
	        0,
	        1
	    ],
	    'lemonchiffon': [
	        255,
	        250,
	        205,
	        1
	    ],
	    'lightblue': [
	        173,
	        216,
	        230,
	        1
	    ],
	    'lightcoral': [
	        240,
	        128,
	        128,
	        1
	    ],
	    'lightcyan': [
	        224,
	        255,
	        255,
	        1
	    ],
	    'lightgoldenrodyellow': [
	        250,
	        250,
	        210,
	        1
	    ],
	    'lightgray': [
	        211,
	        211,
	        211,
	        1
	    ],
	    'lightgreen': [
	        144,
	        238,
	        144,
	        1
	    ],
	    'lightgrey': [
	        211,
	        211,
	        211,
	        1
	    ],
	    'lightpink': [
	        255,
	        182,
	        193,
	        1
	    ],
	    'lightsalmon': [
	        255,
	        160,
	        122,
	        1
	    ],
	    'lightseagreen': [
	        32,
	        178,
	        170,
	        1
	    ],
	    'lightskyblue': [
	        135,
	        206,
	        250,
	        1
	    ],
	    'lightslategray': [
	        119,
	        136,
	        153,
	        1
	    ],
	    'lightslategrey': [
	        119,
	        136,
	        153,
	        1
	    ],
	    'lightsteelblue': [
	        176,
	        196,
	        222,
	        1
	    ],
	    'lightyellow': [
	        255,
	        255,
	        224,
	        1
	    ],
	    'lime': [
	        0,
	        255,
	        0,
	        1
	    ],
	    'limegreen': [
	        50,
	        205,
	        50,
	        1
	    ],
	    'linen': [
	        250,
	        240,
	        230,
	        1
	    ],
	    'magenta': [
	        255,
	        0,
	        255,
	        1
	    ],
	    'maroon': [
	        128,
	        0,
	        0,
	        1
	    ],
	    'mediumaquamarine': [
	        102,
	        205,
	        170,
	        1
	    ],
	    'mediumblue': [
	        0,
	        0,
	        205,
	        1
	    ],
	    'mediumorchid': [
	        186,
	        85,
	        211,
	        1
	    ],
	    'mediumpurple': [
	        147,
	        112,
	        219,
	        1
	    ],
	    'mediumseagreen': [
	        60,
	        179,
	        113,
	        1
	    ],
	    'mediumslateblue': [
	        123,
	        104,
	        238,
	        1
	    ],
	    'mediumspringgreen': [
	        0,
	        250,
	        154,
	        1
	    ],
	    'mediumturquoise': [
	        72,
	        209,
	        204,
	        1
	    ],
	    'mediumvioletred': [
	        199,
	        21,
	        133,
	        1
	    ],
	    'midnightblue': [
	        25,
	        25,
	        112,
	        1
	    ],
	    'mintcream': [
	        245,
	        255,
	        250,
	        1
	    ],
	    'mistyrose': [
	        255,
	        228,
	        225,
	        1
	    ],
	    'moccasin': [
	        255,
	        228,
	        181,
	        1
	    ],
	    'navajowhite': [
	        255,
	        222,
	        173,
	        1
	    ],
	    'navy': [
	        0,
	        0,
	        128,
	        1
	    ],
	    'oldlace': [
	        253,
	        245,
	        230,
	        1
	    ],
	    'olive': [
	        128,
	        128,
	        0,
	        1
	    ],
	    'olivedrab': [
	        107,
	        142,
	        35,
	        1
	    ],
	    'orange': [
	        255,
	        165,
	        0,
	        1
	    ],
	    'orangered': [
	        255,
	        69,
	        0,
	        1
	    ],
	    'orchid': [
	        218,
	        112,
	        214,
	        1
	    ],
	    'palegoldenrod': [
	        238,
	        232,
	        170,
	        1
	    ],
	    'palegreen': [
	        152,
	        251,
	        152,
	        1
	    ],
	    'paleturquoise': [
	        175,
	        238,
	        238,
	        1
	    ],
	    'palevioletred': [
	        219,
	        112,
	        147,
	        1
	    ],
	    'papayawhip': [
	        255,
	        239,
	        213,
	        1
	    ],
	    'peachpuff': [
	        255,
	        218,
	        185,
	        1
	    ],
	    'peru': [
	        205,
	        133,
	        63,
	        1
	    ],
	    'pink': [
	        255,
	        192,
	        203,
	        1
	    ],
	    'plum': [
	        221,
	        160,
	        221,
	        1
	    ],
	    'powderblue': [
	        176,
	        224,
	        230,
	        1
	    ],
	    'purple': [
	        128,
	        0,
	        128,
	        1
	    ],
	    'rebeccapurple': [
	        102,
	        51,
	        153,
	        1
	    ],
	    'red': [
	        255,
	        0,
	        0,
	        1
	    ],
	    'rosybrown': [
	        188,
	        143,
	        143,
	        1
	    ],
	    'royalblue': [
	        65,
	        105,
	        225,
	        1
	    ],
	    'saddlebrown': [
	        139,
	        69,
	        19,
	        1
	    ],
	    'salmon': [
	        250,
	        128,
	        114,
	        1
	    ],
	    'sandybrown': [
	        244,
	        164,
	        96,
	        1
	    ],
	    'seagreen': [
	        46,
	        139,
	        87,
	        1
	    ],
	    'seashell': [
	        255,
	        245,
	        238,
	        1
	    ],
	    'sienna': [
	        160,
	        82,
	        45,
	        1
	    ],
	    'silver': [
	        192,
	        192,
	        192,
	        1
	    ],
	    'skyblue': [
	        135,
	        206,
	        235,
	        1
	    ],
	    'slateblue': [
	        106,
	        90,
	        205,
	        1
	    ],
	    'slategray': [
	        112,
	        128,
	        144,
	        1
	    ],
	    'slategrey': [
	        112,
	        128,
	        144,
	        1
	    ],
	    'snow': [
	        255,
	        250,
	        250,
	        1
	    ],
	    'springgreen': [
	        0,
	        255,
	        127,
	        1
	    ],
	    'steelblue': [
	        70,
	        130,
	        180,
	        1
	    ],
	    'tan': [
	        210,
	        180,
	        140,
	        1
	    ],
	    'teal': [
	        0,
	        128,
	        128,
	        1
	    ],
	    'thistle': [
	        216,
	        191,
	        216,
	        1
	    ],
	    'tomato': [
	        255,
	        99,
	        71,
	        1
	    ],
	    'turquoise': [
	        64,
	        224,
	        208,
	        1
	    ],
	    'violet': [
	        238,
	        130,
	        238,
	        1
	    ],
	    'wheat': [
	        245,
	        222,
	        179,
	        1
	    ],
	    'white': [
	        255,
	        255,
	        255,
	        1
	    ],
	    'whitesmoke': [
	        245,
	        245,
	        245,
	        1
	    ],
	    'yellow': [
	        255,
	        255,
	        0,
	        1
	    ],
	    'yellowgreen': [
	        154,
	        205,
	        50,
	        1
	    ]
	};
	function clamp_css_byte(i) {
	    i = Math.round(i);
	    return i < 0 ? 0 : i > 255 ? 255 : i;
	}
	function clamp_css_float(f) {
	    return f < 0 ? 0 : f > 1 ? 1 : f;
	}
	function parse_css_int(str) {
	    if (str[str.length - 1] === '%') {
	        return clamp_css_byte(parseFloat(str) / 100 * 255);
	    }
	    return clamp_css_byte(parseInt(str));
	}
	function parse_css_float(str) {
	    if (str[str.length - 1] === '%') {
	        return clamp_css_float(parseFloat(str) / 100);
	    }
	    return clamp_css_float(parseFloat(str));
	}
	function css_hue_to_rgb(m1, m2, h) {
	    if (h < 0) {
	        h += 1;
	    } else if (h > 1) {
	        h -= 1;
	    }
	    if (h * 6 < 1) {
	        return m1 + (m2 - m1) * h * 6;
	    }
	    if (h * 2 < 1) {
	        return m2;
	    }
	    if (h * 3 < 2) {
	        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
	    }
	    return m1;
	}
	function parseCSSColor(css_str) {
	    var str = css_str.replace(/ /g, '').toLowerCase();
	    if (str in kCSSColorTable) {
	        return kCSSColorTable[str].slice();
	    }
	    if (str[0] === '#') {
	        if (str.length === 4) {
	            var iv = parseInt(str.substr(1), 16);
	            if (!(iv >= 0 && iv <= 4095)) {
	                return null;
	            }
	            return [
	                (iv & 3840) >> 4 | (iv & 3840) >> 8,
	                iv & 240 | (iv & 240) >> 4,
	                iv & 15 | (iv & 15) << 4,
	                1
	            ];
	        } else if (str.length === 7) {
	            var iv = parseInt(str.substr(1), 16);
	            if (!(iv >= 0 && iv <= 16777215)) {
	                return null;
	            }
	            return [
	                (iv & 16711680) >> 16,
	                (iv & 65280) >> 8,
	                iv & 255,
	                1
	            ];
	        }
	        return null;
	    }
	    var op = str.indexOf('('), ep = str.indexOf(')');
	    if (op !== -1 && ep + 1 === str.length) {
	        var fname = str.substr(0, op);
	        var params = str.substr(op + 1, ep - (op + 1)).split(',');
	        var alpha = 1;
	        switch (fname) {
	        case 'rgba':
	            if (params.length !== 4) {
	                return null;
	            }
	            alpha = parse_css_float(params.pop());
	        case 'rgb':
	            if (params.length !== 3) {
	                return null;
	            }
	            return [
	                parse_css_int(params[0]),
	                parse_css_int(params[1]),
	                parse_css_int(params[2]),
	                alpha
	            ];
	        case 'hsla':
	            if (params.length !== 4) {
	                return null;
	            }
	            alpha = parse_css_float(params.pop());
	        case 'hsl':
	            if (params.length !== 3) {
	                return null;
	            }
	            var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360;
	            var s = parse_css_float(params[1]);
	            var l = parse_css_float(params[2]);
	            var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	            var m1 = l * 2 - m2;
	            return [
	                clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255),
	                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
	                clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255),
	                alpha
	            ];
	        default:
	            return null;
	        }
	    }
	    return null;
	}
	try {
	    exports.parseCSSColor = parseCSSColor;
	} catch (e) {
	}
	});
	var csscolorparser_1 = csscolorparser.parseCSSColor;

	var Color = function Color(r, g, b, a) {
	    if (a === void 0)
	        a = 1;
	    this.r = r;
	    this.g = g;
	    this.b = b;
	    this.a = a;
	};
	Color.parse = function parse(input) {
	    if (!input) {
	        return undefined;
	    }
	    if (input instanceof Color) {
	        return input;
	    }
	    if (typeof input !== 'string') {
	        return undefined;
	    }
	    var rgba = csscolorparser_1(input);
	    if (!rgba) {
	        return undefined;
	    }
	    return new Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);
	};
	Color.prototype.toString = function toString() {
	    var ref = this.toArray();
	    var r = ref[0];
	    var g = ref[1];
	    var b = ref[2];
	    var a = ref[3];
	    return 'rgba(' + Math.round(r) + ',' + Math.round(g) + ',' + Math.round(b) + ',' + a + ')';
	};
	Color.prototype.toArray = function toArray() {
	    var ref = this;
	    var r = ref.r;
	    var g = ref.g;
	    var b = ref.b;
	    var a = ref.a;
	    return a === 0 ? [
	        0,
	        0,
	        0,
	        0
	    ] : [
	        r * 255 / a,
	        g * 255 / a,
	        b * 255 / a,
	        a
	    ];
	};
	Color.black = new Color(0, 0, 0, 1);
	Color.white = new Color(1, 1, 1, 1);
	Color.transparent = new Color(0, 0, 0, 0);
	Color.red = new Color(1, 0, 0, 1);

	var Collator = function Collator(caseSensitive, diacriticSensitive, locale) {
	    if (caseSensitive) {
	        this.sensitivity = diacriticSensitive ? 'variant' : 'case';
	    } else {
	        this.sensitivity = diacriticSensitive ? 'accent' : 'base';
	    }
	    this.locale = locale;
	    this.collator = new Intl.Collator(this.locale ? this.locale : [], {
	        sensitivity: this.sensitivity,
	        usage: 'search'
	    });
	};
	Collator.prototype.compare = function compare(lhs, rhs) {
	    return this.collator.compare(lhs, rhs);
	};
	Collator.prototype.resolvedLocale = function resolvedLocale() {
	    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
	};

	var FormattedSection = function FormattedSection(text, image, scale, fontStack, textColor) {
	    this.text = text;
	    this.image = image;
	    this.scale = scale;
	    this.fontStack = fontStack;
	    this.textColor = textColor;
	};
	var Formatted = function Formatted(sections) {
	    this.sections = sections;
	};
	Formatted.fromString = function fromString(unformatted) {
	    return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);
	};
	Formatted.prototype.isEmpty = function isEmpty() {
	    if (this.sections.length === 0) {
	        return true;
	    }
	    return !this.sections.some(function (section) {
	        return section.text.length !== 0 || section.image && section.image.name.length !== 0;
	    });
	};
	Formatted.factory = function factory(text) {
	    if (text instanceof Formatted) {
	        return text;
	    } else {
	        return Formatted.fromString(text);
	    }
	};
	Formatted.prototype.toString = function toString() {
	    if (this.sections.length === 0) {
	        return '';
	    }
	    return this.sections.map(function (section) {
	        return section.text;
	    }).join('');
	};
	Formatted.prototype.serialize = function serialize() {
	    var serialized = ['format'];
	    for (var i = 0, list = this.sections; i < list.length; i += 1) {
	        var section = list[i];
	        if (section.image) {
	            serialized.push([
	                'image',
	                section.image.name
	            ]);
	            continue;
	        }
	        serialized.push(section.text);
	        var options = {};
	        if (section.fontStack) {
	            options['text-font'] = [
	                'literal',
	                section.fontStack.split(',')
	            ];
	        }
	        if (section.scale) {
	            options['font-scale'] = section.scale;
	        }
	        if (section.textColor) {
	            options['text-color'] = ['rgba'].concat(section.textColor.toArray());
	        }
	        serialized.push(options);
	    }
	    return serialized;
	};

	var ResolvedImage = function ResolvedImage(options) {
	    this.name = options.name;
	    this.available = options.available;
	};
	ResolvedImage.prototype.toString = function toString() {
	    return this.name;
	};
	ResolvedImage.fromString = function fromString(name) {
	    if (!name) {
	        return null;
	    }
	    return new ResolvedImage({
	        name: name,
	        available: false
	    });
	};
	ResolvedImage.prototype.serialize = function serialize() {
	    return [
	        'image',
	        this.name
	    ];
	};

	function validateRGBA(r, g, b, a) {
	    if (!(typeof r === 'number' && r >= 0 && r <= 255 && typeof g === 'number' && g >= 0 && g <= 255 && typeof b === 'number' && b >= 0 && b <= 255)) {
	        var value = typeof a === 'number' ? [
	            r,
	            g,
	            b,
	            a
	        ] : [
	            r,
	            g,
	            b
	        ];
	        return 'Invalid rgba value [' + value.join(', ') + ']: \'r\', \'g\', and \'b\' must be between 0 and 255.';
	    }
	    if (!(typeof a === 'undefined' || typeof a === 'number' && a >= 0 && a <= 1)) {
	        return 'Invalid rgba value [' + [
	            r,
	            g,
	            b,
	            a
	        ].join(', ') + ']: \'a\' must be between 0 and 1.';
	    }
	    return null;
	}
	function isValue(mixed) {
	    if (mixed === null) {
	        return true;
	    } else if (typeof mixed === 'string') {
	        return true;
	    } else if (typeof mixed === 'boolean') {
	        return true;
	    } else if (typeof mixed === 'number') {
	        return true;
	    } else if (mixed instanceof Color) {
	        return true;
	    } else if (mixed instanceof Collator) {
	        return true;
	    } else if (mixed instanceof Formatted) {
	        return true;
	    } else if (mixed instanceof ResolvedImage) {
	        return true;
	    } else if (Array.isArray(mixed)) {
	        for (var i = 0, list = mixed; i < list.length; i += 1) {
	            var item = list[i];
	            if (!isValue(item)) {
	                return false;
	            }
	        }
	        return true;
	    } else if (typeof mixed === 'object') {
	        for (var key in mixed) {
	            if (!isValue(mixed[key])) {
	                return false;
	            }
	        }
	        return true;
	    } else {
	        return false;
	    }
	}
	function typeOf(value) {
	    if (value === null) {
	        return NullType;
	    } else if (typeof value === 'string') {
	        return StringType;
	    } else if (typeof value === 'boolean') {
	        return BooleanType;
	    } else if (typeof value === 'number') {
	        return NumberType;
	    } else if (value instanceof Color) {
	        return ColorType;
	    } else if (value instanceof Collator) {
	        return CollatorType;
	    } else if (value instanceof Formatted) {
	        return FormattedType;
	    } else if (value instanceof ResolvedImage) {
	        return ResolvedImageType;
	    } else if (Array.isArray(value)) {
	        var length = value.length;
	        var itemType;
	        for (var i = 0, list = value; i < list.length; i += 1) {
	            var item = list[i];
	            var t = typeOf(item);
	            if (!itemType) {
	                itemType = t;
	            } else if (itemType === t) {
	                continue;
	            } else {
	                itemType = ValueType;
	                break;
	            }
	        }
	        return array(itemType || ValueType, length);
	    } else {
	        return ObjectType;
	    }
	}
	function toString$1(value) {
	    var type = typeof value;
	    if (value === null) {
	        return '';
	    } else if (type === 'string' || type === 'number' || type === 'boolean') {
	        return String(value);
	    } else if (value instanceof Color || value instanceof Formatted || value instanceof ResolvedImage) {
	        return value.toString();
	    } else {
	        return JSON.stringify(value);
	    }
	}

	var Literal = function Literal(type, value) {
	    this.type = type;
	    this.value = value;
	};
	Literal.parse = function parse(args, context) {
	    if (args.length !== 2) {
	        return context.error('\'literal\' expression requires exactly one argument, but found ' + (args.length - 1) + ' instead.');
	    }
	    if (!isValue(args[1])) {
	        return context.error('invalid value');
	    }
	    var value = args[1];
	    var type = typeOf(value);
	    var expected = context.expectedType;
	    if (type.kind === 'array' && type.N === 0 && expected && expected.kind === 'array' && (typeof expected.N !== 'number' || expected.N === 0)) {
	        type = expected;
	    }
	    return new Literal(type, value);
	};
	Literal.prototype.evaluate = function evaluate() {
	    return this.value;
	};
	Literal.prototype.eachChild = function eachChild() {
	};
	Literal.prototype.outputDefined = function outputDefined() {
	    return true;
	};
	Literal.prototype.serialize = function serialize() {
	    if (this.type.kind === 'array' || this.type.kind === 'object') {
	        return [
	            'literal',
	            this.value
	        ];
	    } else if (this.value instanceof Color) {
	        return ['rgba'].concat(this.value.toArray());
	    } else if (this.value instanceof Formatted) {
	        return this.value.serialize();
	    } else {
	        return this.value;
	    }
	};

	var RuntimeError = function RuntimeError(message) {
	    this.name = 'ExpressionEvaluationError';
	    this.message = message;
	};
	RuntimeError.prototype.toJSON = function toJSON() {
	    return this.message;
	};

	var types = {
	    string: StringType,
	    number: NumberType,
	    boolean: BooleanType,
	    object: ObjectType
	};
	var Assertion = function Assertion(type, args) {
	    this.type = type;
	    this.args = args;
	};
	Assertion.parse = function parse(args, context) {
	    if (args.length < 2) {
	        return context.error('Expected at least one argument.');
	    }
	    var i = 1;
	    var type;
	    var name = args[0];
	    if (name === 'array') {
	        var itemType;
	        if (args.length > 2) {
	            var type$1 = args[1];
	            if (typeof type$1 !== 'string' || !(type$1 in types) || type$1 === 'object') {
	                return context.error('The item type argument of "array" must be one of string, number, boolean', 1);
	            }
	            itemType = types[type$1];
	            i++;
	        } else {
	            itemType = ValueType;
	        }
	        var N;
	        if (args.length > 3) {
	            if (args[2] !== null && (typeof args[2] !== 'number' || args[2] < 0 || args[2] !== Math.floor(args[2]))) {
	                return context.error('The length argument to "array" must be a positive integer literal', 2);
	            }
	            N = args[2];
	            i++;
	        }
	        type = array(itemType, N);
	    } else {
	        type = types[name];
	    }
	    var parsed = [];
	    for (; i < args.length; i++) {
	        var input = context.parse(args[i], i, ValueType);
	        if (!input) {
	            return null;
	        }
	        parsed.push(input);
	    }
	    return new Assertion(type, parsed);
	};
	Assertion.prototype.evaluate = function evaluate(ctx) {
	    for (var i = 0; i < this.args.length; i++) {
	        var value = this.args[i].evaluate(ctx);
	        var error = checkSubtype(this.type, typeOf(value));
	        if (!error) {
	            return value;
	        } else if (i === this.args.length - 1) {
	            throw new RuntimeError('Expected value to be of type ' + toString(this.type) + ', but found ' + toString(typeOf(value)) + ' instead.');
	        }
	    }
	    return null;
	};
	Assertion.prototype.eachChild = function eachChild(fn) {
	    this.args.forEach(fn);
	};
	Assertion.prototype.outputDefined = function outputDefined() {
	    return this.args.every(function (arg) {
	        return arg.outputDefined();
	    });
	};
	Assertion.prototype.serialize = function serialize() {
	    var type = this.type;
	    var serialized = [type.kind];
	    if (type.kind === 'array') {
	        var itemType = type.itemType;
	        if (itemType.kind === 'string' || itemType.kind === 'number' || itemType.kind === 'boolean') {
	            serialized.push(itemType.kind);
	            var N = type.N;
	            if (typeof N === 'number' || this.args.length > 1) {
	                serialized.push(N);
	            }
	        }
	    }
	    return serialized.concat(this.args.map(function (arg) {
	        return arg.serialize();
	    }));
	};

	var FormatExpression = function FormatExpression(sections) {
	    this.type = FormattedType;
	    this.sections = sections;
	};
	FormatExpression.parse = function parse(args, context) {
	    if (args.length < 2) {
	        return context.error('Expected at least one argument.');
	    }
	    var firstArg = args[1];
	    if (!Array.isArray(firstArg) && typeof firstArg === 'object') {
	        return context.error('First argument must be an image or text section.');
	    }
	    var sections = [];
	    var nextTokenMayBeObject = false;
	    for (var i = 1; i <= args.length - 1; ++i) {
	        var arg = args[i];
	        if (nextTokenMayBeObject && typeof arg === 'object' && !Array.isArray(arg)) {
	            nextTokenMayBeObject = false;
	            var scale = null;
	            if (arg['font-scale']) {
	                scale = context.parse(arg['font-scale'], 1, NumberType);
	                if (!scale) {
	                    return null;
	                }
	            }
	            var font = null;
	            if (arg['text-font']) {
	                font = context.parse(arg['text-font'], 1, array(StringType));
	                if (!font) {
	                    return null;
	                }
	            }
	            var textColor = null;
	            if (arg['text-color']) {
	                textColor = context.parse(arg['text-color'], 1, ColorType);
	                if (!textColor) {
	                    return null;
	                }
	            }
	            var lastExpression = sections[sections.length - 1];
	            lastExpression.scale = scale;
	            lastExpression.font = font;
	            lastExpression.textColor = textColor;
	        } else {
	            var content = context.parse(args[i], 1, ValueType);
	            if (!content) {
	                return null;
	            }
	            var kind = content.type.kind;
	            if (kind !== 'string' && kind !== 'value' && kind !== 'null' && kind !== 'resolvedImage') {
	                return context.error('Formatted text type must be \'string\', \'value\', \'image\' or \'null\'.');
	            }
	            nextTokenMayBeObject = true;
	            sections.push({
	                content: content,
	                scale: null,
	                font: null,
	                textColor: null
	            });
	        }
	    }
	    return new FormatExpression(sections);
	};
	FormatExpression.prototype.evaluate = function evaluate(ctx) {
	    var evaluateSection = function (section) {
	        var evaluatedContent = section.content.evaluate(ctx);
	        if (typeOf(evaluatedContent) === ResolvedImageType) {
	            return new FormattedSection('', evaluatedContent, null, null, null);
	        }
	        return new FormattedSection(toString$1(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(',') : null, section.textColor ? section.textColor.evaluate(ctx) : null);
	    };
	    return new Formatted(this.sections.map(evaluateSection));
	};
	FormatExpression.prototype.eachChild = function eachChild(fn) {
	    for (var i = 0, list = this.sections; i < list.length; i += 1) {
	        var section = list[i];
	        fn(section.content);
	        if (section.scale) {
	            fn(section.scale);
	        }
	        if (section.font) {
	            fn(section.font);
	        }
	        if (section.textColor) {
	            fn(section.textColor);
	        }
	    }
	};
	FormatExpression.prototype.outputDefined = function outputDefined() {
	    return false;
	};
	FormatExpression.prototype.serialize = function serialize() {
	    var serialized = ['format'];
	    for (var i = 0, list = this.sections; i < list.length; i += 1) {
	        var section = list[i];
	        serialized.push(section.content.serialize());
	        var options = {};
	        if (section.scale) {
	            options['font-scale'] = section.scale.serialize();
	        }
	        if (section.font) {
	            options['text-font'] = section.font.serialize();
	        }
	        if (section.textColor) {
	            options['text-color'] = section.textColor.serialize();
	        }
	        serialized.push(options);
	    }
	    return serialized;
	};

	var ImageExpression = function ImageExpression(input) {
	    this.type = ResolvedImageType;
	    this.input = input;
	};
	ImageExpression.parse = function parse(args, context) {
	    if (args.length !== 2) {
	        return context.error('Expected two arguments.');
	    }
	    var name = context.parse(args[1], 1, StringType);
	    if (!name) {
	        return context.error('No image name provided.');
	    }
	    return new ImageExpression(name);
	};
	ImageExpression.prototype.evaluate = function evaluate(ctx) {
	    var evaluatedImageName = this.input.evaluate(ctx);
	    var value = ResolvedImage.fromString(evaluatedImageName);
	    if (value && ctx.availableImages) {
	        value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;
	    }
	    return value;
	};
	ImageExpression.prototype.eachChild = function eachChild(fn) {
	    fn(this.input);
	};
	ImageExpression.prototype.outputDefined = function outputDefined() {
	    return false;
	};
	ImageExpression.prototype.serialize = function serialize() {
	    return [
	        'image',
	        this.input.serialize()
	    ];
	};

	var types$1 = {
	    'to-boolean': BooleanType,
	    'to-color': ColorType,
	    'to-number': NumberType,
	    'to-string': StringType
	};
	var Coercion = function Coercion(type, args) {
	    this.type = type;
	    this.args = args;
	};
	Coercion.parse = function parse(args, context) {
	    if (args.length < 2) {
	        return context.error('Expected at least one argument.');
	    }
	    var name = args[0];
	    if ((name === 'to-boolean' || name === 'to-string') && args.length !== 2) {
	        return context.error('Expected one argument.');
	    }
	    var type = types$1[name];
	    var parsed = [];
	    for (var i = 1; i < args.length; i++) {
	        var input = context.parse(args[i], i, ValueType);
	        if (!input) {
	            return null;
	        }
	        parsed.push(input);
	    }
	    return new Coercion(type, parsed);
	};
	Coercion.prototype.evaluate = function evaluate(ctx) {
	    if (this.type.kind === 'boolean') {
	        return Boolean(this.args[0].evaluate(ctx));
	    } else if (this.type.kind === 'color') {
	        var input;
	        var error;
	        for (var i = 0, list = this.args; i < list.length; i += 1) {
	            var arg = list[i];
	            input = arg.evaluate(ctx);
	            error = null;
	            if (input instanceof Color) {
	                return input;
	            } else if (typeof input === 'string') {
	                var c = ctx.parseColor(input);
	                if (c) {
	                    return c;
	                }
	            } else if (Array.isArray(input)) {
	                if (input.length < 3 || input.length > 4) {
	                    error = 'Invalid rbga value ' + JSON.stringify(input) + ': expected an array containing either three or four numeric values.';
	                } else {
	                    error = validateRGBA(input[0], input[1], input[2], input[3]);
	                }
	                if (!error) {
	                    return new Color(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);
	                }
	            }
	        }
	        throw new RuntimeError(error || 'Could not parse color from value \'' + (typeof input === 'string' ? input : String(JSON.stringify(input))) + '\'');
	    } else if (this.type.kind === 'number') {
	        var value = null;
	        for (var i$1 = 0, list$1 = this.args; i$1 < list$1.length; i$1 += 1) {
	            var arg$1 = list$1[i$1];
	            value = arg$1.evaluate(ctx);
	            if (value === null) {
	                return 0;
	            }
	            var num = Number(value);
	            if (isNaN(num)) {
	                continue;
	            }
	            return num;
	        }
	        throw new RuntimeError('Could not convert ' + JSON.stringify(value) + ' to number.');
	    } else if (this.type.kind === 'formatted') {
	        return Formatted.fromString(toString$1(this.args[0].evaluate(ctx)));
	    } else if (this.type.kind === 'resolvedImage') {
	        return ResolvedImage.fromString(toString$1(this.args[0].evaluate(ctx)));
	    } else {
	        return toString$1(this.args[0].evaluate(ctx));
	    }
	};
	Coercion.prototype.eachChild = function eachChild(fn) {
	    this.args.forEach(fn);
	};
	Coercion.prototype.outputDefined = function outputDefined() {
	    return this.args.every(function (arg) {
	        return arg.outputDefined();
	    });
	};
	Coercion.prototype.serialize = function serialize() {
	    if (this.type.kind === 'formatted') {
	        return new FormatExpression([{
	                content: this.args[0],
	                scale: null,
	                font: null,
	                textColor: null
	            }]).serialize();
	    }
	    if (this.type.kind === 'resolvedImage') {
	        return new ImageExpression(this.args[0]).serialize();
	    }
	    var serialized = ['to-' + this.type.kind];
	    this.eachChild(function (child) {
	        serialized.push(child.serialize());
	    });
	    return serialized;
	};

	var geometryTypes = [
	    'Unknown',
	    'Point',
	    'LineString',
	    'Polygon'
	];
	var EvaluationContext = function EvaluationContext() {
	    this.globals = null;
	    this.feature = null;
	    this.featureState = null;
	    this.formattedSection = null;
	    this._parseColorCache = {};
	    this.availableImages = null;
	    this.canonical = null;
	};
	EvaluationContext.prototype.id = function id() {
	    return this.feature && 'id' in this.feature ? this.feature.id : null;
	};
	EvaluationContext.prototype.geometryType = function geometryType() {
	    return this.feature ? typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : this.feature.type : null;
	};
	EvaluationContext.prototype.geometry = function geometry() {
	    return this.feature && 'geometry' in this.feature ? this.feature.geometry : null;
	};
	EvaluationContext.prototype.canonicalID = function canonicalID() {
	    return this.canonical;
	};
	EvaluationContext.prototype.properties = function properties() {
	    return this.feature && this.feature.properties || {};
	};
	EvaluationContext.prototype.parseColor = function parseColor(input) {
	    var cached = this._parseColorCache[input];
	    if (!cached) {
	        cached = this._parseColorCache[input] = Color.parse(input);
	    }
	    return cached;
	};

	var CompoundExpression = function CompoundExpression(name, type, evaluate, args) {
	    this.name = name;
	    this.type = type;
	    this._evaluate = evaluate;
	    this.args = args;
	};
	CompoundExpression.prototype.evaluate = function evaluate(ctx) {
	    return this._evaluate(ctx, this.args);
	};
	CompoundExpression.prototype.eachChild = function eachChild(fn) {
	    this.args.forEach(fn);
	};
	CompoundExpression.prototype.outputDefined = function outputDefined() {
	    return false;
	};
	CompoundExpression.prototype.serialize = function serialize() {
	    return [this.name].concat(this.args.map(function (arg) {
	        return arg.serialize();
	    }));
	};
	CompoundExpression.parse = function parse(args, context) {
	    var ref$1;
	    var op = args[0];
	    var definition = CompoundExpression.definitions[op];
	    if (!definition) {
	        return context.error('Unknown expression "' + op + '". If you wanted a literal array, use ["literal", [...]].', 0);
	    }
	    var type = Array.isArray(definition) ? definition[0] : definition.type;
	    var availableOverloads = Array.isArray(definition) ? [[
	            definition[1],
	            definition[2]
	        ]] : definition.overloads;
	    var overloads = availableOverloads.filter(function (ref) {
	        var signature = ref[0];
	        return !Array.isArray(signature) || signature.length === args.length - 1;
	    });
	    var signatureContext = null;
	    for (var i$3 = 0, list = overloads; i$3 < list.length; i$3 += 1) {
	        var ref = list[i$3];
	        var params = ref[0];
	        var evaluate = ref[1];
	        signatureContext = new ParsingContext(context.registry, context.path, null, context.scope);
	        var parsedArgs = [];
	        var argParseFailed = false;
	        for (var i = 1; i < args.length; i++) {
	            var arg = args[i];
	            var expectedType = Array.isArray(params) ? params[i - 1] : params.type;
	            var parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);
	            if (!parsed) {
	                argParseFailed = true;
	                break;
	            }
	            parsedArgs.push(parsed);
	        }
	        if (argParseFailed) {
	            continue;
	        }
	        if (Array.isArray(params)) {
	            if (params.length !== parsedArgs.length) {
	                signatureContext.error('Expected ' + params.length + ' arguments, but found ' + parsedArgs.length + ' instead.');
	                continue;
	            }
	        }
	        for (var i$1 = 0; i$1 < parsedArgs.length; i$1++) {
	            var expected = Array.isArray(params) ? params[i$1] : params.type;
	            var arg$1 = parsedArgs[i$1];
	            signatureContext.concat(i$1 + 1).checkSubtype(expected, arg$1.type);
	        }
	        if (signatureContext.errors.length === 0) {
	            return new CompoundExpression(op, type, evaluate, parsedArgs);
	        }
	    }
	    if (overloads.length === 1) {
	        (ref$1 = context.errors).push.apply(ref$1, signatureContext.errors);
	    } else {
	        var expected$1 = overloads.length ? overloads : availableOverloads;
	        var signatures = expected$1.map(function (ref) {
	            var params = ref[0];
	            return stringifySignature(params);
	        }).join(' | ');
	        var actualTypes = [];
	        for (var i$2 = 1; i$2 < args.length; i$2++) {
	            var parsed$1 = context.parse(args[i$2], 1 + actualTypes.length);
	            if (!parsed$1) {
	                return null;
	            }
	            actualTypes.push(toString(parsed$1.type));
	        }
	        context.error('Expected arguments of type ' + signatures + ', but found (' + actualTypes.join(', ') + ') instead.');
	    }
	    return null;
	};
	CompoundExpression.register = function register(registry, definitions) {
	    CompoundExpression.definitions = definitions;
	    for (var name in definitions) {
	        registry[name] = CompoundExpression;
	    }
	};
	function stringifySignature(signature) {
	    if (Array.isArray(signature)) {
	        return '(' + signature.map(toString).join(', ') + ')';
	    } else {
	        return '(' + toString(signature.type) + '...)';
	    }
	}

	var CollatorExpression = function CollatorExpression(caseSensitive, diacriticSensitive, locale) {
	    this.type = CollatorType;
	    this.locale = locale;
	    this.caseSensitive = caseSensitive;
	    this.diacriticSensitive = diacriticSensitive;
	};
	CollatorExpression.parse = function parse(args, context) {
	    if (args.length !== 2) {
	        return context.error('Expected one argument.');
	    }
	    var options = args[1];
	    if (typeof options !== 'object' || Array.isArray(options)) {
	        return context.error('Collator options argument must be an object.');
	    }
	    var caseSensitive = context.parse(options['case-sensitive'] === undefined ? false : options['case-sensitive'], 1, BooleanType);
	    if (!caseSensitive) {
	        return null;
	    }
	    var diacriticSensitive = context.parse(options['diacritic-sensitive'] === undefined ? false : options['diacritic-sensitive'], 1, BooleanType);
	    if (!diacriticSensitive) {
	        return null;
	    }
	    var locale = null;
	    if (options['locale']) {
	        locale = context.parse(options['locale'], 1, StringType);
	        if (!locale) {
	            return null;
	        }
	    }
	    return new CollatorExpression(caseSensitive, diacriticSensitive, locale);
	};
	CollatorExpression.prototype.evaluate = function evaluate(ctx) {
	    return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);
	};
	CollatorExpression.prototype.eachChild = function eachChild(fn) {
	    fn(this.caseSensitive);
	    fn(this.diacriticSensitive);
	    if (this.locale) {
	        fn(this.locale);
	    }
	};
	CollatorExpression.prototype.outputDefined = function outputDefined() {
	    return false;
	};
	CollatorExpression.prototype.serialize = function serialize() {
	    var options = {};
	    options['case-sensitive'] = this.caseSensitive.serialize();
	    options['diacritic-sensitive'] = this.diacriticSensitive.serialize();
	    if (this.locale) {
	        options['locale'] = this.locale.serialize();
	    }
	    return [
	        'collator',
	        options
	    ];
	};

	var EXTENT = 8192;
	function updateBBox(bbox, coord) {
	    bbox[0] = Math.min(bbox[0], coord[0]);
	    bbox[1] = Math.min(bbox[1], coord[1]);
	    bbox[2] = Math.max(bbox[2], coord[0]);
	    bbox[3] = Math.max(bbox[3], coord[1]);
	}
	function mercatorXfromLng(lng) {
	    return (180 + lng) / 360;
	}
	function mercatorYfromLat(lat) {
	    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
	}
	function boxWithinBox(bbox1, bbox2) {
	    if (bbox1[0] <= bbox2[0]) {
	        return false;
	    }
	    if (bbox1[2] >= bbox2[2]) {
	        return false;
	    }
	    if (bbox1[1] <= bbox2[1]) {
	        return false;
	    }
	    if (bbox1[3] >= bbox2[3]) {
	        return false;
	    }
	    return true;
	}
	function getTileCoordinates(p, canonical) {
	    var x = mercatorXfromLng(p[0]);
	    var y = mercatorYfromLat(p[1]);
	    var tilesAtZoom = Math.pow(2, canonical.z);
	    return [
	        Math.round(x * tilesAtZoom * EXTENT),
	        Math.round(y * tilesAtZoom * EXTENT)
	    ];
	}
	function onBoundary(p, p1, p2) {
	    var x1 = p[0] - p1[0];
	    var y1 = p[1] - p1[1];
	    var x2 = p[0] - p2[0];
	    var y2 = p[1] - p2[1];
	    return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;
	}
	function rayIntersect(p, p1, p2) {
	    return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];
	}
	function pointWithinPolygon(point, rings) {
	    var inside = false;
	    for (var i = 0, len = rings.length; i < len; i++) {
	        var ring = rings[i];
	        for (var j = 0, len2 = ring.length; j < len2 - 1; j++) {
	            if (onBoundary(point, ring[j], ring[j + 1])) {
	                return false;
	            }
	            if (rayIntersect(point, ring[j], ring[j + 1])) {
	                inside = !inside;
	            }
	        }
	    }
	    return inside;
	}
	function pointWithinPolygons(point, polygons) {
	    for (var i = 0; i < polygons.length; i++) {
	        if (pointWithinPolygon(point, polygons[i])) {
	            return true;
	        }
	    }
	    return false;
	}
	function perp(v1, v2) {
	    return v1[0] * v2[1] - v1[1] * v2[0];
	}
	function twoSided(p1, p2, q1, q2) {
	    var x1 = p1[0] - q1[0];
	    var y1 = p1[1] - q1[1];
	    var x2 = p2[0] - q1[0];
	    var y2 = p2[1] - q1[1];
	    var x3 = q2[0] - q1[0];
	    var y3 = q2[1] - q1[1];
	    var det1 = x1 * y3 - x3 * y1;
	    var det2 = x2 * y3 - x3 * y2;
	    if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0) {
	        return true;
	    }
	    return false;
	}
	function lineIntersectLine(a, b, c, d) {
	    var vectorP = [
	        b[0] - a[0],
	        b[1] - a[1]
	    ];
	    var vectorQ = [
	        d[0] - c[0],
	        d[1] - c[1]
	    ];
	    if (perp(vectorQ, vectorP) === 0) {
	        return false;
	    }
	    if (twoSided(a, b, c, d) && twoSided(c, d, a, b)) {
	        return true;
	    }
	    return false;
	}
	function lineIntersectPolygon(p1, p2, polygon) {
	    for (var i = 0, list = polygon; i < list.length; i += 1) {
	        var ring = list[i];
	        for (var j = 0; j < ring.length - 1; ++j) {
	            if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) {
	                return true;
	            }
	        }
	    }
	    return false;
	}
	function lineStringWithinPolygon(line, polygon) {
	    for (var i = 0; i < line.length; ++i) {
	        if (!pointWithinPolygon(line[i], polygon)) {
	            return false;
	        }
	    }
	    for (var i$1 = 0; i$1 < line.length - 1; ++i$1) {
	        if (lineIntersectPolygon(line[i$1], line[i$1 + 1], polygon)) {
	            return false;
	        }
	    }
	    return true;
	}
	function lineStringWithinPolygons(line, polygons) {
	    for (var i = 0; i < polygons.length; i++) {
	        if (lineStringWithinPolygon(line, polygons[i])) {
	            return true;
	        }
	    }
	    return false;
	}
	function getTilePolygon(coordinates, bbox, canonical) {
	    var polygon = [];
	    for (var i = 0; i < coordinates.length; i++) {
	        var ring = [];
	        for (var j = 0; j < coordinates[i].length; j++) {
	            var coord = getTileCoordinates(coordinates[i][j], canonical);
	            updateBBox(bbox, coord);
	            ring.push(coord);
	        }
	        polygon.push(ring);
	    }
	    return polygon;
	}
	function getTilePolygons(coordinates, bbox, canonical) {
	    var polygons = [];
	    for (var i = 0; i < coordinates.length; i++) {
	        var polygon = getTilePolygon(coordinates[i], bbox, canonical);
	        polygons.push(polygon);
	    }
	    return polygons;
	}
	function updatePoint(p, bbox, polyBBox, worldSize) {
	    if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {
	        var halfWorldSize = worldSize * 0.5;
	        var shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;
	        if (shift === 0) {
	            shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;
	        }
	        p[0] += shift;
	    }
	    updateBBox(bbox, p);
	}
	function resetBBox(bbox) {
	    bbox[0] = bbox[1] = Infinity;
	    bbox[2] = bbox[3] = -Infinity;
	}
	function getTilePoints(geometry, pointBBox, polyBBox, canonical) {
	    var worldSize = Math.pow(2, canonical.z) * EXTENT;
	    var shifts = [
	        canonical.x * EXTENT,
	        canonical.y * EXTENT
	    ];
	    var tilePoints = [];
	    for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
	        var points = list$1[i$1];
	        for (var i = 0, list = points; i < list.length; i += 1) {
	            var point = list[i];
	            var p = [
	                point.x + shifts[0],
	                point.y + shifts[1]
	            ];
	            updatePoint(p, pointBBox, polyBBox, worldSize);
	            tilePoints.push(p);
	        }
	    }
	    return tilePoints;
	}
	function getTileLines(geometry, lineBBox, polyBBox, canonical) {
	    var worldSize = Math.pow(2, canonical.z) * EXTENT;
	    var shifts = [
	        canonical.x * EXTENT,
	        canonical.y * EXTENT
	    ];
	    var tileLines = [];
	    for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
	        var line = list$1[i$1];
	        var tileLine = [];
	        for (var i = 0, list = line; i < list.length; i += 1) {
	            var point = list[i];
	            var p = [
	                point.x + shifts[0],
	                point.y + shifts[1]
	            ];
	            updateBBox(lineBBox, p);
	            tileLine.push(p);
	        }
	        tileLines.push(tileLine);
	    }
	    if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {
	        resetBBox(lineBBox);
	        for (var i$3 = 0, list$3 = tileLines; i$3 < list$3.length; i$3 += 1) {
	            var line$1 = list$3[i$3];
	            for (var i$2 = 0, list$2 = line$1; i$2 < list$2.length; i$2 += 1) {
	                var p$1 = list$2[i$2];
	                updatePoint(p$1, lineBBox, polyBBox, worldSize);
	            }
	        }
	    }
	    return tileLines;
	}
	function pointsWithinPolygons(ctx, polygonGeometry) {
	    var pointBBox = [
	        Infinity,
	        Infinity,
	        -Infinity,
	        -Infinity
	    ];
	    var polyBBox = [
	        Infinity,
	        Infinity,
	        -Infinity,
	        -Infinity
	    ];
	    var canonical = ctx.canonicalID();
	    if (polygonGeometry.type === 'Polygon') {
	        var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
	        var tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
	        if (!boxWithinBox(pointBBox, polyBBox)) {
	            return false;
	        }
	        for (var i = 0, list = tilePoints; i < list.length; i += 1) {
	            var point = list[i];
	            if (!pointWithinPolygon(point, tilePolygon)) {
	                return false;
	            }
	        }
	    }
	    if (polygonGeometry.type === 'MultiPolygon') {
	        var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
	        var tilePoints$1 = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
	        if (!boxWithinBox(pointBBox, polyBBox)) {
	            return false;
	        }
	        for (var i$1 = 0, list$1 = tilePoints$1; i$1 < list$1.length; i$1 += 1) {
	            var point$1 = list$1[i$1];
	            if (!pointWithinPolygons(point$1, tilePolygons)) {
	                return false;
	            }
	        }
	    }
	    return true;
	}
	function linesWithinPolygons(ctx, polygonGeometry) {
	    var lineBBox = [
	        Infinity,
	        Infinity,
	        -Infinity,
	        -Infinity
	    ];
	    var polyBBox = [
	        Infinity,
	        Infinity,
	        -Infinity,
	        -Infinity
	    ];
	    var canonical = ctx.canonicalID();
	    if (polygonGeometry.type === 'Polygon') {
	        var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
	        var tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
	        if (!boxWithinBox(lineBBox, polyBBox)) {
	            return false;
	        }
	        for (var i = 0, list = tileLines; i < list.length; i += 1) {
	            var line = list[i];
	            if (!lineStringWithinPolygon(line, tilePolygon)) {
	                return false;
	            }
	        }
	    }
	    if (polygonGeometry.type === 'MultiPolygon') {
	        var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
	        var tileLines$1 = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
	        if (!boxWithinBox(lineBBox, polyBBox)) {
	            return false;
	        }
	        for (var i$1 = 0, list$1 = tileLines$1; i$1 < list$1.length; i$1 += 1) {
	            var line$1 = list$1[i$1];
	            if (!lineStringWithinPolygons(line$1, tilePolygons)) {
	                return false;
	            }
	        }
	    }
	    return true;
	}
	var Within = function Within(geojson, geometries) {
	    this.type = BooleanType;
	    this.geojson = geojson;
	    this.geometries = geometries;
	};
	Within.parse = function parse(args, context) {
	    if (args.length !== 2) {
	        return context.error('\'within\' expression requires exactly one argument, but found ' + (args.length - 1) + ' instead.');
	    }
	    if (isValue(args[1])) {
	        var geojson = args[1];
	        if (geojson.type === 'FeatureCollection') {
	            for (var i = 0; i < geojson.features.length; ++i) {
	                var type = geojson.features[i].geometry.type;
	                if (type === 'Polygon' || type === 'MultiPolygon') {
	                    return new Within(geojson, geojson.features[i].geometry);
	                }
	            }
	        } else if (geojson.type === 'Feature') {
	            var type$1 = geojson.geometry.type;
	            if (type$1 === 'Polygon' || type$1 === 'MultiPolygon') {
	                return new Within(geojson, geojson.geometry);
	            }
	        } else if (geojson.type === 'Polygon' || geojson.type === 'MultiPolygon') {
	            return new Within(geojson, geojson);
	        }
	    }
	    return context.error('\'within\' expression requires valid geojson object that contains polygon geometry type.');
	};
	Within.prototype.evaluate = function evaluate(ctx) {
	    if (ctx.geometry() != null && ctx.canonicalID() != null) {
	        if (ctx.geometryType() === 'Point') {
	            return pointsWithinPolygons(ctx, this.geometries);
	        } else if (ctx.geometryType() === 'LineString') {
	            return linesWithinPolygons(ctx, this.geometries);
	        }
	    }
	    return false;
	};
	Within.prototype.eachChild = function eachChild() {
	};
	Within.prototype.outputDefined = function outputDefined() {
	    return true;
	};
	Within.prototype.serialize = function serialize() {
	    return [
	        'within',
	        this.geojson
	    ];
	};

	function isFeatureConstant(e) {
	    if (e instanceof CompoundExpression) {
	        if (e.name === 'get' && e.args.length === 1) {
	            return false;
	        } else if (e.name === 'feature-state') {
	            return false;
	        } else if (e.name === 'has' && e.args.length === 1) {
	            return false;
	        } else if (e.name === 'properties' || e.name === 'geometry-type' || e.name === 'id') {
	            return false;
	        } else if (/^filter-/.test(e.name)) {
	            return false;
	        }
	    }
	    if (e instanceof Within) {
	        return false;
	    }
	    var result = true;
	    e.eachChild(function (arg) {
	        if (result && !isFeatureConstant(arg)) {
	            result = false;
	        }
	    });
	    return result;
	}
	function isStateConstant(e) {
	    if (e instanceof CompoundExpression) {
	        if (e.name === 'feature-state') {
	            return false;
	        }
	    }
	    var result = true;
	    e.eachChild(function (arg) {
	        if (result && !isStateConstant(arg)) {
	            result = false;
	        }
	    });
	    return result;
	}
	function isGlobalPropertyConstant(e, properties) {
	    if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) {
	        return false;
	    }
	    var result = true;
	    e.eachChild(function (arg) {
	        if (result && !isGlobalPropertyConstant(arg, properties)) {
	            result = false;
	        }
	    });
	    return result;
	}

	var Var = function Var(name, boundExpression) {
	    this.type = boundExpression.type;
	    this.name = name;
	    this.boundExpression = boundExpression;
	};
	Var.parse = function parse(args, context) {
	    if (args.length !== 2 || typeof args[1] !== 'string') {
	        return context.error('\'var\' expression requires exactly one string literal argument.');
	    }
	    var name = args[1];
	    if (!context.scope.has(name)) {
	        return context.error('Unknown variable "' + name + '". Make sure "' + name + '" has been bound in an enclosing "let" expression before using it.', 1);
	    }
	    return new Var(name, context.scope.get(name));
	};
	Var.prototype.evaluate = function evaluate(ctx) {
	    return this.boundExpression.evaluate(ctx);
	};
	Var.prototype.eachChild = function eachChild() {
	};
	Var.prototype.outputDefined = function outputDefined() {
	    return false;
	};
	Var.prototype.serialize = function serialize() {
	    return [
	        'var',
	        this.name
	    ];
	};

	var ParsingContext = function ParsingContext(registry, path, expectedType, scope, errors) {
	    if (path === void 0)
	        path = [];
	    if (scope === void 0)
	        scope = new Scope();
	    if (errors === void 0)
	        errors = [];
	    this.registry = registry;
	    this.path = path;
	    this.key = path.map(function (part) {
	        return '[' + part + ']';
	    }).join('');
	    this.scope = scope;
	    this.errors = errors;
	    this.expectedType = expectedType;
	};
	ParsingContext.prototype.parse = function parse(expr, index, expectedType, bindings, options) {
	    if (options === void 0)
	        options = {};
	    if (index) {
	        return this.concat(index, expectedType, bindings)._parse(expr, options);
	    }
	    return this._parse(expr, options);
	};
	ParsingContext.prototype._parse = function _parse(expr, options) {
	    if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {
	        expr = [
	            'literal',
	            expr
	        ];
	    }
	    function annotate(parsed, type, typeAnnotation) {
	        if (typeAnnotation === 'assert') {
	            return new Assertion(type, [parsed]);
	        } else if (typeAnnotation === 'coerce') {
	            return new Coercion(type, [parsed]);
	        } else {
	            return parsed;
	        }
	    }
	    if (Array.isArray(expr)) {
	        if (expr.length === 0) {
	            return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
	        }
	        var op = expr[0];
	        if (typeof op !== 'string') {
	            this.error('Expression name must be a string, but found ' + typeof op + ' instead. If you wanted a literal array, use ["literal", [...]].', 0);
	            return null;
	        }
	        var Expr = this.registry[op];
	        if (Expr) {
	            var parsed = Expr.parse(expr, this);
	            if (!parsed) {
	                return null;
	            }
	            if (this.expectedType) {
	                var expected = this.expectedType;
	                var actual = parsed.type;
	                if ((expected.kind === 'string' || expected.kind === 'number' || expected.kind === 'boolean' || expected.kind === 'object' || expected.kind === 'array') && actual.kind === 'value') {
	                    parsed = annotate(parsed, expected, options.typeAnnotation || 'assert');
	                } else if ((expected.kind === 'color' || expected.kind === 'formatted' || expected.kind === 'resolvedImage') && (actual.kind === 'value' || actual.kind === 'string')) {
	                    parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');
	                } else if (this.checkSubtype(expected, actual)) {
	                    return null;
	                }
	            }
	            if (!(parsed instanceof Literal) && parsed.type.kind !== 'resolvedImage' && isConstant(parsed)) {
	                var ec = new EvaluationContext();
	                try {
	                    parsed = new Literal(parsed.type, parsed.evaluate(ec));
	                } catch (e) {
	                    this.error(e.message);
	                    return null;
	                }
	            }
	            return parsed;
	        }
	        return this.error('Unknown expression "' + op + '". If you wanted a literal array, use ["literal", [...]].', 0);
	    } else if (typeof expr === 'undefined') {
	        return this.error('\'undefined\' value invalid. Use null instead.');
	    } else if (typeof expr === 'object') {
	        return this.error('Bare objects invalid. Use ["literal", {...}] instead.');
	    } else {
	        return this.error('Expected an array, but found ' + typeof expr + ' instead.');
	    }
	};
	ParsingContext.prototype.concat = function concat(index, expectedType, bindings) {
	    var path = typeof index === 'number' ? this.path.concat(index) : this.path;
	    var scope = bindings ? this.scope.concat(bindings) : this.scope;
	    return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);
	};
	ParsingContext.prototype.error = function error(error$1) {
	    var keys = [], len = arguments.length - 1;
	    while (len-- > 0)
	        keys[len] = arguments[len + 1];
	    var key = '' + this.key + keys.map(function (k) {
	        return '[' + k + ']';
	    }).join('');
	    this.errors.push(new ParsingError(key, error$1));
	};
	ParsingContext.prototype.checkSubtype = function checkSubtype$1(expected, t) {
	    var error = checkSubtype(expected, t);
	    if (error) {
	        this.error(error);
	    }
	    return error;
	};
	function isConstant(expression) {
	    if (expression instanceof Var) {
	        return isConstant(expression.boundExpression);
	    } else if (expression instanceof CompoundExpression && expression.name === 'error') {
	        return false;
	    } else if (expression instanceof CollatorExpression) {
	        return false;
	    } else if (expression instanceof Within) {
	        return false;
	    }
	    var isTypeAnnotation = expression instanceof Coercion || expression instanceof Assertion;
	    var childrenConstant = true;
	    expression.eachChild(function (child) {
	        if (isTypeAnnotation) {
	            childrenConstant = childrenConstant && isConstant(child);
	        } else {
	            childrenConstant = childrenConstant && child instanceof Literal;
	        }
	    });
	    if (!childrenConstant) {
	        return false;
	    }
	    return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, [
	        'zoom',
	        'heatmap-density',
	        'line-progress',
	        'accumulated',
	        'is-supported-script'
	    ]);
	}

	function findStopLessThanOrEqualTo(stops, input) {
	    var lastIndex = stops.length - 1;
	    var lowerIndex = 0;
	    var upperIndex = lastIndex;
	    var currentIndex = 0;
	    var currentValue, nextValue;
	    while (lowerIndex <= upperIndex) {
	        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
	        currentValue = stops[currentIndex];
	        nextValue = stops[currentIndex + 1];
	        if (currentValue <= input) {
	            if (currentIndex === lastIndex || input < nextValue) {
	                return currentIndex;
	            }
	            lowerIndex = currentIndex + 1;
	        } else if (currentValue > input) {
	            upperIndex = currentIndex - 1;
	        } else {
	            throw new RuntimeError('Input is not a number.');
	        }
	    }
	    return 0;
	}

	var Step = function Step(type, input, stops) {
	    this.type = type;
	    this.input = input;
	    this.labels = [];
	    this.outputs = [];
	    for (var i = 0, list = stops; i < list.length; i += 1) {
	        var ref = list[i];
	        var label = ref[0];
	        var expression = ref[1];
	        this.labels.push(label);
	        this.outputs.push(expression);
	    }
	};
	Step.parse = function parse(args, context) {
	    if (args.length - 1 < 4) {
	        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
	    }
	    if ((args.length - 1) % 2 !== 0) {
	        return context.error('Expected an even number of arguments.');
	    }
	    var input = context.parse(args[1], 1, NumberType);
	    if (!input) {
	        return null;
	    }
	    var stops = [];
	    var outputType = null;
	    if (context.expectedType && context.expectedType.kind !== 'value') {
	        outputType = context.expectedType;
	    }
	    for (var i = 1; i < args.length; i += 2) {
	        var label = i === 1 ? -Infinity : args[i];
	        var value = args[i + 1];
	        var labelKey = i;
	        var valueKey = i + 1;
	        if (typeof label !== 'number') {
	            return context.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
	        }
	        if (stops.length && stops[stops.length - 1][0] >= label) {
	            return context.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', labelKey);
	        }
	        var parsed = context.parse(value, valueKey, outputType);
	        if (!parsed) {
	            return null;
	        }
	        outputType = outputType || parsed.type;
	        stops.push([
	            label,
	            parsed
	        ]);
	    }
	    return new Step(outputType, input, stops);
	};
	Step.prototype.evaluate = function evaluate(ctx) {
	    var labels = this.labels;
	    var outputs = this.outputs;
	    if (labels.length === 1) {
	        return outputs[0].evaluate(ctx);
	    }
	    var value = this.input.evaluate(ctx);
	    if (value <= labels[0]) {
	        return outputs[0].evaluate(ctx);
	    }
	    var stopCount = labels.length;
	    if (value >= labels[stopCount - 1]) {
	        return outputs[stopCount - 1].evaluate(ctx);
	    }
	    var index = findStopLessThanOrEqualTo(labels, value);
	    return outputs[index].evaluate(ctx);
	};
	Step.prototype.eachChild = function eachChild(fn) {
	    fn(this.input);
	    for (var i = 0, list = this.outputs; i < list.length; i += 1) {
	        var expression = list[i];
	        fn(expression);
	    }
	};
	Step.prototype.outputDefined = function outputDefined() {
	    return this.outputs.every(function (out) {
	        return out.outputDefined();
	    });
	};
	Step.prototype.serialize = function serialize() {
	    var serialized = [
	        'step',
	        this.input.serialize()
	    ];
	    for (var i = 0; i < this.labels.length; i++) {
	        if (i > 0) {
	            serialized.push(this.labels[i]);
	        }
	        serialized.push(this.outputs[i].serialize());
	    }
	    return serialized;
	};

	function number(a, b, t) {
	    return a * (1 - t) + b * t;
	}
	function color(from, to, t) {
	    return new Color(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));
	}
	function array$1(from, to, t) {
	    return from.map(function (d, i) {
	        return number(d, to[i], t);
	    });
	}

	var interpolate = /*#__PURE__*/Object.freeze({
	__proto__: null,
	number: number,
	color: color,
	array: array$1
	});

	var Xn = 0.95047, Yn = 1, Zn = 1.08883, t0 = 4 / 29, t1 = 6 / 29, t2 = 3 * t1 * t1, t3 = t1 * t1 * t1, deg2rad = Math.PI / 180, rad2deg = 180 / Math.PI;
	function xyz2lab(t) {
	    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
	}
	function lab2xyz(t) {
	    return t > t1 ? t * t * t : t2 * (t - t0);
	}
	function xyz2rgb(x) {
	    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
	}
	function rgb2xyz(x) {
	    x /= 255;
	    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
	}
	function rgbToLab(rgbColor) {
	    var b = rgb2xyz(rgbColor.r), a = rgb2xyz(rgbColor.g), l = rgb2xyz(rgbColor.b), x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn), y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn), z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);
	    return {
	        l: 116 * y - 16,
	        a: 500 * (x - y),
	        b: 200 * (y - z),
	        alpha: rgbColor.a
	    };
	}
	function labToRgb(labColor) {
	    var y = (labColor.l + 16) / 116, x = isNaN(labColor.a) ? y : y + labColor.a / 500, z = isNaN(labColor.b) ? y : y - labColor.b / 200;
	    y = Yn * lab2xyz(y);
	    x = Xn * lab2xyz(x);
	    z = Zn * lab2xyz(z);
	    return new Color(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);
	}
	function interpolateLab(from, to, t) {
	    return {
	        l: number(from.l, to.l, t),
	        a: number(from.a, to.a, t),
	        b: number(from.b, to.b, t),
	        alpha: number(from.alpha, to.alpha, t)
	    };
	}
	function rgbToHcl(rgbColor) {
	    var ref = rgbToLab(rgbColor);
	    var l = ref.l;
	    var a = ref.a;
	    var b = ref.b;
	    var h = Math.atan2(b, a) * rad2deg;
	    return {
	        h: h < 0 ? h + 360 : h,
	        c: Math.sqrt(a * a + b * b),
	        l: l,
	        alpha: rgbColor.a
	    };
	}
	function hclToRgb(hclColor) {
	    var h = hclColor.h * deg2rad, c = hclColor.c, l = hclColor.l;
	    return labToRgb({
	        l: l,
	        a: Math.cos(h) * c,
	        b: Math.sin(h) * c,
	        alpha: hclColor.alpha
	    });
	}
	function interpolateHue(a, b, t) {
	    var d = b - a;
	    return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);
	}
	function interpolateHcl(from, to, t) {
	    return {
	        h: interpolateHue(from.h, to.h, t),
	        c: number(from.c, to.c, t),
	        l: number(from.l, to.l, t),
	        alpha: number(from.alpha, to.alpha, t)
	    };
	}
	var lab = {
	    forward: rgbToLab,
	    reverse: labToRgb,
	    interpolate: interpolateLab
	};
	var hcl = {
	    forward: rgbToHcl,
	    reverse: hclToRgb,
	    interpolate: interpolateHcl
	};

	var colorSpaces = /*#__PURE__*/Object.freeze({
	__proto__: null,
	lab: lab,
	hcl: hcl
	});

	var Interpolate = function Interpolate(type, operator, interpolation, input, stops) {
	    this.type = type;
	    this.operator = operator;
	    this.interpolation = interpolation;
	    this.input = input;
	    this.labels = [];
	    this.outputs = [];
	    for (var i = 0, list = stops; i < list.length; i += 1) {
	        var ref = list[i];
	        var label = ref[0];
	        var expression = ref[1];
	        this.labels.push(label);
	        this.outputs.push(expression);
	    }
	};
	Interpolate.interpolationFactor = function interpolationFactor(interpolation, input, lower, upper) {
	    var t = 0;
	    if (interpolation.name === 'exponential') {
	        t = exponentialInterpolation(input, interpolation.base, lower, upper);
	    } else if (interpolation.name === 'linear') {
	        t = exponentialInterpolation(input, 1, lower, upper);
	    } else if (interpolation.name === 'cubic-bezier') {
	        var c = interpolation.controlPoints;
	        var ub = new unitbezier(c[0], c[1], c[2], c[3]);
	        t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
	    }
	    return t;
	};
	Interpolate.parse = function parse(args, context) {
	    var operator = args[0];
	    var interpolation = args[1];
	    var input = args[2];
	    var rest = args.slice(3);
	    if (!Array.isArray(interpolation) || interpolation.length === 0) {
	        return context.error('Expected an interpolation type expression.', 1);
	    }
	    if (interpolation[0] === 'linear') {
	        interpolation = { name: 'linear' };
	    } else if (interpolation[0] === 'exponential') {
	        var base = interpolation[1];
	        if (typeof base !== 'number') {
	            return context.error('Exponential interpolation requires a numeric base.', 1, 1);
	        }
	        interpolation = {
	            name: 'exponential',
	            base: base
	        };
	    } else if (interpolation[0] === 'cubic-bezier') {
	        var controlPoints = interpolation.slice(1);
	        if (controlPoints.length !== 4 || controlPoints.some(function (t) {
	                return typeof t !== 'number' || t < 0 || t > 1;
	            })) {
	            return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);
	        }
	        interpolation = {
	            name: 'cubic-bezier',
	            controlPoints: controlPoints
	        };
	    } else {
	        return context.error('Unknown interpolation type ' + String(interpolation[0]), 1, 0);
	    }
	    if (args.length - 1 < 4) {
	        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
	    }
	    if ((args.length - 1) % 2 !== 0) {
	        return context.error('Expected an even number of arguments.');
	    }
	    input = context.parse(input, 2, NumberType);
	    if (!input) {
	        return null;
	    }
	    var stops = [];
	    var outputType = null;
	    if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') {
	        outputType = ColorType;
	    } else if (context.expectedType && context.expectedType.kind !== 'value') {
	        outputType = context.expectedType;
	    }
	    for (var i = 0; i < rest.length; i += 2) {
	        var label = rest[i];
	        var value = rest[i + 1];
	        var labelKey = i + 3;
	        var valueKey = i + 4;
	        if (typeof label !== 'number') {
	            return context.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
	        }
	        if (stops.length && stops[stops.length - 1][0] >= label) {
	            return context.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', labelKey);
	        }
	        var parsed = context.parse(value, valueKey, outputType);
	        if (!parsed) {
	            return null;
	        }
	        outputType = outputType || parsed.type;
	        stops.push([
	            label,
	            parsed
	        ]);
	    }
	    if (outputType.kind !== 'number' && outputType.kind !== 'color' && !(outputType.kind === 'array' && outputType.itemType.kind === 'number' && typeof outputType.N === 'number')) {
	        return context.error('Type ' + toString(outputType) + ' is not interpolatable.');
	    }
	    return new Interpolate(outputType, operator, interpolation, input, stops);
	};
	Interpolate.prototype.evaluate = function evaluate(ctx) {
	    var labels = this.labels;
	    var outputs = this.outputs;
	    if (labels.length === 1) {
	        return outputs[0].evaluate(ctx);
	    }
	    var value = this.input.evaluate(ctx);
	    if (value <= labels[0]) {
	        return outputs[0].evaluate(ctx);
	    }
	    var stopCount = labels.length;
	    if (value >= labels[stopCount - 1]) {
	        return outputs[stopCount - 1].evaluate(ctx);
	    }
	    var index = findStopLessThanOrEqualTo(labels, value);
	    var lower = labels[index];
	    var upper = labels[index + 1];
	    var t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);
	    var outputLower = outputs[index].evaluate(ctx);
	    var outputUpper = outputs[index + 1].evaluate(ctx);
	    if (this.operator === 'interpolate') {
	        return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t);
	    } else if (this.operator === 'interpolate-hcl') {
	        return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));
	    } else {
	        return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));
	    }
	};
	Interpolate.prototype.eachChild = function eachChild(fn) {
	    fn(this.input);
	    for (var i = 0, list = this.outputs; i < list.length; i += 1) {
	        var expression = list[i];
	        fn(expression);
	    }
	};
	Interpolate.prototype.outputDefined = function outputDefined() {
	    return this.outputs.every(function (out) {
	        return out.outputDefined();
	    });
	};
	Interpolate.prototype.serialize = function serialize() {
	    var interpolation;
	    if (this.interpolation.name === 'linear') {
	        interpolation = ['linear'];
	    } else if (this.interpolation.name === 'exponential') {
	        if (this.interpolation.base === 1) {
	            interpolation = ['linear'];
	        } else {
	            interpolation = [
	                'exponential',
	                this.interpolation.base
	            ];
	        }
	    } else {
	        interpolation = ['cubic-bezier'].concat(this.interpolation.controlPoints);
	    }
	    var serialized = [
	        this.operator,
	        interpolation,
	        this.input.serialize()
	    ];
	    for (var i = 0; i < this.labels.length; i++) {
	        serialized.push(this.labels[i], this.outputs[i].serialize());
	    }
	    return serialized;
	};
	function exponentialInterpolation(input, base, lowerValue, upperValue) {
	    var difference = upperValue - lowerValue;
	    var progress = input - lowerValue;
	    if (difference === 0) {
	        return 0;
	    } else if (base === 1) {
	        return progress / difference;
	    } else {
	        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
	    }
	}

	var Coalesce = function Coalesce(type, args) {
	    this.type = type;
	    this.args = args;
	};
	Coalesce.parse = function parse(args, context) {
	    if (args.length < 2) {
	        return context.error('Expectected at least one argument.');
	    }
	    var outputType = null;
	    var expectedType = context.expectedType;
	    if (expectedType && expectedType.kind !== 'value') {
	        outputType = expectedType;
	    }
	    var parsedArgs = [];
	    for (var i = 0, list = args.slice(1); i < list.length; i += 1) {
	        var arg = list[i];
	        var parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, { typeAnnotation: 'omit' });
	        if (!parsed) {
	            return null;
	        }
	        outputType = outputType || parsed.type;
	        parsedArgs.push(parsed);
	    }
	    var needsAnnotation = expectedType && parsedArgs.some(function (arg) {
	        return checkSubtype(expectedType, arg.type);
	    });
	    return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);
	};
	Coalesce.prototype.evaluate = function evaluate(ctx) {
	    var result = null;
	    var argCount = 0;
	    var requestedImageName;
	    for (var i = 0, list = this.args; i < list.length; i += 1) {
	        var arg = list[i];
	        argCount++;
	        result = arg.evaluate(ctx);
	        if (result && result instanceof ResolvedImage && !result.available) {
	            if (!requestedImageName) {
	                requestedImageName = result.name;
	            }
	            result = null;
	            if (argCount === this.args.length) {
	                result = requestedImageName;
	            }
	        }
	        if (result !== null) {
	            break;
	        }
	    }
	    return result;
	};
	Coalesce.prototype.eachChild = function eachChild(fn) {
	    this.args.forEach(fn);
	};
	Coalesce.prototype.outputDefined = function outputDefined() {
	    return this.args.every(function (arg) {
	        return arg.outputDefined();
	    });
	};
	Coalesce.prototype.serialize = function serialize() {
	    var serialized = ['coalesce'];
	    this.eachChild(function (child) {
	        serialized.push(child.serialize());
	    });
	    return serialized;
	};

	var Let = function Let(bindings, result) {
	    this.type = result.type;
	    this.bindings = [].concat(bindings);
	    this.result = result;
	};
	Let.prototype.evaluate = function evaluate(ctx) {
	    return this.result.evaluate(ctx);
	};
	Let.prototype.eachChild = function eachChild(fn) {
	    for (var i = 0, list = this.bindings; i < list.length; i += 1) {
	        var binding = list[i];
	        fn(binding[1]);
	    }
	    fn(this.result);
	};
	Let.parse = function parse(args, context) {
	    if (args.length < 4) {
	        return context.error('Expected at least 3 arguments, but found ' + (args.length - 1) + ' instead.');
	    }
	    var bindings = [];
	    for (var i = 1; i < args.length - 1; i += 2) {
	        var name = args[i];
	        if (typeof name !== 'string') {
	            return context.error('Expected string, but found ' + typeof name + ' instead.', i);
	        }
	        if (/[^a-zA-Z0-9_]/.test(name)) {
	            return context.error('Variable names must contain only alphanumeric characters or \'_\'.', i);
	        }
	        var value = context.parse(args[i + 1], i + 1);
	        if (!value) {
	            return null;
	        }
	        bindings.push([
	            name,
	            value
	        ]);
	    }
	    var result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);
	    if (!result) {
	        return null;
	    }
	    return new Let(bindings, result);
	};
	Let.prototype.outputDefined = function outputDefined() {
	    return this.result.outputDefined();
	};
	Let.prototype.serialize = function serialize() {
	    var serialized = ['let'];
	    for (var i = 0, list = this.bindings; i < list.length; i += 1) {
	        var ref = list[i];
	        var name = ref[0];
	        var expr = ref[1];
	        serialized.push(name, expr.serialize());
	    }
	    serialized.push(this.result.serialize());
	    return serialized;
	};

	var At = function At(type, index, input) {
	    this.type = type;
	    this.index = index;
	    this.input = input;
	};
	At.parse = function parse(args, context) {
	    if (args.length !== 3) {
	        return context.error('Expected 2 arguments, but found ' + (args.length - 1) + ' instead.');
	    }
	    var index = context.parse(args[1], 1, NumberType);
	    var input = context.parse(args[2], 2, array(context.expectedType || ValueType));
	    if (!index || !input) {
	        return null;
	    }
	    var t = input.type;
	    return new At(t.itemType, index, input);
	};
	At.prototype.evaluate = function evaluate(ctx) {
	    var index = this.index.evaluate(ctx);
	    var array = this.input.evaluate(ctx);
	    if (index < 0) {
	        throw new RuntimeError('Array index out of bounds: ' + index + ' < 0.');
	    }
	    if (index >= array.length) {
	        throw new RuntimeError('Array index out of bounds: ' + index + ' > ' + (array.length - 1) + '.');
	    }
	    if (index !== Math.floor(index)) {
	        throw new RuntimeError('Array index must be an integer, but found ' + index + ' instead.');
	    }
	    return array[index];
	};
	At.prototype.eachChild = function eachChild(fn) {
	    fn(this.index);
	    fn(this.input);
	};
	At.prototype.outputDefined = function outputDefined() {
	    return false;
	};
	At.prototype.serialize = function serialize() {
	    return [
	        'at',
	        this.index.serialize(),
	        this.input.serialize()
	    ];
	};

	var In = function In(needle, haystack) {
	    this.type = BooleanType;
	    this.needle = needle;
	    this.haystack = haystack;
	};
	In.parse = function parse(args, context) {
	    if (args.length !== 3) {
	        return context.error('Expected 2 arguments, but found ' + (args.length - 1) + ' instead.');
	    }
	    var needle = context.parse(args[1], 1, ValueType);
	    var haystack = context.parse(args[2], 2, ValueType);
	    if (!needle || !haystack) {
	        return null;
	    }
	    if (!isValidType(needle.type, [
	            BooleanType,
	            StringType,
	            NumberType,
	            NullType,
	            ValueType
	        ])) {
	        return context.error('Expected first argument to be of type boolean, string, number or null, but found ' + toString(needle.type) + ' instead');
	    }
	    return new In(needle, haystack);
	};
	In.prototype.evaluate = function evaluate(ctx) {
	    var needle = this.needle.evaluate(ctx);
	    var haystack = this.haystack.evaluate(ctx);
	    if (!haystack) {
	        return false;
	    }
	    if (!isValidNativeType(needle, [
	            'boolean',
	            'string',
	            'number',
	            'null'
	        ])) {
	        throw new RuntimeError('Expected first argument to be of type boolean, string, number or null, but found ' + toString(typeOf(needle)) + ' instead.');
	    }
	    if (!isValidNativeType(haystack, [
	            'string',
	            'array'
	        ])) {
	        throw new RuntimeError('Expected second argument to be of type array or string, but found ' + toString(typeOf(haystack)) + ' instead.');
	    }
	    return haystack.indexOf(needle) >= 0;
	};
	In.prototype.eachChild = function eachChild(fn) {
	    fn(this.needle);
	    fn(this.haystack);
	};
	In.prototype.outputDefined = function outputDefined() {
	    return true;
	};
	In.prototype.serialize = function serialize() {
	    return [
	        'in',
	        this.needle.serialize(),
	        this.haystack.serialize()
	    ];
	};

	var IndexOf = function IndexOf(needle, haystack, fromIndex) {
	    this.type = NumberType;
	    this.needle = needle;
	    this.haystack = haystack;
	    this.fromIndex = fromIndex;
	};
	IndexOf.parse = function parse(args, context) {
	    if (args.length <= 2 || args.length >= 5) {
	        return context.error('Expected 3 or 4 arguments, but found ' + (args.length - 1) + ' instead.');
	    }
	    var needle = context.parse(args[1], 1, ValueType);
	    var haystack = context.parse(args[2], 2, ValueType);
	    if (!needle || !haystack) {
	        return null;
	    }
	    if (!isValidType(needle.type, [
	            BooleanType,
	            StringType,
	            NumberType,
	            NullType,
	            ValueType
	        ])) {
	        return context.error('Expected first argument to be of type boolean, string, number or null, but found ' + toString(needle.type) + ' instead');
	    }
	    if (args.length === 4) {
	        var fromIndex = context.parse(args[3], 3, NumberType);
	        if (!fromIndex) {
	            return null;
	        }
	        return new IndexOf(needle, haystack, fromIndex);
	    } else {
	        return new IndexOf(needle, haystack);
	    }
	};
	IndexOf.prototype.evaluate = function evaluate(ctx) {
	    var needle = this.needle.evaluate(ctx);
	    var haystack = this.haystack.evaluate(ctx);
	    if (!isValidNativeType(needle, [
	            'boolean',
	            'string',
	            'number',
	            'null'
	        ])) {
	        throw new RuntimeError('Expected first argument to be of type boolean, string, number or null, but found ' + toString(typeOf(needle)) + ' instead.');
	    }
	    if (!isValidNativeType(haystack, [
	            'string',
	            'array'
	        ])) {
	        throw new RuntimeError('Expected second argument to be of type array or string, but found ' + toString(typeOf(haystack)) + ' instead.');
	    }
	    if (this.fromIndex) {
	        var fromIndex = this.fromIndex.evaluate(ctx);
	        return haystack.indexOf(needle, fromIndex);
	    }
	    return haystack.indexOf(needle);
	};
	IndexOf.prototype.eachChild = function eachChild(fn) {
	    fn(this.needle);
	    fn(this.haystack);
	    if (this.fromIndex) {
	        fn(this.fromIndex);
	    }
	};
	IndexOf.prototype.outputDefined = function outputDefined() {
	    return false;
	};
	IndexOf.prototype.serialize = function serialize() {
	    if (this.fromIndex != null && this.fromIndex !== undefined) {
	        var fromIndex = this.fromIndex.serialize();
	        return [
	            'index-of',
	            this.needle.serialize(),
	            this.haystack.serialize(),
	            fromIndex
	        ];
	    }
	    return [
	        'index-of',
	        this.needle.serialize(),
	        this.haystack.serialize()
	    ];
	};

	var Match = function Match(inputType, outputType, input, cases, outputs, otherwise) {
	    this.inputType = inputType;
	    this.type = outputType;
	    this.input = input;
	    this.cases = cases;
	    this.outputs = outputs;
	    this.otherwise = otherwise;
	};
	Match.parse = function parse(args, context) {
	    if (args.length < 5) {
	        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
	    }
	    if (args.length % 2 !== 1) {
	        return context.error('Expected an even number of arguments.');
	    }
	    var inputType;
	    var outputType;
	    if (context.expectedType && context.expectedType.kind !== 'value') {
	        outputType = context.expectedType;
	    }
	    var cases = {};
	    var outputs = [];
	    for (var i = 2; i < args.length - 1; i += 2) {
	        var labels = args[i];
	        var value = args[i + 1];
	        if (!Array.isArray(labels)) {
	            labels = [labels];
	        }
	        var labelContext = context.concat(i);
	        if (labels.length === 0) {
	            return labelContext.error('Expected at least one branch label.');
	        }
	        for (var i$1 = 0, list = labels; i$1 < list.length; i$1 += 1) {
	            var label = list[i$1];
	            if (typeof label !== 'number' && typeof label !== 'string') {
	                return labelContext.error('Branch labels must be numbers or strings.');
	            } else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {
	                return labelContext.error('Branch labels must be integers no larger than ' + Number.MAX_SAFE_INTEGER + '.');
	            } else if (typeof label === 'number' && Math.floor(label) !== label) {
	                return labelContext.error('Numeric branch labels must be integer values.');
	            } else if (!inputType) {
	                inputType = typeOf(label);
	            } else if (labelContext.checkSubtype(inputType, typeOf(label))) {
	                return null;
	            }
	            if (typeof cases[String(label)] !== 'undefined') {
	                return labelContext.error('Branch labels must be unique.');
	            }
	            cases[String(label)] = outputs.length;
	        }
	        var result = context.parse(value, i, outputType);
	        if (!result) {
	            return null;
	        }
	        outputType = outputType || result.type;
	        outputs.push(result);
	    }
	    var input = context.parse(args[1], 1, ValueType);
	    if (!input) {
	        return null;
	    }
	    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
	    if (!otherwise) {
	        return null;
	    }
	    if (input.type.kind !== 'value' && context.concat(1).checkSubtype(inputType, input.type)) {
	        return null;
	    }
	    return new Match(inputType, outputType, input, cases, outputs, otherwise);
	};
	Match.prototype.evaluate = function evaluate(ctx) {
	    var input = this.input.evaluate(ctx);
	    var output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
	    return output.evaluate(ctx);
	};
	Match.prototype.eachChild = function eachChild(fn) {
	    fn(this.input);
	    this.outputs.forEach(fn);
	    fn(this.otherwise);
	};
	Match.prototype.outputDefined = function outputDefined() {
	    return this.outputs.every(function (out) {
	        return out.outputDefined();
	    }) && this.otherwise.outputDefined();
	};
	Match.prototype.serialize = function serialize() {
	    var this$1 = this;
	    var serialized = [
	        'match',
	        this.input.serialize()
	    ];
	    var sortedLabels = Object.keys(this.cases).sort();
	    var groupedByOutput = [];
	    var outputLookup = {};
	    for (var i = 0, list = sortedLabels; i < list.length; i += 1) {
	        var label = list[i];
	        var outputIndex = outputLookup[this.cases[label]];
	        if (outputIndex === undefined) {
	            outputLookup[this.cases[label]] = groupedByOutput.length;
	            groupedByOutput.push([
	                this.cases[label],
	                [label]
	            ]);
	        } else {
	            groupedByOutput[outputIndex][1].push(label);
	        }
	    }
	    var coerceLabel = function (label) {
	        return this$1.inputType.kind === 'number' ? Number(label) : label;
	    };
	    for (var i$1 = 0, list$1 = groupedByOutput; i$1 < list$1.length; i$1 += 1) {
	        var ref = list$1[i$1];
	        var outputIndex = ref[0];
	        var labels = ref[1];
	        if (labels.length === 1) {
	            serialized.push(coerceLabel(labels[0]));
	        } else {
	            serialized.push(labels.map(coerceLabel));
	        }
	        serialized.push(this.outputs[outputIndex$1].serialize());
	    }
	    serialized.push(this.otherwise.serialize());
	    return serialized;
	};

	var Case = function Case(type, branches, otherwise) {
	    this.type = type;
	    this.branches = branches;
	    this.otherwise = otherwise;
	};
	Case.parse = function parse(args, context) {
	    if (args.length < 4) {
	        return context.error('Expected at least 3 arguments, but found only ' + (args.length - 1) + '.');
	    }
	    if (args.length % 2 !== 0) {
	        return context.error('Expected an odd number of arguments.');
	    }
	    var outputType;
	    if (context.expectedType && context.expectedType.kind !== 'value') {
	        outputType = context.expectedType;
	    }
	    var branches = [];
	    for (var i = 1; i < args.length - 1; i += 2) {
	        var test = context.parse(args[i], i, BooleanType);
	        if (!test) {
	            return null;
	        }
	        var result = context.parse(args[i + 1], i + 1, outputType);
	        if (!result) {
	            return null;
	        }
	        branches.push([
	            test,
	            result
	        ]);
	        outputType = outputType || result.type;
	    }
	    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
	    if (!otherwise) {
	        return null;
	    }
	    return new Case(outputType, branches, otherwise);
	};
	Case.prototype.evaluate = function evaluate(ctx) {
	    for (var i = 0, list = this.branches; i < list.length; i += 1) {
	        var ref = list[i];
	        var test = ref[0];
	        var expression = ref[1];
	        if (test.evaluate(ctx)) {
	            return expression.evaluate(ctx);
	        }
	    }
	    return this.otherwise.evaluate(ctx);
	};
	Case.prototype.eachChild = function eachChild(fn) {
	    for (var i = 0, list = this.branches; i < list.length; i += 1) {
	        var ref = list[i];
	        var test = ref[0];
	        var expression = ref[1];
	        fn(test);
	        fn(expression);
	    }
	    fn(this.otherwise);
	};
	Case.prototype.outputDefined = function outputDefined() {
	    return this.branches.every(function (ref) {
	        var _ = ref[0];
	        var out = ref[1];
	        return out.outputDefined();
	    }) && this.otherwise.outputDefined();
	};
	Case.prototype.serialize = function serialize() {
	    var serialized = ['case'];
	    this.eachChild(function (child) {
	        serialized.push(child.serialize());
	    });
	    return serialized;
	};

	var Slice = function Slice(type, input, beginIndex, endIndex) {
	    this.type = type;
	    this.input = input;
	    this.beginIndex = beginIndex;
	    this.endIndex = endIndex;
	};
	Slice.parse = function parse(args, context) {
	    if (args.length <= 2 || args.length >= 5) {
	        return context.error('Expected 3 or 4 arguments, but found ' + (args.length - 1) + ' instead.');
	    }
	    var input = context.parse(args[1], 1, ValueType);
	    var beginIndex = context.parse(args[2], 2, NumberType);
	    if (!input || !beginIndex) {
	        return null;
	    }
	    if (!isValidType(input.type, [
	            array(ValueType),
	            StringType,
	            ValueType
	        ])) {
	        return context.error('Expected first argument to be of type array or string, but found ' + toString(input.type) + ' instead');
	    }
	    if (args.length === 4) {
	        var endIndex = context.parse(args[3], 3, NumberType);
	        if (!endIndex) {
	            return null;
	        }
	        return new Slice(input.type, input, beginIndex, endIndex);
	    } else {
	        return new Slice(input.type, input, beginIndex);
	    }
	};
	Slice.prototype.evaluate = function evaluate(ctx) {
	    var input = this.input.evaluate(ctx);
	    var beginIndex = this.beginIndex.evaluate(ctx);
	    if (!isValidNativeType(input, [
	            'string',
	            'array'
	        ])) {
	        throw new RuntimeError('Expected first argument to be of type array or string, but found ' + toString(typeOf(input)) + ' instead.');
	    }
	    if (this.endIndex) {
	        var endIndex = this.endIndex.evaluate(ctx);
	        return input.slice(beginIndex, endIndex);
	    }
	    return input.slice(beginIndex);
	};
	Slice.prototype.eachChild = function eachChild(fn) {
	    fn(this.input);
	    fn(this.beginIndex);
	    if (this.endIndex) {
	        fn(this.endIndex);
	    }
	};
	Slice.prototype.outputDefined = function outputDefined() {
	    return false;
	};
	Slice.prototype.serialize = function serialize() {
	    if (this.endIndex != null && this.endIndex !== undefined) {
	        var endIndex = this.endIndex.serialize();
	        return [
	            'slice',
	            this.input.serialize(),
	            this.beginIndex.serialize(),
	            endIndex
	        ];
	    }
	    return [
	        'slice',
	        this.input.serialize(),
	        this.beginIndex.serialize()
	    ];
	};

	function isComparableType(op, type) {
	    if (op === '==' || op === '!=') {
	        return type.kind === 'boolean' || type.kind === 'string' || type.kind === 'number' || type.kind === 'null' || type.kind === 'value';
	    } else {
	        return type.kind === 'string' || type.kind === 'number' || type.kind === 'value';
	    }
	}
	function eq(ctx, a, b) {
	    return a === b;
	}
	function neq(ctx, a, b) {
	    return a !== b;
	}
	function lt(ctx, a, b) {
	    return a < b;
	}
	function gt(ctx, a, b) {
	    return a > b;
	}
	function lteq(ctx, a, b) {
	    return a <= b;
	}
	function gteq(ctx, a, b) {
	    return a >= b;
	}
	function eqCollate(ctx, a, b, c) {
	    return c.compare(a, b) === 0;
	}
	function neqCollate(ctx, a, b, c) {
	    return !eqCollate(ctx, a, b, c);
	}
	function ltCollate(ctx, a, b, c) {
	    return c.compare(a, b) < 0;
	}
	function gtCollate(ctx, a, b, c) {
	    return c.compare(a, b) > 0;
	}
	function lteqCollate(ctx, a, b, c) {
	    return c.compare(a, b) <= 0;
	}
	function gteqCollate(ctx, a, b, c) {
	    return c.compare(a, b) >= 0;
	}
	function makeComparison(op, compareBasic, compareWithCollator) {
	    var isOrderComparison = op !== '==' && op !== '!=';
	    return function () {
	        function Comparison(lhs, rhs, collator) {
	            this.type = BooleanType;
	            this.lhs = lhs;
	            this.rhs = rhs;
	            this.collator = collator;
	            this.hasUntypedArgument = lhs.type.kind === 'value' || rhs.type.kind === 'value';
	        }
	        Comparison.parse = function parse(args, context) {
	            if (args.length !== 3 && args.length !== 4) {
	                return context.error('Expected two or three arguments.');
	            }
	            var op = args[0];
	            var lhs = context.parse(args[1], 1, ValueType);
	            if (!lhs) {
	                return null;
	            }
	            if (!isComparableType(op, lhs.type)) {
	                return context.concat(1).error('"' + op + '" comparisons are not supported for type \'' + toString(lhs.type) + '\'.');
	            }
	            var rhs = context.parse(args[2], 2, ValueType);
	            if (!rhs) {
	                return null;
	            }
	            if (!isComparableType(op, rhs.type)) {
	                return context.concat(2).error('"' + op + '" comparisons are not supported for type \'' + toString(rhs.type) + '\'.');
	            }
	            if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
	                return context.error('Cannot compare types \'' + toString(lhs.type) + '\' and \'' + toString(rhs.type) + '\'.');
	            }
	            if (isOrderComparison) {
	                if (lhs.type.kind === 'value' && rhs.type.kind !== 'value') {
	                    lhs = new Assertion(rhs.type, [lhs]);
	                } else if (lhs.type.kind !== 'value' && rhs.type.kind === 'value') {
	                    rhs = new Assertion(lhs.type, [rhs]);
	                }
	            }
	            var collator = null;
	            if (args.length === 4) {
	                if (lhs.type.kind !== 'string' && rhs.type.kind !== 'string' && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
	                    return context.error('Cannot use collator to compare non-string types.');
	                }
	                collator = context.parse(args[3], 3, CollatorType);
	                if (!collator) {
	                    return null;
	                }
	            }
	            return new Comparison(lhs, rhs, collator);
	        };
	        Comparison.prototype.evaluate = function evaluate(ctx) {
	            var lhs = this.lhs.evaluate(ctx);
	            var rhs = this.rhs.evaluate(ctx);
	            if (isOrderComparison && this.hasUntypedArgument) {
	                var lt = typeOf(lhs);
	                var rt = typeOf(rhs);
	                if (lt.kind !== rt.kind || !(lt.kind === 'string' || lt.kind === 'number')) {
	                    throw new RuntimeError('Expected arguments for "' + op + '" to be (string, string) or (number, number), but found (' + lt.kind + ', ' + rt.kind + ') instead.');
	                }
	            }
	            if (this.collator && !isOrderComparison && this.hasUntypedArgument) {
	                var lt$1 = typeOf(lhs);
	                var rt$1 = typeOf(rhs);
	                if (lt$1.kind !== 'string' || rt$1.kind !== 'string') {
	                    return compareBasic(ctx, lhs, rhs);
	                }
	            }
	            return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);
	        };
	        Comparison.prototype.eachChild = function eachChild(fn) {
	            fn(this.lhs);
	            fn(this.rhs);
	            if (this.collator) {
	                fn(this.collator);
	            }
	        };
	        Comparison.prototype.outputDefined = function outputDefined() {
	            return true;
	        };
	        Comparison.prototype.serialize = function serialize() {
	            var serialized = [op];
	            this.eachChild(function (child) {
	                serialized.push(child.serialize());
	            });
	            return serialized;
	        };
	        return Comparison;
	    }();
	}
	var Equals = makeComparison('==', eq, eqCollate);
	var NotEquals = makeComparison('!=', neq, neqCollate);
	var LessThan = makeComparison('<', lt, ltCollate);
	var GreaterThan = makeComparison('>', gt, gtCollate);
	var LessThanOrEqual = makeComparison('<=', lteq, lteqCollate);
	var GreaterThanOrEqual = makeComparison('>=', gteq, gteqCollate);

	var NumberFormat = function NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits) {
	    this.type = StringType;
	    this.number = number;
	    this.locale = locale;
	    this.currency = currency;
	    this.minFractionDigits = minFractionDigits;
	    this.maxFractionDigits = maxFractionDigits;
	};
	NumberFormat.parse = function parse(args, context) {
	    if (args.length !== 3) {
	        return context.error('Expected two arguments.');
	    }
	    var number = context.parse(args[1], 1, NumberType);
	    if (!number) {
	        return null;
	    }
	    var options = args[2];
	    if (typeof options !== 'object' || Array.isArray(options)) {
	        return context.error('NumberFormat options argument must be an object.');
	    }
	    var locale = null;
	    if (options['locale']) {
	        locale = context.parse(options['locale'], 1, StringType);
	        if (!locale) {
	            return null;
	        }
	    }
	    var currency = null;
	    if (options['currency']) {
	        currency = context.parse(options['currency'], 1, StringType);
	        if (!currency) {
	            return null;
	        }
	    }
	    var minFractionDigits = null;
	    if (options['min-fraction-digits']) {
	        minFractionDigits = context.parse(options['min-fraction-digits'], 1, NumberType);
	        if (!minFractionDigits) {
	            return null;
	        }
	    }
	    var maxFractionDigits = null;
	    if (options['max-fraction-digits']) {
	        maxFractionDigits = context.parse(options['max-fraction-digits'], 1, NumberType);
	        if (!maxFractionDigits) {
	            return null;
	        }
	    }
	    return new NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits);
	};
	NumberFormat.prototype.evaluate = function evaluate(ctx) {
	    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {
	        style: this.currency ? 'currency' : 'decimal',
	        currency: this.currency ? this.currency.evaluate(ctx) : undefined,
	        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,
	        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined
	    }).format(this.number.evaluate(ctx));
	};
	NumberFormat.prototype.eachChild = function eachChild(fn) {
	    fn(this.number);
	    if (this.locale) {
	        fn(this.locale);
	    }
	    if (this.currency) {
	        fn(this.currency);
	    }
	    if (this.minFractionDigits) {
	        fn(this.minFractionDigits);
	    }
	    if (this.maxFractionDigits) {
	        fn(this.maxFractionDigits);
	    }
	};
	NumberFormat.prototype.outputDefined = function outputDefined() {
	    return false;
	};
	NumberFormat.prototype.serialize = function serialize() {
	    var options = {};
	    if (this.locale) {
	        options['locale'] = this.locale.serialize();
	    }
	    if (this.currency) {
	        options['currency'] = this.currency.serialize();
	    }
	    if (this.minFractionDigits) {
	        options['min-fraction-digits'] = this.minFractionDigits.serialize();
	    }
	    if (this.maxFractionDigits) {
	        options['max-fraction-digits'] = this.maxFractionDigits.serialize();
	    }
	    return [
	        'number-format',
	        this.number.serialize(),
	        options
	    ];
	};

	var Length = function Length(input) {
	    this.type = NumberType;
	    this.input = input;
	};
	Length.parse = function parse(args, context) {
	    if (args.length !== 2) {
	        return context.error('Expected 1 argument, but found ' + (args.length - 1) + ' instead.');
	    }
	    var input = context.parse(args[1], 1);
	    if (!input) {
	        return null;
	    }
	    if (input.type.kind !== 'array' && input.type.kind !== 'string' && input.type.kind !== 'value') {
	        return context.error('Expected argument of type string or array, but found ' + toString(input.type) + ' instead.');
	    }
	    return new Length(input);
	};
	Length.prototype.evaluate = function evaluate(ctx) {
	    var input = this.input.evaluate(ctx);
	    if (typeof input === 'string') {
	        return input.length;
	    } else if (Array.isArray(input)) {
	        return input.length;
	    } else {
	        throw new RuntimeError('Expected value to be of type string or array, but found ' + toString(typeOf(input)) + ' instead.');
	    }
	};
	Length.prototype.eachChild = function eachChild(fn) {
	    fn(this.input);
	};
	Length.prototype.outputDefined = function outputDefined() {
	    return false;
	};
	Length.prototype.serialize = function serialize() {
	    var serialized = ['length'];
	    this.eachChild(function (child) {
	        serialized.push(child.serialize());
	    });
	    return serialized;
	};

	var expressions = {
	    '==': Equals,
	    '!=': NotEquals,
	    '>': GreaterThan,
	    '<': LessThan,
	    '>=': GreaterThanOrEqual,
	    '<=': LessThanOrEqual,
	    'array': Assertion,
	    'at': At,
	    'boolean': Assertion,
	    'case': Case,
	    'coalesce': Coalesce,
	    'collator': CollatorExpression,
	    'format': FormatExpression,
	    'image': ImageExpression,
	    'in': In,
	    'index-of': IndexOf,
	    'interpolate': Interpolate,
	    'interpolate-hcl': Interpolate,
	    'interpolate-lab': Interpolate,
	    'length': Length,
	    'let': Let,
	    'literal': Literal,
	    'match': Match,
	    'number': Assertion,
	    'number-format': NumberFormat,
	    'object': Assertion,
	    'slice': Slice,
	    'step': Step,
	    'string': Assertion,
	    'to-boolean': Coercion,
	    'to-color': Coercion,
	    'to-number': Coercion,
	    'to-string': Coercion,
	    'var': Var,
	    'within': Within
	};
	function rgba(ctx, ref) {
	    var r = ref[0];
	    var g = ref[1];
	    var b = ref[2];
	    var a = ref[3];
	    r = r.evaluate(ctx);
	    g = g.evaluate(ctx);
	    b = b.evaluate(ctx);
	    var alpha = a ? a.evaluate(ctx) : 1;
	    var error = validateRGBA(r, g, b, alpha);
	    if (error) {
	        throw new RuntimeError(error);
	    }
	    return new Color(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);
	}
	function has(key, obj) {
	    return key in obj;
	}
	function get(key, obj) {
	    var v = obj[key];
	    return typeof v === 'undefined' ? null : v;
	}
	function binarySearch(v, a, i, j) {
	    while (i <= j) {
	        var m = i + j >> 1;
	        if (a[m] === v) {
	            return true;
	        }
	        if (a[m] > v) {
	            j = m - 1;
	        } else {
	            i = m + 1;
	        }
	    }
	    return false;
	}
	function varargs(type) {
	    return { type: type };
	}
	CompoundExpression.register(expressions, {
	    'error': [
	        ErrorType,
	        [StringType],
	        function (ctx, ref) {
	            var v = ref[0];
	            throw new RuntimeError(v.evaluate(ctx));
	        }
	    ],
	    'typeof': [
	        StringType,
	        [ValueType],
	        function (ctx, ref) {
	            var v = ref[0];
	            return toString(typeOf(v.evaluate(ctx)));
	        }
	    ],
	    'to-rgba': [
	        array(NumberType, 4),
	        [ColorType],
	        function (ctx, ref) {
	            var v = ref[0];
	            return v.evaluate(ctx).toArray();
	        }
	    ],
	    'rgb': [
	        ColorType,
	        [
	            NumberType,
	            NumberType,
	            NumberType
	        ],
	        rgba
	    ],
	    'rgba': [
	        ColorType,
	        [
	            NumberType,
	            NumberType,
	            NumberType,
	            NumberType
	        ],
	        rgba
	    ],
	    'has': {
	        type: BooleanType,
	        overloads: [
	            [
	                [StringType],
	                function (ctx, ref) {
	                    var key = ref[0];
	                    return has(key.evaluate(ctx), ctx.properties());
	                }
	            ],
	            [
	                [
	                    StringType,
	                    ObjectType
	                ],
	                function (ctx, ref) {
	                    var key = ref[0];
	                    var obj = ref[1];
	                    return has(key.evaluate(ctx), obj.evaluate(ctx));
	                }
	            ]
	        ]
	    },
	    'get': {
	        type: ValueType,
	        overloads: [
	            [
	                [StringType],
	                function (ctx, ref) {
	                    var key = ref[0];
	                    return get(key.evaluate(ctx), ctx.properties());
	                }
	            ],
	            [
	                [
	                    StringType,
	                    ObjectType
	                ],
	                function (ctx, ref) {
	                    var key = ref[0];
	                    var obj = ref[1];
	                    return get(key.evaluate(ctx), obj.evaluate(ctx));
	                }
	            ]
	        ]
	    },
	    'feature-state': [
	        ValueType,
	        [StringType],
	        function (ctx, ref) {
	            var key = ref[0];
	            return get(key.evaluate(ctx), ctx.featureState || {});
	        }
	    ],
	    'properties': [
	        ObjectType,
	        [],
	        function (ctx) {
	            return ctx.properties();
	        }
	    ],
	    'geometry-type': [
	        StringType,
	        [],
	        function (ctx) {
	            return ctx.geometryType();
	        }
	    ],
	    'id': [
	        ValueType,
	        [],
	        function (ctx) {
	            return ctx.id();
	        }
	    ],
	    'zoom': [
	        NumberType,
	        [],
	        function (ctx) {
	            return ctx.globals.zoom;
	        }
	    ],
	    'heatmap-density': [
	        NumberType,
	        [],
	        function (ctx) {
	            return ctx.globals.heatmapDensity || 0;
	        }
	    ],
	    'line-progress': [
	        NumberType,
	        [],
	        function (ctx) {
	            return ctx.globals.lineProgress || 0;
	        }
	    ],
	    'accumulated': [
	        ValueType,
	        [],
	        function (ctx) {
	            return ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated;
	        }
	    ],
	    '+': [
	        NumberType,
	        varargs(NumberType),
	        function (ctx, args) {
	            var result = 0;
	            for (var i = 0, list = args; i < list.length; i += 1) {
	                var arg = list[i];
	                result += arg.evaluate(ctx);
	            }
	            return result;
	        }
	    ],
	    '*': [
	        NumberType,
	        varargs(NumberType),
	        function (ctx, args) {
	            var result = 1;
	            for (var i = 0, list = args; i < list.length; i += 1) {
	                var arg = list[i];
	                result *= arg.evaluate(ctx);
	            }
	            return result;
	        }
	    ],
	    '-': {
	        type: NumberType,
	        overloads: [
	            [
	                [
	                    NumberType,
	                    NumberType
	                ],
	                function (ctx, ref) {
	                    var a = ref[0];
	                    var b = ref[1];
	                    return a.evaluate(ctx) - b.evaluate(ctx);
	                }
	            ],
	            [
	                [NumberType],
	                function (ctx, ref) {
	                    var a = ref[0];
	                    return -a.evaluate(ctx);
	                }
	            ]
	        ]
	    },
	    '/': [
	        NumberType,
	        [
	            NumberType,
	            NumberType
	        ],
	        function (ctx, ref) {
	            var a = ref[0];
	            var b = ref[1];
	            return a.evaluate(ctx) / b.evaluate(ctx);
	        }
	    ],
	    '%': [
	        NumberType,
	        [
	            NumberType,
	            NumberType
	        ],
	        function (ctx, ref) {
	            var a = ref[0];
	            var b = ref[1];
	            return a.evaluate(ctx) % b.evaluate(ctx);
	        }
	    ],
	    'ln2': [
	        NumberType,
	        [],
	        function () {
	            return Math.LN2;
	        }
	    ],
	    'pi': [
	        NumberType,
	        [],
	        function () {
	            return Math.PI;
	        }
	    ],
	    'e': [
	        NumberType,
	        [],
	        function () {
	            return Math.E;
	        }
	    ],
	    '^': [
	        NumberType,
	        [
	            NumberType,
	            NumberType
	        ],
	        function (ctx, ref) {
	            var b = ref[0];
	            var e = ref[1];
	            return Math.pow(b.evaluate(ctx), e.evaluate(ctx));
	        }
	    ],
	    'sqrt': [
	        NumberType,
	        [NumberType],
	        function (ctx, ref) {
	            var x = ref[0];
	            return Math.sqrt(x.evaluate(ctx));
	        }
	    ],
	    'log10': [
	        NumberType,
	        [NumberType],
	        function (ctx, ref) {
	            var n = ref[0];
	            return Math.log(n.evaluate(ctx)) / Math.LN10;
	        }
	    ],
	    'ln': [
	        NumberType,
	        [NumberType],
	        function (ctx, ref) {
	            var n = ref[0];
	            return Math.log(n.evaluate(ctx));
	        }
	    ],
	    'log2': [
	        NumberType,
	        [NumberType],
	        function (ctx, ref) {
	            var n = ref[0];
	            return Math.log(n.evaluate(ctx)) / Math.LN2;
	        }
	    ],
	    'sin': [
	        NumberType,
	        [NumberType],
	        function (ctx, ref) {
	            var n = ref[0];
	            return Math.sin(n.evaluate(ctx));
	        }
	    ],
	    'cos': [
	        NumberType,
	        [NumberType],
	        function (ctx, ref) {
	            var n = ref[0];
	            return Math.cos(n.evaluate(ctx));
	        }
	    ],
	    'tan': [
	        NumberType,
	        [NumberType],
	        function (ctx, ref) {
	            var n = ref[0];
	            return Math.tan(n.evaluate(ctx));
	        }
	    ],
	    'asin': [
	        NumberType,
	        [NumberType],
	        function (ctx, ref) {
	            var n = ref[0];
	            return Math.asin(n.evaluate(ctx));
	        }
	    ],
	    'acos': [
	        NumberType,
	        [NumberType],
	        function (ctx, ref) {
	            var n = ref[0];
	            return Math.acos(n.evaluate(ctx));
	        }
	    ],
	    'atan': [
	        NumberType,
	        [NumberType],
	        function (ctx, ref) {
	            var n = ref[0];
	            return Math.atan(n.evaluate(ctx));
	        }
	    ],
	    'min': [
	        NumberType,
	        varargs(NumberType),
	        function (ctx, args) {
	            return Math.min.apply(Math, args.map(function (arg) {
	                return arg.evaluate(ctx);
	            }));
	        }
	    ],
	    'max': [
	        NumberType,
	        varargs(NumberType),
	        function (ctx, args) {
	            return Math.max.apply(Math, args.map(function (arg) {
	                return arg.evaluate(ctx);
	            }));
	        }
	    ],
	    'abs': [
	        NumberType,
	        [NumberType],
	        function (ctx, ref) {
	            var n = ref[0];
	            return Math.abs(n.evaluate(ctx));
	        }
	    ],
	    'round': [
	        NumberType,
	        [NumberType],
	        function (ctx, ref) {
	            var n = ref[0];
	            var v = n.evaluate(ctx);
	            return v < 0 ? -Math.round(-v) : Math.round(v);
	        }
	    ],
	    'floor': [
	        NumberType,
	        [NumberType],
	        function (ctx, ref) {
	            var n = ref[0];
	            return Math.floor(n.evaluate(ctx));
	        }
	    ],
	    'ceil': [
	        NumberType,
	        [NumberType],
	        function (ctx, ref) {
	            var n = ref[0];
	            return Math.ceil(n.evaluate(ctx));
	        }
	    ],
	    'filter-==': [
	        BooleanType,
	        [
	            StringType,
	            ValueType
	        ],
	        function (ctx, ref) {
	            var k = ref[0];
	            var v = ref[1];
	            return ctx.properties()[k.value] === v.value;
	        }
	    ],
	    'filter-id-==': [
	        BooleanType,
	        [ValueType],
	        function (ctx, ref) {
	            var v = ref[0];
	            return ctx.id() === v.value;
	        }
	    ],
	    'filter-type-==': [
	        BooleanType,
	        [StringType],
	        function (ctx, ref) {
	            var v = ref[0];
	            return ctx.geometryType() === v.value;
	        }
	    ],
	    'filter-<': [
	        BooleanType,
	        [
	            StringType,
	            ValueType
	        ],
	        function (ctx, ref) {
	            var k = ref[0];
	            var v = ref[1];
	            var a = ctx.properties()[k.value];
	            var b = v.value;
	            return typeof a === typeof b && a < b;
	        }
	    ],
	    'filter-id-<': [
	        BooleanType,
	        [ValueType],
	        function (ctx, ref) {
	            var v = ref[0];
	            var a = ctx.id();
	            var b = v.value;
	            return typeof a === typeof b && a < b;
	        }
	    ],
	    'filter->': [
	        BooleanType,
	        [
	            StringType,
	            ValueType
	        ],
	        function (ctx, ref) {
	            var k = ref[0];
	            var v = ref[1];
	            var a = ctx.properties()[k.value];
	            var b = v.value;
	            return typeof a === typeof b && a > b;
	        }
	    ],
	    'filter-id->': [
	        BooleanType,
	        [ValueType],
	        function (ctx, ref) {
	            var v = ref[0];
	            var a = ctx.id();
	            var b = v.value;
	            return typeof a === typeof b && a > b;
	        }
	    ],
	    'filter-<=': [
	        BooleanType,
	        [
	            StringType,
	            ValueType
	        ],
	        function (ctx, ref) {
	            var k = ref[0];
	            var v = ref[1];
	            var a = ctx.properties()[k.value];
	            var b = v.value;
	            return typeof a === typeof b && a <= b;
	        }
	    ],
	    'filter-id-<=': [
	        BooleanType,
	        [ValueType],
	        function (ctx, ref) {
	            var v = ref[0];
	            var a = ctx.id();
	            var b = v.value;
	            return typeof a === typeof b && a <= b;
	        }
	    ],
	    'filter->=': [
	        BooleanType,
	        [
	            StringType,
	            ValueType
	        ],
	        function (ctx, ref) {
	            var k = ref[0];
	            var v = ref[1];
	            var a = ctx.properties()[k.value];
	            var b = v.value;
	            return typeof a === typeof b && a >= b;
	        }
	    ],
	    'filter-id->=': [
	        BooleanType,
	        [ValueType],
	        function (ctx, ref) {
	            var v = ref[0];
	            var a = ctx.id();
	            var b = v.value;
	            return typeof a === typeof b && a >= b;
	        }
	    ],
	    'filter-has': [
	        BooleanType,
	        [ValueType],
	        function (ctx, ref) {
	            var k = ref[0];
	            return k.value in ctx.properties();
	        }
	    ],
	    'filter-has-id': [
	        BooleanType,
	        [],
	        function (ctx) {
	            return ctx.id() !== null && ctx.id() !== undefined;
	        }
	    ],
	    'filter-type-in': [
	        BooleanType,
	        [array(StringType)],
	        function (ctx, ref) {
	            var v = ref[0];
	            return v.value.indexOf(ctx.geometryType()) >= 0;
	        }
	    ],
	    'filter-id-in': [
	        BooleanType,
	        [array(ValueType)],
	        function (ctx, ref) {
	            var v = ref[0];
	            return v.value.indexOf(ctx.id()) >= 0;
	        }
	    ],
	    'filter-in-small': [
	        BooleanType,
	        [
	            StringType,
	            array(ValueType)
	        ],
	        function (ctx, ref) {
	            var k = ref[0];
	            var v = ref[1];
	            return v.value.indexOf(ctx.properties()[k.value]) >= 0;
	        }
	    ],
	    'filter-in-large': [
	        BooleanType,
	        [
	            StringType,
	            array(ValueType)
	        ],
	        function (ctx, ref) {
	            var k = ref[0];
	            var v = ref[1];
	            return binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1);
	        }
	    ],
	    'all': {
	        type: BooleanType,
	        overloads: [
	            [
	                [
	                    BooleanType,
	                    BooleanType
	                ],
	                function (ctx, ref) {
	                    var a = ref[0];
	                    var b = ref[1];
	                    return a.evaluate(ctx) && b.evaluate(ctx);
	                }
	            ],
	            [
	                varargs(BooleanType),
	                function (ctx, args) {
	                    for (var i = 0, list = args; i < list.length; i += 1) {
	                        var arg = list[i];
	                        if (!arg.evaluate(ctx)) {
	                            return false;
	                        }
	                    }
	                    return true;
	                }
	            ]
	        ]
	    },
	    'any': {
	        type: BooleanType,
	        overloads: [
	            [
	                [
	                    BooleanType,
	                    BooleanType
	                ],
	                function (ctx, ref) {
	                    var a = ref[0];
	                    var b = ref[1];
	                    return a.evaluate(ctx) || b.evaluate(ctx);
	                }
	            ],
	            [
	                varargs(BooleanType),
	                function (ctx, args) {
	                    for (var i = 0, list = args; i < list.length; i += 1) {
	                        var arg = list[i];
	                        if (arg.evaluate(ctx)) {
	                            return true;
	                        }
	                    }
	                    return false;
	                }
	            ]
	        ]
	    },
	    '!': [
	        BooleanType,
	        [BooleanType],
	        function (ctx, ref) {
	            var b = ref[0];
	            return !b.evaluate(ctx);
	        }
	    ],
	    'is-supported-script': [
	        BooleanType,
	        [StringType],
	        function (ctx, ref) {
	            var s = ref[0];
	            var isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;
	            if (isSupportedScript) {
	                return isSupportedScript(s.evaluate(ctx));
	            }
	            return true;
	        }
	    ],
	    'upcase': [
	        StringType,
	        [StringType],
	        function (ctx, ref) {
	            var s = ref[0];
	            return s.evaluate(ctx).toUpperCase();
	        }
	    ],
	    'downcase': [
	        StringType,
	        [StringType],
	        function (ctx, ref) {
	            var s = ref[0];
	            return s.evaluate(ctx).toLowerCase();
	        }
	    ],
	    'concat': [
	        StringType,
	        varargs(ValueType),
	        function (ctx, args) {
	            return args.map(function (arg) {
	                return toString$1(arg.evaluate(ctx));
	            }).join('');
	        }
	    ],
	    'resolved-locale': [
	        StringType,
	        [CollatorType],
	        function (ctx, ref) {
	            var collator = ref[0];
	            return collator.evaluate(ctx).resolvedLocale();
	        }
	    ]
	});

	function success(value) {
	    return {
	        result: 'success',
	        value: value
	    };
	}
	function error(value) {
	    return {
	        result: 'error',
	        value: value
	    };
	}

	function supportsPropertyExpression(spec) {
	    return spec['property-type'] === 'data-driven' || spec['property-type'] === 'cross-faded-data-driven';
	}
	function supportsZoomExpression(spec) {
	    return !!spec.expression && spec.expression.parameters.indexOf('zoom') > -1;
	}
	function supportsInterpolation(spec) {
	    return !!spec.expression && spec.expression.interpolated;
	}

	function getType(val) {
	    if (val instanceof Number) {
	        return 'number';
	    } else if (val instanceof String) {
	        return 'string';
	    } else if (val instanceof Boolean) {
	        return 'boolean';
	    } else if (Array.isArray(val)) {
	        return 'array';
	    } else if (val === null) {
	        return 'null';
	    } else {
	        return typeof val;
	    }
	}

	function isFunction(value) {
	    return typeof value === 'object' && value !== null && !Array.isArray(value);
	}
	function identityFunction(x) {
	    return x;
	}
	function createFunction(parameters, propertySpec) {
	    var isColor = propertySpec.type === 'color';
	    var zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === 'object';
	    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
	    var zoomDependent = zoomAndFeatureDependent || !featureDependent;
	    var type = parameters.type || (supportsInterpolation(propertySpec) ? 'exponential' : 'interval');
	    if (isColor) {
	        parameters = extend$1({}, parameters);
	        if (parameters.stops) {
	            parameters.stops = parameters.stops.map(function (stop) {
	                return [
	                    stop[0],
	                    Color.parse(stop[1])
	                ];
	            });
	        }
	        if (parameters.default) {
	            parameters.default = Color.parse(parameters.default);
	        } else {
	            parameters.default = Color.parse(propertySpec.default);
	        }
	    }
	    if (parameters.colorSpace && parameters.colorSpace !== 'rgb' && !colorSpaces[parameters.colorSpace]) {
	        throw new Error('Unknown color space: ' + parameters.colorSpace);
	    }
	    var innerFun;
	    var hashedStops;
	    var categoricalKeyType;
	    if (type === 'exponential') {
	        innerFun = evaluateExponentialFunction;
	    } else if (type === 'interval') {
	        innerFun = evaluateIntervalFunction;
	    } else if (type === 'categorical') {
	        innerFun = evaluateCategoricalFunction;
	        hashedStops = Object.create(null);
	        for (var i = 0, list = parameters.stops; i < list.length; i += 1) {
	            var stop = list[i];
	            hashedStops[stop[0]] = stop[1];
	        }
	        categoricalKeyType = typeof parameters.stops[0][0];
	    } else if (type === 'identity') {
	        innerFun = evaluateIdentityFunction;
	    } else {
	        throw new Error('Unknown function type "' + type + '"');
	    }
	    if (zoomAndFeatureDependent) {
	        var featureFunctions = {};
	        var zoomStops = [];
	        for (var s = 0; s < parameters.stops.length; s++) {
	            var stop$1 = parameters.stops[s];
	            var zoom = stop$1[0].zoom;
	            if (featureFunctions[zoom] === undefined) {
	                featureFunctions[zoom] = {
	                    zoom: zoom,
	                    type: parameters.type,
	                    property: parameters.property,
	                    default: parameters.default,
	                    stops: []
	                };
	                zoomStops.push(zoom);
	            }
	            featureFunctions[zoom].stops.push([
	                stop$1[0].value,
	                stop$1[1]
	            ]);
	        }
	        var featureFunctionStops = [];
	        for (var i$1 = 0, list$1 = zoomStops; i$1 < list$1.length; i$1 += 1) {
	            var z = list$1[i$1];
	            featureFunctionStops.push([
	                featureFunctions[z].zoom,
	                createFunction(featureFunctions[z], propertySpec)
	            ]);
	        }
	        var interpolationType = { name: 'linear' };
	        return {
	            kind: 'composite',
	            interpolationType: interpolationType,
	            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType),
	            zoomStops: featureFunctionStops.map(function (s) {
	                return s[0];
	            }),
	            evaluate: function evaluate(ref, properties) {
	                var zoom = ref.zoom;
	                return evaluateExponentialFunction({
	                    stops: featureFunctionStops,
	                    base: parameters.base
	                }, propertySpec, zoom).evaluate(zoom, properties);
	            }
	        };
	    } else if (zoomDependent) {
	        var interpolationType$1 = type === 'exponential' ? {
	            name: 'exponential',
	            base: parameters.base !== undefined ? parameters.base : 1
	        } : null;
	        return {
	            kind: 'camera',
	            interpolationType: interpolationType$1,
	            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType$1),
	            zoomStops: parameters.stops.map(function (s) {
	                return s[0];
	            }),
	            evaluate: function (ref) {
	                var zoom = ref.zoom;
	                return innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType);
	            }
	        };
	    } else {
	        return {
	            kind: 'source',
	            evaluate: function evaluate(_, feature) {
	                var value = feature && feature.properties ? feature.properties[parameters.property] : undefined;
	                if (value === undefined) {
	                    return coalesce(parameters.default, propertySpec.default);
	                }
	                return innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType);
	            }
	        };
	    }
	}
	function coalesce(a, b, c) {
	    if (a !== undefined) {
	        return a;
	    }
	    if (b !== undefined) {
	        return b;
	    }
	    if (c !== undefined) {
	        return c;
	    }
	}
	function evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {
	    var evaluated = typeof input === keyType ? hashedStops[input] : undefined;
	    return coalesce(evaluated, parameters.default, propertySpec.default);
	}
	function evaluateIntervalFunction(parameters, propertySpec, input) {
	    if (getType(input) !== 'number') {
	        return coalesce(parameters.default, propertySpec.default);
	    }
	    var n = parameters.stops.length;
	    if (n === 1) {
	        return parameters.stops[0][1];
	    }
	    if (input <= parameters.stops[0][0]) {
	        return parameters.stops[0][1];
	    }
	    if (input >= parameters.stops[n - 1][0]) {
	        return parameters.stops[n - 1][1];
	    }
	    var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {
	        return stop[0];
	    }), input);
	    return parameters.stops[index][1];
	}
	function evaluateExponentialFunction(parameters, propertySpec, input) {
	    var base = parameters.base !== undefined ? parameters.base : 1;
	    if (getType(input) !== 'number') {
	        return coalesce(parameters.default, propertySpec.default);
	    }
	    var n = parameters.stops.length;
	    if (n === 1) {
	        return parameters.stops[0][1];
	    }
	    if (input <= parameters.stops[0][0]) {
	        return parameters.stops[0][1];
	    }
	    if (input >= parameters.stops[n - 1][0]) {
	        return parameters.stops[n - 1][1];
	    }
	    var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {
	        return stop[0];
	    }), input);
	    var t = interpolationFactor(input, base, parameters.stops[index][0], parameters.stops[index + 1][0]);
	    var outputLower = parameters.stops[index][1];
	    var outputUpper = parameters.stops[index + 1][1];
	    var interp = interpolate[propertySpec.type] || identityFunction;
	    if (parameters.colorSpace && parameters.colorSpace !== 'rgb') {
	        var colorspace = colorSpaces[parameters.colorSpace];
	        interp = function (a, b) {
	            return colorspace.reverse(colorspace.interpolate(colorspace.forward(a), colorspace.forward(b), t));
	        };
	    }
	    if (typeof outputLower.evaluate === 'function') {
	        return {
	            evaluate: function evaluate() {
	                var args = [], len = arguments.length;
	                while (len--)
	                    args[len] = arguments[len];
	                var evaluatedLower = outputLower.evaluate.apply(undefined, args);
	                var evaluatedUpper = outputUpper.evaluate.apply(undefined, args);
	                if (evaluatedLower === undefined || evaluatedUpper === undefined) {
	                    return undefined;
	                }
	                return interp(evaluatedLower, evaluatedUpper, t);
	            }
	        };
	    }
	    return interp(outputLower, outputUpper, t);
	}
	function evaluateIdentityFunction(parameters, propertySpec, input) {
	    if (propertySpec.type === 'color') {
	        input = Color.parse(input);
	    } else if (propertySpec.type === 'formatted') {
	        input = Formatted.fromString(input.toString());
	    } else if (propertySpec.type === 'resolvedImage') {
	        input = ResolvedImage.fromString(input.toString());
	    } else if (getType(input) !== propertySpec.type && (propertySpec.type !== 'enum' || !propertySpec.values[input])) {
	        input = undefined;
	    }
	    return coalesce(input, parameters.default, propertySpec.default);
	}
	function interpolationFactor(input, base, lowerValue, upperValue) {
	    var difference = upperValue - lowerValue;
	    var progress = input - lowerValue;
	    if (difference === 0) {
	        return 0;
	    } else if (base === 1) {
	        return progress / difference;
	    } else {
	        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
	    }
	}

	var StyleExpression = function StyleExpression(expression, propertySpec) {
	    this.expression = expression;
	    this._warningHistory = {};
	    this._evaluator = new EvaluationContext();
	    this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;
	    this._enumValues = propertySpec && propertySpec.type === 'enum' ? propertySpec.values : null;
	};
	StyleExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
	    this._evaluator.globals = globals;
	    this._evaluator.feature = feature;
	    this._evaluator.featureState = featureState;
	    this._evaluator.canonical = canonical;
	    this._evaluator.availableImages = availableImages || null;
	    this._evaluator.formattedSection = formattedSection;
	    return this.expression.evaluate(this._evaluator);
	};
	StyleExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
	    this._evaluator.globals = globals;
	    this._evaluator.feature = feature || null;
	    this._evaluator.featureState = featureState || null;
	    this._evaluator.canonical = canonical;
	    this._evaluator.availableImages = availableImages || null;
	    this._evaluator.formattedSection = formattedSection || null;
	    try {
	        var val = this.expression.evaluate(this._evaluator);
	        if (val === null || val === undefined || typeof val === 'number' && val !== val) {
	            return this._defaultValue;
	        }
	        if (this._enumValues && !(val in this._enumValues)) {
	            throw new RuntimeError('Expected value to be one of ' + Object.keys(this._enumValues).map(function (v) {
	                return JSON.stringify(v);
	            }).join(', ') + ', but found ' + JSON.stringify(val) + ' instead.');
	        }
	        return val;
	    } catch (e) {
	        if (!this._warningHistory[e.message]) {
	            this._warningHistory[e.message] = true;
	            if (typeof console !== 'undefined') {
	                console.warn(e.message);
	            }
	        }
	        return this._defaultValue;
	    }
	};
	function isExpression(expression) {
	    return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === 'string' && expression[0] in expressions;
	}
	function createExpression(expression, propertySpec) {
	    var parser = new ParsingContext(expressions, [], propertySpec ? getExpectedType(propertySpec) : undefined);
	    var parsed = parser.parse(expression, undefined, undefined, undefined, propertySpec && propertySpec.type === 'string' ? { typeAnnotation: 'coerce' } : undefined);
	    if (!parsed) {
	        return error(parser.errors);
	    }
	    return success(new StyleExpression(parsed, propertySpec));
	}
	var ZoomConstantExpression = function ZoomConstantExpression(kind, expression) {
	    this.kind = kind;
	    this._styleExpression = expression;
	    this.isStateDependent = kind !== 'constant' && !isStateConstant(expression.expression);
	};
	ZoomConstantExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
	    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
	};
	ZoomConstantExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
	    return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
	};
	var ZoomDependentExpression = function ZoomDependentExpression(kind, expression, zoomStops, interpolationType) {
	    this.kind = kind;
	    this.zoomStops = zoomStops;
	    this._styleExpression = expression;
	    this.isStateDependent = kind !== 'camera' && !isStateConstant(expression.expression);
	    this.interpolationType = interpolationType;
	};
	ZoomDependentExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
	    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
	};
	ZoomDependentExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
	    return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
	};
	ZoomDependentExpression.prototype.interpolationFactor = function interpolationFactor(input, lower, upper) {
	    if (this.interpolationType) {
	        return Interpolate.interpolationFactor(this.interpolationType, input, lower, upper);
	    } else {
	        return 0;
	    }
	};
	function createPropertyExpression(expression, propertySpec) {
	    expression = createExpression(expression, propertySpec);
	    if (expression.result === 'error') {
	        return expression;
	    }
	    var parsed = expression.value.expression;
	    var isFeatureConstant$1 = isFeatureConstant(parsed);
	    if (!isFeatureConstant$1 && !supportsPropertyExpression(propertySpec)) {
	        return error([new ParsingError('', 'data expressions not supported')]);
	    }
	    var isZoomConstant = isGlobalPropertyConstant(parsed, ['zoom']);
	    if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {
	        return error([new ParsingError('', 'zoom expressions not supported')]);
	    }
	    var zoomCurve = findZoomCurve(parsed);
	    if (!zoomCurve && !isZoomConstant) {
	        return error([new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
	    } else if (zoomCurve instanceof ParsingError) {
	        return error([zoomCurve]);
	    } else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {
	        return error([new ParsingError('', '"interpolate" expressions cannot be used with this property')]);
	    }
	    if (!zoomCurve) {
	        return success(isFeatureConstant$1 ? new ZoomConstantExpression('constant', expression.value) : new ZoomConstantExpression('source', expression.value));
	    }
	    var interpolationType = zoomCurve instanceof Interpolate ? zoomCurve.interpolation : undefined;
	    return success(isFeatureConstant$1 ? new ZoomDependentExpression('camera', expression.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression('composite', expression.value, zoomCurve.labels, interpolationType));
	}
	var StylePropertyFunction = function StylePropertyFunction(parameters, specification) {
	    this._parameters = parameters;
	    this._specification = specification;
	    extend$1(this, createFunction(this._parameters, this._specification));
	};
	StylePropertyFunction.deserialize = function deserialize(serialized) {
	    return new StylePropertyFunction(serialized._parameters, serialized._specification);
	};
	StylePropertyFunction.serialize = function serialize(input) {
	    return {
	        _parameters: input._parameters,
	        _specification: input._specification
	    };
	};
	function normalizePropertyExpression(value, specification) {
	    if (isFunction(value)) {
	        return new StylePropertyFunction(value, specification);
	    } else if (isExpression(value)) {
	        var expression = createPropertyExpression(value, specification);
	        if (expression.result === 'error') {
	            throw new Error(expression.value.map(function (err) {
	                return err.key + ': ' + err.message;
	            }).join(', '));
	        }
	        return expression.value;
	    } else {
	        var constant = value;
	        if (typeof value === 'string' && specification.type === 'color') {
	            constant = Color.parse(value);
	        }
	        return {
	            kind: 'constant',
	            evaluate: function () {
	                return constant;
	            }
	        };
	    }
	}
	function findZoomCurve(expression) {
	    var result = null;
	    if (expression instanceof Let) {
	        result = findZoomCurve(expression.result);
	    } else if (expression instanceof Coalesce) {
	        for (var i = 0, list = expression.args; i < list.length; i += 1) {
	            var arg = list[i];
	            result = findZoomCurve(arg);
	            if (result) {
	                break;
	            }
	        }
	    } else if ((expression instanceof Step || expression instanceof Interpolate) && expression.input instanceof CompoundExpression && expression.input.name === 'zoom') {
	        result = expression;
	    }
	    if (result instanceof ParsingError) {
	        return result;
	    }
	    expression.eachChild(function (child) {
	        var childResult = findZoomCurve(child);
	        if (childResult instanceof ParsingError) {
	            result = childResult;
	        } else if (!result && childResult) {
	            result = new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.');
	        } else if (result && childResult && result !== childResult) {
	            result = new ParsingError('', 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.');
	        }
	    });
	    return result;
	}
	function getExpectedType(spec) {
	    var types = {
	        color: ColorType,
	        string: StringType,
	        number: NumberType,
	        enum: StringType,
	        boolean: BooleanType,
	        formatted: FormattedType,
	        resolvedImage: ResolvedImageType
	    };
	    if (spec.type === 'array') {
	        return array(types[spec.value] || ValueType, spec.length);
	    }
	    return types[spec.type];
	}
	function getDefaultValue(spec) {
	    if (spec.type === 'color' && isFunction(spec.default)) {
	        return new Color(0, 0, 0, 0);
	    } else if (spec.type === 'color') {
	        return Color.parse(spec.default) || null;
	    } else if (spec.default === undefined) {
	        return null;
	    } else {
	        return spec.default;
	    }
	}

	function validateObject(options) {
	    var key = options.key;
	    var object = options.value;
	    var elementSpecs = options.valueSpec || {};
	    var elementValidators = options.objectElementValidators || {};
	    var style = options.style;
	    var styleSpec = options.styleSpec;
	    var errors = [];
	    var type = getType(object);
	    if (type !== 'object') {
	        return [new ValidationError(key, object, 'object expected, ' + type + ' found')];
	    }
	    for (var objectKey in object) {
	        var elementSpecKey = objectKey.split('.')[0];
	        var elementSpec = elementSpecs[elementSpecKey] || elementSpecs['*'];
	        var validateElement = void 0;
	        if (elementValidators[elementSpecKey]) {
	            validateElement = elementValidators[elementSpecKey];
	        } else if (elementSpecs[elementSpecKey]) {
	            validateElement = validate;
	        } else if (elementValidators['*']) {
	            validateElement = elementValidators['*'];
	        } else if (elementSpecs['*']) {
	            validateElement = validate;
	        } else {
	            errors.push(new ValidationError(key, object[objectKey], 'unknown property "' + objectKey + '"'));
	            continue;
	        }
	        errors = errors.concat(validateElement({
	            key: (key ? key + '.' : key) + objectKey,
	            value: object[objectKey],
	            valueSpec: elementSpec,
	            style: style,
	            styleSpec: styleSpec,
	            object: object,
	            objectKey: objectKey
	        }, object));
	    }
	    for (var elementSpecKey$1 in elementSpecs) {
	        if (elementValidators[elementSpecKey$1]) {
	            continue;
	        }
	        if (elementSpecs[elementSpecKey$1].required && elementSpecs[elementSpecKey$1]['default'] === undefined && object[elementSpecKey$1] === undefined) {
	            errors.push(new ValidationError(key, object, 'missing required property "' + elementSpecKey$1 + '"'));
	        }
	    }
	    return errors;
	}

	function validateArray(options) {
	    var array = options.value;
	    var arraySpec = options.valueSpec;
	    var style = options.style;
	    var styleSpec = options.styleSpec;
	    var key = options.key;
	    var validateArrayElement = options.arrayElementValidator || validate;
	    if (getType(array) !== 'array') {
	        return [new ValidationError(key, array, 'array expected, ' + getType(array) + ' found')];
	    }
	    if (arraySpec.length && array.length !== arraySpec.length) {
	        return [new ValidationError(key, array, 'array length ' + arraySpec.length + ' expected, length ' + array.length + ' found')];
	    }
	    if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {
	        return [new ValidationError(key, array, 'array length at least ' + arraySpec['min-length'] + ' expected, length ' + array.length + ' found')];
	    }
	    var arrayElementSpec = {
	        'type': arraySpec.value,
	        'values': arraySpec.values
	    };
	    if (styleSpec.$version < 7) {
	        arrayElementSpec.function = arraySpec.function;
	    }
	    if (getType(arraySpec.value) === 'object') {
	        arrayElementSpec = arraySpec.value;
	    }
	    var errors = [];
	    for (var i = 0; i < array.length; i++) {
	        errors = errors.concat(validateArrayElement({
	            array: array,
	            arrayIndex: i,
	            value: array[i],
	            valueSpec: arrayElementSpec,
	            style: style,
	            styleSpec: styleSpec,
	            key: key + '[' + i + ']'
	        }));
	    }
	    return errors;
	}

	function validateNumber(options) {
	    var key = options.key;
	    var value = options.value;
	    var valueSpec = options.valueSpec;
	    var type = getType(value);
	    if (type === 'number' && value !== value) {
	        type = 'NaN';
	    }
	    if (type !== 'number') {
	        return [new ValidationError(key, value, 'number expected, ' + type + ' found')];
	    }
	    if ('minimum' in valueSpec && value < valueSpec.minimum) {
	        return [new ValidationError(key, value, value + ' is less than the minimum value ' + valueSpec.minimum)];
	    }
	    if ('maximum' in valueSpec && value > valueSpec.maximum) {
	        return [new ValidationError(key, value, value + ' is greater than the maximum value ' + valueSpec.maximum)];
	    }
	    return [];
	}

	function validateFunction(options) {
	    var functionValueSpec = options.valueSpec;
	    var functionType = unbundle(options.value.type);
	    var stopKeyType;
	    var stopDomainValues = {};
	    var previousStopDomainValue;
	    var previousStopDomainZoom;
	    var isZoomFunction = functionType !== 'categorical' && options.value.property === undefined;
	    var isPropertyFunction = !isZoomFunction;
	    var isZoomAndPropertyFunction = getType(options.value.stops) === 'array' && getType(options.value.stops[0]) === 'array' && getType(options.value.stops[0][0]) === 'object';
	    var errors = validateObject({
	        key: options.key,
	        value: options.value,
	        valueSpec: options.styleSpec.function,
	        style: options.style,
	        styleSpec: options.styleSpec,
	        objectElementValidators: {
	            stops: validateFunctionStops,
	            default: validateFunctionDefault
	        }
	    });
	    if (functionType === 'identity' && isZoomFunction) {
	        errors.push(new ValidationError(options.key, options.value, 'missing required property "property"'));
	    }
	    if (functionType !== 'identity' && !options.value.stops) {
	        errors.push(new ValidationError(options.key, options.value, 'missing required property "stops"'));
	    }
	    if (functionType === 'exponential' && options.valueSpec.expression && !supportsInterpolation(options.valueSpec)) {
	        errors.push(new ValidationError(options.key, options.value, 'exponential functions not supported'));
	    }
	    if (options.styleSpec.$version >= 8) {
	        if (isPropertyFunction && !supportsPropertyExpression(options.valueSpec)) {
	            errors.push(new ValidationError(options.key, options.value, 'property functions not supported'));
	        } else if (isZoomFunction && !supportsZoomExpression(options.valueSpec)) {
	            errors.push(new ValidationError(options.key, options.value, 'zoom functions not supported'));
	        }
	    }
	    if ((functionType === 'categorical' || isZoomAndPropertyFunction) && options.value.property === undefined) {
	        errors.push(new ValidationError(options.key, options.value, '"property" property is required'));
	    }
	    return errors;
	    function validateFunctionStops(options) {
	        if (functionType === 'identity') {
	            return [new ValidationError(options.key, options.value, 'identity function may not have a "stops" property')];
	        }
	        var errors = [];
	        var value = options.value;
	        errors = errors.concat(validateArray({
	            key: options.key,
	            value: value,
	            valueSpec: options.valueSpec,
	            style: options.style,
	            styleSpec: options.styleSpec,
	            arrayElementValidator: validateFunctionStop
	        }));
	        if (getType(value) === 'array' && value.length === 0) {
	            errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));
	        }
	        return errors;
	    }
	    function validateFunctionStop(options) {
	        var errors = [];
	        var value = options.value;
	        var key = options.key;
	        if (getType(value) !== 'array') {
	            return [new ValidationError(key, value, 'array expected, ' + getType(value) + ' found')];
	        }
	        if (value.length !== 2) {
	            return [new ValidationError(key, value, 'array length 2 expected, length ' + value.length + ' found')];
	        }
	        if (isZoomAndPropertyFunction) {
	            if (getType(value[0]) !== 'object') {
	                return [new ValidationError(key, value, 'object expected, ' + getType(value[0]) + ' found')];
	            }
	            if (value[0].zoom === undefined) {
	                return [new ValidationError(key, value, 'object stop key must have zoom')];
	            }
	            if (value[0].value === undefined) {
	                return [new ValidationError(key, value, 'object stop key must have value')];
	            }
	            if (previousStopDomainZoom && previousStopDomainZoom > unbundle(value[0].zoom)) {
	                return [new ValidationError(key, value[0].zoom, 'stop zoom values must appear in ascending order')];
	            }
	            if (unbundle(value[0].zoom) !== previousStopDomainZoom) {
	                previousStopDomainZoom = unbundle(value[0].zoom);
	                previousStopDomainValue = undefined;
	                stopDomainValues = {};
	            }
	            errors = errors.concat(validateObject({
	                key: key + '[0]',
	                value: value[0],
	                valueSpec: { zoom: {} },
	                style: options.style,
	                styleSpec: options.styleSpec,
	                objectElementValidators: {
	                    zoom: validateNumber,
	                    value: validateStopDomainValue
	                }
	            }));
	        } else {
	            errors = errors.concat(validateStopDomainValue({
	                key: key + '[0]',
	                value: value[0],
	                valueSpec: {},
	                style: options.style,
	                styleSpec: options.styleSpec
	            }, value));
	        }
	        if (isExpression(deepUnbundle(value[1]))) {
	            return errors.concat([new ValidationError(key + '[1]', value[1], 'expressions are not allowed in function stops.')]);
	        }
	        return errors.concat(validate({
	            key: key + '[1]',
	            value: value[1],
	            valueSpec: functionValueSpec,
	            style: options.style,
	            styleSpec: options.styleSpec
	        }));
	    }
	    function validateStopDomainValue(options, stop) {
	        var type = getType(options.value);
	        var value = unbundle(options.value);
	        var reportValue = options.value !== null ? options.value : stop;
	        if (!stopKeyType) {
	            stopKeyType = type;
	        } else if (type !== stopKeyType) {
	            return [new ValidationError(options.key, reportValue, type + ' stop domain type must match previous stop domain type ' + stopKeyType)];
	        }
	        if (type !== 'number' && type !== 'string' && type !== 'boolean') {
	            return [new ValidationError(options.key, reportValue, 'stop domain value must be a number, string, or boolean')];
	        }
	        if (type !== 'number' && functionType !== 'categorical') {
	            var message = 'number expected, ' + type + ' found';
	            if (supportsPropertyExpression(functionValueSpec) && functionType === undefined) {
	                message += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.';
	            }
	            return [new ValidationError(options.key, reportValue, message)];
	        }
	        if (functionType === 'categorical' && type === 'number' && (!isFinite(value) || Math.floor(value) !== value)) {
	            return [new ValidationError(options.key, reportValue, 'integer expected, found ' + value)];
	        }
	        if (functionType !== 'categorical' && type === 'number' && previousStopDomainValue !== undefined && value < previousStopDomainValue) {
	            return [new ValidationError(options.key, reportValue, 'stop domain values must appear in ascending order')];
	        } else {
	            previousStopDomainValue = value;
	        }
	        if (functionType === 'categorical' && value in stopDomainValues) {
	            return [new ValidationError(options.key, reportValue, 'stop domain values must be unique')];
	        } else {
	            stopDomainValues[value] = true;
	        }
	        return [];
	    }
	    function validateFunctionDefault(options) {
	        return validate({
	            key: options.key,
	            value: options.value,
	            valueSpec: functionValueSpec,
	            style: options.style,
	            styleSpec: options.styleSpec
	        });
	    }
	}

	function validateExpression(options) {
	    var expression = (options.expressionContext === 'property' ? createPropertyExpression : createExpression)(deepUnbundle(options.value), options.valueSpec);
	    if (expression.result === 'error') {
	        return expression.value.map(function (error) {
	            return new ValidationError('' + options.key + error.key, options.value, error.message);
	        });
	    }
	    var expressionObj = expression.value.expression || expression.value._styleExpression.expression;
	    if (options.expressionContext === 'property' && options.propertyKey === 'text-font' && !expressionObj.outputDefined()) {
	        return [new ValidationError(options.key, options.value, 'Invalid data expression for "' + options.propertyKey + '". Output values must be contained as literals within the expression.')];
	    }
	    if (options.expressionContext === 'property' && options.propertyType === 'layout' && !isStateConstant(expressionObj)) {
	        return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with layout properties.')];
	    }
	    if (options.expressionContext === 'filter' && !isStateConstant(expressionObj)) {
	        return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with filters.')];
	    }
	    if (options.expressionContext && options.expressionContext.indexOf('cluster') === 0) {
	        if (!isGlobalPropertyConstant(expressionObj, [
	                'zoom',
	                'feature-state'
	            ])) {
	            return [new ValidationError(options.key, options.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
	        }
	        if (options.expressionContext === 'cluster-initial' && !isFeatureConstant(expressionObj)) {
	            return [new ValidationError(options.key, options.value, 'Feature data expressions are not supported with initial expression part of cluster properties.')];
	        }
	    }
	    return [];
	}

	function validateBoolean(options) {
	    var value = options.value;
	    var key = options.key;
	    var type = getType(value);
	    if (type !== 'boolean') {
	        return [new ValidationError(key, value, 'boolean expected, ' + type + ' found')];
	    }
	    return [];
	}

	function validateColor(options) {
	    var key = options.key;
	    var value = options.value;
	    var type = getType(value);
	    if (type !== 'string') {
	        return [new ValidationError(key, value, 'color expected, ' + type + ' found')];
	    }
	    if (csscolorparser_1(value) === null) {
	        return [new ValidationError(key, value, 'color expected, "' + value + '" found')];
	    }
	    return [];
	}

	function validateEnum(options) {
	    var key = options.key;
	    var value = options.value;
	    var valueSpec = options.valueSpec;
	    var errors = [];
	    if (Array.isArray(valueSpec.values)) {
	        if (valueSpec.values.indexOf(unbundle(value)) === -1) {
	            errors.push(new ValidationError(key, value, 'expected one of [' + valueSpec.values.join(', ') + '], ' + JSON.stringify(value) + ' found'));
	        }
	    } else {
	        if (Object.keys(valueSpec.values).indexOf(unbundle(value)) === -1) {
	            errors.push(new ValidationError(key, value, 'expected one of [' + Object.keys(valueSpec.values).join(', ') + '], ' + JSON.stringify(value) + ' found'));
	        }
	    }
	    return errors;
	}

	function isExpressionFilter(filter) {
	    if (filter === true || filter === false) {
	        return true;
	    }
	    if (!Array.isArray(filter) || filter.length === 0) {
	        return false;
	    }
	    switch (filter[0]) {
	    case 'has':
	        return filter.length >= 2 && filter[1] !== '$id' && filter[1] !== '$type';
	    case 'in':
	        return filter.length >= 3 && (typeof filter[1] !== 'string' || Array.isArray(filter[2]));
	    case '!in':
	    case '!has':
	    case 'none':
	        return false;
	    case '==':
	    case '!=':
	    case '>':
	    case '>=':
	    case '<':
	    case '<=':
	        return filter.length !== 3 || (Array.isArray(filter[1]) || Array.isArray(filter[2]));
	    case 'any':
	    case 'all':
	        for (var i = 0, list = filter.slice(1); i < list.length; i += 1) {
	            var f = list[i];
	            if (!isExpressionFilter(f) && typeof f !== 'boolean') {
	                return false;
	            }
	        }
	        return true;
	    default:
	        return true;
	    }
	}
	var filterSpec = {
	    'type': 'boolean',
	    'default': false,
	    'transition': false,
	    'property-type': 'data-driven',
	    'expression': {
	        'interpolated': false,
	        'parameters': [
	            'zoom',
	            'feature'
	        ]
	    }
	};
	function createFilter(filter) {
	    if (filter === null || filter === undefined) {
	        return {
	            filter: function () {
	                return true;
	            },
	            needGeometry: false
	        };
	    }
	    if (!isExpressionFilter(filter)) {
	        filter = convertFilter(filter);
	    }
	    var compiled = createExpression(filter, filterSpec);
	    if (compiled.result === 'error') {
	        throw new Error(compiled.value.map(function (err) {
	            return err.key + ': ' + err.message;
	        }).join(', '));
	    } else {
	        var needGeometry = geometryNeeded(filter);
	        return {
	            filter: function (globalProperties, feature, canonical) {
	                return compiled.value.evaluate(globalProperties, feature, {}, canonical);
	            },
	            needGeometry: needGeometry
	        };
	    }
	}
	function compare(a, b) {
	    return a < b ? -1 : a > b ? 1 : 0;
	}
	function geometryNeeded(filter) {
	    if (!Array.isArray(filter)) {
	        return false;
	    }
	    if (filter[0] === 'within') {
	        return true;
	    }
	    for (var index = 1; index < filter.length; index++) {
	        if (geometryNeeded(filter[index])) {
	            return true;
	        }
	    }
	    return false;
	}
	function convertFilter(filter) {
	    if (!filter) {
	        return true;
	    }
	    var op = filter[0];
	    if (filter.length <= 1) {
	        return op !== 'any';
	    }
	    var converted = op === '==' ? convertComparisonOp(filter[1], filter[2], '==') : op === '!=' ? convertNegation(convertComparisonOp(filter[1], filter[2], '==')) : op === '<' || op === '>' || op === '<=' || op === '>=' ? convertComparisonOp(filter[1], filter[2], op) : op === 'any' ? convertDisjunctionOp(filter.slice(1)) : op === 'all' ? ['all'].concat(filter.slice(1).map(convertFilter)) : op === 'none' ? ['all'].concat(filter.slice(1).map(convertFilter).map(convertNegation)) : op === 'in' ? convertInOp(filter[1], filter.slice(2)) : op === '!in' ? convertNegation(convertInOp(filter[1], filter.slice(2))) : op === 'has' ? convertHasOp(filter[1]) : op === '!has' ? convertNegation(convertHasOp(filter[1])) : op === 'within' ? filter : true;
	    return converted;
	}
	function convertComparisonOp(property, value, op) {
	    switch (property) {
	    case '$type':
	        return [
	            'filter-type-' + op,
	            value
	        ];
	    case '$id':
	        return [
	            'filter-id-' + op,
	            value
	        ];
	    default:
	        return [
	            'filter-' + op,
	            property,
	            value
	        ];
	    }
	}
	function convertDisjunctionOp(filters) {
	    return ['any'].concat(filters.map(convertFilter));
	}
	function convertInOp(property, values) {
	    if (values.length === 0) {
	        return false;
	    }
	    switch (property) {
	    case '$type':
	        return [
	            'filter-type-in',
	            [
	                'literal',
	                values
	            ]
	        ];
	    case '$id':
	        return [
	            'filter-id-in',
	            [
	                'literal',
	                values
	            ]
	        ];
	    default:
	        if (values.length > 200 && !values.some(function (v) {
	                return typeof v !== typeof values[0];
	            })) {
	            return [
	                'filter-in-large',
	                property,
	                [
	                    'literal',
	                    values.sort(compare)
	                ]
	            ];
	        } else {
	            return [
	                'filter-in-small',
	                property,
	                [
	                    'literal',
	                    values
	                ]
	            ];
	        }
	    }
	}
	function convertHasOp(property) {
	    switch (property) {
	    case '$type':
	        return true;
	    case '$id':
	        return ['filter-has-id'];
	    default:
	        return [
	            'filter-has',
	            property
	        ];
	    }
	}
	function convertNegation(filter) {
	    return [
	        '!',
	        filter
	    ];
	}

	function validateFilter(options) {
	    if (isExpressionFilter(deepUnbundle(options.value))) {
	        return validateExpression(extend$1({}, options, {
	            expressionContext: 'filter',
	            valueSpec: { value: 'boolean' }
	        }));
	    } else {
	        return validateNonExpressionFilter(options);
	    }
	}
	function validateNonExpressionFilter(options) {
	    var value = options.value;
	    var key = options.key;
	    if (getType(value) !== 'array') {
	        return [new ValidationError(key, value, 'array expected, ' + getType(value) + ' found')];
	    }
	    var styleSpec = options.styleSpec;
	    var type;
	    var errors = [];
	    if (value.length < 1) {
	        return [new ValidationError(key, value, 'filter array must have at least 1 element')];
	    }
	    errors = errors.concat(validateEnum({
	        key: key + '[0]',
	        value: value[0],
	        valueSpec: styleSpec.filter_operator,
	        style: options.style,
	        styleSpec: options.styleSpec
	    }));
	    switch (unbundle(value[0])) {
	    case '<':
	    case '<=':
	    case '>':
	    case '>=':
	        if (value.length >= 2 && unbundle(value[1]) === '$type') {
	            errors.push(new ValidationError(key, value, '"$type" cannot be use with operator "' + value[0] + '"'));
	        }
	    case '==':
	    case '!=':
	        if (value.length !== 3) {
	            errors.push(new ValidationError(key, value, 'filter array for operator "' + value[0] + '" must have 3 elements'));
	        }
	    case 'in':
	    case '!in':
	        if (value.length >= 2) {
	            type = getType(value[1]);
	            if (type !== 'string') {
	                errors.push(new ValidationError(key + '[1]', value[1], 'string expected, ' + type + ' found'));
	            }
	        }
	        for (var i = 2; i < value.length; i++) {
	            type = getType(value[i]);
	            if (unbundle(value[1]) === '$type') {
	                errors = errors.concat(validateEnum({
	                    key: key + '[' + i + ']',
	                    value: value[i],
	                    valueSpec: styleSpec.geometry_type,
	                    style: options.style,
	                    styleSpec: options.styleSpec
	                }));
	            } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
	                errors.push(new ValidationError(key + '[' + i + ']', value[i], 'string, number, or boolean expected, ' + type + ' found'));
	            }
	        }
	        break;
	    case 'any':
	    case 'all':
	    case 'none':
	        for (var i$1 = 1; i$1 < value.length; i$1++) {
	            errors = errors.concat(validateNonExpressionFilter({
	                key: key + '[' + i$1 + ']',
	                value: value[i$1],
	                style: options.style,
	                styleSpec: options.styleSpec
	            }));
	        }
	        break;
	    case 'has':
	    case '!has':
	        type = getType(value[1]);
	        if (value.length !== 2) {
	            errors.push(new ValidationError(key, value, 'filter array for "' + value[0] + '" operator must have 2 elements'));
	        } else if (type !== 'string') {
	            errors.push(new ValidationError(key + '[1]', value[1], 'string expected, ' + type + ' found'));
	        }
	        break;
	    case 'within':
	        type = getType(value[1]);
	        if (value.length !== 2) {
	            errors.push(new ValidationError(key, value, 'filter array for "' + value[0] + '" operator must have 2 elements'));
	        } else if (type !== 'object') {
	            errors.push(new ValidationError(key + '[1]', value[1], 'object expected, ' + type + ' found'));
	        }
	        break;
	    }
	    return errors;
	}

	function validateProperty(options, propertyType) {
	    var key = options.key;
	    var style = options.style;
	    var styleSpec = options.styleSpec;
	    var value = options.value;
	    var propertyKey = options.objectKey;
	    var layerSpec = styleSpec[propertyType + '_' + options.layerType];
	    if (!layerSpec) {
	        return [];
	    }
	    var transitionMatch = propertyKey.match(/^(.*)-transition$/);
	    if (propertyType === 'paint' && transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {
	        return validate({
	            key: key,
	            value: value,
	            valueSpec: styleSpec.transition,
	            style: style,
	            styleSpec: styleSpec
	        });
	    }
	    var valueSpec = options.valueSpec || layerSpec[propertyKey];
	    if (!valueSpec) {
	        return [new ValidationError(key, value, 'unknown property "' + propertyKey + '"')];
	    }
	    var tokenMatch;
	    if (getType(value) === 'string' && supportsPropertyExpression(valueSpec) && !valueSpec.tokens && (tokenMatch = /^{([^}]+)}$/.exec(value))) {
	        return [new ValidationError(key, value, '"' + propertyKey + '" does not support interpolation syntax\n' + 'Use an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(tokenMatch[1]) + ' }`.')];
	    }
	    var errors = [];
	    if (options.layerType === 'symbol') {
	        if (propertyKey === 'text-field' && style && !style.glyphs) {
	            errors.push(new ValidationError(key, value, 'use of "text-field" requires a style "glyphs" property'));
	        }
	        if (propertyKey === 'text-font' && isFunction(deepUnbundle(value)) && unbundle(value.type) === 'identity') {
	            errors.push(new ValidationError(key, value, '"text-font" does not support identity functions'));
	        }
	    }
	    return errors.concat(validate({
	        key: options.key,
	        value: value,
	        valueSpec: valueSpec,
	        style: style,
	        styleSpec: styleSpec,
	        expressionContext: 'property',
	        propertyType: propertyType,
	        propertyKey: propertyKey
	    }));
	}

	function validatePaintProperty(options) {
	    return validateProperty(options, 'paint');
	}

	function validateLayoutProperty(options) {
	    return validateProperty(options, 'layout');
	}

	function validateLayer(options) {
	    var errors = [];
	    var layer = options.value;
	    var key = options.key;
	    var style = options.style;
	    var styleSpec = options.styleSpec;
	    if (!layer.type && !layer.ref) {
	        errors.push(new ValidationError(key, layer, 'either "type" or "ref" is required'));
	    }
	    var type = unbundle(layer.type);
	    var ref = unbundle(layer.ref);
	    if (layer.id) {
	        var layerId = unbundle(layer.id);
	        for (var i = 0; i < options.arrayIndex; i++) {
	            var otherLayer = style.layers[i];
	            if (unbundle(otherLayer.id) === layerId) {
	                errors.push(new ValidationError(key, layer.id, 'duplicate layer id "' + layer.id + '", previously used at line ' + otherLayer.id.__line__));
	            }
	        }
	    }
	    if ('ref' in layer) {
	        [
	            'type',
	            'source',
	            'source-layer',
	            'filter',
	            'layout'
	        ].forEach(function (p) {
	            if (p in layer) {
	                errors.push(new ValidationError(key, layer[p], '"' + p + '" is prohibited for ref layers'));
	            }
	        });
	        var parent;
	        style.layers.forEach(function (layer) {
	            if (unbundle(layer.id) === ref) {
	                parent = layer;
	            }
	        });
	        if (!parent) {
	            errors.push(new ValidationError(key, layer.ref, 'ref layer "' + ref + '" not found'));
	        } else if (parent.ref) {
	            errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));
	        } else {
	            type = unbundle(parent.type);
	        }
	    } else if (type !== 'background') {
	        if (!layer.source) {
	            errors.push(new ValidationError(key, layer, 'missing required property "source"'));
	        } else {
	            var source = style.sources && style.sources[layer.source];
	            var sourceType = source && unbundle(source.type);
	            if (!source) {
	                errors.push(new ValidationError(key, layer.source, 'source "' + layer.source + '" not found'));
	            } else if (sourceType === 'vector' && type === 'raster') {
	                errors.push(new ValidationError(key, layer.source, 'layer "' + layer.id + '" requires a raster source'));
	            } else if (sourceType === 'raster' && type !== 'raster') {
	                errors.push(new ValidationError(key, layer.source, 'layer "' + layer.id + '" requires a vector source'));
	            } else if (sourceType === 'vector' && !layer['source-layer']) {
	                errors.push(new ValidationError(key, layer, 'layer "' + layer.id + '" must specify a "source-layer"'));
	            } else if (sourceType === 'raster-dem' && type !== 'hillshade') {
	                errors.push(new ValidationError(key, layer.source, 'raster-dem source can only be used with layer type \'hillshade\'.'));
	            } else if (type === 'line' && layer.paint && layer.paint['line-gradient'] && (sourceType !== 'geojson' || !source.lineMetrics)) {
	                errors.push(new ValidationError(key, layer, 'layer "' + layer.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.'));
	            }
	        }
	    }
	    errors = errors.concat(validateObject({
	        key: key,
	        value: layer,
	        valueSpec: styleSpec.layer,
	        style: options.style,
	        styleSpec: options.styleSpec,
	        objectElementValidators: {
	            '*': function _() {
	                return [];
	            },
	            type: function type() {
	                return validate({
	                    key: key + '.type',
	                    value: layer.type,
	                    valueSpec: styleSpec.layer.type,
	                    style: options.style,
	                    styleSpec: options.styleSpec,
	                    object: layer,
	                    objectKey: 'type'
	                });
	            },
	            filter: validateFilter,
	            layout: function layout(options) {
	                return validateObject({
	                    layer: layer,
	                    key: options.key,
	                    value: options.value,
	                    style: options.style,
	                    styleSpec: options.styleSpec,
	                    objectElementValidators: {
	                        '*': function _(options) {
	                            return validateLayoutProperty(extend$1({ layerType: type }, options));
	                        }
	                    }
	                });
	            },
	            paint: function paint(options) {
	                return validateObject({
	                    layer: layer,
	                    key: options.key,
	                    value: options.value,
	                    style: options.style,
	                    styleSpec: options.styleSpec,
	                    objectElementValidators: {
	                        '*': function _(options) {
	                            return validatePaintProperty(extend$1({ layerType: type }, options));
	                        }
	                    }
	                });
	            }
	        }
	    }));
	    return errors;
	}

	function validateString(options) {
	    var value = options.value;
	    var key = options.key;
	    var type = getType(value);
	    if (type !== 'string') {
	        return [new ValidationError(key, value, 'string expected, ' + type + ' found')];
	    }
	    return [];
	}

	var objectElementValidators = { promoteId: validatePromoteId };
	function validateSource(options) {
	    var value = options.value;
	    var key = options.key;
	    var styleSpec = options.styleSpec;
	    var style = options.style;
	    if (!value.type) {
	        return [new ValidationError(key, value, '"type" is required')];
	    }
	    var type = unbundle(value.type);
	    var errors;
	    switch (type) {
	    case 'vector':
	    case 'raster':
	    case 'raster-dem':
	        errors = validateObject({
	            key: key,
	            value: value,
	            valueSpec: styleSpec['source_' + type.replace('-', '_')],
	            style: options.style,
	            styleSpec: styleSpec,
	            objectElementValidators: objectElementValidators
	        });
	        return errors;
	    case 'geojson':
	        errors = validateObject({
	            key: key,
	            value: value,
	            valueSpec: styleSpec.source_geojson,
	            style: style,
	            styleSpec: styleSpec,
	            objectElementValidators: objectElementValidators
	        });
	        if (value.cluster) {
	            for (var prop in value.clusterProperties) {
	                var ref = value.clusterProperties[prop];
	                var operator = ref[0];
	                var mapExpr = ref[1];
	                var reduceExpr = typeof operator === 'string' ? [
	                    operator,
	                    ['accumulated'],
	                    [
	                        'get',
	                        prop
	                    ]
	                ] : operator;
	                errors.push.apply(errors, validateExpression({
	                    key: key + '.' + prop + '.map',
	                    value: mapExpr,
	                    expressionContext: 'cluster-map'
	                }));
	                errors.push.apply(errors, validateExpression({
	                    key: key + '.' + prop + '.reduce',
	                    value: reduceExpr,
	                    expressionContext: 'cluster-reduce'
	                }));
	            }
	        }
	        return errors;
	    case 'video':
	        return validateObject({
	            key: key,
	            value: value,
	            valueSpec: styleSpec.source_video,
	            style: style,
	            styleSpec: styleSpec
	        });
	    case 'image':
	        return validateObject({
	            key: key,
	            value: value,
	            valueSpec: styleSpec.source_image,
	            style: style,
	            styleSpec: styleSpec
	        });
	    case 'canvas':
	        return [new ValidationError(key, null, 'Please use runtime APIs to add canvas sources, rather than including them in stylesheets.', 'source.canvas')];
	    default:
	        return validateEnum({
	            key: key + '.type',
	            value: value.type,
	            valueSpec: {
	                values: [
	                    'vector',
	                    'raster',
	                    'raster-dem',
	                    'geojson',
	                    'video',
	                    'image'
	                ]
	            },
	            style: style,
	            styleSpec: styleSpec
	        });
	    }
	}
	function validatePromoteId(ref) {
	    var key = ref.key;
	    var value = ref.value;
	    if (getType(value) === 'string') {
	        return validateString({
	            key: key,
	            value: value
	        });
	    } else {
	        var errors = [];
	        for (var prop in value) {
	            errors.push.apply(errors, validateString({
	                key: key + '.' + prop,
	                value: value[prop]
	            }));
	        }
	        return errors;
	    }
	}

	function validateLight(options) {
	    var light = options.value;
	    var styleSpec = options.styleSpec;
	    var lightSpec = styleSpec.light;
	    var style = options.style;
	    var errors = [];
	    var rootType = getType(light);
	    if (light === undefined) {
	        return errors;
	    } else if (rootType !== 'object') {
	        errors = errors.concat([new ValidationError('light', light, 'object expected, ' + rootType + ' found')]);
	        return errors;
	    }
	    for (var key in light) {
	        var transitionMatch = key.match(/^(.*)-transition$/);
	        if (transitionMatch && lightSpec[transitionMatch[1]] && lightSpec[transitionMatch[1]].transition) {
	            errors = errors.concat(validate({
	                key: key,
	                value: light[key],
	                valueSpec: styleSpec.transition,
	                style: style,
	                styleSpec: styleSpec
	            }));
	        } else if (lightSpec[key]) {
	            errors = errors.concat(validate({
	                key: key,
	                value: light[key],
	                valueSpec: lightSpec[key],
	                style: style,
	                styleSpec: styleSpec
	            }));
	        } else {
	            errors = errors.concat([new ValidationError(key, light[key], 'unknown property "' + key + '"')]);
	        }
	    }
	    return errors;
	}

	function validateFormatted(options) {
	    if (validateString(options).length === 0) {
	        return [];
	    }
	    return validateExpression(options);
	}

	function validateImage(options) {
	    if (validateString(options).length === 0) {
	        return [];
	    }
	    return validateExpression(options);
	}

	var VALIDATORS = {
	    '*': function _() {
	        return [];
	    },
	    'array': validateArray,
	    'boolean': validateBoolean,
	    'number': validateNumber,
	    'color': validateColor,
	    'constants': validateConstants,
	    'enum': validateEnum,
	    'filter': validateFilter,
	    'function': validateFunction,
	    'layer': validateLayer,
	    'object': validateObject,
	    'source': validateSource,
	    'light': validateLight,
	    'string': validateString,
	    'formatted': validateFormatted,
	    'resolvedImage': validateImage
	};
	function validate(options) {
	    var value = options.value;
	    var valueSpec = options.valueSpec;
	    var styleSpec = options.styleSpec;
	    if (valueSpec.expression && isFunction(unbundle(value))) {
	        return validateFunction(options);
	    } else if (valueSpec.expression && isExpression(deepUnbundle(value))) {
	        return validateExpression(options);
	    } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {
	        return VALIDATORS[valueSpec.type](options);
	    } else {
	        var valid = validateObject(extend$1({}, options, { valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec }));
	        return valid;
	    }
	}

	function validateGlyphsURL (options) {
	    var value = options.value;
	    var key = options.key;
	    var errors = validateString(options);
	    if (errors.length) {
	        return errors;
	    }
	    if (value.indexOf('{fontstack}') === -1) {
	        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{fontstack}" token'));
	    }
	    if (value.indexOf('{range}') === -1) {
	        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{range}" token'));
	    }
	    return errors;
	}

	function validateStyleMin(style, styleSpec) {
	    if (styleSpec === void 0)
	        styleSpec = spec;
	    var errors = [];
	    errors = errors.concat(validate({
	        key: '',
	        value: style,
	        valueSpec: styleSpec.$root,
	        styleSpec: styleSpec,
	        style: style,
	        objectElementValidators: {
	            glyphs: validateGlyphsURL,
	            '*': function _() {
	                return [];
	            }
	        }
	    }));
	    if (style.constants) {
	        errors = errors.concat(validateConstants({
	            key: 'constants',
	            value: style.constants,
	            style: style,
	            styleSpec: styleSpec
	        }));
	    }
	    return sortErrors(errors);
	}
	validateStyleMin.source = wrapCleanErrors(validateSource);
	validateStyleMin.light = wrapCleanErrors(validateLight);
	validateStyleMin.layer = wrapCleanErrors(validateLayer);
	validateStyleMin.filter = wrapCleanErrors(validateFilter);
	validateStyleMin.paintProperty = wrapCleanErrors(validatePaintProperty);
	validateStyleMin.layoutProperty = wrapCleanErrors(validateLayoutProperty);
	function sortErrors(errors) {
	    return [].concat(errors).sort(function (a, b) {
	        return a.line - b.line;
	    });
	}
	function wrapCleanErrors(inner) {
	    return function () {
	        var args = [], len = arguments.length;
	        while (len--)
	            args[len] = arguments[len];
	        return sortErrors(inner.apply(this, args));
	    };
	}

	var validateStyle = validateStyleMin;
	var validateLight$1 = validateStyle.light;
	var validatePaintProperty$1 = validateStyle.paintProperty;
	var validateLayoutProperty$1 = validateStyle.layoutProperty;
	function emitValidationErrors(emitter, errors) {
	    var hasErrors = false;
	    if (errors && errors.length) {
	        for (var i = 0, list = errors; i < list.length; i += 1) {
	            var error = list[i];
	            emitter.fire(new ErrorEvent(new Error(error.message)));
	            hasErrors = true;
	        }
	    }
	    return hasErrors;
	}

	var gridIndex = GridIndex;
	var NUM_PARAMS = 3;
	function GridIndex(extent, n, padding) {
	    var cells = this.cells = [];
	    if (extent instanceof ArrayBuffer) {
	        this.arrayBuffer = extent;
	        var array = new Int32Array(this.arrayBuffer);
	        extent = array[0];
	        n = array[1];
	        padding = array[2];
	        this.d = n + 2 * padding;
	        for (var k = 0; k < this.d * this.d; k++) {
	            var start = array[NUM_PARAMS + k];
	            var end = array[NUM_PARAMS + k + 1];
	            cells.push(start === end ? null : array.subarray(start, end));
	        }
	        var keysOffset = array[NUM_PARAMS + cells.length];
	        var bboxesOffset = array[NUM_PARAMS + cells.length + 1];
	        this.keys = array.subarray(keysOffset, bboxesOffset);
	        this.bboxes = array.subarray(bboxesOffset);
	        this.insert = this._insertReadonly;
	    } else {
	        this.d = n + 2 * padding;
	        for (var i = 0; i < this.d * this.d; i++) {
	            cells.push([]);
	        }
	        this.keys = [];
	        this.bboxes = [];
	    }
	    this.n = n;
	    this.extent = extent;
	    this.padding = padding;
	    this.scale = n / extent;
	    this.uid = 0;
	    var p = padding / n * extent;
	    this.min = -p;
	    this.max = extent + p;
	}
	GridIndex.prototype.insert = function (key, x1, y1, x2, y2) {
	    this._forEachCell(x1, y1, x2, y2, this._insertCell, this.uid++);
	    this.keys.push(key);
	    this.bboxes.push(x1);
	    this.bboxes.push(y1);
	    this.bboxes.push(x2);
	    this.bboxes.push(y2);
	};
	GridIndex.prototype._insertReadonly = function () {
	    throw 'Cannot insert into a GridIndex created from an ArrayBuffer.';
	};
	GridIndex.prototype._insertCell = function (x1, y1, x2, y2, cellIndex, uid) {
	    this.cells[cellIndex].push(uid);
	};
	GridIndex.prototype.query = function (x1, y1, x2, y2, intersectionTest) {
	    var min = this.min;
	    var max = this.max;
	    if (x1 <= min && y1 <= min && max <= x2 && max <= y2 && !intersectionTest) {
	        return Array.prototype.slice.call(this.keys);
	    } else {
	        var result = [];
	        var seenUids = {};
	        this._forEachCell(x1, y1, x2, y2, this._queryCell, result, seenUids, intersectionTest);
	        return result;
	    }
	};
	GridIndex.prototype._queryCell = function (x1, y1, x2, y2, cellIndex, result, seenUids, intersectionTest) {
	    var cell = this.cells[cellIndex];
	    if (cell !== null) {
	        var keys = this.keys;
	        var bboxes = this.bboxes;
	        for (var u = 0; u < cell.length; u++) {
	            var uid = cell[u];
	            if (seenUids[uid] === undefined) {
	                var offset = uid * 4;
	                if (intersectionTest ? intersectionTest(bboxes[offset + 0], bboxes[offset + 1], bboxes[offset + 2], bboxes[offset + 3]) : x1 <= bboxes[offset + 2] && y1 <= bboxes[offset + 3] && x2 >= bboxes[offset + 0] && y2 >= bboxes[offset + 1]) {
	                    seenUids[uid] = true;
	                    result.push(keys[uid]);
	                } else {
	                    seenUids[uid] = false;
	                }
	            }
	        }
	    }
	};
	GridIndex.prototype._forEachCell = function (x1, y1, x2, y2, fn, arg1, arg2, intersectionTest) {
	    var cx1 = this._convertToCellCoord(x1);
	    var cy1 = this._convertToCellCoord(y1);
	    var cx2 = this._convertToCellCoord(x2);
	    var cy2 = this._convertToCellCoord(y2);
	    for (var x = cx1; x <= cx2; x++) {
	        for (var y = cy1; y <= cy2; y++) {
	            var cellIndex = this.d * y + x;
	            if (intersectionTest && !intersectionTest(this._convertFromCellCoord(x), this._convertFromCellCoord(y), this._convertFromCellCoord(x + 1), this._convertFromCellCoord(y + 1))) {
	                continue;
	            }
	            if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2, intersectionTest)) {
	                return;
	            }
	        }
	    }
	};
	GridIndex.prototype._convertFromCellCoord = function (x) {
	    return (x - this.padding) / this.scale;
	};
	GridIndex.prototype._convertToCellCoord = function (x) {
	    return Math.max(0, Math.min(this.d - 1, Math.floor(x * this.scale) + this.padding));
	};
	GridIndex.prototype.toArrayBuffer = function () {
	    if (this.arrayBuffer) {
	        return this.arrayBuffer;
	    }
	    var cells = this.cells;
	    var metadataLength = NUM_PARAMS + this.cells.length + 1 + 1;
	    var totalCellLength = 0;
	    for (var i = 0; i < this.cells.length; i++) {
	        totalCellLength += this.cells[i].length;
	    }
	    var array = new Int32Array(metadataLength + totalCellLength + this.keys.length + this.bboxes.length);
	    array[0] = this.extent;
	    array[1] = this.n;
	    array[2] = this.padding;
	    var offset = metadataLength;
	    for (var k = 0; k < cells.length; k++) {
	        var cell = cells[k];
	        array[NUM_PARAMS + k] = offset;
	        array.set(cell, offset);
	        offset += cell.length;
	    }
	    array[NUM_PARAMS + cells.length] = offset;
	    array.set(this.keys, offset);
	    offset += this.keys.length;
	    array[NUM_PARAMS + cells.length + 1] = offset;
	    array.set(this.bboxes, offset);
	    offset += this.bboxes.length;
	    return array.buffer;
	};

	var ImageData = window$1.ImageData;
	var ImageBitmap = window$1.ImageBitmap;
	var registry = {};
	function register(name, klass, options) {
	    if (options === void 0)
	        options = {};
	    Object.defineProperty(klass, '_classRegistryKey', {
	        value: name,
	        writeable: false
	    });
	    registry[name] = {
	        klass: klass,
	        omit: options.omit || [],
	        shallow: options.shallow || []
	    };
	}
	register('Object', Object);
	gridIndex.serialize = function serialize(grid, transferables) {
	    var buffer = grid.toArrayBuffer();
	    if (transferables) {
	        transferables.push(buffer);
	    }
	    return { buffer: buffer };
	};
	gridIndex.deserialize = function deserialize(serialized) {
	    return new gridIndex(serialized.buffer);
	};
	register('Grid', gridIndex);
	register('Color', Color);
	register('Error', Error);
	register('ResolvedImage', ResolvedImage);
	register('StylePropertyFunction', StylePropertyFunction);
	register('StyleExpression', StyleExpression, { omit: ['_evaluator'] });
	register('ZoomDependentExpression', ZoomDependentExpression);
	register('ZoomConstantExpression', ZoomConstantExpression);
	register('CompoundExpression', CompoundExpression, { omit: ['_evaluate'] });
	for (var name in expressions) {
	    if (expressions[name]._classRegistryKey) {
	        continue;
	    }
	    register('Expression_' + name, expressions[name]);
	}
	function isArrayBuffer(val) {
	    return val && typeof ArrayBuffer !== 'undefined' && (val instanceof ArrayBuffer || val.constructor && val.constructor.name === 'ArrayBuffer');
	}
	function isImageBitmap(val) {
	    return ImageBitmap && val instanceof ImageBitmap;
	}
	function serialize(input, transferables) {
	    if (input === null || input === undefined || typeof input === 'boolean' || typeof input === 'number' || typeof input === 'string' || input instanceof Boolean || input instanceof Number || input instanceof String || input instanceof Date || input instanceof RegExp) {
	        return input;
	    }
	    if (isArrayBuffer(input) || isImageBitmap(input)) {
	        if (transferables) {
	            transferables.push(input);
	        }
	        return input;
	    }
	    if (ArrayBuffer.isView(input)) {
	        var view = input;
	        if (transferables) {
	            transferables.push(view.buffer);
	        }
	        return view;
	    }
	    if (input instanceof ImageData) {
	        if (transferables) {
	            transferables.push(input.data.buffer);
	        }
	        return input;
	    }
	    if (Array.isArray(input)) {
	        var serialized = [];
	        for (var i = 0, list = input; i < list.length; i += 1) {
	            var item = list[i];
	            serialized.push(serialize(item, transferables));
	        }
	        return serialized;
	    }
	    if (typeof input === 'object') {
	        var klass = input.constructor;
	        var name = klass._classRegistryKey;
	        if (!name) {
	            throw new Error('can\'t serialize object of unregistered class');
	        }
	        var properties = klass.serialize ? klass.serialize(input, transferables) : {};
	        if (!klass.serialize) {
	            for (var key in input) {
	                if (!input.hasOwnProperty(key)) {
	                    continue;
	                }
	                if (registry[name].omit.indexOf(key) >= 0) {
	                    continue;
	                }
	                var property = input[key];
	                properties[key] = registry[name].shallow.indexOf(key) >= 0 ? property : serialize(property, transferables);
	            }
	            if (input instanceof Error) {
	                properties.message = input.message;
	            }
	        }
	        if (properties.$name) {
	            throw new Error('$name property is reserved for worker serialization logic.');
	        }
	        if (name !== 'Object') {
	            properties.$name = name;
	        }
	        return properties;
	    }
	    throw new Error('can\'t serialize object of type ' + typeof input);
	}
	function deserialize(input) {
	    if (input === null || input === undefined || typeof input === 'boolean' || typeof input === 'number' || typeof input === 'string' || input instanceof Boolean || input instanceof Number || input instanceof String || input instanceof Date || input instanceof RegExp || isArrayBuffer(input) || isImageBitmap(input) || ArrayBuffer.isView(input) || input instanceof ImageData) {
	        return input;
	    }
	    if (Array.isArray(input)) {
	        return input.map(deserialize);
	    }
	    if (typeof input === 'object') {
	        var name = input.$name || 'Object';
	        var ref = registry[name];
	        var klass = ref.klass;
	        if (!klass) {
	            throw new Error('can\'t deserialize unregistered class ' + name);
	        }
	        if (klass.deserialize) {
	            return klass.deserialize(input);
	        }
	        var result = Object.create(klass.prototype);
	        for (var i = 0, list = Object.keys(input); i < list.length; i += 1) {
	            var key = list[i];
	            if (key === '$name') {
	                continue;
	            }
	            var value = input[key];
	            result[key] = registry[name].shallow.indexOf(key) >= 0 ? value : deserialize(value);
	        }
	        return result;
	    }
	    throw new Error('can\'t deserialize object of type ' + typeof input);
	}

	var ZoomHistory = function ZoomHistory() {
	    this.first = true;
	};
	ZoomHistory.prototype.update = function update(z, now) {
	    var floorZ = Math.floor(z);
	    if (this.first) {
	        this.first = false;
	        this.lastIntegerZoom = floorZ;
	        this.lastIntegerZoomTime = 0;
	        this.lastZoom = z;
	        this.lastFloorZoom = floorZ;
	        return true;
	    }
	    if (this.lastFloorZoom > floorZ) {
	        this.lastIntegerZoom = floorZ + 1;
	        this.lastIntegerZoomTime = now;
	    } else if (this.lastFloorZoom < floorZ) {
	        this.lastIntegerZoom = floorZ;
	        this.lastIntegerZoomTime = now;
	    }
	    if (z !== this.lastZoom) {
	        this.lastZoom = z;
	        this.lastFloorZoom = floorZ;
	        return true;
	    }
	    return false;
	};

	var unicodeBlockLookup = {
	    'Latin-1 Supplement': function (char) {
	        return char >= 128 && char <= 255;
	    },
	    'Arabic': function (char) {
	        return char >= 1536 && char <= 1791;
	    },
	    'Arabic Supplement': function (char) {
	        return char >= 1872 && char <= 1919;
	    },
	    'Arabic Extended-A': function (char) {
	        return char >= 2208 && char <= 2303;
	    },
	    'Hangul Jamo': function (char) {
	        return char >= 4352 && char <= 4607;
	    },
	    'Unified Canadian Aboriginal Syllabics': function (char) {
	        return char >= 5120 && char <= 5759;
	    },
	    'Khmer': function (char) {
	        return char >= 6016 && char <= 6143;
	    },
	    'Unified Canadian Aboriginal Syllabics Extended': function (char) {
	        return char >= 6320 && char <= 6399;
	    },
	    'General Punctuation': function (char) {
	        return char >= 8192 && char <= 8303;
	    },
	    'Letterlike Symbols': function (char) {
	        return char >= 8448 && char <= 8527;
	    },
	    'Number Forms': function (char) {
	        return char >= 8528 && char <= 8591;
	    },
	    'Miscellaneous Technical': function (char) {
	        return char >= 8960 && char <= 9215;
	    },
	    'Control Pictures': function (char) {
	        return char >= 9216 && char <= 9279;
	    },
	    'Optical Character Recognition': function (char) {
	        return char >= 9280 && char <= 9311;
	    },
	    'Enclosed Alphanumerics': function (char) {
	        return char >= 9312 && char <= 9471;
	    },
	    'Geometric Shapes': function (char) {
	        return char >= 9632 && char <= 9727;
	    },
	    'Miscellaneous Symbols': function (char) {
	        return char >= 9728 && char <= 9983;
	    },
	    'Miscellaneous Symbols and Arrows': function (char) {
	        return char >= 11008 && char <= 11263;
	    },
	    'CJK Radicals Supplement': function (char) {
	        return char >= 11904 && char <= 12031;
	    },
	    'Kangxi Radicals': function (char) {
	        return char >= 12032 && char <= 12255;
	    },
	    'Ideographic Description Characters': function (char) {
	        return char >= 12272 && char <= 12287;
	    },
	    'CJK Symbols and Punctuation': function (char) {
	        return char >= 12288 && char <= 12351;
	    },
	    'Hiragana': function (char) {
	        return char >= 12352 && char <= 12447;
	    },
	    'Katakana': function (char) {
	        return char >= 12448 && char <= 12543;
	    },
	    'Bopomofo': function (char) {
	        return char >= 12544 && char <= 12591;
	    },
	    'Hangul Compatibility Jamo': function (char) {
	        return char >= 12592 && char <= 12687;
	    },
	    'Kanbun': function (char) {
	        return char >= 12688 && char <= 12703;
	    },
	    'Bopomofo Extended': function (char) {
	        return char >= 12704 && char <= 12735;
	    },
	    'CJK Strokes': function (char) {
	        return char >= 12736 && char <= 12783;
	    },
	    'Katakana Phonetic Extensions': function (char) {
	        return char >= 12784 && char <= 12799;
	    },
	    'Enclosed CJK Letters and Months': function (char) {
	        return char >= 12800 && char <= 13055;
	    },
	    'CJK Compatibility': function (char) {
	        return char >= 13056 && char <= 13311;
	    },
	    'CJK Unified Ideographs Extension A': function (char) {
	        return char >= 13312 && char <= 19903;
	    },
	    'Yijing Hexagram Symbols': function (char) {
	        return char >= 19904 && char <= 19967;
	    },
	    'CJK Unified Ideographs': function (char) {
	        return char >= 19968 && char <= 40959;
	    },
	    'Yi Syllables': function (char) {
	        return char >= 40960 && char <= 42127;
	    },
	    'Yi Radicals': function (char) {
	        return char >= 42128 && char <= 42191;
	    },
	    'Hangul Jamo Extended-A': function (char) {
	        return char >= 43360 && char <= 43391;
	    },
	    'Hangul Syllables': function (char) {
	        return char >= 44032 && char <= 55215;
	    },
	    'Hangul Jamo Extended-B': function (char) {
	        return char >= 55216 && char <= 55295;
	    },
	    'Private Use Area': function (char) {
	        return char >= 57344 && char <= 63743;
	    },
	    'CJK Compatibility Ideographs': function (char) {
	        return char >= 63744 && char <= 64255;
	    },
	    'Arabic Presentation Forms-A': function (char) {
	        return char >= 64336 && char <= 65023;
	    },
	    'Vertical Forms': function (char) {
	        return char >= 65040 && char <= 65055;
	    },
	    'CJK Compatibility Forms': function (char) {
	        return char >= 65072 && char <= 65103;
	    },
	    'Small Form Variants': function (char) {
	        return char >= 65104 && char <= 65135;
	    },
	    'Arabic Presentation Forms-B': function (char) {
	        return char >= 65136 && char <= 65279;
	    },
	    'Halfwidth and Fullwidth Forms': function (char) {
	        return char >= 65280 && char <= 65519;
	    }
	};

	function allowsVerticalWritingMode(chars) {
	    for (var i = 0, list = chars; i < list.length; i += 1) {
	        var char = list[i];
	        if (charHasUprightVerticalOrientation(char.charCodeAt(0))) {
	            return true;
	        }
	    }
	    return false;
	}
	function allowsLetterSpacing(chars) {
	    for (var i = 0, list = chars; i < list.length; i += 1) {
	        var char = list[i];
	        if (!charAllowsLetterSpacing(char.charCodeAt(0))) {
	            return false;
	        }
	    }
	    return true;
	}
	function charAllowsLetterSpacing(char) {
	    if (unicodeBlockLookup['Arabic'](char)) {
	        return false;
	    }
	    if (unicodeBlockLookup['Arabic Supplement'](char)) {
	        return false;
	    }
	    if (unicodeBlockLookup['Arabic Extended-A'](char)) {
	        return false;
	    }
	    if (unicodeBlockLookup['Arabic Presentation Forms-A'](char)) {
	        return false;
	    }
	    if (unicodeBlockLookup['Arabic Presentation Forms-B'](char)) {
	        return false;
	    }
	    return true;
	}
	function charAllowsIdeographicBreaking(char) {
	    if (char < 11904) {
	        return false;
	    }
	    if (unicodeBlockLookup['Bopomofo Extended'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Bopomofo'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Compatibility Forms'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Compatibility Ideographs'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Compatibility'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Radicals Supplement'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Strokes'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Symbols and Punctuation'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Unified Ideographs Extension A'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Unified Ideographs'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Enclosed CJK Letters and Months'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Halfwidth and Fullwidth Forms'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Hiragana'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Ideographic Description Characters'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Kangxi Radicals'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Katakana Phonetic Extensions'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Katakana'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Vertical Forms'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Yi Radicals'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Yi Syllables'](char)) {
	        return true;
	    }
	    return false;
	}
	function charHasUprightVerticalOrientation(char) {
	    if (char === 746 || char === 747) {
	        return true;
	    }
	    if (char < 4352) {
	        return false;
	    }
	    if (unicodeBlockLookup['Bopomofo Extended'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Bopomofo'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Compatibility Forms'](char)) {
	        if (!(char >= 65097 && char <= 65103)) {
	            return true;
	        }
	    }
	    if (unicodeBlockLookup['CJK Compatibility Ideographs'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Compatibility'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Radicals Supplement'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Strokes'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Symbols and Punctuation'](char)) {
	        if (!(char >= 12296 && char <= 12305) && !(char >= 12308 && char <= 12319) && char !== 12336) {
	            return true;
	        }
	    }
	    if (unicodeBlockLookup['CJK Unified Ideographs Extension A'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Unified Ideographs'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Enclosed CJK Letters and Months'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Hangul Compatibility Jamo'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Hangul Jamo Extended-A'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Hangul Jamo Extended-B'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Hangul Jamo'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Hangul Syllables'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Hiragana'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Ideographic Description Characters'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Kanbun'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Kangxi Radicals'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Katakana Phonetic Extensions'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Katakana'](char)) {
	        if (char !== 12540) {
	            return true;
	        }
	    }
	    if (unicodeBlockLookup['Halfwidth and Fullwidth Forms'](char)) {
	        if (char !== 65288 && char !== 65289 && char !== 65293 && !(char >= 65306 && char <= 65310) && char !== 65339 && char !== 65341 && char !== 65343 && !(char >= 65371 && char <= 65503) && char !== 65507 && !(char >= 65512 && char <= 65519)) {
	            return true;
	        }
	    }
	    if (unicodeBlockLookup['Small Form Variants'](char)) {
	        if (!(char >= 65112 && char <= 65118) && !(char >= 65123 && char <= 65126)) {
	            return true;
	        }
	    }
	    if (unicodeBlockLookup['Unified Canadian Aboriginal Syllabics'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Unified Canadian Aboriginal Syllabics Extended'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Vertical Forms'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Yijing Hexagram Symbols'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Yi Syllables'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Yi Radicals'](char)) {
	        return true;
	    }
	    return false;
	}
	function charHasNeutralVerticalOrientation(char) {
	    if (unicodeBlockLookup['Latin-1 Supplement'](char)) {
	        if (char === 167 || char === 169 || char === 174 || char === 177 || char === 188 || char === 189 || char === 190 || char === 215 || char === 247) {
	            return true;
	        }
	    }
	    if (unicodeBlockLookup['General Punctuation'](char)) {
	        if (char === 8214 || char === 8224 || char === 8225 || char === 8240 || char === 8241 || char === 8251 || char === 8252 || char === 8258 || char === 8263 || char === 8264 || char === 8265 || char === 8273) {
	            return true;
	        }
	    }
	    if (unicodeBlockLookup['Letterlike Symbols'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Number Forms'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Miscellaneous Technical'](char)) {
	        if (char >= 8960 && char <= 8967 || char >= 8972 && char <= 8991 || char >= 8996 && char <= 9000 || char === 9003 || char >= 9085 && char <= 9114 || char >= 9150 && char <= 9165 || char === 9167 || char >= 9169 && char <= 9179 || char >= 9186 && char <= 9215) {
	            return true;
	        }
	    }
	    if (unicodeBlockLookup['Control Pictures'](char) && char !== 9251) {
	        return true;
	    }
	    if (unicodeBlockLookup['Optical Character Recognition'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Enclosed Alphanumerics'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Geometric Shapes'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Miscellaneous Symbols'](char)) {
	        if (!(char >= 9754 && char <= 9759)) {
	            return true;
	        }
	    }
	    if (unicodeBlockLookup['Miscellaneous Symbols and Arrows'](char)) {
	        if (char >= 11026 && char <= 11055 || char >= 11088 && char <= 11097 || char >= 11192 && char <= 11243) {
	            return true;
	        }
	    }
	    if (unicodeBlockLookup['CJK Symbols and Punctuation'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Katakana'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Private Use Area'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['CJK Compatibility Forms'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Small Form Variants'](char)) {
	        return true;
	    }
	    if (unicodeBlockLookup['Halfwidth and Fullwidth Forms'](char)) {
	        return true;
	    }
	    if (char === 8734 || char === 8756 || char === 8757 || char >= 9984 && char <= 10087 || char >= 10102 && char <= 10131 || char === 65532 || char === 65533) {
	        return true;
	    }
	    return false;
	}
	function charHasRotatedVerticalOrientation(char) {
	    return !(charHasUprightVerticalOrientation(char) || charHasNeutralVerticalOrientation(char));
	}
	function charInComplexShapingScript(char) {
	    return unicodeBlockLookup['Arabic'](char) || unicodeBlockLookup['Arabic Supplement'](char) || unicodeBlockLookup['Arabic Extended-A'](char) || unicodeBlockLookup['Arabic Presentation Forms-A'](char) || unicodeBlockLookup['Arabic Presentation Forms-B'](char);
	}
	function charInRTLScript(char) {
	    return char >= 1424 && char <= 2303 || unicodeBlockLookup['Arabic Presentation Forms-A'](char) || unicodeBlockLookup['Arabic Presentation Forms-B'](char);
	}
	function charInSupportedScript(char, canRenderRTL) {
	    if (!canRenderRTL && charInRTLScript(char)) {
	        return false;
	    }
	    if (char >= 2304 && char <= 3583 || char >= 3840 && char <= 4255 || unicodeBlockLookup['Khmer'](char)) {
	        return false;
	    }
	    return true;
	}
	function stringContainsRTLText(chars) {
	    for (var i = 0, list = chars; i < list.length; i += 1) {
	        var char = list[i];
	        if (charInRTLScript(char.charCodeAt(0))) {
	            return true;
	        }
	    }
	    return false;
	}
	function isStringInSupportedScript(chars, canRenderRTL) {
	    for (var i = 0, list = chars; i < list.length; i += 1) {
	        var char = list[i];
	        if (!charInSupportedScript(char.charCodeAt(0), canRenderRTL)) {
	            return false;
	        }
	    }
	    return true;
	}

	var status = {
	    unavailable: 'unavailable',
	    deferred: 'deferred',
	    loading: 'loading',
	    loaded: 'loaded',
	    error: 'error'
	};
	var _completionCallback = null;
	var pluginStatus = status.unavailable;
	var pluginURL = null;
	var triggerPluginCompletionEvent = function (error) {
	    if (error && typeof error === 'string' && error.indexOf('NetworkError') > -1) {
	        pluginStatus = status.error;
	    }
	    if (_completionCallback) {
	        _completionCallback(error);
	    }
	};
	function sendPluginStateToWorker() {
	    evented.fire(new Event('pluginStateChange', {
	        pluginStatus: pluginStatus,
	        pluginURL: pluginURL
	    }));
	}
	var evented = new Evented();
	var getRTLTextPluginStatus = function () {
	    return pluginStatus;
	};
	var registerForPluginStateChange = function (callback) {
	    callback({
	        pluginStatus: pluginStatus,
	        pluginURL: pluginURL
	    });
	    evented.on('pluginStateChange', callback);
	    return callback;
	};
	var setRTLTextPlugin = function (url, callback, deferred) {
	    if (deferred === void 0)
	        deferred = false;
	    if (pluginStatus === status.deferred || pluginStatus === status.loading || pluginStatus === status.loaded) {
	        throw new Error('setRTLTextPlugin cannot be called multiple times.');
	    }
	    pluginURL = exported.resolveURL(url);
	    pluginStatus = status.deferred;
	    _completionCallback = callback;
	    sendPluginStateToWorker();
	    if (!deferred) {
	        downloadRTLTextPlugin();
	    }
	};
	var downloadRTLTextPlugin = function () {
	    if (pluginStatus !== status.deferred || !pluginURL) {
	        throw new Error('rtl-text-plugin cannot be downloaded unless a pluginURL is specified');
	    }
	    pluginStatus = status.loading;
	    sendPluginStateToWorker();
	    if (pluginURL) {
	        getArrayBuffer({ url: pluginURL }, function (error) {
	            if (error) {
	                triggerPluginCompletionEvent(error);
	            } else {
	                pluginStatus = status.loaded;
	                sendPluginStateToWorker();
	            }
	        });
	    }
	};
	var plugin = {
	    applyArabicShaping: null,
	    processBidirectionalText: null,
	    processStyledBidirectionalText: null,
	    isLoaded: function isLoaded() {
	        return pluginStatus === status.loaded || plugin.applyArabicShaping != null;
	    },
	    isLoading: function isLoading() {
	        return pluginStatus === status.loading;
	    },
	    setState: function setState(state) {
	        pluginStatus = state.pluginStatus;
	        pluginURL = state.pluginURL;
	    },
	    isParsed: function isParsed() {
	        return plugin.applyArabicShaping != null && plugin.processBidirectionalText != null && plugin.processStyledBidirectionalText != null;
	    },
	    getPluginURL: function getPluginURL() {
	        return pluginURL;
	    }
	};
	var lazyLoadRTLTextPlugin = function () {
	    if (!plugin.isLoading() && !plugin.isLoaded() && getRTLTextPluginStatus() === 'deferred') {
	        downloadRTLTextPlugin();
	    }
	};

	var EvaluationParameters = function EvaluationParameters(zoom, options) {
	    this.zoom = zoom;
	    if (options) {
	        this.now = options.now;
	        this.fadeDuration = options.fadeDuration;
	        this.zoomHistory = options.zoomHistory;
	        this.transition = options.transition;
	    } else {
	        this.now = 0;
	        this.fadeDuration = 0;
	        this.zoomHistory = new ZoomHistory();
	        this.transition = {};
	    }
	};
	EvaluationParameters.prototype.isSupportedScript = function isSupportedScript(str) {
	    return isStringInSupportedScript(str, plugin.isLoaded());
	};
	EvaluationParameters.prototype.crossFadingFactor = function crossFadingFactor() {
	    if (this.fadeDuration === 0) {
	        return 1;
	    } else {
	        return Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
	    }
	};
	EvaluationParameters.prototype.getCrossfadeParameters = function getCrossfadeParameters() {
	    var z = this.zoom;
	    var fraction = z - Math.floor(z);
	    var t = this.crossFadingFactor();
	    return z > this.zoomHistory.lastIntegerZoom ? {
	        fromScale: 2,
	        toScale: 1,
	        t: fraction + (1 - fraction) * t
	    } : {
	        fromScale: 0.5,
	        toScale: 1,
	        t: 1 - (1 - t) * fraction
	    };
	};

	var PropertyValue = function PropertyValue(property, value) {
	    this.property = property;
	    this.value = value;
	    this.expression = normalizePropertyExpression(value === undefined ? property.specification.default : value, property.specification);
	};
	PropertyValue.prototype.isDataDriven = function isDataDriven() {
	    return this.expression.kind === 'source' || this.expression.kind === 'composite';
	};
	PropertyValue.prototype.possiblyEvaluate = function possiblyEvaluate(parameters, canonical, availableImages) {
	    return this.property.possiblyEvaluate(this, parameters, canonical, availableImages);
	};
	var TransitionablePropertyValue = function TransitionablePropertyValue(property) {
	    this.property = property;
	    this.value = new PropertyValue(property, undefined);
	};
	TransitionablePropertyValue.prototype.transitioned = function transitioned(parameters, prior) {
	    return new TransitioningPropertyValue(this.property, this.value, prior, extend({}, parameters.transition, this.transition), parameters.now);
	};
	TransitionablePropertyValue.prototype.untransitioned = function untransitioned() {
	    return new TransitioningPropertyValue(this.property, this.value, null, {}, 0);
	};
	var Transitionable = function Transitionable(properties) {
	    this._properties = properties;
	    this._values = Object.create(properties.defaultTransitionablePropertyValues);
	};
	Transitionable.prototype.getValue = function getValue(name) {
	    return clone(this._values[name].value.value);
	};
	Transitionable.prototype.setValue = function setValue(name, value) {
	    if (!this._values.hasOwnProperty(name)) {
	        this._values[name] = new TransitionablePropertyValue(this._values[name].property);
	    }
	    this._values[name].value = new PropertyValue(this._values[name].property, value === null ? undefined : clone(value));
	};
	Transitionable.prototype.getTransition = function getTransition(name) {
	    return clone(this._values[name].transition);
	};
	Transitionable.prototype.setTransition = function setTransition(name, value) {
	    if (!this._values.hasOwnProperty(name)) {
	        this._values[name] = new TransitionablePropertyValue(this._values[name].property);
	    }
	    this._values[name].transition = clone(value) || undefined;
	};
	Transitionable.prototype.serialize = function serialize() {
	    var result = {};
	    for (var i = 0, list = Object.keys(this._values); i < list.length; i += 1) {
	        var property = list[i];
	        var value = this.getValue(property);
	        if (value !== undefined) {
	            result[property] = value;
	        }
	        var transition = this.getTransition(property);
	        if (transition !== undefined) {
	            result[property + '-transition'] = transition;
	        }
	    }
	    return result;
	};
	Transitionable.prototype.transitioned = function transitioned(parameters, prior) {
	    var result = new Transitioning(this._properties);
	    for (var i = 0, list = Object.keys(this._values); i < list.length; i += 1) {
	        var property = list[i];
	        result._values[property] = this._values[property].transitioned(parameters, prior._values[property]);
	    }
	    return result;
	};
	Transitionable.prototype.untransitioned = function untransitioned() {
	    var result = new Transitioning(this._properties);
	    for (var i = 0, list = Object.keys(this._values); i < list.length; i += 1) {
	        var property = list[i];
	        result._values[property] = this._values[property].untransitioned();
	    }
	    return result;
	};
	var TransitioningPropertyValue = function TransitioningPropertyValue(property, value, prior, transition, now) {
	    this.property = property;
	    this.value = value;
	    this.begin = now + transition.delay || 0;
	    this.end = this.begin + transition.duration || 0;
	    if (property.specification.transition && (transition.delay || transition.duration)) {
	        this.prior = prior;
	    }
	};
	TransitioningPropertyValue.prototype.possiblyEvaluate = function possiblyEvaluate(parameters, canonical, availableImages) {
	    var now = parameters.now || 0;
	    var finalValue = this.value.possiblyEvaluate(parameters, canonical, availableImages);
	    var prior = this.prior;
	    if (!prior) {
	        return finalValue;
	    } else if (now > this.end) {
	        this.prior = null;
	        return finalValue;
	    } else if (this.value.isDataDriven()) {
	        this.prior = null;
	        return finalValue;
	    } else if (now < this.begin) {
	        return prior.possiblyEvaluate(parameters, canonical, availableImages);
	    } else {
	        var t = (now - this.begin) / (this.end - this.begin);
	        return this.property.interpolate(prior.possiblyEvaluate(parameters, canonical, availableImages), finalValue, easeCubicInOut(t));
	    }
	};
	var Transitioning = function Transitioning(properties) {
	    this._properties = properties;
	    this._values = Object.create(properties.defaultTransitioningPropertyValues);
	};
	Transitioning.prototype.possiblyEvaluate = function possiblyEvaluate(parameters, canonical, availableImages) {
	    var result = new PossiblyEvaluated(this._properties);
	    for (var i = 0, list = Object.keys(this._values); i < list.length; i += 1) {
	        var property = list[i];
	        result._values[property] = this._values[property].possiblyEvaluate(parameters, canonical, availableImages);
	    }
	    return result;
	};
	Transitioning.prototype.hasTransition = function hasTransition() {
	    for (var i = 0, list = Object.keys(this._values); i < list.length; i += 1) {
	        var property = list[i];
	        if (this._values[property].prior) {
	            return true;
	        }
	    }
	    return false;
	};
	var Layout = function Layout(properties) {
	    this._properties = properties;
	    this._values = Object.create(properties.defaultPropertyValues);
	};
	Layout.prototype.getValue = function getValue(name) {
	    return clone(this._values[name].value);
	};
	Layout.prototype.setValue = function setValue(name, value) {
	    this._values[name] = new PropertyValue(this._values[name].property, value === null ? undefined : clone(value));
	};
	Layout.prototype.serialize = function serialize() {
	    var result = {};
	    for (var i = 0, list = Object.keys(this._values); i < list.length; i += 1) {
	        var property = list[i];
	        var value = this.getValue(property);
	        if (value !== undefined) {
	            result[property] = value;
	        }
	    }
	    return result;
	};
	Layout.prototype.possiblyEvaluate = function possiblyEvaluate(parameters, canonical, availableImages) {
	    var result = new PossiblyEvaluated(this._properties);
	    for (var i = 0, list = Object.keys(this._values); i < list.length; i += 1) {
	        var property = list[i];
	        result._values[property] = this._values[property].possiblyEvaluate(parameters, canonical, availableImages);
	    }
	    return result;
	};
	var PossiblyEvaluatedPropertyValue = function PossiblyEvaluatedPropertyValue(property, value, parameters) {
	    this.property = property;
	    this.value = value;
	    this.parameters = parameters;
	};
	PossiblyEvaluatedPropertyValue.prototype.isConstant = function isConstant() {
	    return this.value.kind === 'constant';
	};
	PossiblyEvaluatedPropertyValue.prototype.constantOr = function constantOr(value) {
	    if (this.value.kind === 'constant') {
	        return this.value.value;
	    } else {
	        return value;
	    }
	};
	PossiblyEvaluatedPropertyValue.prototype.evaluate = function evaluate(feature, featureState, canonical, availableImages) {
	    return this.property.evaluate(this.value, this.parameters, feature, featureState, canonical, availableImages);
	};
	var PossiblyEvaluated = function PossiblyEvaluated(properties) {
	    this._properties = properties;
	    this._values = Object.create(properties.defaultPossiblyEvaluatedValues);
	};
	PossiblyEvaluated.prototype.get = function get(name) {
	    return this._values[name];
	};
	var DataConstantProperty = function DataConstantProperty(specification) {
	    this.specification = specification;
	};
	DataConstantProperty.prototype.possiblyEvaluate = function possiblyEvaluate(value, parameters) {
	    return value.expression.evaluate(parameters);
	};
	DataConstantProperty.prototype.interpolate = function interpolate$1(a, b, t) {
	    var interp = interpolate[this.specification.type];
	    if (interp) {
	        return interp(a, b, t);
	    } else {
	        return a;
	    }
	};
	var DataDrivenProperty = function DataDrivenProperty(specification, overrides) {
	    this.specification = specification;
	    this.overrides = overrides;
	};
	DataDrivenProperty.prototype.possiblyEvaluate = function possiblyEvaluate(value, parameters, canonical, availableImages) {
	    if (value.expression.kind === 'constant' || value.expression.kind === 'camera') {
	        return new PossiblyEvaluatedPropertyValue(this, {
	            kind: 'constant',
	            value: value.expression.evaluate(parameters, null, {}, canonical, availableImages)
	        }, parameters);
	    } else {
	        return new PossiblyEvaluatedPropertyValue(this, value.expression, parameters);
	    }
	};
	DataDrivenProperty.prototype.interpolate = function interpolate$2(a, b, t) {
	    if (a.value.kind !== 'constant' || b.value.kind !== 'constant') {
	        return a;
	    }
	    if (a.value.value === undefined || b.value.value === undefined) {
	        return new PossiblyEvaluatedPropertyValue(this, {
	            kind: 'constant',
	            value: undefined
	        }, a.parameters);
	    }
	    var interp = interpolate[this.specification.type];
	    if (interp) {
	        return new PossiblyEvaluatedPropertyValue(this, {
	            kind: 'constant',
	            value: interp(a.value.value, b.value.value, t)
	        }, a.parameters);
	    } else {
	        return a;
	    }
	};
	DataDrivenProperty.prototype.evaluate = function evaluate(value, parameters, feature, featureState, canonical, availableImages) {
	    if (value.kind === 'constant') {
	        return value.value;
	    } else {
	        return value.evaluate(parameters, feature, featureState, canonical, availableImages);
	    }
	};
	var CrossFadedDataDrivenProperty = function (DataDrivenProperty) {
	    function CrossFadedDataDrivenProperty() {
	        DataDrivenProperty.apply(this, arguments);
	    }
	    if (DataDrivenProperty)
	        CrossFadedDataDrivenProperty.__proto__ = DataDrivenProperty;
	    CrossFadedDataDrivenProperty.prototype = Object.create(DataDrivenProperty && DataDrivenProperty.prototype);
	    CrossFadedDataDrivenProperty.prototype.constructor = CrossFadedDataDrivenProperty;
	    CrossFadedDataDrivenProperty.prototype.possiblyEvaluate = function possiblyEvaluate(value, parameters, canonical, availableImages) {
	        if (value.value === undefined) {
	            return new PossiblyEvaluatedPropertyValue(this, {
	                kind: 'constant',
	                value: undefined
	            }, parameters);
	        } else if (value.expression.kind === 'constant') {
	            var evaluatedValue = value.expression.evaluate(parameters, null, {}, canonical, availableImages);
	            var isImageExpression = value.property.specification.type === 'resolvedImage';
	            var constantValue = isImageExpression && typeof evaluatedValue !== 'string' ? evaluatedValue.name : evaluatedValue;
	            var constant = this._calculate(constantValue, constantValue, constantValue, parameters);
	            return new PossiblyEvaluatedPropertyValue(this, {
	                kind: 'constant',
	                value: constant
	            }, parameters);
	        } else if (value.expression.kind === 'camera') {
	            var cameraVal = this._calculate(value.expression.evaluate({ zoom: parameters.zoom - 1 }), value.expression.evaluate({ zoom: parameters.zoom }), value.expression.evaluate({ zoom: parameters.zoom + 1 }), parameters);
	            return new PossiblyEvaluatedPropertyValue(this, {
	                kind: 'constant',
	                value: cameraVal
	            }, parameters);
	        } else {
	            return new PossiblyEvaluatedPropertyValue(this, value.expression, parameters);
	        }
	    };
	    CrossFadedDataDrivenProperty.prototype.evaluate = function evaluate(value, globals, feature, featureState, canonical, availableImages) {
	        if (value.kind === 'source') {
	            var constant = value.evaluate(globals, feature, featureState, canonical, availableImages);
	            return this._calculate(constant, constant, constant, globals);
	        } else if (value.kind === 'composite') {
	            return this._calculate(value.evaluate({ zoom: Math.floor(globals.zoom) - 1 }, feature, featureState), value.evaluate({ zoom: Math.floor(globals.zoom) }, feature, featureState), value.evaluate({ zoom: Math.floor(globals.zoom) + 1 }, feature, featureState), globals);
	        } else {
	            return value.value;
	        }
	    };
	    CrossFadedDataDrivenProperty.prototype._calculate = function _calculate(min, mid, max, parameters) {
	        var z = parameters.zoom;
	        return z > parameters.zoomHistory.lastIntegerZoom ? {
	            from: min,
	            to: mid
	        } : {
	            from: max,
	            to: mid
	        };
	    };
	    CrossFadedDataDrivenProperty.prototype.interpolate = function interpolate(a) {
	        return a;
	    };
	    return CrossFadedDataDrivenProperty;
	}(DataDrivenProperty);
	var CrossFadedProperty = function CrossFadedProperty(specification) {
	    this.specification = specification;
	};
	CrossFadedProperty.prototype.possiblyEvaluate = function possiblyEvaluate(value, parameters, canonical, availableImages) {
	    if (value.value === undefined) {
	        return undefined;
	    } else if (value.expression.kind === 'constant') {
	        var constant = value.expression.evaluate(parameters, null, {}, canonical, availableImages);
	        return this._calculate(constant, constant, constant, parameters);
	    } else {
	        return this._calculate(value.expression.evaluate(new EvaluationParameters(Math.floor(parameters.zoom - 1), parameters)), value.expression.evaluate(new EvaluationParameters(Math.floor(parameters.zoom), parameters)), value.expression.evaluate(new EvaluationParameters(Math.floor(parameters.zoom + 1), parameters)), parameters);
	    }
	};
	CrossFadedProperty.prototype._calculate = function _calculate(min, mid, max, parameters) {
	    var z = parameters.zoom;
	    return z > parameters.zoomHistory.lastIntegerZoom ? {
	        from: min,
	        to: mid
	    } : {
	        from: max,
	        to: mid
	    };
	};
	CrossFadedProperty.prototype.interpolate = function interpolate(a) {
	    return a;
	};
	var ColorRampProperty = function ColorRampProperty(specification) {
	    this.specification = specification;
	};
	ColorRampProperty.prototype.possiblyEvaluate = function possiblyEvaluate(value, parameters, canonical, availableImages) {
	    return !!value.expression.evaluate(parameters, null, {}, canonical, availableImages);
	};
	ColorRampProperty.prototype.interpolate = function interpolate() {
	    return false;
	};
	var Properties = function Properties(properties) {
	    this.properties = properties;
	    this.defaultPropertyValues = {};
	    this.defaultTransitionablePropertyValues = {};
	    this.defaultTransitioningPropertyValues = {};
	    this.defaultPossiblyEvaluatedValues = {};
	    this.overridableProperties = [];
	    for (var property in properties) {
	        var prop = properties[property];
	        if (prop.specification.overridable) {
	            this.overridableProperties.push(property);
	        }
	        var defaultPropertyValue = this.defaultPropertyValues[property] = new PropertyValue(prop, undefined);
	        var defaultTransitionablePropertyValue = this.defaultTransitionablePropertyValues[property] = new TransitionablePropertyValue(prop);
	        this.defaultTransitioningPropertyValues[property] = defaultTransitionablePropertyValue.untransitioned();
	        this.defaultPossiblyEvaluatedValues[property] = defaultPropertyValue.possiblyEvaluate({});
	    }
	};
	register('DataDrivenProperty', DataDrivenProperty);
	register('DataConstantProperty', DataConstantProperty);
	register('CrossFadedDataDrivenProperty', CrossFadedDataDrivenProperty);
	register('CrossFadedProperty', CrossFadedProperty);
	register('ColorRampProperty', ColorRampProperty);

	var TRANSITION_SUFFIX = '-transition';
	var StyleLayer = function (Evented) {
	    function StyleLayer(layer, properties) {
	        Evented.call(this);
	        this.id = layer.id;
	        this.type = layer.type;
	        this._featureFilter = {
	            filter: function () {
	                return true;
	            },
	            needGeometry: false
	        };
	        if (layer.type === 'custom') {
	            return;
	        }
	        layer = layer;
	        this.metadata = layer.metadata;
	        this.minzoom = layer.minzoom;
	        this.maxzoom = layer.maxzoom;
	        if (layer.type !== 'background') {
	            this.source = layer.source;
	            this.sourceLayer = layer['source-layer'];
	            this.filter = layer.filter;
	        }
	        if (properties.layout) {
	            this._unevaluatedLayout = new Layout(properties.layout);
	        }
	        if (properties.paint) {
	            this._transitionablePaint = new Transitionable(properties.paint);
	            for (var property in layer.paint) {
	                this.setPaintProperty(property, layer.paint[property], { validate: false });
	            }
	            for (var property$1 in layer.layout) {
	                this.setLayoutProperty(property$1, layer.layout[property$1], { validate: false });
	            }
	            this._transitioningPaint = this._transitionablePaint.untransitioned();
	            this.paint = new PossiblyEvaluated(properties.paint);
	        }
	    }
	    if (Evented)
	        StyleLayer.__proto__ = Evented;
	    StyleLayer.prototype = Object.create(Evented && Evented.prototype);
	    StyleLayer.prototype.constructor = StyleLayer;
	    StyleLayer.prototype.getCrossfadeParameters = function getCrossfadeParameters() {
	        return this._crossfadeParameters;
	    };
	    StyleLayer.prototype.getLayoutProperty = function getLayoutProperty(name) {
	        if (name === 'visibility') {
	            return this.visibility;
	        }
	        return this._unevaluatedLayout.getValue(name);
	    };
	    StyleLayer.prototype.setLayoutProperty = function setLayoutProperty(name, value, options) {
	        if (options === void 0)
	            options = {};
	        if (value !== null && value !== undefined) {
	            var key = 'layers.' + this.id + '.layout.' + name;
	            if (this._validate(validateLayoutProperty$1, key, name, value, options)) {
	                return;
	            }
	        }
	        if (name === 'visibility') {
	            this.visibility = value;
	            return;
	        }
	        this._unevaluatedLayout.setValue(name, value);
	    };
	    StyleLayer.prototype.getPaintProperty = function getPaintProperty(name) {
	        if (endsWith(name, TRANSITION_SUFFIX)) {
	            return this._transitionablePaint.getTransition(name.slice(0, -TRANSITION_SUFFIX.length));
	        } else {
	            return this._transitionablePaint.getValue(name);
	        }
	    };
	    StyleLayer.prototype.setPaintProperty = function setPaintProperty(name, value, options) {
	        if (options === void 0)
	            options = {};
	        if (value !== null && value !== undefined) {
	            var key = 'layers.' + this.id + '.paint.' + name;
	            if (this._validate(validatePaintProperty$1, key, name, value, options)) {
	                return false;
	            }
	        }
	        if (endsWith(name, TRANSITION_SUFFIX)) {
	            this._transitionablePaint.setTransition(name.slice(0, -TRANSITION_SUFFIX.length), value || undefined);
	            return false;
	        } else {
	            var transitionable = this._transitionablePaint._values[name];
	            var isCrossFadedProperty = transitionable.property.specification['property-type'] === 'cross-faded-data-driven';
	            var wasDataDriven = transitionable.value.isDataDriven();
	            var oldValue = transitionable.value;
	            this._transitionablePaint.setValue(name, value);
	            this._handleSpecialPaintPropertyUpdate(name);
	            var newValue = this._transitionablePaint._values[name].value;
	            var isDataDriven = newValue.isDataDriven();
	            return isDataDriven || wasDataDriven || isCrossFadedProperty || this._handleOverridablePaintPropertyUpdate(name, oldValue, newValue);
	        }
	    };
	    StyleLayer.prototype._handleSpecialPaintPropertyUpdate = function _handleSpecialPaintPropertyUpdate(_) {
	    };
	    StyleLayer.prototype._handleOverridablePaintPropertyUpdate = function _handleOverridablePaintPropertyUpdate(name, oldValue, newValue) {
	        return false;
	    };
	    StyleLayer.prototype.isHidden = function isHidden(zoom) {
	        if (this.minzoom && zoom < this.minzoom) {
	            return true;
	        }
	        if (this.maxzoom && zoom >= this.maxzoom) {
	            return true;
	        }
	        return this.visibility === 'none';
	    };
	    StyleLayer.prototype.updateTransitions = function updateTransitions(parameters) {
	        this._transitioningPaint = this._transitionablePaint.transitioned(parameters, this._transitioningPaint);
	    };
	    StyleLayer.prototype.hasTransition = function hasTransition() {
	        return this._transitioningPaint.hasTransition();
	    };
	    StyleLayer.prototype.recalculate = function recalculate(parameters, availableImages) {
	        if (parameters.getCrossfadeParameters) {
	            this._crossfadeParameters = parameters.getCrossfadeParameters();
	        }
	        if (this._unevaluatedLayout) {
	            this.layout = this._unevaluatedLayout.possiblyEvaluate(parameters, undefined, availableImages);
	        }
	        this.paint = this._transitioningPaint.possiblyEvaluate(parameters, undefined, availableImages);
	    };
	    StyleLayer.prototype.serialize = function serialize() {
	        var output = {
	            'id': this.id,
	            'type': this.type,
	            'source': this.source,
	            'source-layer': this.sourceLayer,
	            'metadata': this.metadata,
	            'minzoom': this.minzoom,
	            'maxzoom': this.maxzoom,
	            'filter': this.filter,
	            'layout': this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
	            'paint': this._transitionablePaint && this._transitionablePaint.serialize()
	        };
	        if (this.visibility) {
	            output.layout = output.layout || {};
	            output.layout.visibility = this.visibility;
	        }
	        return filterObject(output, function (value, key) {
	            return value !== undefined && !(key === 'layout' && !Object.keys(value).length) && !(key === 'paint' && !Object.keys(value).length);
	        });
	    };
	    StyleLayer.prototype._validate = function _validate(validate, key, name, value, options) {
	        if (options === void 0)
	            options = {};
	        if (options && options.validate === false) {
	            return false;
	        }
	        return emitValidationErrors(this, validate.call(validateStyle, {
	            key: key,
	            layerType: this.type,
	            objectKey: name,
	            value: value,
	            styleSpec: spec,
	            style: {
	                glyphs: true,
	                sprite: true
	            }
	        }));
	    };
	    StyleLayer.prototype.is3D = function is3D() {
	        return false;
	    };
	    StyleLayer.prototype.isTileClipped = function isTileClipped() {
	        return false;
	    };
	    StyleLayer.prototype.hasOffscreenPass = function hasOffscreenPass() {
	        return false;
	    };
	    StyleLayer.prototype.resize = function resize() {
	    };
	    StyleLayer.prototype.isStateDependent = function isStateDependent() {
	        for (var property in this.paint._values) {
	            var value = this.paint.get(property);
	            if (!(value instanceof PossiblyEvaluatedPropertyValue) || !supportsPropertyExpression(value.property.specification)) {
	                continue;
	            }
	            if ((value.value.kind === 'source' || value.value.kind === 'composite') && value.value.isStateDependent) {
	                return true;
	            }
	        }
	        return false;
	    };
	    return StyleLayer;
	}(Evented);

	var viewTypes = {
	    'Int8': Int8Array,
	    'Uint8': Uint8Array,
	    'Int16': Int16Array,
	    'Uint16': Uint16Array,
	    'Int32': Int32Array,
	    'Uint32': Uint32Array,
	    'Float32': Float32Array
	};
	var Struct = function Struct(structArray, index) {
	    this._structArray = structArray;
	    this._pos1 = index * this.size;
	    this._pos2 = this._pos1 / 2;
	    this._pos4 = this._pos1 / 4;
	    this._pos8 = this._pos1 / 8;
	};
	var DEFAULT_CAPACITY = 128;
	var RESIZE_MULTIPLIER = 5;
	var StructArray = function StructArray() {
	    this.isTransferred = false;
	    this.capacity = -1;
	    this.resize(0);
	};
	StructArray.serialize = function serialize(array, transferables) {
	    array._trim();
	    if (transferables) {
	        array.isTransferred = true;
	        transferables.push(array.arrayBuffer);
	    }
	    return {
	        length: array.length,
	        arrayBuffer: array.arrayBuffer
	    };
	};
	StructArray.deserialize = function deserialize(input) {
	    var structArray = Object.create(this.prototype);
	    structArray.arrayBuffer = input.arrayBuffer;
	    structArray.length = input.length;
	    structArray.capacity = input.arrayBuffer.byteLength / structArray.bytesPerElement;
	    structArray._refreshViews();
	    return structArray;
	};
	StructArray.prototype._trim = function _trim() {
	    if (this.length !== this.capacity) {
	        this.capacity = this.length;
	        this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement);
	        this._refreshViews();
	    }
	};
	StructArray.prototype.clear = function clear() {
	    this.length = 0;
	};
	StructArray.prototype.resize = function resize(n) {
	    this.reserve(n);
	    this.length = n;
	};
	StructArray.prototype.reserve = function reserve(n) {
	    if (n > this.capacity) {
	        this.capacity = Math.max(n, Math.floor(this.capacity * RESIZE_MULTIPLIER), DEFAULT_CAPACITY);
	        this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
	        var oldUint8Array = this.uint8;
	        this._refreshViews();
	        if (oldUint8Array) {
	            this.uint8.set(oldUint8Array);
	        }
	    }
	};
	StructArray.prototype._refreshViews = function _refreshViews() {
	    throw new Error('_refreshViews() must be implemented by each concrete StructArray layout');
	};
	function createLayout(members, alignment) {
	    if (alignment === void 0)
	        alignment = 1;
	    var offset = 0;
	    var maxSize = 0;
	    var layoutMembers = members.map(function (member) {
	        var typeSize = sizeOf(member.type);
	        var memberOffset = offset = align(offset, Math.max(alignment, typeSize));
	        var components = member.components || 1;
	        maxSize = Math.max(maxSize, typeSize);
	        offset += typeSize * components;
	        return {
	            name: member.name,
	            type: member.type,
	            components: components,
	            offset: memberOffset
	        };
	    });
	    var size = align(offset, Math.max(maxSize, alignment));
	    return {
	        members: layoutMembers,
	        size: size,
	        alignment: alignment
	    };
	}
	function sizeOf(type) {
	    return viewTypes[type].BYTES_PER_ELEMENT;
	}
	function align(offset, size) {
	    return Math.ceil(offset / size) * size;
	}

	var StructArrayLayout2i4 = function (StructArray) {
	    function StructArrayLayout2i4() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout2i4.__proto__ = StructArray;
	    StructArrayLayout2i4.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout2i4.prototype.constructor = StructArrayLayout2i4;
	    StructArrayLayout2i4.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.int16 = new Int16Array(this.arrayBuffer);
	    };
	    StructArrayLayout2i4.prototype.emplaceBack = function emplaceBack(v0, v1) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1);
	    };
	    StructArrayLayout2i4.prototype.emplace = function emplace(i, v0, v1) {
	        var o2 = i * 2;
	        this.int16[o2 + 0] = v0;
	        this.int16[o2 + 1] = v1;
	        return i;
	    };
	    return StructArrayLayout2i4;
	}(StructArray);
	StructArrayLayout2i4.prototype.bytesPerElement = 4;
	register('StructArrayLayout2i4', StructArrayLayout2i4);
	var StructArrayLayout4i8 = function (StructArray) {
	    function StructArrayLayout4i8() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout4i8.__proto__ = StructArray;
	    StructArrayLayout4i8.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout4i8.prototype.constructor = StructArrayLayout4i8;
	    StructArrayLayout4i8.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.int16 = new Int16Array(this.arrayBuffer);
	    };
	    StructArrayLayout4i8.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2, v3);
	    };
	    StructArrayLayout4i8.prototype.emplace = function emplace(i, v0, v1, v2, v3) {
	        var o2 = i * 4;
	        this.int16[o2 + 0] = v0;
	        this.int16[o2 + 1] = v1;
	        this.int16[o2 + 2] = v2;
	        this.int16[o2 + 3] = v3;
	        return i;
	    };
	    return StructArrayLayout4i8;
	}(StructArray);
	StructArrayLayout4i8.prototype.bytesPerElement = 8;
	register('StructArrayLayout4i8', StructArrayLayout4i8);
	var StructArrayLayout2i4i12 = function (StructArray) {
	    function StructArrayLayout2i4i12() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout2i4i12.__proto__ = StructArray;
	    StructArrayLayout2i4i12.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout2i4i12.prototype.constructor = StructArrayLayout2i4i12;
	    StructArrayLayout2i4i12.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.int16 = new Int16Array(this.arrayBuffer);
	    };
	    StructArrayLayout2i4i12.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2, v3, v4, v5);
	    };
	    StructArrayLayout2i4i12.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5) {
	        var o2 = i * 6;
	        this.int16[o2 + 0] = v0;
	        this.int16[o2 + 1] = v1;
	        this.int16[o2 + 2] = v2;
	        this.int16[o2 + 3] = v3;
	        this.int16[o2 + 4] = v4;
	        this.int16[o2 + 5] = v5;
	        return i;
	    };
	    return StructArrayLayout2i4i12;
	}(StructArray);
	StructArrayLayout2i4i12.prototype.bytesPerElement = 12;
	register('StructArrayLayout2i4i12', StructArrayLayout2i4i12);
	var StructArrayLayout2i4ub8 = function (StructArray) {
	    function StructArrayLayout2i4ub8() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout2i4ub8.__proto__ = StructArray;
	    StructArrayLayout2i4ub8.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout2i4ub8.prototype.constructor = StructArrayLayout2i4ub8;
	    StructArrayLayout2i4ub8.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.int16 = new Int16Array(this.arrayBuffer);
	    };
	    StructArrayLayout2i4ub8.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2, v3, v4, v5);
	    };
	    StructArrayLayout2i4ub8.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5) {
	        var o2 = i * 4;
	        var o1 = i * 8;
	        this.int16[o2 + 0] = v0;
	        this.int16[o2 + 1] = v1;
	        this.uint8[o1 + 4] = v2;
	        this.uint8[o1 + 5] = v3;
	        this.uint8[o1 + 6] = v4;
	        this.uint8[o1 + 7] = v5;
	        return i;
	    };
	    return StructArrayLayout2i4ub8;
	}(StructArray);
	StructArrayLayout2i4ub8.prototype.bytesPerElement = 8;
	register('StructArrayLayout2i4ub8', StructArrayLayout2i4ub8);
	var StructArrayLayout2f8 = function (StructArray) {
	    function StructArrayLayout2f8() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout2f8.__proto__ = StructArray;
	    StructArrayLayout2f8.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout2f8.prototype.constructor = StructArrayLayout2f8;
	    StructArrayLayout2f8.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.float32 = new Float32Array(this.arrayBuffer);
	    };
	    StructArrayLayout2f8.prototype.emplaceBack = function emplaceBack(v0, v1) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1);
	    };
	    StructArrayLayout2f8.prototype.emplace = function emplace(i, v0, v1) {
	        var o4 = i * 2;
	        this.float32[o4 + 0] = v0;
	        this.float32[o4 + 1] = v1;
	        return i;
	    };
	    return StructArrayLayout2f8;
	}(StructArray);
	StructArrayLayout2f8.prototype.bytesPerElement = 8;
	register('StructArrayLayout2f8', StructArrayLayout2f8);
	var StructArrayLayout10ui20 = function (StructArray) {
	    function StructArrayLayout10ui20() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout10ui20.__proto__ = StructArray;
	    StructArrayLayout10ui20.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout10ui20.prototype.constructor = StructArrayLayout10ui20;
	    StructArrayLayout10ui20.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.uint16 = new Uint16Array(this.arrayBuffer);
	    };
	    StructArrayLayout10ui20.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	    };
	    StructArrayLayout10ui20.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	        var o2 = i * 10;
	        this.uint16[o2 + 0] = v0;
	        this.uint16[o2 + 1] = v1;
	        this.uint16[o2 + 2] = v2;
	        this.uint16[o2 + 3] = v3;
	        this.uint16[o2 + 4] = v4;
	        this.uint16[o2 + 5] = v5;
	        this.uint16[o2 + 6] = v6;
	        this.uint16[o2 + 7] = v7;
	        this.uint16[o2 + 8] = v8;
	        this.uint16[o2 + 9] = v9;
	        return i;
	    };
	    return StructArrayLayout10ui20;
	}(StructArray);
	StructArrayLayout10ui20.prototype.bytesPerElement = 20;
	register('StructArrayLayout10ui20', StructArrayLayout10ui20);
	var StructArrayLayout4i4ui4i24 = function (StructArray) {
	    function StructArrayLayout4i4ui4i24() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout4i4ui4i24.__proto__ = StructArray;
	    StructArrayLayout4i4ui4i24.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout4i4ui4i24.prototype.constructor = StructArrayLayout4i4ui4i24;
	    StructArrayLayout4i4ui4i24.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.int16 = new Int16Array(this.arrayBuffer);
	        this.uint16 = new Uint16Array(this.arrayBuffer);
	    };
	    StructArrayLayout4i4ui4i24.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);
	    };
	    StructArrayLayout4i4ui4i24.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) {
	        var o2 = i * 12;
	        this.int16[o2 + 0] = v0;
	        this.int16[o2 + 1] = v1;
	        this.int16[o2 + 2] = v2;
	        this.int16[o2 + 3] = v3;
	        this.uint16[o2 + 4] = v4;
	        this.uint16[o2 + 5] = v5;
	        this.uint16[o2 + 6] = v6;
	        this.uint16[o2 + 7] = v7;
	        this.int16[o2 + 8] = v8;
	        this.int16[o2 + 9] = v9;
	        this.int16[o2 + 10] = v10;
	        this.int16[o2 + 11] = v11;
	        return i;
	    };
	    return StructArrayLayout4i4ui4i24;
	}(StructArray);
	StructArrayLayout4i4ui4i24.prototype.bytesPerElement = 24;
	register('StructArrayLayout4i4ui4i24', StructArrayLayout4i4ui4i24);
	var StructArrayLayout3f12 = function (StructArray) {
	    function StructArrayLayout3f12() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout3f12.__proto__ = StructArray;
	    StructArrayLayout3f12.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout3f12.prototype.constructor = StructArrayLayout3f12;
	    StructArrayLayout3f12.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.float32 = new Float32Array(this.arrayBuffer);
	    };
	    StructArrayLayout3f12.prototype.emplaceBack = function emplaceBack(v0, v1, v2) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2);
	    };
	    StructArrayLayout3f12.prototype.emplace = function emplace(i, v0, v1, v2) {
	        var o4 = i * 3;
	        this.float32[o4 + 0] = v0;
	        this.float32[o4 + 1] = v1;
	        this.float32[o4 + 2] = v2;
	        return i;
	    };
	    return StructArrayLayout3f12;
	}(StructArray);
	StructArrayLayout3f12.prototype.bytesPerElement = 12;
	register('StructArrayLayout3f12', StructArrayLayout3f12);
	var StructArrayLayout1ul4 = function (StructArray) {
	    function StructArrayLayout1ul4() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout1ul4.__proto__ = StructArray;
	    StructArrayLayout1ul4.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout1ul4.prototype.constructor = StructArrayLayout1ul4;
	    StructArrayLayout1ul4.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.uint32 = new Uint32Array(this.arrayBuffer);
	    };
	    StructArrayLayout1ul4.prototype.emplaceBack = function emplaceBack(v0) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0);
	    };
	    StructArrayLayout1ul4.prototype.emplace = function emplace(i, v0) {
	        var o4 = i * 1;
	        this.uint32[o4 + 0] = v0;
	        return i;
	    };
	    return StructArrayLayout1ul4;
	}(StructArray);
	StructArrayLayout1ul4.prototype.bytesPerElement = 4;
	register('StructArrayLayout1ul4', StructArrayLayout1ul4);
	var StructArrayLayout6i1ul2ui20 = function (StructArray) {
	    function StructArrayLayout6i1ul2ui20() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout6i1ul2ui20.__proto__ = StructArray;
	    StructArrayLayout6i1ul2ui20.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout6i1ul2ui20.prototype.constructor = StructArrayLayout6i1ul2ui20;
	    StructArrayLayout6i1ul2ui20.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.int16 = new Int16Array(this.arrayBuffer);
	        this.uint32 = new Uint32Array(this.arrayBuffer);
	        this.uint16 = new Uint16Array(this.arrayBuffer);
	    };
	    StructArrayLayout6i1ul2ui20.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7, v8) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8);
	    };
	    StructArrayLayout6i1ul2ui20.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8) {
	        var o2 = i * 10;
	        var o4 = i * 5;
	        this.int16[o2 + 0] = v0;
	        this.int16[o2 + 1] = v1;
	        this.int16[o2 + 2] = v2;
	        this.int16[o2 + 3] = v3;
	        this.int16[o2 + 4] = v4;
	        this.int16[o2 + 5] = v5;
	        this.uint32[o4 + 3] = v6;
	        this.uint16[o2 + 8] = v7;
	        this.uint16[o2 + 9] = v8;
	        return i;
	    };
	    return StructArrayLayout6i1ul2ui20;
	}(StructArray);
	StructArrayLayout6i1ul2ui20.prototype.bytesPerElement = 20;
	register('StructArrayLayout6i1ul2ui20', StructArrayLayout6i1ul2ui20);
	var StructArrayLayout2i2i2i12 = function (StructArray) {
	    function StructArrayLayout2i2i2i12() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout2i2i2i12.__proto__ = StructArray;
	    StructArrayLayout2i2i2i12.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout2i2i2i12.prototype.constructor = StructArrayLayout2i2i2i12;
	    StructArrayLayout2i2i2i12.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.int16 = new Int16Array(this.arrayBuffer);
	    };
	    StructArrayLayout2i2i2i12.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2, v3, v4, v5);
	    };
	    StructArrayLayout2i2i2i12.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5) {
	        var o2 = i * 6;
	        this.int16[o2 + 0] = v0;
	        this.int16[o2 + 1] = v1;
	        this.int16[o2 + 2] = v2;
	        this.int16[o2 + 3] = v3;
	        this.int16[o2 + 4] = v4;
	        this.int16[o2 + 5] = v5;
	        return i;
	    };
	    return StructArrayLayout2i2i2i12;
	}(StructArray);
	StructArrayLayout2i2i2i12.prototype.bytesPerElement = 12;
	register('StructArrayLayout2i2i2i12', StructArrayLayout2i2i2i12);
	var StructArrayLayout2f1f2i16 = function (StructArray) {
	    function StructArrayLayout2f1f2i16() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout2f1f2i16.__proto__ = StructArray;
	    StructArrayLayout2f1f2i16.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout2f1f2i16.prototype.constructor = StructArrayLayout2f1f2i16;
	    StructArrayLayout2f1f2i16.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.float32 = new Float32Array(this.arrayBuffer);
	        this.int16 = new Int16Array(this.arrayBuffer);
	    };
	    StructArrayLayout2f1f2i16.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2, v3, v4);
	    };
	    StructArrayLayout2f1f2i16.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4) {
	        var o4 = i * 4;
	        var o2 = i * 8;
	        this.float32[o4 + 0] = v0;
	        this.float32[o4 + 1] = v1;
	        this.float32[o4 + 2] = v2;
	        this.int16[o2 + 6] = v3;
	        this.int16[o2 + 7] = v4;
	        return i;
	    };
	    return StructArrayLayout2f1f2i16;
	}(StructArray);
	StructArrayLayout2f1f2i16.prototype.bytesPerElement = 16;
	register('StructArrayLayout2f1f2i16', StructArrayLayout2f1f2i16);
	var StructArrayLayout2ub2f12 = function (StructArray) {
	    function StructArrayLayout2ub2f12() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout2ub2f12.__proto__ = StructArray;
	    StructArrayLayout2ub2f12.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout2ub2f12.prototype.constructor = StructArrayLayout2ub2f12;
	    StructArrayLayout2ub2f12.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.float32 = new Float32Array(this.arrayBuffer);
	    };
	    StructArrayLayout2ub2f12.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2, v3);
	    };
	    StructArrayLayout2ub2f12.prototype.emplace = function emplace(i, v0, v1, v2, v3) {
	        var o1 = i * 12;
	        var o4 = i * 3;
	        this.uint8[o1 + 0] = v0;
	        this.uint8[o1 + 1] = v1;
	        this.float32[o4 + 1] = v2;
	        this.float32[o4 + 2] = v3;
	        return i;
	    };
	    return StructArrayLayout2ub2f12;
	}(StructArray);
	StructArrayLayout2ub2f12.prototype.bytesPerElement = 12;
	register('StructArrayLayout2ub2f12', StructArrayLayout2ub2f12);
	var StructArrayLayout3ui6 = function (StructArray) {
	    function StructArrayLayout3ui6() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout3ui6.__proto__ = StructArray;
	    StructArrayLayout3ui6.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout3ui6.prototype.constructor = StructArrayLayout3ui6;
	    StructArrayLayout3ui6.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.uint16 = new Uint16Array(this.arrayBuffer);
	    };
	    StructArrayLayout3ui6.prototype.emplaceBack = function emplaceBack(v0, v1, v2) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2);
	    };
	    StructArrayLayout3ui6.prototype.emplace = function emplace(i, v0, v1, v2) {
	        var o2 = i * 3;
	        this.uint16[o2 + 0] = v0;
	        this.uint16[o2 + 1] = v1;
	        this.uint16[o2 + 2] = v2;
	        return i;
	    };
	    return StructArrayLayout3ui6;
	}(StructArray);
	StructArrayLayout3ui6.prototype.bytesPerElement = 6;
	register('StructArrayLayout3ui6', StructArrayLayout3ui6);
	var StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48 = function (StructArray) {
	    function StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48.__proto__ = StructArray;
	    StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48.prototype.constructor = StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48;
	    StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.int16 = new Int16Array(this.arrayBuffer);
	        this.uint16 = new Uint16Array(this.arrayBuffer);
	        this.uint32 = new Uint32Array(this.arrayBuffer);
	        this.float32 = new Float32Array(this.arrayBuffer);
	    };
	    StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16);
	    };
	    StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) {
	        var o2 = i * 24;
	        var o4 = i * 12;
	        var o1 = i * 48;
	        this.int16[o2 + 0] = v0;
	        this.int16[o2 + 1] = v1;
	        this.uint16[o2 + 2] = v2;
	        this.uint16[o2 + 3] = v3;
	        this.uint32[o4 + 2] = v4;
	        this.uint32[o4 + 3] = v5;
	        this.uint32[o4 + 4] = v6;
	        this.uint16[o2 + 10] = v7;
	        this.uint16[o2 + 11] = v8;
	        this.uint16[o2 + 12] = v9;
	        this.float32[o4 + 7] = v10;
	        this.float32[o4 + 8] = v11;
	        this.uint8[o1 + 36] = v12;
	        this.uint8[o1 + 37] = v13;
	        this.uint8[o1 + 38] = v14;
	        this.uint32[o4 + 10] = v15;
	        this.int16[o2 + 22] = v16;
	        return i;
	    };
	    return StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48;
	}(StructArray);
	StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48.prototype.bytesPerElement = 48;
	register('StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48', StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48);
	var StructArrayLayout8i15ui1ul4f68 = function (StructArray) {
	    function StructArrayLayout8i15ui1ul4f68() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout8i15ui1ul4f68.__proto__ = StructArray;
	    StructArrayLayout8i15ui1ul4f68.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout8i15ui1ul4f68.prototype.constructor = StructArrayLayout8i15ui1ul4f68;
	    StructArrayLayout8i15ui1ul4f68.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.int16 = new Int16Array(this.arrayBuffer);
	        this.uint16 = new Uint16Array(this.arrayBuffer);
	        this.uint32 = new Uint32Array(this.arrayBuffer);
	        this.float32 = new Float32Array(this.arrayBuffer);
	    };
	    StructArrayLayout8i15ui1ul4f68.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27);
	    };
	    StructArrayLayout8i15ui1ul4f68.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) {
	        var o2 = i * 34;
	        var o4 = i * 17;
	        this.int16[o2 + 0] = v0;
	        this.int16[o2 + 1] = v1;
	        this.int16[o2 + 2] = v2;
	        this.int16[o2 + 3] = v3;
	        this.int16[o2 + 4] = v4;
	        this.int16[o2 + 5] = v5;
	        this.int16[o2 + 6] = v6;
	        this.int16[o2 + 7] = v7;
	        this.uint16[o2 + 8] = v8;
	        this.uint16[o2 + 9] = v9;
	        this.uint16[o2 + 10] = v10;
	        this.uint16[o2 + 11] = v11;
	        this.uint16[o2 + 12] = v12;
	        this.uint16[o2 + 13] = v13;
	        this.uint16[o2 + 14] = v14;
	        this.uint16[o2 + 15] = v15;
	        this.uint16[o2 + 16] = v16;
	        this.uint16[o2 + 17] = v17;
	        this.uint16[o2 + 18] = v18;
	        this.uint16[o2 + 19] = v19;
	        this.uint16[o2 + 20] = v20;
	        this.uint16[o2 + 21] = v21;
	        this.uint16[o2 + 22] = v22;
	        this.uint32[o4 + 12] = v23;
	        this.float32[o4 + 13] = v24;
	        this.float32[o4 + 14] = v25;
	        this.float32[o4 + 15] = v26;
	        this.float32[o4 + 16] = v27;
	        return i;
	    };
	    return StructArrayLayout8i15ui1ul4f68;
	}(StructArray);
	StructArrayLayout8i15ui1ul4f68.prototype.bytesPerElement = 68;
	register('StructArrayLayout8i15ui1ul4f68', StructArrayLayout8i15ui1ul4f68);
	var StructArrayLayout1f4 = function (StructArray) {
	    function StructArrayLayout1f4() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout1f4.__proto__ = StructArray;
	    StructArrayLayout1f4.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout1f4.prototype.constructor = StructArrayLayout1f4;
	    StructArrayLayout1f4.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.float32 = new Float32Array(this.arrayBuffer);
	    };
	    StructArrayLayout1f4.prototype.emplaceBack = function emplaceBack(v0) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0);
	    };
	    StructArrayLayout1f4.prototype.emplace = function emplace(i, v0) {
	        var o4 = i * 1;
	        this.float32[o4 + 0] = v0;
	        return i;
	    };
	    return StructArrayLayout1f4;
	}(StructArray);
	StructArrayLayout1f4.prototype.bytesPerElement = 4;
	register('StructArrayLayout1f4', StructArrayLayout1f4);
	var StructArrayLayout3i6 = function (StructArray) {
	    function StructArrayLayout3i6() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout3i6.__proto__ = StructArray;
	    StructArrayLayout3i6.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout3i6.prototype.constructor = StructArrayLayout3i6;
	    StructArrayLayout3i6.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.int16 = new Int16Array(this.arrayBuffer);
	    };
	    StructArrayLayout3i6.prototype.emplaceBack = function emplaceBack(v0, v1, v2) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2);
	    };
	    StructArrayLayout3i6.prototype.emplace = function emplace(i, v0, v1, v2) {
	        var o2 = i * 3;
	        this.int16[o2 + 0] = v0;
	        this.int16[o2 + 1] = v1;
	        this.int16[o2 + 2] = v2;
	        return i;
	    };
	    return StructArrayLayout3i6;
	}(StructArray);
	StructArrayLayout3i6.prototype.bytesPerElement = 6;
	register('StructArrayLayout3i6', StructArrayLayout3i6);
	var StructArrayLayout1ul2ui8 = function (StructArray) {
	    function StructArrayLayout1ul2ui8() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout1ul2ui8.__proto__ = StructArray;
	    StructArrayLayout1ul2ui8.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout1ul2ui8.prototype.constructor = StructArrayLayout1ul2ui8;
	    StructArrayLayout1ul2ui8.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.uint32 = new Uint32Array(this.arrayBuffer);
	        this.uint16 = new Uint16Array(this.arrayBuffer);
	    };
	    StructArrayLayout1ul2ui8.prototype.emplaceBack = function emplaceBack(v0, v1, v2) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2);
	    };
	    StructArrayLayout1ul2ui8.prototype.emplace = function emplace(i, v0, v1, v2) {
	        var o4 = i * 2;
	        var o2 = i * 4;
	        this.uint32[o4 + 0] = v0;
	        this.uint16[o2 + 2] = v1;
	        this.uint16[o2 + 3] = v2;
	        return i;
	    };
	    return StructArrayLayout1ul2ui8;
	}(StructArray);
	StructArrayLayout1ul2ui8.prototype.bytesPerElement = 8;
	register('StructArrayLayout1ul2ui8', StructArrayLayout1ul2ui8);
	var StructArrayLayout2ui4 = function (StructArray) {
	    function StructArrayLayout2ui4() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout2ui4.__proto__ = StructArray;
	    StructArrayLayout2ui4.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout2ui4.prototype.constructor = StructArrayLayout2ui4;
	    StructArrayLayout2ui4.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.uint16 = new Uint16Array(this.arrayBuffer);
	    };
	    StructArrayLayout2ui4.prototype.emplaceBack = function emplaceBack(v0, v1) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1);
	    };
	    StructArrayLayout2ui4.prototype.emplace = function emplace(i, v0, v1) {
	        var o2 = i * 2;
	        this.uint16[o2 + 0] = v0;
	        this.uint16[o2 + 1] = v1;
	        return i;
	    };
	    return StructArrayLayout2ui4;
	}(StructArray);
	StructArrayLayout2ui4.prototype.bytesPerElement = 4;
	register('StructArrayLayout2ui4', StructArrayLayout2ui4);
	var StructArrayLayout1ui2 = function (StructArray) {
	    function StructArrayLayout1ui2() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout1ui2.__proto__ = StructArray;
	    StructArrayLayout1ui2.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout1ui2.prototype.constructor = StructArrayLayout1ui2;
	    StructArrayLayout1ui2.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.uint16 = new Uint16Array(this.arrayBuffer);
	    };
	    StructArrayLayout1ui2.prototype.emplaceBack = function emplaceBack(v0) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0);
	    };
	    StructArrayLayout1ui2.prototype.emplace = function emplace(i, v0) {
	        var o2 = i * 1;
	        this.uint16[o2 + 0] = v0;
	        return i;
	    };
	    return StructArrayLayout1ui2;
	}(StructArray);
	StructArrayLayout1ui2.prototype.bytesPerElement = 2;
	register('StructArrayLayout1ui2', StructArrayLayout1ui2);
	var StructArrayLayout4f16 = function (StructArray) {
	    function StructArrayLayout4f16() {
	        StructArray.apply(this, arguments);
	    }
	    if (StructArray)
	        StructArrayLayout4f16.__proto__ = StructArray;
	    StructArrayLayout4f16.prototype = Object.create(StructArray && StructArray.prototype);
	    StructArrayLayout4f16.prototype.constructor = StructArrayLayout4f16;
	    StructArrayLayout4f16.prototype._refreshViews = function _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer);
	        this.float32 = new Float32Array(this.arrayBuffer);
	    };
	    StructArrayLayout4f16.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3) {
	        var i = this.length;
	        this.resize(i + 1);
	        return this.emplace(i, v0, v1, v2, v3);
	    };
	    StructArrayLayout4f16.prototype.emplace = function emplace(i, v0, v1, v2, v3) {
	        var o4 = i * 4;
	        this.float32[o4 + 0] = v0;
	        this.float32[o4 + 1] = v1;
	        this.float32[o4 + 2] = v2;
	        this.float32[o4 + 3] = v3;
	        return i;
	    };
	    return StructArrayLayout4f16;
	}(StructArray);
	StructArrayLayout4f16.prototype.bytesPerElement = 16;
	register('StructArrayLayout4f16', StructArrayLayout4f16);
	var CollisionBoxStruct = function (Struct) {
	    function CollisionBoxStruct() {
	        Struct.apply(this, arguments);
	    }
	    if (Struct)
	        CollisionBoxStruct.__proto__ = Struct;
	    CollisionBoxStruct.prototype = Object.create(Struct && Struct.prototype);
	    CollisionBoxStruct.prototype.constructor = CollisionBoxStruct;
	    var prototypeAccessors = {
	        anchorPointX: { configurable: true },
	        anchorPointY: { configurable: true },
	        x1: { configurable: true },
	        y1: { configurable: true },
	        x2: { configurable: true },
	        y2: { configurable: true },
	        featureIndex: { configurable: true },
	        sourceLayerIndex: { configurable: true },
	        bucketIndex: { configurable: true },
	        anchorPoint: { configurable: true }
	    };
	    prototypeAccessors.anchorPointX.get = function () {
	        return this._structArray.int16[this._pos2 + 0];
	    };
	    prototypeAccessors.anchorPointY.get = function () {
	        return this._structArray.int16[this._pos2 + 1];
	    };
	    prototypeAccessors.x1.get = function () {
	        return this._structArray.int16[this._pos2 + 2];
	    };
	    prototypeAccessors.y1.get = function () {
	        return this._structArray.int16[this._pos2 + 3];
	    };
	    prototypeAccessors.x2.get = function () {
	        return this._structArray.int16[this._pos2 + 4];
	    };
	    prototypeAccessors.y2.get = function () {
	        return this._structArray.int16[this._pos2 + 5];
	    };
	    prototypeAccessors.featureIndex.get = function () {
	        return this._structArray.uint32[this._pos4 + 3];
	    };
	    prototypeAccessors.sourceLayerIndex.get = function () {
	        return this._structArray.uint16[this._pos2 + 8];
	    };
	    prototypeAccessors.bucketIndex.get = function () {
	        return this._structArray.uint16[this._pos2 + 9];
	    };
	    prototypeAccessors.anchorPoint.get = function () {
	        return new pointGeometry(this.anchorPointX, this.anchorPointY);
	    };
	    Object.defineProperties(CollisionBoxStruct.prototype, prototypeAccessors);
	    return CollisionBoxStruct;
	}(Struct);
	CollisionBoxStruct.prototype.size = 20;
	var CollisionBoxArray = function (StructArrayLayout6i1ul2ui20) {
	    function CollisionBoxArray() {
	        StructArrayLayout6i1ul2ui20.apply(this, arguments);
	    }
	    if (StructArrayLayout6i1ul2ui20)
	        CollisionBoxArray.__proto__ = StructArrayLayout6i1ul2ui20;
	    CollisionBoxArray.prototype = Object.create(StructArrayLayout6i1ul2ui20 && StructArrayLayout6i1ul2ui20.prototype);
	    CollisionBoxArray.prototype.constructor = CollisionBoxArray;
	    CollisionBoxArray.prototype.get = function get(index) {
	        return new CollisionBoxStruct(this, index);
	    };
	    return CollisionBoxArray;
	}(StructArrayLayout6i1ul2ui20);
	register('CollisionBoxArray', CollisionBoxArray);
	var PlacedSymbolStruct = function (Struct) {
	    function PlacedSymbolStruct() {
	        Struct.apply(this, arguments);
	    }
	    if (Struct)
	        PlacedSymbolStruct.__proto__ = Struct;
	    PlacedSymbolStruct.prototype = Object.create(Struct && Struct.prototype);
	    PlacedSymbolStruct.prototype.constructor = PlacedSymbolStruct;
	    var prototypeAccessors$1 = {
	        anchorX: { configurable: true },
	        anchorY: { configurable: true },
	        glyphStartIndex: { configurable: true },
	        numGlyphs: { configurable: true },
	        vertexStartIndex: { configurable: true },
	        lineStartIndex: { configurable: true },
	        lineLength: { configurable: true },
	        segment: { configurable: true },
	        lowerSize: { configurable: true },
	        upperSize: { configurable: true },
	        lineOffsetX: { configurable: true },
	        lineOffsetY: { configurable: true },
	        writingMode: { configurable: true },
	        placedOrientation: { configurable: true },
	        hidden: { configurable: true },
	        crossTileID: { configurable: true },
	        associatedIconIndex: { configurable: true }
	    };
	    prototypeAccessors$1.anchorX.get = function () {
	        return this._structArray.int16[this._pos2 + 0];
	    };
	    prototypeAccessors$1.anchorY.get = function () {
	        return this._structArray.int16[this._pos2 + 1];
	    };
	    prototypeAccessors$1.glyphStartIndex.get = function () {
	        return this._structArray.uint16[this._pos2 + 2];
	    };
	    prototypeAccessors$1.numGlyphs.get = function () {
	        return this._structArray.uint16[this._pos2 + 3];
	    };
	    prototypeAccessors$1.vertexStartIndex.get = function () {
	        return this._structArray.uint32[this._pos4 + 2];
	    };
	    prototypeAccessors$1.lineStartIndex.get = function () {
	        return this._structArray.uint32[this._pos4 + 3];
	    };
	    prototypeAccessors$1.lineLength.get = function () {
	        return this._structArray.uint32[this._pos4 + 4];
	    };
	    prototypeAccessors$1.segment.get = function () {
	        return this._structArray.uint16[this._pos2 + 10];
	    };
	    prototypeAccessors$1.lowerSize.get = function () {
	        return this._structArray.uint16[this._pos2 + 11];
	    };
	    prototypeAccessors$1.upperSize.get = function () {
	        return this._structArray.uint16[this._pos2 + 12];
	    };
	    prototypeAccessors$1.lineOffsetX.get = function () {
	        return this._structArray.float32[this._pos4 + 7];
	    };
	    prototypeAccessors$1.lineOffsetY.get = function () {
	        return this._structArray.float32[this._pos4 + 8];
	    };
	    prototypeAccessors$1.writingMode.get = function () {
	        return this._structArray.uint8[this._pos1 + 36];
	    };
	    prototypeAccessors$1.placedOrientation.get = function () {
	        return this._structArray.uint8[this._pos1 + 37];
	    };
	    prototypeAccessors$1.placedOrientation.set = function (x) {
	        this._structArray.uint8[this._pos1 + 37] = x;
	    };
	    prototypeAccessors$1.hidden.get = function () {
	        return this._structArray.uint8[this._pos1 + 38];
	    };
	    prototypeAccessors$1.hidden.set = function (x) {
	        this._structArray.uint8[this._pos1 + 38] = x;
	    };
	    prototypeAccessors$1.crossTileID.get = function () {
	        return this._structArray.uint32[this._pos4 + 10];
	    };
	    prototypeAccessors$1.crossTileID.set = function (x) {
	        this._structArray.uint32[this._pos4 + 10] = x;
	    };
	    prototypeAccessors$1.associatedIconIndex.get = function () {
	        return this._structArray.int16[this._pos2 + 22];
	    };
	    Object.defineProperties(PlacedSymbolStruct.prototype, prototypeAccessors$1);
	    return PlacedSymbolStruct;
	}(Struct);
	PlacedSymbolStruct.prototype.size = 48;
	var PlacedSymbolArray = function (StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48) {
	    function PlacedSymbolArray() {
	        StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48.apply(this, arguments);
	    }
	    if (StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48)
	        PlacedSymbolArray.__proto__ = StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48;
	    PlacedSymbolArray.prototype = Object.create(StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48 && StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48.prototype);
	    PlacedSymbolArray.prototype.constructor = PlacedSymbolArray;
	    PlacedSymbolArray.prototype.get = function get(index) {
	        return new PlacedSymbolStruct(this, index);
	    };
	    return PlacedSymbolArray;
	}(StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48);
	register('PlacedSymbolArray', PlacedSymbolArray);
	var SymbolInstanceStruct = function (Struct) {
	    function SymbolInstanceStruct() {
	        Struct.apply(this, arguments);
	    }
	    if (Struct)
	        SymbolInstanceStruct.__proto__ = Struct;
	    SymbolInstanceStruct.prototype = Object.create(Struct && Struct.prototype);
	    SymbolInstanceStruct.prototype.constructor = SymbolInstanceStruct;
	    var prototypeAccessors$2 = {
	        anchorX: { configurable: true },
	        anchorY: { configurable: true },
	        rightJustifiedTextSymbolIndex: { configurable: true },
	        centerJustifiedTextSymbolIndex: { configurable: true },
	        leftJustifiedTextSymbolIndex: { configurable: true },
	        verticalPlacedTextSymbolIndex: { configurable: true },
	        placedIconSymbolIndex: { configurable: true },
	        verticalPlacedIconSymbolIndex: { configurable: true },
	        key: { configurable: true },
	        textBoxStartIndex: { configurable: true },
	        textBoxEndIndex: { configurable: true },
	        verticalTextBoxStartIndex: { configurable: true },
	        verticalTextBoxEndIndex: { configurable: true },
	        iconBoxStartIndex: { configurable: true },
	        iconBoxEndIndex: { configurable: true },
	        verticalIconBoxStartIndex: { configurable: true },
	        verticalIconBoxEndIndex: { configurable: true },
	        featureIndex: { configurable: true },
	        numHorizontalGlyphVertices: { configurable: true },
	        numVerticalGlyphVertices: { configurable: true },
	        numIconVertices: { configurable: true },
	        numVerticalIconVertices: { configurable: true },
	        useRuntimeCollisionCircles: { configurable: true },
	        crossTileID: { configurable: true },
	        textBoxScale: { configurable: true },
	        textOffset0: { configurable: true },
	        textOffset1: { configurable: true },
	        collisionCircleDiameter: { configurable: true }
	    };
	    prototypeAccessors$2.anchorX.get = function () {
	        return this._structArray.int16[this._pos2 + 0];
	    };
	    prototypeAccessors$2.anchorY.get = function () {
	        return this._structArray.int16[this._pos2 + 1];
	    };
	    prototypeAccessors$2.rightJustifiedTextSymbolIndex.get = function () {
	        return this._structArray.int16[this._pos2 + 2];
	    };
	    prototypeAccessors$2.centerJustifiedTextSymbolIndex.get = function () {
	        return this._structArray.int16[this._pos2 + 3];
	    };
	    prototypeAccessors$2.leftJustifiedTextSymbolIndex.get = function () {
	        return this._structArray.int16[this._pos2 + 4];
	    };
	    prototypeAccessors$2.verticalPlacedTextSymbolIndex.get = function () {
	        return this._structArray.int16[this._pos2 + 5];
	    };
	    prototypeAccessors$2.placedIconSymbolIndex.get = function () {
	        return this._structArray.int16[this._pos2 + 6];
	    };
	    prototypeAccessors$2.verticalPlacedIconSymbolIndex.get = function () {
	        return this._structArray.int16[this._pos2 + 7];
	    };
	    prototypeAccessors$2.key.get = function () {
	        return this._structArray.uint16[this._pos2 + 8];
	    };
	    prototypeAccessors$2.textBoxStartIndex.get = function () {
	        return this._structArray.uint16[this._pos2 + 9];
	    };
	    prototypeAccessors$2.textBoxEndIndex.get = function () {
	        return this._structArray.uint16[this._pos2 + 10];
	    };
	    prototypeAccessors$2.verticalTextBoxStartIndex.get = function () {
	        return this._structArray.uint16[this._pos2 + 11];
	    };
	    prototypeAccessors$2.verticalTextBoxEndIndex.get = function () {
	        return this._structArray.uint16[this._pos2 + 12];
	    };
	    prototypeAccessors$2.iconBoxStartIndex.get = function () {
	        return this._structArray.uint16[this._pos2 + 13];
	    };
	    prototypeAccessors$2.iconBoxEndIndex.get = function () {
	        return this._structArray.uint16[this._pos2 + 14];
	    };
	    prototypeAccessors$2.verticalIconBoxStartIndex.get = function () {
	        return this._structArray.uint16[this._pos2 + 15];
	    };
	    prototypeAccessors$2.verticalIconBoxEndIndex.get = function () {
	        return this._structArray.uint16[this._pos2 + 16];
	    };
	    prototypeAccessors$2.featureIndex.get = function () {
	        return this._structArray.uint16[this._pos2 + 17];
	    };
	    prototypeAccessors$2.numHorizontalGlyphVertices.get = function () {
	        return this._structArray.uint16[this._pos2 + 18];
	    };
	    prototypeAccessors$2.numVerticalGlyphVertices.get = function () {
	        return this._structArray.uint16[this._pos2 + 19];
	    };
	    prototypeAccessors$2.numIconVertices.get = function () {
	        return this._structArray.uint16[this._pos2 + 20];
	    };
	    prototypeAccessors$2.numVerticalIconVertices.get = function () {
	        return this._structArray.uint16[this._pos2 + 21];
	    };
	    prototypeAccessors$2.useRuntimeCollisionCircles.get = function () {
	        return this._structArray.uint16[this._pos2 + 22];
	    };
	    prototypeAccessors$2.crossTileID.get = function () {
	        return this._structArray.uint32[this._pos4 + 12];
	    };
	    prototypeAccessors$2.crossTileID.set = function (x) {
	        this._structArray.uint32[this._pos4 + 12] = x;
	    };
	    prototypeAccessors$2.textBoxScale.get = function () {
	        return this._structArray.float32[this._pos4 + 13];
	    };
	    prototypeAccessors$2.textOffset0.get = function () {
	        return this._structArray.float32[this._pos4 + 14];
	    };
	    prototypeAccessors$2.textOffset1.get = function () {
	        return this._structArray.float32[this._pos4 + 15];
	    };
	    prototypeAccessors$2.collisionCircleDiameter.get = function () {
	        return this._structArray.float32[this._pos4 + 16];
	    };
	    Object.defineProperties(SymbolInstanceStruct.prototype, prototypeAccessors$2);
	    return SymbolInstanceStruct;
	}(Struct);
	SymbolInstanceStruct.prototype.size = 68;
	var SymbolInstanceArray = function (StructArrayLayout8i15ui1ul4f68) {
	    function SymbolInstanceArray() {
	        StructArrayLayout8i15ui1ul4f68.apply(this, arguments);
	    }
	    if (StructArrayLayout8i15ui1ul4f68)
	        SymbolInstanceArray.__proto__ = StructArrayLayout8i15ui1ul4f68;
	    SymbolInstanceArray.prototype = Object.create(StructArrayLayout8i15ui1ul4f68 && StructArrayLayout8i15ui1ul4f68.prototype);
	    SymbolInstanceArray.prototype.constructor = SymbolInstanceArray;
	    SymbolInstanceArray.prototype.get = function get(index) {
	        return new SymbolInstanceStruct(this, index);
	    };
	    return SymbolInstanceArray;
	}(StructArrayLayout8i15ui1ul4f68);
	register('SymbolInstanceArray', SymbolInstanceArray);
	var GlyphOffsetArray = function (StructArrayLayout1f4) {
	    function GlyphOffsetArray() {
	        StructArrayLayout1f4.apply(this, arguments);
	    }
	    if (StructArrayLayout1f4)
	        GlyphOffsetArray.__proto__ = StructArrayLayout1f4;
	    GlyphOffsetArray.prototype = Object.create(StructArrayLayout1f4 && StructArrayLayout1f4.prototype);
	    GlyphOffsetArray.prototype.constructor = GlyphOffsetArray;
	    GlyphOffsetArray.prototype.getoffsetX = function getoffsetX(index) {
	        return this.float32[index * 1 + 0];
	    };
	    return GlyphOffsetArray;
	}(StructArrayLayout1f4);
	register('GlyphOffsetArray', GlyphOffsetArray);
	var SymbolLineVertexArray = function (StructArrayLayout3i6) {
	    function SymbolLineVertexArray() {
	        StructArrayLayout3i6.apply(this, arguments);
	    }
	    if (StructArrayLayout3i6)
	        SymbolLineVertexArray.__proto__ = StructArrayLayout3i6;
	    SymbolLineVertexArray.prototype = Object.create(StructArrayLayout3i6 && StructArrayLayout3i6.prototype);
	    SymbolLineVertexArray.prototype.constructor = SymbolLineVertexArray;
	    SymbolLineVertexArray.prototype.getx = function getx(index) {
	        return this.int16[index * 3 + 0];
	    };
	    SymbolLineVertexArray.prototype.gety = function gety(index) {
	        return this.int16[index * 3 + 1];
	    };
	    SymbolLineVertexArray.prototype.gettileUnitDistanceFromAnchor = function gettileUnitDistanceFromAnchor(index) {
	        return this.int16[index * 3 + 2];
	    };
	    return SymbolLineVertexArray;
	}(StructArrayLayout3i6);
	register('SymbolLineVertexArray', SymbolLineVertexArray);
	var FeatureIndexStruct = function (Struct) {
	    function FeatureIndexStruct() {
	        Struct.apply(this, arguments);
	    }
	    if (Struct)
	        FeatureIndexStruct.__proto__ = Struct;
	    FeatureIndexStruct.prototype = Object.create(Struct && Struct.prototype);
	    FeatureIndexStruct.prototype.constructor = FeatureIndexStruct;
	    var prototypeAccessors$3 = {
	        featureIndex: { configurable: true },
	        sourceLayerIndex: { configurable: true },
	        bucketIndex: { configurable: true }
	    };
	    prototypeAccessors$3.featureIndex.get = function () {
	        return this._structArray.uint32[this._pos4 + 0];
	    };
	    prototypeAccessors$3.sourceLayerIndex.get = function () {
	        return this._structArray.uint16[this._pos2 + 2];
	    };
	    prototypeAccessors$3.bucketIndex.get = function () {
	        return this._structArray.uint16[this._pos2 + 3];
	    };
	    Object.defineProperties(FeatureIndexStruct.prototype, prototypeAccessors$3);
	    return FeatureIndexStruct;
	}(Struct);
	FeatureIndexStruct.prototype.size = 8;
	var FeatureIndexArray = function (StructArrayLayout1ul2ui8) {
	    function FeatureIndexArray() {
	        StructArrayLayout1ul2ui8.apply(this, arguments);
	    }
	    if (StructArrayLayout1ul2ui8)
	        FeatureIndexArray.__proto__ = StructArrayLayout1ul2ui8;
	    FeatureIndexArray.prototype = Object.create(StructArrayLayout1ul2ui8 && StructArrayLayout1ul2ui8.prototype);
	    FeatureIndexArray.prototype.constructor = FeatureIndexArray;
	    FeatureIndexArray.prototype.get = function get(index) {
	        return new FeatureIndexStruct(this, index);
	    };
	    return FeatureIndexArray;
	}(StructArrayLayout1ul2ui8);
	register('FeatureIndexArray', FeatureIndexArray);

	var layout$1 = createLayout([{
	        name: 'a_pos',
	        components: 2,
	        type: 'Int16'
	    }], 4);
	var members = layout$1.members;

	var SegmentVector = function SegmentVector(segments) {
	    if (segments === void 0)
	        segments = [];
	    this.segments = segments;
	};
	SegmentVector.prototype.prepareSegment = function prepareSegment(numVertices, layoutVertexArray, indexArray, sortKey) {
	    var segment = this.segments[this.segments.length - 1];
	    if (numVertices > SegmentVector.MAX_VERTEX_ARRAY_LENGTH) {
	        warnOnce('Max vertices per segment is ' + SegmentVector.MAX_VERTEX_ARRAY_LENGTH + ': bucket requested ' + numVertices);
	    }
	    if (!segment || segment.vertexLength + numVertices > SegmentVector.MAX_VERTEX_ARRAY_LENGTH || segment.sortKey !== sortKey) {
	        segment = {
	            vertexOffset: layoutVertexArray.length,
	            primitiveOffset: indexArray.length,
	            vertexLength: 0,
	            primitiveLength: 0
	        };
	        if (sortKey !== undefined) {
	            segment.sortKey = sortKey;
	        }
	        this.segments.push(segment);
	    }
	    return segment;
	};
	SegmentVector.prototype.get = function get() {
	    return this.segments;
	};
	SegmentVector.prototype.destroy = function destroy() {
	    for (var i = 0, list = this.segments; i < list.length; i += 1) {
	        var segment = list[i];
	        for (var k in segment.vaos) {
	            segment.vaos[k].destroy();
	        }
	    }
	};
	SegmentVector.simpleSegment = function simpleSegment(vertexOffset, primitiveOffset, vertexLength, primitiveLength) {
	    return new SegmentVector([{
	            vertexOffset: vertexOffset,
	            primitiveOffset: primitiveOffset,
	            vertexLength: vertexLength,
	            primitiveLength: primitiveLength,
	            vaos: {},
	            sortKey: 0
	        }]);
	};
	SegmentVector.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1;
	register('SegmentVector', SegmentVector);

	function packUint8ToFloat(a, b) {
	    a = clamp(Math.floor(a), 0, 255);
	    b = clamp(Math.floor(b), 0, 255);
	    return 256 * a + b;
	}

	var patternAttributes = createLayout([
	    {
	        name: 'a_pattern_from',
	        components: 4,
	        type: 'Uint16'
	    },
	    {
	        name: 'a_pattern_to',
	        components: 4,
	        type: 'Uint16'
	    },
	    {
	        name: 'a_pixel_ratio_from',
	        components: 1,
	        type: 'Uint16'
	    },
	    {
	        name: 'a_pixel_ratio_to',
	        components: 1,
	        type: 'Uint16'
	    }
	]);

	var murmurhash3_gc = createCommonjsModule(function (module) {
	function murmurhash3_32_gc(key, seed) {
	    var remainder, bytes, h1, h1b, c1, c2, k1, i;
	    remainder = key.length & 3;
	    bytes = key.length - remainder;
	    h1 = seed;
	    c1 = 3432918353;
	    c2 = 461845907;
	    i = 0;
	    while (i < bytes) {
	        k1 = key.charCodeAt(i) & 255 | (key.charCodeAt(++i) & 255) << 8 | (key.charCodeAt(++i) & 255) << 16 | (key.charCodeAt(++i) & 255) << 24;
	        ++i;
	        k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
	        k1 = k1 << 15 | k1 >>> 17;
	        k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
	        h1 ^= k1;
	        h1 = h1 << 13 | h1 >>> 19;
	        h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;
	        h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);
	    }
	    k1 = 0;
	    switch (remainder) {
	    case 3:
	        k1 ^= (key.charCodeAt(i + 2) & 255) << 16;
	    case 2:
	        k1 ^= (key.charCodeAt(i + 1) & 255) << 8;
	    case 1:
	        k1 ^= key.charCodeAt(i) & 255;
	        k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
	        k1 = k1 << 15 | k1 >>> 17;
	        k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
	        h1 ^= k1;
	    }
	    h1 ^= key.length;
	    h1 ^= h1 >>> 16;
	    h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;
	    h1 ^= h1 >>> 13;
	    h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;
	    h1 ^= h1 >>> 16;
	    return h1 >>> 0;
	}
	{
	    module.exports = murmurhash3_32_gc;
	}
	});

	var murmurhash2_gc = createCommonjsModule(function (module) {
	function murmurhash2_32_gc(str, seed) {
	    var l = str.length, h = seed ^ l, i = 0, k;
	    while (l >= 4) {
	        k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
	        k = (k & 65535) * 1540483477 + (((k >>> 16) * 1540483477 & 65535) << 16);
	        k ^= k >>> 24;
	        k = (k & 65535) * 1540483477 + (((k >>> 16) * 1540483477 & 65535) << 16);
	        h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16) ^ k;
	        l -= 4;
	        ++i;
	    }
	    switch (l) {
	    case 3:
	        h ^= (str.charCodeAt(i + 2) & 255) << 16;
	    case 2:
	        h ^= (str.charCodeAt(i + 1) & 255) << 8;
	    case 1:
	        h ^= str.charCodeAt(i) & 255;
	        h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16);
	    }
	    h ^= h >>> 13;
	    h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16);
	    h ^= h >>> 15;
	    return h >>> 0;
	}
	{
	    module.exports = murmurhash2_32_gc;
	}
	});

	var murmurhashJs = murmurhash3_gc;
	var murmur3_1 = murmurhash3_gc;
	var murmur2_1 = murmurhash2_gc;
	murmurhashJs.murmur3 = murmur3_1;
	murmurhashJs.murmur2 = murmur2_1;

	var FeaturePositionMap = function FeaturePositionMap() {
	    this.ids = [];
	    this.positions = [];
	    this.indexed = false;
	};
	FeaturePositionMap.prototype.add = function add(id, index, start, end) {
	    this.ids.push(getNumericId(id));
	    this.positions.push(index, start, end);
	};
	FeaturePositionMap.prototype.getPositions = function getPositions(id) {
	    var intId = getNumericId(id);
	    var i = 0;
	    var j = this.ids.length - 1;
	    while (i < j) {
	        var m = i + j >> 1;
	        if (this.ids[m] >= intId) {
	            j = m;
	        } else {
	            i = m + 1;
	        }
	    }
	    var positions = [];
	    while (this.ids[i] === intId) {
	        var index = this.positions[3 * i];
	        var start = this.positions[3 * i + 1];
	        var end = this.positions[3 * i + 2];
	        positions.push({
	            index: index,
	            start: start,
	            end: end
	        });
	        i++;
	    }
	    return positions;
	};
	FeaturePositionMap.serialize = function serialize(map, transferables) {
	    var ids = new Float64Array(map.ids);
	    var positions = new Uint32Array(map.positions);
	    sort(ids, positions, 0, ids.length - 1);
	    if (transferables) {
	        transferables.push(ids.buffer, positions.buffer);
	    }
	    return {
	        ids: ids,
	        positions: positions
	    };
	};
	FeaturePositionMap.deserialize = function deserialize(obj) {
	    var map = new FeaturePositionMap();
	    map.ids = obj.ids;
	    map.positions = obj.positions;
	    map.indexed = true;
	    return map;
	};
	var MAX_SAFE_INTEGER$1 = Math.pow(2, 53) - 1;
	function getNumericId(value) {
	    var numValue = +value;
	    if (!isNaN(numValue) && numValue <= MAX_SAFE_INTEGER$1) {
	        return numValue;
	    }
	    return murmurhashJs(String(value));
	}
	function sort(ids, positions, left, right) {
	    while (left < right) {
	        var pivot = ids[left + right >> 1];
	        var i = left - 1;
	        var j = right + 1;
	        while (true) {
	            do {
	                i++;
	            } while (ids[i] < pivot);
	            do {
	                j--;
	            } while (ids[j] > pivot);
	            if (i >= j) {
	                break;
	            }
	            swap(ids, i, j);
	            swap(positions, 3 * i, 3 * j);
	            swap(positions, 3 * i + 1, 3 * j + 1);
	            swap(positions, 3 * i + 2, 3 * j + 2);
	        }
	        if (j - left < right - j) {
	            sort(ids, positions, left, j);
	            left = j + 1;
	        } else {
	            sort(ids, positions, j + 1, right);
	            right = j;
	        }
	    }
	}
	function swap(arr, i, j) {
	    var tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}
	register('FeaturePositionMap', FeaturePositionMap);

	var Uniform = function Uniform(context, location) {
	    this.gl = context.gl;
	    this.location = location;
	};
	var Uniform1i = function (Uniform) {
	    function Uniform1i(context, location) {
	        Uniform.call(this, context, location);
	        this.current = 0;
	    }
	    if (Uniform)
	        Uniform1i.__proto__ = Uniform;
	    Uniform1i.prototype = Object.create(Uniform && Uniform.prototype);
	    Uniform1i.prototype.constructor = Uniform1i;
	    Uniform1i.prototype.set = function set(v) {
	        if (this.current !== v) {
	            this.current = v;
	            this.gl.uniform1i(this.location, v);
	        }
	    };
	    return Uniform1i;
	}(Uniform);
	var Uniform1f = function (Uniform) {
	    function Uniform1f(context, location) {
	        Uniform.call(this, context, location);
	        this.current = 0;
	    }
	    if (Uniform)
	        Uniform1f.__proto__ = Uniform;
	    Uniform1f.prototype = Object.create(Uniform && Uniform.prototype);
	    Uniform1f.prototype.constructor = Uniform1f;
	    Uniform1f.prototype.set = function set(v) {
	        if (this.current !== v) {
	            this.current = v;
	            this.gl.uniform1f(this.location, v);
	        }
	    };
	    return Uniform1f;
	}(Uniform);
	var Uniform2f = function (Uniform) {
	    function Uniform2f(context, location) {
	        Uniform.call(this, context, location);
	        this.current = [
	            0,
	            0
	        ];
	    }
	    if (Uniform)
	        Uniform2f.__proto__ = Uniform;
	    Uniform2f.prototype = Object.create(Uniform && Uniform.prototype);
	    Uniform2f.prototype.constructor = Uniform2f;
	    Uniform2f.prototype.set = function set(v) {
	        if (v[0] !== this.current[0] || v[1] !== this.current[1]) {
	            this.current = v;
	            this.gl.uniform2f(this.location, v[0], v[1]);
	        }
	    };
	    return Uniform2f;
	}(Uniform);
	var Uniform3f = function (Uniform) {
	    function Uniform3f(context, location) {
	        Uniform.call(this, context, location);
	        this.current = [
	            0,
	            0,
	            0
	        ];
	    }
	    if (Uniform)
	        Uniform3f.__proto__ = Uniform;
	    Uniform3f.prototype = Object.create(Uniform && Uniform.prototype);
	    Uniform3f.prototype.constructor = Uniform3f;
	    Uniform3f.prototype.set = function set(v) {
	        if (v[0] !== this.current[0] || v[1] !== this.current[1] || v[2] !== this.current[2]) {
	            this.current = v;
	            this.gl.uniform3f(this.location, v[0], v[1], v[2]);
	        }
	    };
	    return Uniform3f;
	}(Uniform);
	var Uniform4f = function (Uniform) {
	    function Uniform4f(context, location) {
	        Uniform.call(this, context, location);
	        this.current = [
	            0,
	            0,
	            0,
	            0
	        ];
	    }
	    if (Uniform)
	        Uniform4f.__proto__ = Uniform;
	    Uniform4f.prototype = Object.create(Uniform && Uniform.prototype);
	    Uniform4f.prototype.constructor = Uniform4f;
	    Uniform4f.prototype.set = function set(v) {
	        if (v[0] !== this.current[0] || v[1] !== this.current[1] || v[2] !== this.current[2] || v[3] !== this.current[3]) {
	            this.current = v;
	            this.gl.uniform4f(this.location, v[0], v[1], v[2], v[3]);
	        }
	    };
	    return Uniform4f;
	}(Uniform);
	var UniformColor = function (Uniform) {
	    function UniformColor(context, location) {
	        Uniform.call(this, context, location);
	        this.current = Color.transparent;
	    }
	    if (Uniform)
	        UniformColor.__proto__ = Uniform;
	    UniformColor.prototype = Object.create(Uniform && Uniform.prototype);
	    UniformColor.prototype.constructor = UniformColor;
	    UniformColor.prototype.set = function set(v) {
	        if (v.r !== this.current.r || v.g !== this.current.g || v.b !== this.current.b || v.a !== this.current.a) {
	            this.current = v;
	            this.gl.uniform4f(this.location, v.r, v.g, v.b, v.a);
	        }
	    };
	    return UniformColor;
	}(Uniform);
	var emptyMat4 = new Float32Array(16);
	var UniformMatrix4f = function (Uniform) {
	    function UniformMatrix4f(context, location) {
	        Uniform.call(this, context, location);
	        this.current = emptyMat4;
	    }
	    if (Uniform)
	        UniformMatrix4f.__proto__ = Uniform;
	    UniformMatrix4f.prototype = Object.create(Uniform && Uniform.prototype);
	    UniformMatrix4f.prototype.constructor = UniformMatrix4f;
	    UniformMatrix4f.prototype.set = function set(v) {
	        if (v[12] !== this.current[12] || v[0] !== this.current[0]) {
	            this.current = v;
	            this.gl.uniformMatrix4fv(this.location, false, v);
	            return;
	        }
	        for (var i = 1; i < 16; i++) {
	            if (v[i] !== this.current[i]) {
	                this.current = v;
	                this.gl.uniformMatrix4fv(this.location, false, v);
	                break;
	            }
	        }
	    };
	    return UniformMatrix4f;
	}(Uniform);

	function packColor(color) {
	    return [
	        packUint8ToFloat(255 * color.r, 255 * color.g),
	        packUint8ToFloat(255 * color.b, 255 * color.a)
	    ];
	}
	var ConstantBinder = function ConstantBinder(value, names, type) {
	    this.value = value;
	    this.uniformNames = names.map(function (name) {
	        return 'u_' + name;
	    });
	    this.type = type;
	};
	ConstantBinder.prototype.setUniform = function setUniform(uniform, globals, currentValue) {
	    uniform.set(currentValue.constantOr(this.value));
	};
	ConstantBinder.prototype.getBinding = function getBinding(context, location, _) {
	    return this.type === 'color' ? new UniformColor(context, location) : new Uniform1f(context, location);
	};
	var CrossFadedConstantBinder = function CrossFadedConstantBinder(value, names) {
	    this.uniformNames = names.map(function (name) {
	        return 'u_' + name;
	    });
	    this.patternFrom = null;
	    this.patternTo = null;
	    this.pixelRatioFrom = 1;
	    this.pixelRatioTo = 1;
	};
	CrossFadedConstantBinder.prototype.setConstantPatternPositions = function setConstantPatternPositions(posTo, posFrom) {
	    this.pixelRatioFrom = posFrom.pixelRatio;
	    this.pixelRatioTo = posTo.pixelRatio;
	    this.patternFrom = posFrom.tlbr;
	    this.patternTo = posTo.tlbr;
	};
	CrossFadedConstantBinder.prototype.setUniform = function setUniform(uniform, globals, currentValue, uniformName) {
	    var pos = uniformName === 'u_pattern_to' ? this.patternTo : uniformName === 'u_pattern_from' ? this.patternFrom : uniformName === 'u_pixel_ratio_to' ? this.pixelRatioTo : uniformName === 'u_pixel_ratio_from' ? this.pixelRatioFrom : null;
	    if (pos) {
	        uniform.set(pos);
	    }
	};
	CrossFadedConstantBinder.prototype.getBinding = function getBinding(context, location, name) {
	    return name.substr(0, 9) === 'u_pattern' ? new Uniform4f(context, location) : new Uniform1f(context, location);
	};
	var SourceExpressionBinder = function SourceExpressionBinder(expression, names, type, PaintVertexArray) {
	    this.expression = expression;
	    this.type = type;
	    this.maxValue = 0;
	    this.paintVertexAttributes = names.map(function (name) {
	        return {
	            name: 'a_' + name,
	            type: 'Float32',
	            components: type === 'color' ? 2 : 1,
	            offset: 0
	        };
	    });
	    this.paintVertexArray = new PaintVertexArray();
	};
	SourceExpressionBinder.prototype.populatePaintArray = function populatePaintArray(newLength, feature, imagePositions, canonical, formattedSection) {
	    var start = this.paintVertexArray.length;
	    var value = this.expression.evaluate(new EvaluationParameters(0), feature, {}, canonical, [], formattedSection);
	    this.paintVertexArray.resize(newLength);
	    this._setPaintValue(start, newLength, value);
	};
	SourceExpressionBinder.prototype.updatePaintArray = function updatePaintArray(start, end, feature, featureState) {
	    var value = this.expression.evaluate({ zoom: 0 }, feature, featureState);
	    this._setPaintValue(start, end, value);
	};
	SourceExpressionBinder.prototype._setPaintValue = function _setPaintValue(start, end, value) {
	    if (this.type === 'color') {
	        var color = packColor(value);
	        for (var i = start; i < end; i++) {
	            this.paintVertexArray.emplace(i, color[0], color[1]);
	        }
	    } else {
	        for (var i$1 = start; i$1 < end; i$1++) {
	            this.paintVertexArray.emplace(i$1, value);
	        }
	        this.maxValue = Math.max(this.maxValue, Math.abs(value));
	    }
	};
	SourceExpressionBinder.prototype.upload = function upload(context) {
	    if (this.paintVertexArray && this.paintVertexArray.arrayBuffer) {
	        if (this.paintVertexBuffer && this.paintVertexBuffer.buffer) {
	            this.paintVertexBuffer.updateData(this.paintVertexArray);
	        } else {
	            this.paintVertexBuffer = context.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent);
	        }
	    }
	};
	SourceExpressionBinder.prototype.destroy = function destroy() {
	    if (this.paintVertexBuffer) {
	        this.paintVertexBuffer.destroy();
	    }
	};
	var CompositeExpressionBinder = function CompositeExpressionBinder(expression, names, type, useIntegerZoom, zoom, PaintVertexArray) {
	    this.expression = expression;
	    this.uniformNames = names.map(function (name) {
	        return 'u_' + name + '_t';
	    });
	    this.type = type;
	    this.useIntegerZoom = useIntegerZoom;
	    this.zoom = zoom;
	    this.maxValue = 0;
	    this.paintVertexAttributes = names.map(function (name) {
	        return {
	            name: 'a_' + name,
	            type: 'Float32',
	            components: type === 'color' ? 4 : 2,
	            offset: 0
	        };
	    });
	    this.paintVertexArray = new PaintVertexArray();
	};
	CompositeExpressionBinder.prototype.populatePaintArray = function populatePaintArray(newLength, feature, imagePositions, canonical, formattedSection) {
	    var min = this.expression.evaluate(new EvaluationParameters(this.zoom), feature, {}, canonical, [], formattedSection);
	    var max = this.expression.evaluate(new EvaluationParameters(this.zoom + 1), feature, {}, canonical, [], formattedSection);
	    var start = this.paintVertexArray.length;
	    this.paintVertexArray.resize(newLength);
	    this._setPaintValue(start, newLength, min, max);
	};
	CompositeExpressionBinder.prototype.updatePaintArray = function updatePaintArray(start, end, feature, featureState) {
	    var min = this.expression.evaluate({ zoom: this.zoom }, feature, featureState);
	    var max = this.expression.evaluate({ zoom: this.zoom + 1 }, feature, featureState);
	    this._setPaintValue(start, end, min, max);
	};
	CompositeExpressionBinder.prototype._setPaintValue = function _setPaintValue(start, end, min, max) {
	    if (this.type === 'color') {
	        var minColor = packColor(min);
	        var maxColor = packColor(max);
	        for (var i = start; i < end; i++) {
	            this.paintVertexArray.emplace(i, minColor[0], minColor[1], maxColor[0], maxColor[1]);
	        }
	    } else {
	        for (var i$1 = start; i$1 < end; i$1++) {
	            this.paintVertexArray.emplace(i$1, min, max);
	        }
	        this.maxValue = Math.max(this.maxValue, Math.abs(min), Math.abs(max));
	    }
	};
	CompositeExpressionBinder.prototype.upload = function upload(context) {
	    if (this.paintVertexArray && this.paintVertexArray.arrayBuffer) {
	        if (this.paintVertexBuffer && this.paintVertexBuffer.buffer) {
	            this.paintVertexBuffer.updateData(this.paintVertexArray);
	        } else {
	            this.paintVertexBuffer = context.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent);
	        }
	    }
	};
	CompositeExpressionBinder.prototype.destroy = function destroy() {
	    if (this.paintVertexBuffer) {
	        this.paintVertexBuffer.destroy();
	    }
	};
	CompositeExpressionBinder.prototype.setUniform = function setUniform(uniform, globals) {
	    var currentZoom = this.useIntegerZoom ? Math.floor(globals.zoom) : globals.zoom;
	    var factor = clamp(this.expression.interpolationFactor(currentZoom, this.zoom, this.zoom + 1), 0, 1);
	    uniform.set(factor);
	};
	CompositeExpressionBinder.prototype.getBinding = function getBinding(context, location, _) {
	    return new Uniform1f(context, location);
	};
	var CrossFadedCompositeBinder = function CrossFadedCompositeBinder(expression, type, useIntegerZoom, zoom, PaintVertexArray, layerId) {
	    this.expression = expression;
	    this.type = type;
	    this.useIntegerZoom = useIntegerZoom;
	    this.zoom = zoom;
	    this.layerId = layerId;
	    this.zoomInPaintVertexArray = new PaintVertexArray();
	    this.zoomOutPaintVertexArray = new PaintVertexArray();
	};
	CrossFadedCompositeBinder.prototype.populatePaintArray = function populatePaintArray(length, feature, imagePositions) {
	    var start = this.zoomInPaintVertexArray.length;
	    this.zoomInPaintVertexArray.resize(length);
	    this.zoomOutPaintVertexArray.resize(length);
	    this._setPaintValues(start, length, feature.patterns && feature.patterns[this.layerId], imagePositions);
	};
	CrossFadedCompositeBinder.prototype.updatePaintArray = function updatePaintArray(start, end, feature, featureState, imagePositions) {
	    this._setPaintValues(start, end, feature.patterns && feature.patterns[this.layerId], imagePositions);
	};
	CrossFadedCompositeBinder.prototype._setPaintValues = function _setPaintValues(start, end, patterns, positions) {
	    if (!positions || !patterns) {
	        return;
	    }
	    var min = patterns.min;
	    var mid = patterns.mid;
	    var max = patterns.max;
	    var imageMin = positions[min];
	    var imageMid = positions[mid];
	    var imageMax = positions[max];
	    if (!imageMin || !imageMid || !imageMax) {
	        return;
	    }
	    for (var i = start; i < end; i++) {
	        this.zoomInPaintVertexArray.emplace(i, imageMid.tl[0], imageMid.tl[1], imageMid.br[0], imageMid.br[1], imageMin.tl[0], imageMin.tl[1], imageMin.br[0], imageMin.br[1], imageMid.pixelRatio, imageMin.pixelRatio);
	        this.zoomOutPaintVertexArray.emplace(i, imageMid.tl[0], imageMid.tl[1], imageMid.br[0], imageMid.br[1], imageMax.tl[0], imageMax.tl[1], imageMax.br[0], imageMax.br[1], imageMid.pixelRatio, imageMax.pixelRatio);
	    }
	};
	CrossFadedCompositeBinder.prototype.upload = function upload(context) {
	    if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
	        this.zoomInPaintVertexBuffer = context.createVertexBuffer(this.zoomInPaintVertexArray, patternAttributes.members, this.expression.isStateDependent);
	        this.zoomOutPaintVertexBuffer = context.createVertexBuffer(this.zoomOutPaintVertexArray, patternAttributes.members, this.expression.isStateDependent);
	    }
	};
	CrossFadedCompositeBinder.prototype.destroy = function destroy() {
	    if (this.zoomOutPaintVertexBuffer) {
	        this.zoomOutPaintVertexBuffer.destroy();
	    }
	    if (this.zoomInPaintVertexBuffer) {
	        this.zoomInPaintVertexBuffer.destroy();
	    }
	};
	var ProgramConfiguration = function ProgramConfiguration(layer, zoom, filterProperties) {
	    this.binders = {};
	    this._buffers = [];
	    var keys = [];
	    for (var property in layer.paint._values) {
	        if (!filterProperties(property)) {
	            continue;
	        }
	        var value = layer.paint.get(property);
	        if (!(value instanceof PossiblyEvaluatedPropertyValue) || !supportsPropertyExpression(value.property.specification)) {
	            continue;
	        }
	        var names = paintAttributeNames(property, layer.type);
	        var expression = value.value;
	        var type = value.property.specification.type;
	        var useIntegerZoom = value.property.useIntegerZoom;
	        var propType = value.property.specification['property-type'];
	        var isCrossFaded = propType === 'cross-faded' || propType === 'cross-faded-data-driven';
	        if (expression.kind === 'constant') {
	            this.binders[property] = isCrossFaded ? new CrossFadedConstantBinder(expression.value, names) : new ConstantBinder(expression.value, names, type);
	            keys.push('/u_' + property);
	        } else if (expression.kind === 'source' || isCrossFaded) {
	            var StructArrayLayout = layoutType(property, type, 'source');
	            this.binders[property] = isCrossFaded ? new CrossFadedCompositeBinder(expression, type, useIntegerZoom, zoom, StructArrayLayout, layer.id) : new SourceExpressionBinder(expression, names, type, StructArrayLayout);
	            keys.push('/a_' + property);
	        } else {
	            var StructArrayLayout$1 = layoutType(property, type, 'composite');
	            this.binders[property] = new CompositeExpressionBinder(expression, names, type, useIntegerZoom, zoom, StructArrayLayout$1);
	            keys.push('/z_' + property);
	        }
	    }
	    this.cacheKey = keys.sort().join('');
	};
	ProgramConfiguration.prototype.getMaxValue = function getMaxValue(property) {
	    var binder = this.binders[property];
	    return binder instanceof SourceExpressionBinder || binder instanceof CompositeExpressionBinder ? binder.maxValue : 0;
	};
	ProgramConfiguration.prototype.populatePaintArrays = function populatePaintArrays(newLength, feature, imagePositions, canonical, formattedSection) {
	    for (var property in this.binders) {
	        var binder = this.binders[property];
	        if (binder instanceof SourceExpressionBinder || binder instanceof CompositeExpressionBinder || binder instanceof CrossFadedCompositeBinder) {
	            binder.populatePaintArray(newLength, feature, imagePositions, canonical, formattedSection);
	        }
	    }
	};
	ProgramConfiguration.prototype.setConstantPatternPositions = function setConstantPatternPositions(posTo, posFrom) {
	    for (var property in this.binders) {
	        var binder = this.binders[property];
	        if (binder instanceof CrossFadedConstantBinder) {
	            binder.setConstantPatternPositions(posTo, posFrom);
	        }
	    }
	};
	ProgramConfiguration.prototype.updatePaintArrays = function updatePaintArrays(featureStates, featureMap, vtLayer, layer, imagePositions) {
	    var dirty = false;
	    for (var id in featureStates) {
	        var positions = featureMap.getPositions(id);
	        for (var i = 0, list = positions; i < list.length; i += 1) {
	            var pos = list[i];
	            var feature = vtLayer.feature(pos.index);
	            for (var property in this.binders) {
	                var binder = this.binders[property];
	                if ((binder instanceof SourceExpressionBinder || binder instanceof CompositeExpressionBinder || binder instanceof CrossFadedCompositeBinder) && binder.expression.isStateDependent === true) {
	                    var value = layer.paint.get(property);
	                    binder.expression = value.value;
	                    binder.updatePaintArray(pos.start, pos.end, feature, featureStates[id], imagePositions);
	                    dirty = true;
	                }
	            }
	        }
	    }
	    return dirty;
	};
	ProgramConfiguration.prototype.defines = function defines() {
	    var result = [];
	    for (var property in this.binders) {
	        var binder = this.binders[property];
	        if (binder instanceof ConstantBinder || binder instanceof CrossFadedConstantBinder) {
	            result.push.apply(result, binder.uniformNames.map(function (name) {
	                return '#define HAS_UNIFORM_' + name;
	            }));
	        }
	    }
	    return result;
	};
	ProgramConfiguration.prototype.getBinderAttributes = function getBinderAttributes() {
	    var result = [];
	    for (var property in this.binders) {
	        var binder = this.binders[property];
	        if (binder instanceof SourceExpressionBinder || binder instanceof CompositeExpressionBinder) {
	            for (var i = 0; i < binder.paintVertexAttributes.length; i++) {
	                result.push(binder.paintVertexAttributes[i].name);
	            }
	        } else if (binder instanceof CrossFadedCompositeBinder) {
	            for (var i$1 = 0; i$1 < patternAttributes.members.length; i$1++) {
	                result.push(patternAttributes.members[i$1].name);
	            }
	        }
	    }
	    return result;
	};
	ProgramConfiguration.prototype.getBinderUniforms = function getBinderUniforms() {
	    var uniforms = [];
	    for (var property in this.binders) {
	        var binder = this.binders[property];
	        if (binder instanceof ConstantBinder || binder instanceof CrossFadedConstantBinder || binder instanceof CompositeExpressionBinder) {
	            for (var i = 0, list = binder.uniformNames; i < list.length; i += 1) {
	                var uniformName = list[i];
	                uniforms.push(uniformName);
	            }
	        }
	    }
	    return uniforms;
	};
	ProgramConfiguration.prototype.getPaintVertexBuffers = function getPaintVertexBuffers() {
	    return this._buffers;
	};
	ProgramConfiguration.prototype.getUniforms = function getUniforms(context, locations) {
	    var uniforms = [];
	    for (var property in this.binders) {
	        var binder = this.binders[property];
	        if (binder instanceof ConstantBinder || binder instanceof CrossFadedConstantBinder || binder instanceof CompositeExpressionBinder) {
	            for (var i = 0, list = binder.uniformNames; i < list.length; i += 1) {
	                var name = list[i];
	                if (locations[name]) {
	                    var binding = binder.getBinding(context, locations[name], name);
	                    uniforms.push({
	                        name: name,
	                        property: property,
	                        binding: binding
	                    });
	                }
	            }
	        }
	    }
	    return uniforms;
	};
	ProgramConfiguration.prototype.setUniforms = function setUniforms(context, binderUniforms, properties, globals) {
	    for (var i = 0, list = binderUniforms; i < list.length; i += 1) {
	        var ref = list[i];
	        var name = ref.name;
	        var property = ref.property;
	        var binding = ref.binding;
	        this.binders[property].setUniform(binding, globals, properties.get(property), name);
	    }
	};
	ProgramConfiguration.prototype.updatePaintBuffers = function updatePaintBuffers(crossfade) {
	    this._buffers = [];
	    for (var property in this.binders) {
	        var binder = this.binders[property];
	        if (crossfade && binder instanceof CrossFadedCompositeBinder) {
	            var patternVertexBuffer = crossfade.fromScale === 2 ? binder.zoomInPaintVertexBuffer : binder.zoomOutPaintVertexBuffer;
	            if (patternVertexBuffer) {
	                this._buffers.push(patternVertexBuffer);
	            }
	        } else if ((binder instanceof SourceExpressionBinder || binder instanceof CompositeExpressionBinder) && binder.paintVertexBuffer) {
	            this._buffers.push(binder.paintVertexBuffer);
	        }
	    }
	};
	ProgramConfiguration.prototype.upload = function upload(context) {
	    for (var property in this.binders) {
	        var binder = this.binders[property];
	        if (binder instanceof SourceExpressionBinder || binder instanceof CompositeExpressionBinder || binder instanceof CrossFadedCompositeBinder) {
	            binder.upload(context);
	        }
	    }
	    this.updatePaintBuffers();
	};
	ProgramConfiguration.prototype.destroy = function destroy() {
	    for (var property in this.binders) {
	        var binder = this.binders[property];
	        if (binder instanceof SourceExpressionBinder || binder instanceof CompositeExpressionBinder || binder instanceof CrossFadedCompositeBinder) {
	            binder.destroy();
	        }
	    }
	};
	var ProgramConfigurationSet = function ProgramConfigurationSet(layers, zoom, filterProperties) {
	    if (filterProperties === void 0)
	        filterProperties = function () {
	            return true;
	        };
	    this.programConfigurations = {};
	    for (var i = 0, list = layers; i < list.length; i += 1) {
	        var layer = list[i];
	        this.programConfigurations[layer.id] = new ProgramConfiguration(layer, zoom, filterProperties);
	    }
	    this.needsUpload = false;
	    this._featureMap = new FeaturePositionMap();
	    this._bufferOffset = 0;
	};
	ProgramConfigurationSet.prototype.populatePaintArrays = function populatePaintArrays(length, feature, index, imagePositions, canonical, formattedSection) {
	    for (var key in this.programConfigurations) {
	        this.programConfigurations[key].populatePaintArrays(length, feature, imagePositions, canonical, formattedSection);
	    }
	    if (feature.id !== undefined) {
	        this._featureMap.add(feature.id, index, this._bufferOffset, length);
	    }
	    this._bufferOffset = length;
	    this.needsUpload = true;
	};
	ProgramConfigurationSet.prototype.updatePaintArrays = function updatePaintArrays(featureStates, vtLayer, layers, imagePositions) {
	    for (var i = 0, list = layers; i < list.length; i += 1) {
	        var layer = list[i];
	        this.needsUpload = this.programConfigurations[layer.id].updatePaintArrays(featureStates, this._featureMap, vtLayer, layer, imagePositions) || this.needsUpload;
	    }
	};
	ProgramConfigurationSet.prototype.get = function get(layerId) {
	    return this.programConfigurations[layerId];
	};
	ProgramConfigurationSet.prototype.upload = function upload(context) {
	    if (!this.needsUpload) {
	        return;
	    }
	    for (var layerId in this.programConfigurations) {
	        this.programConfigurations[layerId].upload(context);
	    }
	    this.needsUpload = false;
	};
	ProgramConfigurationSet.prototype.destroy = function destroy() {
	    for (var layerId in this.programConfigurations) {
	        this.programConfigurations[layerId].destroy();
	    }
	};
	function paintAttributeNames(property, type) {
	    var attributeNameExceptions = {
	        'text-opacity': ['opacity'],
	        'icon-opacity': ['opacity'],
	        'text-color': ['fill_color'],
	        'icon-color': ['fill_color'],
	        'text-halo-color': ['halo_color'],
	        'icon-halo-color': ['halo_color'],
	        'text-halo-blur': ['halo_blur'],
	        'icon-halo-blur': ['halo_blur'],
	        'text-halo-width': ['halo_width'],
	        'icon-halo-width': ['halo_width'],
	        'line-gap-width': ['gapwidth'],
	        'line-pattern': [
	            'pattern_to',
	            'pattern_from',
	            'pixel_ratio_to',
	            'pixel_ratio_from'
	        ],
	        'fill-pattern': [
	            'pattern_to',
	            'pattern_from',
	            'pixel_ratio_to',
	            'pixel_ratio_from'
	        ],
	        'fill-extrusion-pattern': [
	            'pattern_to',
	            'pattern_from',
	            'pixel_ratio_to',
	            'pixel_ratio_from'
	        ]
	    };
	    return attributeNameExceptions[property] || [property.replace(type + '-', '').replace(/-/g, '_')];
	}
	function getLayoutException(property) {
	    var propertyExceptions = {
	        'line-pattern': {
	            'source': StructArrayLayout10ui20,
	            'composite': StructArrayLayout10ui20
	        },
	        'fill-pattern': {
	            'source': StructArrayLayout10ui20,
	            'composite': StructArrayLayout10ui20
	        },
	        'fill-extrusion-pattern': {
	            'source': StructArrayLayout10ui20,
	            'composite': StructArrayLayout10ui20
	        }
	    };
	    return propertyExceptions[property];
	}
	function layoutType(property, type, binderType) {
	    var defaultLayouts = {
	        'color': {
	            'source': StructArrayLayout2f8,
	            'composite': StructArrayLayout4f16
	        },
	        'number': {
	            'source': StructArrayLayout1f4,
	            'composite': StructArrayLayout2f8
	        }
	    };
	    var layoutException = getLayoutException(property);
	    return layoutException && layoutException[binderType] || defaultLayouts[type][binderType];
	}
	register('ConstantBinder', ConstantBinder);
	register('CrossFadedConstantBinder', CrossFadedConstantBinder);
	register('SourceExpressionBinder', SourceExpressionBinder);
	register('CrossFadedCompositeBinder', CrossFadedCompositeBinder);
	register('CompositeExpressionBinder', CompositeExpressionBinder);
	register('ProgramConfiguration', ProgramConfiguration, { omit: ['_buffers'] });
	register('ProgramConfigurationSet', ProgramConfigurationSet);

	var EXTENT$1 = 8192;

	var BITS = 15;
	var MAX = Math.pow(2, BITS - 1) - 1;
	var MIN = -MAX - 1;
	function loadGeometry(feature) {
	    var scale = EXTENT$1 / feature.extent;
	    var geometry = feature.loadGeometry();
	    for (var r = 0; r < geometry.length; r++) {
	        var ring = geometry[r];
	        for (var p = 0; p < ring.length; p++) {
	            var point = ring[p];
	            var x = Math.round(point.x * scale);
	            var y = Math.round(point.y * scale);
	            point.x = clamp(x, MIN, MAX);
	            point.y = clamp(y, MIN, MAX);
	            if (x < point.x || x > point.x + 1 || y < point.y || y > point.y + 1) {
	                warnOnce('Geometry exceeds allowed extent, reduce your vector tile buffer size');
	            }
	        }
	    }
	    return geometry;
	}

	function toEvaluationFeature(feature, needGeometry) {
	    return {
	        type: feature.type,
	        id: feature.id,
	        properties: feature.properties,
	        geometry: needGeometry ? loadGeometry(feature) : []
	    };
	}

	function addCircleVertex(layoutVertexArray, x, y, extrudeX, extrudeY) {
	    layoutVertexArray.emplaceBack(x * 2 + (extrudeX + 1) / 2, y * 2 + (extrudeY + 1) / 2);
	}
	var CircleBucket = function CircleBucket(options) {
	    this.zoom = options.zoom;
	    this.overscaling = options.overscaling;
	    this.layers = options.layers;
	    this.layerIds = this.layers.map(function (layer) {
	        return layer.id;
	    });
	    this.index = options.index;
	    this.hasPattern = false;
	    this.layoutVertexArray = new StructArrayLayout2i4();
	    this.indexArray = new StructArrayLayout3ui6();
	    this.segments = new SegmentVector();
	    this.programConfigurations = new ProgramConfigurationSet(options.layers, options.zoom);
	    this.stateDependentLayerIds = this.layers.filter(function (l) {
	        return l.isStateDependent();
	    }).map(function (l) {
	        return l.id;
	    });
	};
	CircleBucket.prototype.populate = function populate(features, options, canonical) {
	    var styleLayer = this.layers[0];
	    var bucketFeatures = [];
	    var circleSortKey = null;
	    if (styleLayer.type === 'circle') {
	        circleSortKey = styleLayer.layout.get('circle-sort-key');
	    }
	    for (var i = 0, list = features; i < list.length; i += 1) {
	        var ref = list[i];
	        var feature = ref.feature;
	        var id = ref.id;
	        var index = ref.index;
	        var sourceLayerIndex = ref.sourceLayerIndex;
	        var needGeometry = this.layers[0]._featureFilter.needGeometry;
	        var evaluationFeature = toEvaluationFeature(feature, needGeometry);
	        if (!this.layers[0]._featureFilter.filter(new EvaluationParameters(this.zoom), evaluationFeature, canonical)) {
	            continue;
	        }
	        var sortKey = circleSortKey ? circleSortKey.evaluate(evaluationFeature, {}, canonical) : undefined;
	        var bucketFeature = {
	            id: id,
	            properties: feature.properties,
	            type: feature.type,
	            sourceLayerIndex: sourceLayerIndex,
	            index: index,
	            geometry: needGeometry ? evaluationFeature.geometry : loadGeometry(feature),
	            patterns: {},
	            sortKey: sortKey
	        };
	        bucketFeatures.push(bucketFeature);
	    }
	    if (circleSortKey) {
	        bucketFeatures.sort(function (a, b) {
	            return a.sortKey - b.sortKey;
	        });
	    }
	    for (var i$1 = 0, list$1 = bucketFeatures; i$1 < list$1.length; i$1 += 1) {
	        var bucketFeature$1 = list$1[i$1];
	        var ref$1 = bucketFeature$1;
	        var geometry = ref$1.geometry;
	        var index$1 = ref$1.index;
	        var sourceLayerIndex$1 = ref$1.sourceLayerIndex;
	        var feature$1 = features[index$1].feature;
	        this.addFeature(bucketFeature$1, geometry, index$1, canonical);
	        options.featureIndex.insert(feature$1, geometry, index$1, sourceLayerIndex$1, this.index);
	    }
	};
	CircleBucket.prototype.update = function update(states, vtLayer, imagePositions) {
	    if (!this.stateDependentLayers.length) {
	        return;
	    }
	    this.programConfigurations.updatePaintArrays(states, vtLayer, this.stateDependentLayers, imagePositions);
	};
	CircleBucket.prototype.isEmpty = function isEmpty() {
	    return this.layoutVertexArray.length === 0;
	};
	CircleBucket.prototype.uploadPending = function uploadPending() {
	    return !this.uploaded || this.programConfigurations.needsUpload;
	};
	CircleBucket.prototype.upload = function upload(context) {
	    if (!this.uploaded) {
	        this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, members);
	        this.indexBuffer = context.createIndexBuffer(this.indexArray);
	    }
	    this.programConfigurations.upload(context);
	    this.uploaded = true;
	};
	CircleBucket.prototype.destroy = function destroy() {
	    if (!this.layoutVertexBuffer) {
	        return;
	    }
	    this.layoutVertexBuffer.destroy();
	    this.indexBuffer.destroy();
	    this.programConfigurations.destroy();
	    this.segments.destroy();
	};
	CircleBucket.prototype.addFeature = function addFeature(feature, geometry, index, canonical) {
	    for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
	        var ring = list$1[i$1];
	        for (var i = 0, list = ring; i < list.length; i += 1) {
	            var point = list[i];
	            var x = point.x;
	            var y = point.y;
	            if (x < 0 || x >= EXTENT$1 || y < 0 || y >= EXTENT$1) {
	                continue;
	            }
	            var segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, feature.sortKey);
	            var index$1 = segment.vertexLength;
	            addCircleVertex(this.layoutVertexArray, x, y, -1, -1);
	            addCircleVertex(this.layoutVertexArray, x, y, 1, -1);
	            addCircleVertex(this.layoutVertexArray, x, y, 1, 1);
	            addCircleVertex(this.layoutVertexArray, x, y, -1, 1);
	            this.indexArray.emplaceBack(index$1, index$1 + 1, index$1 + 2);
	            this.indexArray.emplaceBack(index$1, index$1 + 3, index$1 + 2);
	            segment.vertexLength += 4;
	            segment.primitiveLength += 2;
	        }
	    }
	    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, feature, index, {}, canonical);
	};
	register('CircleBucket', CircleBucket, { omit: ['layers'] });

	function polygonIntersectsPolygon(polygonA, polygonB) {
	    for (var i = 0; i < polygonA.length; i++) {
	        if (polygonContainsPoint(polygonB, polygonA[i])) {
	            return true;
	        }
	    }
	    for (var i$1 = 0; i$1 < polygonB.length; i$1++) {
	        if (polygonContainsPoint(polygonA, polygonB[i$1])) {
	            return true;
	        }
	    }
	    if (lineIntersectsLine(polygonA, polygonB)) {
	        return true;
	    }
	    return false;
	}
	function polygonIntersectsBufferedPoint(polygon, point, radius) {
	    if (polygonContainsPoint(polygon, point)) {
	        return true;
	    }
	    if (pointIntersectsBufferedLine(point, polygon, radius)) {
	        return true;
	    }
	    return false;
	}
	function polygonIntersectsMultiPolygon(polygon, multiPolygon) {
	    if (polygon.length === 1) {
	        return multiPolygonContainsPoint(multiPolygon, polygon[0]);
	    }
	    for (var m = 0; m < multiPolygon.length; m++) {
	        var ring = multiPolygon[m];
	        for (var n = 0; n < ring.length; n++) {
	            if (polygonContainsPoint(polygon, ring[n])) {
	                return true;
	            }
	        }
	    }
	    for (var i = 0; i < polygon.length; i++) {
	        if (multiPolygonContainsPoint(multiPolygon, polygon[i])) {
	            return true;
	        }
	    }
	    for (var k = 0; k < multiPolygon.length; k++) {
	        if (lineIntersectsLine(polygon, multiPolygon[k])) {
	            return true;
	        }
	    }
	    return false;
	}
	function polygonIntersectsBufferedMultiLine(polygon, multiLine, radius) {
	    for (var i = 0; i < multiLine.length; i++) {
	        var line = multiLine[i];
	        if (polygon.length >= 3) {
	            for (var k = 0; k < line.length; k++) {
	                if (polygonContainsPoint(polygon, line[k])) {
	                    return true;
	                }
	            }
	        }
	        if (lineIntersectsBufferedLine(polygon, line, radius)) {
	            return true;
	        }
	    }
	    return false;
	}
	function lineIntersectsBufferedLine(lineA, lineB, radius) {
	    if (lineA.length > 1) {
	        if (lineIntersectsLine(lineA, lineB)) {
	            return true;
	        }
	        for (var j = 0; j < lineB.length; j++) {
	            if (pointIntersectsBufferedLine(lineB[j], lineA, radius)) {
	                return true;
	            }
	        }
	    }
	    for (var k = 0; k < lineA.length; k++) {
	        if (pointIntersectsBufferedLine(lineA[k], lineB, radius)) {
	            return true;
	        }
	    }
	    return false;
	}
	function lineIntersectsLine(lineA, lineB) {
	    if (lineA.length === 0 || lineB.length === 0) {
	        return false;
	    }
	    for (var i = 0; i < lineA.length - 1; i++) {
	        var a0 = lineA[i];
	        var a1 = lineA[i + 1];
	        for (var j = 0; j < lineB.length - 1; j++) {
	            var b0 = lineB[j];
	            var b1 = lineB[j + 1];
	            if (lineSegmentIntersectsLineSegment(a0, a1, b0, b1)) {
	                return true;
	            }
	        }
	    }
	    return false;
	}
	function lineSegmentIntersectsLineSegment(a0, a1, b0, b1) {
	    return isCounterClockwise(a0, b0, b1) !== isCounterClockwise(a1, b0, b1) && isCounterClockwise(a0, a1, b0) !== isCounterClockwise(a0, a1, b1);
	}
	function pointIntersectsBufferedLine(p, line, radius) {
	    var radiusSquared = radius * radius;
	    if (line.length === 1) {
	        return p.distSqr(line[0]) < radiusSquared;
	    }
	    for (var i = 1; i < line.length; i++) {
	        var v = line[i - 1], w = line[i];
	        if (distToSegmentSquared(p, v, w) < radiusSquared) {
	            return true;
	        }
	    }
	    return false;
	}
	function distToSegmentSquared(p, v, w) {
	    var l2 = v.distSqr(w);
	    if (l2 === 0) {
	        return p.distSqr(v);
	    }
	    var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
	    if (t < 0) {
	        return p.distSqr(v);
	    }
	    if (t > 1) {
	        return p.distSqr(w);
	    }
	    return p.distSqr(w.sub(v)._mult(t)._add(v));
	}
	function multiPolygonContainsPoint(rings, p) {
	    var c = false, ring, p1, p2;
	    for (var k = 0; k < rings.length; k++) {
	        ring = rings[k];
	        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
	            p1 = ring[i];
	            p2 = ring[j];
	            if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
	                c = !c;
	            }
	        }
	    }
	    return c;
	}
	function polygonContainsPoint(ring, p) {
	    var c = false;
	    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
	        var p1 = ring[i];
	        var p2 = ring[j];
	        if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
	            c = !c;
	        }
	    }
	    return c;
	}
	function polygonIntersectsBox(ring, boxX1, boxY1, boxX2, boxY2) {
	    for (var i$1 = 0, list = ring; i$1 < list.length; i$1 += 1) {
	        var p = list[i$1];
	        if (boxX1 <= p.x && boxY1 <= p.y && boxX2 >= p.x && boxY2 >= p.y) {
	            return true;
	        }
	    }
	    var corners = [
	        new pointGeometry(boxX1, boxY1),
	        new pointGeometry(boxX1, boxY2),
	        new pointGeometry(boxX2, boxY2),
	        new pointGeometry(boxX2, boxY1)
	    ];
	    if (ring.length > 2) {
	        for (var i$2 = 0, list$1 = corners; i$2 < list$1.length; i$2 += 1) {
	            var corner = list$1[i$2];
	            if (polygonContainsPoint(ring, corner)) {
	                return true;
	            }
	        }
	    }
	    for (var i = 0; i < ring.length - 1; i++) {
	        var p1 = ring[i];
	        var p2 = ring[i + 1];
	        if (edgeIntersectsBox(p1, p2, corners)) {
	            return true;
	        }
	    }
	    return false;
	}
	function edgeIntersectsBox(e1, e2, corners) {
	    var tl = corners[0];
	    var br = corners[2];
	    if (e1.x < tl.x && e2.x < tl.x || e1.x > br.x && e2.x > br.x || e1.y < tl.y && e2.y < tl.y || e1.y > br.y && e2.y > br.y) {
	        return false;
	    }
	    var dir = isCounterClockwise(e1, e2, corners[0]);
	    return dir !== isCounterClockwise(e1, e2, corners[1]) || dir !== isCounterClockwise(e1, e2, corners[2]) || dir !== isCounterClockwise(e1, e2, corners[3]);
	}

	function getMaximumPaintValue(property, layer, bucket) {
	    var value = layer.paint.get(property).value;
	    if (value.kind === 'constant') {
	        return value.value;
	    } else {
	        return bucket.programConfigurations.get(layer.id).getMaxValue(property);
	    }
	}
	function translateDistance(translate) {
	    return Math.sqrt(translate[0] * translate[0] + translate[1] * translate[1]);
	}
	function translate(queryGeometry, translate, translateAnchor, bearing, pixelsToTileUnits) {
	    if (!translate[0] && !translate[1]) {
	        return queryGeometry;
	    }
	    var pt = pointGeometry.convert(translate)._mult(pixelsToTileUnits);
	    if (translateAnchor === 'viewport') {
	        pt._rotate(-bearing);
	    }
	    var translated = [];
	    for (var i = 0; i < queryGeometry.length; i++) {
	        var point = queryGeometry[i];
	        translated.push(point.sub(pt));
	    }
	    return translated;
	}

	var layout$2 = new Properties({ 'circle-sort-key': new DataDrivenProperty(spec['layout_circle']['circle-sort-key']) });
	var paint$1 = new Properties({
	    'circle-radius': new DataDrivenProperty(spec['paint_circle']['circle-radius']),
	    'circle-color': new DataDrivenProperty(spec['paint_circle']['circle-color']),
	    'circle-blur': new DataDrivenProperty(spec['paint_circle']['circle-blur']),
	    'circle-opacity': new DataDrivenProperty(spec['paint_circle']['circle-opacity']),
	    'circle-translate': new DataConstantProperty(spec['paint_circle']['circle-translate']),
	    'circle-translate-anchor': new DataConstantProperty(spec['paint_circle']['circle-translate-anchor']),
	    'circle-pitch-scale': new DataConstantProperty(spec['paint_circle']['circle-pitch-scale']),
	    'circle-pitch-alignment': new DataConstantProperty(spec['paint_circle']['circle-pitch-alignment']),
	    'circle-stroke-width': new DataDrivenProperty(spec['paint_circle']['circle-stroke-width']),
	    'circle-stroke-color': new DataDrivenProperty(spec['paint_circle']['circle-stroke-color']),
	    'circle-stroke-opacity': new DataDrivenProperty(spec['paint_circle']['circle-stroke-opacity'])
	});
	var properties = {
	    paint: paint$1,
	    layout: layout$2
	};

	var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
	if (!Math.hypot) {
	    Math.hypot = function () {
	        var arguments$1 = arguments;
	        var y = 0, i = arguments.length;
	        while (i--) {
	            y += arguments$1[i] * arguments$1[i];
	        }
	        return Math.sqrt(y);
	    };
	}

	function create() {
	    var out = new ARRAY_TYPE(4);
	    if (ARRAY_TYPE != Float32Array) {
	        out[1] = 0;
	        out[2] = 0;
	    }
	    out[0] = 1;
	    out[3] = 1;
	    return out;
	}
	function rotate(out, a, rad) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
	    var s = Math.sin(rad);
	    var c = Math.cos(rad);
	    out[0] = a0 * c + a2 * s;
	    out[1] = a1 * c + a3 * s;
	    out[2] = a0 * -s + a2 * c;
	    out[3] = a1 * -s + a3 * c;
	    return out;
	}

	function create$1() {
	    var out = new ARRAY_TYPE(9);
	    if (ARRAY_TYPE != Float32Array) {
	        out[1] = 0;
	        out[2] = 0;
	        out[3] = 0;
	        out[5] = 0;
	        out[6] = 0;
	        out[7] = 0;
	    }
	    out[0] = 1;
	    out[4] = 1;
	    out[8] = 1;
	    return out;
	}
	function fromRotation(out, rad) {
	    var s = Math.sin(rad), c = Math.cos(rad);
	    out[0] = c;
	    out[1] = s;
	    out[2] = 0;
	    out[3] = -s;
	    out[4] = c;
	    out[5] = 0;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	}

	function create$2() {
	    var out = new ARRAY_TYPE(16);
	    if (ARRAY_TYPE != Float32Array) {
	        out[1] = 0;
	        out[2] = 0;
	        out[3] = 0;
	        out[4] = 0;
	        out[6] = 0;
	        out[7] = 0;
	        out[8] = 0;
	        out[9] = 0;
	        out[11] = 0;
	        out[12] = 0;
	        out[13] = 0;
	        out[14] = 0;
	    }
	    out[0] = 1;
	    out[5] = 1;
	    out[10] = 1;
	    out[15] = 1;
	    return out;
	}
	function clone$1(a) {
	    var out = new ARRAY_TYPE(16);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	}
	function identity(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	}
	function invert(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
	    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
	    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
	    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
	    var b00 = a00 * a11 - a01 * a10;
	    var b01 = a00 * a12 - a02 * a10;
	    var b02 = a00 * a13 - a03 * a10;
	    var b03 = a01 * a12 - a02 * a11;
	    var b04 = a01 * a13 - a03 * a11;
	    var b05 = a02 * a13 - a03 * a12;
	    var b06 = a20 * a31 - a21 * a30;
	    var b07 = a20 * a32 - a22 * a30;
	    var b08 = a20 * a33 - a23 * a30;
	    var b09 = a21 * a32 - a22 * a31;
	    var b10 = a21 * a33 - a23 * a31;
	    var b11 = a22 * a33 - a23 * a32;
	    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	    if (!det) {
	        return null;
	    }
	    det = 1 / det;
	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
	    return out;
	}
	function multiply(out, a, b) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
	    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
	    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
	    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
	    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
	    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	    b0 = b[4];
	    b1 = b[5];
	    b2 = b[6];
	    b3 = b[7];
	    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	    b0 = b[8];
	    b1 = b[9];
	    b2 = b[10];
	    b3 = b[11];
	    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	    b0 = b[12];
	    b1 = b[13];
	    b2 = b[14];
	    b3 = b[15];
	    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	    return out;
	}
	function translate$1(out, a, v) {
	    var x = v[0], y = v[1], z = v[2];
	    var a00, a01, a02, a03;
	    var a10, a11, a12, a13;
	    var a20, a21, a22, a23;
	    if (a === out) {
	        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
	        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
	        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
	        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	    } else {
	        a00 = a[0];
	        a01 = a[1];
	        a02 = a[2];
	        a03 = a[3];
	        a10 = a[4];
	        a11 = a[5];
	        a12 = a[6];
	        a13 = a[7];
	        a20 = a[8];
	        a21 = a[9];
	        a22 = a[10];
	        a23 = a[11];
	        out[0] = a00;
	        out[1] = a01;
	        out[2] = a02;
	        out[3] = a03;
	        out[4] = a10;
	        out[5] = a11;
	        out[6] = a12;
	        out[7] = a13;
	        out[8] = a20;
	        out[9] = a21;
	        out[10] = a22;
	        out[11] = a23;
	        out[12] = a00 * x + a10 * y + a20 * z + a[12];
	        out[13] = a01 * x + a11 * y + a21 * z + a[13];
	        out[14] = a02 * x + a12 * y + a22 * z + a[14];
	        out[15] = a03 * x + a13 * y + a23 * z + a[15];
	    }
	    return out;
	}
	function scale(out, a, v) {
	    var x = v[0], y = v[1], z = v[2];
	    out[0] = a[0] * x;
	    out[1] = a[1] * x;
	    out[2] = a[2] * x;
	    out[3] = a[3] * x;
	    out[4] = a[4] * y;
	    out[5] = a[5] * y;
	    out[6] = a[6] * y;
	    out[7] = a[7] * y;
	    out[8] = a[8] * z;
	    out[9] = a[9] * z;
	    out[10] = a[10] * z;
	    out[11] = a[11] * z;
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	}
	function rotateX(out, a, rad) {
	    var s = Math.sin(rad);
	    var c = Math.cos(rad);
	    var a10 = a[4];
	    var a11 = a[5];
	    var a12 = a[6];
	    var a13 = a[7];
	    var a20 = a[8];
	    var a21 = a[9];
	    var a22 = a[10];
	    var a23 = a[11];
	    if (a !== out) {
	        out[0] = a[0];
	        out[1] = a[1];
	        out[2] = a[2];
	        out[3] = a[3];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }
	    out[4] = a10 * c + a20 * s;
	    out[5] = a11 * c + a21 * s;
	    out[6] = a12 * c + a22 * s;
	    out[7] = a13 * c + a23 * s;
	    out[8] = a20 * c - a10 * s;
	    out[9] = a21 * c - a11 * s;
	    out[10] = a22 * c - a12 * s;
	    out[11] = a23 * c - a13 * s;
	    return out;
	}
	function rotateZ(out, a, rad) {
	    var s = Math.sin(rad);
	    var c = Math.cos(rad);
	    var a00 = a[0];
	    var a01 = a[1];
	    var a02 = a[2];
	    var a03 = a[3];
	    var a10 = a[4];
	    var a11 = a[5];
	    var a12 = a[6];
	    var a13 = a[7];
	    if (a !== out) {
	        out[8] = a[8];
	        out[9] = a[9];
	        out[10] = a[10];
	        out[11] = a[11];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }
	    out[0] = a00 * c + a10 * s;
	    out[1] = a01 * c + a11 * s;
	    out[2] = a02 * c + a12 * s;
	    out[3] = a03 * c + a13 * s;
	    out[4] = a10 * c - a00 * s;
	    out[5] = a11 * c - a01 * s;
	    out[6] = a12 * c - a02 * s;
	    out[7] = a13 * c - a03 * s;
	    return out;
	}
	function perspective(out, fovy, aspect, near, far) {
	    var f = 1 / Math.tan(fovy / 2), nf;
	    out[0] = f / aspect;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = f;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[15] = 0;
	    if (far != null && far !== Infinity) {
	        nf = 1 / (near - far);
	        out[10] = (far + near) * nf;
	        out[14] = 2 * far * near * nf;
	    } else {
	        out[10] = -1;
	        out[14] = -2 * near;
	    }
	    return out;
	}
	function ortho(out, left, right, bottom, top, near, far) {
	    var lr = 1 / (left - right);
	    var bt = 1 / (bottom - top);
	    var nf = 1 / (near - far);
	    out[0] = -2 * lr;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = -2 * bt;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 2 * nf;
	    out[11] = 0;
	    out[12] = (left + right) * lr;
	    out[13] = (top + bottom) * bt;
	    out[14] = (far + near) * nf;
	    out[15] = 1;
	    return out;
	}
	var mul = multiply;

	function create$3() {
	    var out = new ARRAY_TYPE(3);
	    if (ARRAY_TYPE != Float32Array) {
	        out[0] = 0;
	        out[1] = 0;
	        out[2] = 0;
	    }
	    return out;
	}
	function clone$2(a) {
	    var out = new ARRAY_TYPE(3);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    return out;
	}
	function add(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    out[2] = a[2] + b[2];
	    return out;
	}
	function subtract(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    out[2] = a[2] - b[2];
	    return out;
	}
	function scale$1(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    out[2] = a[2] * b;
	    return out;
	}
	function normalize(out, a) {
	    var x = a[0];
	    var y = a[1];
	    var z = a[2];
	    var len = x * x + y * y + z * z;
	    if (len > 0) {
	        len = 1 / Math.sqrt(len);
	    }
	    out[0] = a[0] * len;
	    out[1] = a[1] * len;
	    out[2] = a[2] * len;
	    return out;
	}
	function dot(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	}
	function cross(out, a, b) {
	    var ax = a[0], ay = a[1], az = a[2];
	    var bx = b[0], by = b[1], bz = b[2];
	    out[0] = ay * bz - az * by;
	    out[1] = az * bx - ax * bz;
	    out[2] = ax * by - ay * bx;
	    return out;
	}
	function transformMat3(out, a, m) {
	    var x = a[0], y = a[1], z = a[2];
	    out[0] = x * m[0] + y * m[3] + z * m[6];
	    out[1] = x * m[1] + y * m[4] + z * m[7];
	    out[2] = x * m[2] + y * m[5] + z * m[8];
	    return out;
	}
	var sub = subtract;
	var forEach = function () {
	    var vec = create$3();
	    return function (a, stride, offset, count, fn, arg) {
	        var i, l;
	        if (!stride) {
	            stride = 3;
	        }
	        if (!offset) {
	            offset = 0;
	        }
	        if (count) {
	            l = Math.min(count * stride + offset, a.length);
	        } else {
	            l = a.length;
	        }
	        for (i = offset; i < l; i += stride) {
	            vec[0] = a[i];
	            vec[1] = a[i + 1];
	            vec[2] = a[i + 2];
	            fn(vec, vec, arg);
	            a[i] = vec[0];
	            a[i + 1] = vec[1];
	            a[i + 2] = vec[2];
	        }
	        return a;
	    };
	}();

	function create$4() {
	    var out = new ARRAY_TYPE(4);
	    if (ARRAY_TYPE != Float32Array) {
	        out[0] = 0;
	        out[1] = 0;
	        out[2] = 0;
	        out[3] = 0;
	    }
	    return out;
	}
	function scale$2(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    out[2] = a[2] * b;
	    out[3] = a[3] * b;
	    return out;
	}
	function dot$1(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	}
	function transformMat4(out, a, m) {
	    var x = a[0], y = a[1], z = a[2], w = a[3];
	    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
	    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
	    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
	    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
	    return out;
	}
	var forEach$1 = function () {
	    var vec = create$4();
	    return function (a, stride, offset, count, fn, arg) {
	        var i, l;
	        if (!stride) {
	            stride = 4;
	        }
	        if (!offset) {
	            offset = 0;
	        }
	        if (count) {
	            l = Math.min(count * stride + offset, a.length);
	        } else {
	            l = a.length;
	        }
	        for (i = offset; i < l; i += stride) {
	            vec[0] = a[i];
	            vec[1] = a[i + 1];
	            vec[2] = a[i + 2];
	            vec[3] = a[i + 3];
	            fn(vec, vec, arg);
	            a[i] = vec[0];
	            a[i + 1] = vec[1];
	            a[i + 2] = vec[2];
	            a[i + 3] = vec[3];
	        }
	        return a;
	    };
	}();

	function create$5() {
	    var out = new ARRAY_TYPE(2);
	    if (ARRAY_TYPE != Float32Array) {
	        out[0] = 0;
	        out[1] = 0;
	    }
	    return out;
	}
	function squaredLength(a) {
	    var x = a[0], y = a[1];
	    return x * x + y * y;
	}
	var sqrLen = squaredLength;
	var forEach$2 = function () {
	    var vec = create$5();
	    return function (a, stride, offset, count, fn, arg) {
	        var i, l;
	        if (!stride) {
	            stride = 2;
	        }
	        if (!offset) {
	            offset = 0;
	        }
	        if (count) {
	            l = Math.min(count * stride + offset, a.length);
	        } else {
	            l = a.length;
	        }
	        for (i = offset; i < l; i += stride) {
	            vec[0] = a[i];
	            vec[1] = a[i + 1];
	            fn(vec, vec, arg);
	            a[i] = vec[0];
	            a[i + 1] = vec[1];
	        }
	        return a;
	    };
	}();

	var CircleStyleLayer = function (StyleLayer) {
	    function CircleStyleLayer(layer) {
	        StyleLayer.call(this, layer, properties);
	    }
	    if (StyleLayer)
	        CircleStyleLayer.__proto__ = StyleLayer;
	    CircleStyleLayer.prototype = Object.create(StyleLayer && StyleLayer.prototype);
	    CircleStyleLayer.prototype.constructor = CircleStyleLayer;
	    CircleStyleLayer.prototype.createBucket = function createBucket(parameters) {
	        return new CircleBucket(parameters);
	    };
	    CircleStyleLayer.prototype.queryRadius = function queryRadius(bucket) {
	        var circleBucket = bucket;
	        return getMaximumPaintValue('circle-radius', this, circleBucket) + getMaximumPaintValue('circle-stroke-width', this, circleBucket) + translateDistance(this.paint.get('circle-translate'));
	    };
	    CircleStyleLayer.prototype.queryIntersectsFeature = function queryIntersectsFeature(queryGeometry, feature, featureState, geometry, zoom, transform, pixelsToTileUnits, pixelPosMatrix) {
	        var translatedPolygon = translate(queryGeometry, this.paint.get('circle-translate'), this.paint.get('circle-translate-anchor'), transform.angle, pixelsToTileUnits);
	        var radius = this.paint.get('circle-radius').evaluate(feature, featureState);
	        var stroke = this.paint.get('circle-stroke-width').evaluate(feature, featureState);
	        var size = radius + stroke;
	        var alignWithMap = this.paint.get('circle-pitch-alignment') === 'map';
	        var transformedPolygon = alignWithMap ? translatedPolygon : projectQueryGeometry(translatedPolygon, pixelPosMatrix);
	        var transformedSize = alignWithMap ? size * pixelsToTileUnits : size;
	        for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
	            var ring = list$1[i$1];
	            for (var i = 0, list = ring; i < list.length; i += 1) {
	                var point = list[i];
	                var transformedPoint = alignWithMap ? point : projectPoint(point, pixelPosMatrix);
	                var adjustedSize = transformedSize;
	                var projectedCenter = transformMat4([], [
	                    point.x,
	                    point.y,
	                    0,
	                    1
	                ], pixelPosMatrix);
	                if (this.paint.get('circle-pitch-scale') === 'viewport' && this.paint.get('circle-pitch-alignment') === 'map') {
	                    adjustedSize *= projectedCenter[3] / transform.cameraToCenterDistance;
	                } else if (this.paint.get('circle-pitch-scale') === 'map' && this.paint.get('circle-pitch-alignment') === 'viewport') {
	                    adjustedSize *= transform.cameraToCenterDistance / projectedCenter[3];
	                }
	                if (polygonIntersectsBufferedPoint(transformedPolygon, transformedPoint, adjustedSize)) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    };
	    return CircleStyleLayer;
	}(StyleLayer);
	function projectPoint(p, pixelPosMatrix) {
	    var point = transformMat4([], [
	        p.x,
	        p.y,
	        0,
	        1
	    ], pixelPosMatrix);
	    return new pointGeometry(point[0] / point[3], point[1] / point[3]);
	}
	function projectQueryGeometry(queryGeometry, pixelPosMatrix) {
	    return queryGeometry.map(function (p) {
	        return projectPoint(p, pixelPosMatrix);
	    });
	}

	var HeatmapBucket = function (CircleBucket) {
	    function HeatmapBucket() {
	        CircleBucket.apply(this, arguments);
	    }
	    if (CircleBucket)
	        HeatmapBucket.__proto__ = CircleBucket;
	    HeatmapBucket.prototype = Object.create(CircleBucket && CircleBucket.prototype);
	    HeatmapBucket.prototype.constructor = HeatmapBucket;
	    return HeatmapBucket;
	}(CircleBucket);
	register('HeatmapBucket', HeatmapBucket, { omit: ['layers'] });

	function createImage(image, ref, channels, data) {
	    var width = ref.width;
	    var height = ref.height;
	    if (!data) {
	        data = new Uint8Array(width * height * channels);
	    } else if (data instanceof Uint8ClampedArray) {
	        data = new Uint8Array(data.buffer);
	    } else if (data.length !== width * height * channels) {
	        throw new RangeError('mismatched image size');
	    }
	    image.width = width;
	    image.height = height;
	    image.data = data;
	    return image;
	}
	function resizeImage(image, ref, channels) {
	    var width = ref.width;
	    var height = ref.height;
	    if (width === image.width && height === image.height) {
	        return;
	    }
	    var newImage = createImage({}, {
	        width: width,
	        height: height
	    }, channels);
	    copyImage(image, newImage, {
	        x: 0,
	        y: 0
	    }, {
	        x: 0,
	        y: 0
	    }, {
	        width: Math.min(image.width, width),
	        height: Math.min(image.height, height)
	    }, channels);
	    image.width = width;
	    image.height = height;
	    image.data = newImage.data;
	}
	function copyImage(srcImg, dstImg, srcPt, dstPt, size, channels) {
	    if (size.width === 0 || size.height === 0) {
	        return dstImg;
	    }
	    if (size.width > srcImg.width || size.height > srcImg.height || srcPt.x > srcImg.width - size.width || srcPt.y > srcImg.height - size.height) {
	        throw new RangeError('out of range source coordinates for image copy');
	    }
	    if (size.width > dstImg.width || size.height > dstImg.height || dstPt.x > dstImg.width - size.width || dstPt.y > dstImg.height - size.height) {
	        throw new RangeError('out of range destination coordinates for image copy');
	    }
	    var srcData = srcImg.data;
	    var dstData = dstImg.data;
	    for (var y = 0; y < size.height; y++) {
	        var srcOffset = ((srcPt.y + y) * srcImg.width + srcPt.x) * channels;
	        var dstOffset = ((dstPt.y + y) * dstImg.width + dstPt.x) * channels;
	        for (var i = 0; i < size.width * channels; i++) {
	            dstData[dstOffset + i] = srcData[srcOffset + i];
	        }
	    }
	    return dstImg;
	}
	var AlphaImage = function AlphaImage(size, data) {
	    createImage(this, size, 1, data);
	};
	AlphaImage.prototype.resize = function resize(size) {
	    resizeImage(this, size, 1);
	};
	AlphaImage.prototype.clone = function clone() {
	    return new AlphaImage({
	        width: this.width,
	        height: this.height
	    }, new Uint8Array(this.data));
	};
	AlphaImage.copy = function copy(srcImg, dstImg, srcPt, dstPt, size) {
	    copyImage(srcImg, dstImg, srcPt, dstPt, size, 1);
	};
	var RGBAImage = function RGBAImage(size, data) {
	    createImage(this, size, 4, data);
	};
	RGBAImage.prototype.resize = function resize(size) {
	    resizeImage(this, size, 4);
	};
	RGBAImage.prototype.replace = function replace(data, copy) {
	    if (copy) {
	        this.data.set(data);
	    } else if (data instanceof Uint8ClampedArray) {
	        this.data = new Uint8Array(data.buffer);
	    } else {
	        this.data = data;
	    }
	};
	RGBAImage.prototype.clone = function clone() {
	    return new RGBAImage({
	        width: this.width,
	        height: this.height
	    }, new Uint8Array(this.data));
	};
	RGBAImage.copy = function copy(srcImg, dstImg, srcPt, dstPt, size) {
	    copyImage(srcImg, dstImg, srcPt, dstPt, size, 4);
	};
	register('AlphaImage', AlphaImage);
	register('RGBAImage', RGBAImage);

	var paint$2 = new Properties({
	    'heatmap-radius': new DataDrivenProperty(spec['paint_heatmap']['heatmap-radius']),
	    'heatmap-weight': new DataDrivenProperty(spec['paint_heatmap']['heatmap-weight']),
	    'heatmap-intensity': new DataConstantProperty(spec['paint_heatmap']['heatmap-intensity']),
	    'heatmap-color': new ColorRampProperty(spec['paint_heatmap']['heatmap-color']),
	    'heatmap-opacity': new DataConstantProperty(spec['paint_heatmap']['heatmap-opacity'])
	});
	var properties$1 = { paint: paint$2 };

	function renderColorRamp(params) {
	    var evaluationGlobals = {};
	    var width = params.resolution || 256;
	    var height = params.clips ? params.clips.length : 1;
	    var image = params.image || new RGBAImage({
	        width: width,
	        height: height
	    });
	    var renderPixel = function (stride, index, progress) {
	        evaluationGlobals[params.evaluationKey] = progress;
	        var pxColor = params.expression.evaluate(evaluationGlobals);
	        image.data[stride + index + 0] = Math.floor(pxColor.r * 255 / pxColor.a);
	        image.data[stride + index + 1] = Math.floor(pxColor.g * 255 / pxColor.a);
	        image.data[stride + index + 2] = Math.floor(pxColor.b * 255 / pxColor.a);
	        image.data[stride + index + 3] = Math.floor(pxColor.a * 255);
	    };
	    if (!params.clips) {
	        for (var i = 0, j = 0; i < width; i++, j += 4) {
	            var progress = i / (width - 1);
	            renderPixel(0, j, progress);
	        }
	    } else {
	        for (var clip = 0, stride = 0; clip < height; ++clip, stride += width * 4) {
	            for (var i$1 = 0, j$1 = 0; i$1 < width; i$1++, j$1 += 4) {
	                var progress$1 = i$1 / (width - 1);
	                var ref = params.clips[clip];
	                var start = ref.start;
	                var end = ref.end;
	                var evaluationProgress = start * (1 - progress$1) + end * progress$1;
	                renderPixel(stride, j$1, evaluationProgress);
	            }
	        }
	    }
	    return image;
	}

	var HeatmapStyleLayer = function (StyleLayer) {
	    function HeatmapStyleLayer(layer) {
	        StyleLayer.call(this, layer, properties$1);
	        this._updateColorRamp();
	    }
	    if (StyleLayer)
	        HeatmapStyleLayer.__proto__ = StyleLayer;
	    HeatmapStyleLayer.prototype = Object.create(StyleLayer && StyleLayer.prototype);
	    HeatmapStyleLayer.prototype.constructor = HeatmapStyleLayer;
	    HeatmapStyleLayer.prototype.createBucket = function createBucket(options) {
	        return new HeatmapBucket(options);
	    };
	    HeatmapStyleLayer.prototype._handleSpecialPaintPropertyUpdate = function _handleSpecialPaintPropertyUpdate(name) {
	        if (name === 'heatmap-color') {
	            this._updateColorRamp();
	        }
	    };
	    HeatmapStyleLayer.prototype._updateColorRamp = function _updateColorRamp() {
	        var expression = this._transitionablePaint._values['heatmap-color'].value.expression;
	        this.colorRamp = renderColorRamp({
	            expression: expression,
	            evaluationKey: 'heatmapDensity',
	            image: this.colorRamp
	        });
	        this.colorRampTexture = null;
	    };
	    HeatmapStyleLayer.prototype.resize = function resize() {
	        if (this.heatmapFbo) {
	            this.heatmapFbo.destroy();
	            this.heatmapFbo = null;
	        }
	    };
	    HeatmapStyleLayer.prototype.queryRadius = function queryRadius() {
	        return 0;
	    };
	    HeatmapStyleLayer.prototype.queryIntersectsFeature = function queryIntersectsFeature() {
	        return false;
	    };
	    HeatmapStyleLayer.prototype.hasOffscreenPass = function hasOffscreenPass() {
	        return this.paint.get('heatmap-opacity') !== 0 && this.visibility !== 'none';
	    };
	    return HeatmapStyleLayer;
	}(StyleLayer);

	var paint$3 = new Properties({
	    'hillshade-illumination-direction': new DataConstantProperty(spec['paint_hillshade']['hillshade-illumination-direction']),
	    'hillshade-illumination-anchor': new DataConstantProperty(spec['paint_hillshade']['hillshade-illumination-anchor']),
	    'hillshade-exaggeration': new DataConstantProperty(spec['paint_hillshade']['hillshade-exaggeration']),
	    'hillshade-shadow-color': new DataConstantProperty(spec['paint_hillshade']['hillshade-shadow-color']),
	    'hillshade-highlight-color': new DataConstantProperty(spec['paint_hillshade']['hillshade-highlight-color']),
	    'hillshade-accent-color': new DataConstantProperty(spec['paint_hillshade']['hillshade-accent-color'])
	});
	var properties$2 = { paint: paint$3 };

	var HillshadeStyleLayer = function (StyleLayer) {
	    function HillshadeStyleLayer(layer) {
	        StyleLayer.call(this, layer, properties$2);
	    }
	    if (StyleLayer)
	        HillshadeStyleLayer.__proto__ = StyleLayer;
	    HillshadeStyleLayer.prototype = Object.create(StyleLayer && StyleLayer.prototype);
	    HillshadeStyleLayer.prototype.constructor = HillshadeStyleLayer;
	    HillshadeStyleLayer.prototype.hasOffscreenPass = function hasOffscreenPass() {
	        return this.paint.get('hillshade-exaggeration') !== 0 && this.visibility !== 'none';
	    };
	    return HillshadeStyleLayer;
	}(StyleLayer);

	var layout$3 = createLayout([{
	        name: 'a_pos',
	        components: 2,
	        type: 'Int16'
	    }], 4);
	var members$1 = layout$3.members;

	var earcut_1 = earcut;
	var default_1 = earcut;
	function earcut(data, holeIndices, dim) {
	    dim = dim || 2;
	    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
	    if (!outerNode || outerNode.next === outerNode.prev) {
	        return triangles;
	    }
	    var minX, minY, maxX, maxY, x, y, invSize;
	    if (hasHoles) {
	        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
	    }
	    if (data.length > 80 * dim) {
	        minX = maxX = data[0];
	        minY = maxY = data[1];
	        for (var i = dim; i < outerLen; i += dim) {
	            x = data[i];
	            y = data[i + 1];
	            if (x < minX) {
	                minX = x;
	            }
	            if (y < minY) {
	                minY = y;
	            }
	            if (x > maxX) {
	                maxX = x;
	            }
	            if (y > maxY) {
	                maxY = y;
	            }
	        }
	        invSize = Math.max(maxX - minX, maxY - minY);
	        invSize = invSize !== 0 ? 1 / invSize : 0;
	    }
	    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
	    return triangles;
	}
	function linkedList(data, start, end, dim, clockwise) {
	    var i, last;
	    if (clockwise === signedArea(data, start, end, dim) > 0) {
	        for (i = start; i < end; i += dim) {
	            last = insertNode(i, data[i], data[i + 1], last);
	        }
	    } else {
	        for (i = end - dim; i >= start; i -= dim) {
	            last = insertNode(i, data[i], data[i + 1], last);
	        }
	    }
	    if (last && equals(last, last.next)) {
	        removeNode(last);
	        last = last.next;
	    }
	    return last;
	}
	function filterPoints(start, end) {
	    if (!start) {
	        return start;
	    }
	    if (!end) {
	        end = start;
	    }
	    var p = start, again;
	    do {
	        again = false;
	        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
	            removeNode(p);
	            p = end = p.prev;
	            if (p === p.next) {
	                break;
	            }
	            again = true;
	        } else {
	            p = p.next;
	        }
	    } while (again || p !== end);
	    return end;
	}
	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
	    if (!ear) {
	        return;
	    }
	    if (!pass && invSize) {
	        indexCurve(ear, minX, minY, invSize);
	    }
	    var stop = ear, prev, next;
	    while (ear.prev !== ear.next) {
	        prev = ear.prev;
	        next = ear.next;
	        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
	            triangles.push(prev.i / dim);
	            triangles.push(ear.i / dim);
	            triangles.push(next.i / dim);
	            removeNode(ear);
	            ear = next.next;
	            stop = next.next;
	            continue;
	        }
	        ear = next;
	        if (ear === stop) {
	            if (!pass) {
	                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
	            } else if (pass === 1) {
	                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
	                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
	            } else if (pass === 2) {
	                splitEarcut(ear, triangles, dim, minX, minY, invSize);
	            }
	            break;
	        }
	    }
	}
	function isEar(ear) {
	    var a = ear.prev, b = ear, c = ear.next;
	    if (area(a, b, c) >= 0) {
	        return false;
	    }
	    var p = ear.next.next;
	    while (p !== ear.prev) {
	        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
	            return false;
	        }
	        p = p.next;
	    }
	    return true;
	}
	function isEarHashed(ear, minX, minY, invSize) {
	    var a = ear.prev, b = ear, c = ear.next;
	    if (area(a, b, c) >= 0) {
	        return false;
	    }
	    var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
	    var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
	    var p = ear.prevZ, n = ear.nextZ;
	    while (p && p.z >= minZ && n && n.z <= maxZ) {
	        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
	            return false;
	        }
	        p = p.prevZ;
	        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) {
	            return false;
	        }
	        n = n.nextZ;
	    }
	    while (p && p.z >= minZ) {
	        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
	            return false;
	        }
	        p = p.prevZ;
	    }
	    while (n && n.z <= maxZ) {
	        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) {
	            return false;
	        }
	        n = n.nextZ;
	    }
	    return true;
	}
	function cureLocalIntersections(start, triangles, dim) {
	    var p = start;
	    do {
	        var a = p.prev, b = p.next.next;
	        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
	            triangles.push(a.i / dim);
	            triangles.push(p.i / dim);
	            triangles.push(b.i / dim);
	            removeNode(p);
	            removeNode(p.next);
	            p = start = b;
	        }
	        p = p.next;
	    } while (p !== start);
	    return filterPoints(p);
	}
	function splitEarcut(start, triangles, dim, minX, minY, invSize) {
	    var a = start;
	    do {
	        var b = a.next.next;
	        while (b !== a.prev) {
	            if (a.i !== b.i && isValidDiagonal(a, b)) {
	                var c = splitPolygon(a, b);
	                a = filterPoints(a, a.next);
	                c = filterPoints(c, c.next);
	                earcutLinked(a, triangles, dim, minX, minY, invSize);
	                earcutLinked(c, triangles, dim, minX, minY, invSize);
	                return;
	            }
	            b = b.next;
	        }
	        a = a.next;
	    } while (a !== start);
	}
	function eliminateHoles(data, holeIndices, outerNode, dim) {
	    var queue = [], i, len, start, end, list;
	    for (i = 0, len = holeIndices.length; i < len; i++) {
	        start = holeIndices[i] * dim;
	        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	        list = linkedList(data, start, end, dim, false);
	        if (list === list.next) {
	            list.steiner = true;
	        }
	        queue.push(getLeftmost(list));
	    }
	    queue.sort(compareX);
	    for (i = 0; i < queue.length; i++) {
	        outerNode = eliminateHole(queue[i], outerNode);
	        outerNode = filterPoints(outerNode, outerNode.next);
	    }
	    return outerNode;
	}
	function compareX(a, b) {
	    return a.x - b.x;
	}
	function eliminateHole(hole, outerNode) {
	    var bridge = findHoleBridge(hole, outerNode);
	    if (!bridge) {
	        return outerNode;
	    }
	    var bridgeReverse = splitPolygon(bridge, hole);
	    var filteredBridge = filterPoints(bridge, bridge.next);
	    filterPoints(bridgeReverse, bridgeReverse.next);
	    return outerNode === bridge ? filteredBridge : outerNode;
	}
	function findHoleBridge(hole, outerNode) {
	    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
	    do {
	        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
	            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
	            if (x <= hx && x > qx) {
	                qx = x;
	                if (x === hx) {
	                    if (hy === p.y) {
	                        return p;
	                    }
	                    if (hy === p.next.y) {
	                        return p.next;
	                    }
	                }
	                m = p.x < p.next.x ? p : p.next;
	            }
	        }
	        p = p.next;
	    } while (p !== outerNode);
	    if (!m) {
	        return null;
	    }
	    if (hx === qx) {
	        return m;
	    }
	    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
	    p = m;
	    do {
	        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
	            tan = Math.abs(hy - p.y) / (hx - p.x);
	            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
	                m = p;
	                tanMin = tan;
	            }
	        }
	        p = p.next;
	    } while (p !== stop);
	    return m;
	}
	function sectorContainsSector(m, p) {
	    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
	}
	function indexCurve(start, minX, minY, invSize) {
	    var p = start;
	    do {
	        if (p.z === null) {
	            p.z = zOrder(p.x, p.y, minX, minY, invSize);
	        }
	        p.prevZ = p.prev;
	        p.nextZ = p.next;
	        p = p.next;
	    } while (p !== start);
	    p.prevZ.nextZ = null;
	    p.prevZ = null;
	    sortLinked(p);
	}
	function sortLinked(list) {
	    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
	    do {
	        p = list;
	        list = null;
	        tail = null;
	        numMerges = 0;
	        while (p) {
	            numMerges++;
	            q = p;
	            pSize = 0;
	            for (i = 0; i < inSize; i++) {
	                pSize++;
	                q = q.nextZ;
	                if (!q) {
	                    break;
	                }
	            }
	            qSize = inSize;
	            while (pSize > 0 || qSize > 0 && q) {
	                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
	                    e = p;
	                    p = p.nextZ;
	                    pSize--;
	                } else {
	                    e = q;
	                    q = q.nextZ;
	                    qSize--;
	                }
	                if (tail) {
	                    tail.nextZ = e;
	                } else {
	                    list = e;
	                }
	                e.prevZ = tail;
	                tail = e;
	            }
	            p = q;
	        }
	        tail.nextZ = null;
	        inSize *= 2;
	    } while (numMerges > 1);
	    return list;
	}
	function zOrder(x, y, minX, minY, invSize) {
	    x = 32767 * (x - minX) * invSize;
	    y = 32767 * (y - minY) * invSize;
	    x = (x | x << 8) & 16711935;
	    x = (x | x << 4) & 252645135;
	    x = (x | x << 2) & 858993459;
	    x = (x | x << 1) & 1431655765;
	    y = (y | y << 8) & 16711935;
	    y = (y | y << 4) & 252645135;
	    y = (y | y << 2) & 858993459;
	    y = (y | y << 1) & 1431655765;
	    return x | y << 1;
	}
	function getLeftmost(start) {
	    var p = start, leftmost = start;
	    do {
	        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) {
	            leftmost = p;
	        }
	        p = p.next;
	    } while (p !== start);
	    return leftmost;
	}
	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
	    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	}
	function isValidDiagonal(a, b) {
	    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
	}
	function area(p, q, r) {
	    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	}
	function equals(p1, p2) {
	    return p1.x === p2.x && p1.y === p2.y;
	}
	function intersects(p1, q1, p2, q2) {
	    var o1 = sign(area(p1, q1, p2));
	    var o2 = sign(area(p1, q1, q2));
	    var o3 = sign(area(p2, q2, p1));
	    var o4 = sign(area(p2, q2, q1));
	    if (o1 !== o2 && o3 !== o4) {
	        return true;
	    }
	    if (o1 === 0 && onSegment(p1, p2, q1)) {
	        return true;
	    }
	    if (o2 === 0 && onSegment(p1, q2, q1)) {
	        return true;
	    }
	    if (o3 === 0 && onSegment(p2, p1, q2)) {
	        return true;
	    }
	    if (o4 === 0 && onSegment(p2, q1, q2)) {
	        return true;
	    }
	    return false;
	}
	function onSegment(p, q, r) {
	    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
	}
	function sign(num) {
	    return num > 0 ? 1 : num < 0 ? -1 : 0;
	}
	function intersectsPolygon(a, b) {
	    var p = a;
	    do {
	        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
	            return true;
	        }
	        p = p.next;
	    } while (p !== a);
	    return false;
	}
	function locallyInside(a, b) {
	    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	}
	function middleInside(a, b) {
	    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
	    do {
	        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
	            inside = !inside;
	        }
	        p = p.next;
	    } while (p !== a);
	    return inside;
	}
	function splitPolygon(a, b) {
	    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
	    a.next = b;
	    b.prev = a;
	    a2.next = an;
	    an.prev = a2;
	    b2.next = a2;
	    a2.prev = b2;
	    bp.next = b2;
	    b2.prev = bp;
	    return b2;
	}
	function insertNode(i, x, y, last) {
	    var p = new Node(i, x, y);
	    if (!last) {
	        p.prev = p;
	        p.next = p;
	    } else {
	        p.next = last.next;
	        p.prev = last;
	        last.next.prev = p;
	        last.next = p;
	    }
	    return p;
	}
	function removeNode(p) {
	    p.next.prev = p.prev;
	    p.prev.next = p.next;
	    if (p.prevZ) {
	        p.prevZ.nextZ = p.nextZ;
	    }
	    if (p.nextZ) {
	        p.nextZ.prevZ = p.prevZ;
	    }
	}
	function Node(i, x, y) {
	    this.i = i;
	    this.x = x;
	    this.y = y;
	    this.prev = null;
	    this.next = null;
	    this.z = null;
	    this.prevZ = null;
	    this.nextZ = null;
	    this.steiner = false;
	}
	earcut.deviation = function (data, holeIndices, dim, triangles) {
	    var hasHoles = holeIndices && holeIndices.length;
	    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
	    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
	    if (hasHoles) {
	        for (var i = 0, len = holeIndices.length; i < len; i++) {
	            var start = holeIndices[i] * dim;
	            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	            polygonArea -= Math.abs(signedArea(data, start, end, dim));
	        }
	    }
	    var trianglesArea = 0;
	    for (i = 0; i < triangles.length; i += 3) {
	        var a = triangles[i] * dim;
	        var b = triangles[i + 1] * dim;
	        var c = triangles[i + 2] * dim;
	        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
	    }
	    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
	};
	function signedArea(data, start, end, dim) {
	    var sum = 0;
	    for (var i = start, j = end - dim; i < end; i += dim) {
	        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
	        j = i;
	    }
	    return sum;
	}
	earcut.flatten = function (data) {
	    var dim = data[0][0].length, result = {
	            vertices: [],
	            holes: [],
	            dimensions: dim
	        }, holeIndex = 0;
	    for (var i = 0; i < data.length; i++) {
	        for (var j = 0; j < data[i].length; j++) {
	            for (var d = 0; d < dim; d++) {
	                result.vertices.push(data[i][j][d]);
	            }
	        }
	        if (i > 0) {
	            holeIndex += data[i - 1].length;
	            result.holes.push(holeIndex);
	        }
	    }
	    return result;
	};
	earcut_1.default = default_1;

	function quickselect(arr, k, left, right, compare) {
	    quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
	}
	function quickselectStep(arr, k, left, right, compare) {
	    while (right > left) {
	        if (right - left > 600) {
	            var n = right - left + 1;
	            var m = k - left + 1;
	            var z = Math.log(n);
	            var s = 0.5 * Math.exp(2 * z / 3);
	            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
	            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
	            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
	            quickselectStep(arr, k, newLeft, newRight, compare);
	        }
	        var t = arr[k];
	        var i = left;
	        var j = right;
	        swap$1(arr, left, k);
	        if (compare(arr[right], t) > 0) {
	            swap$1(arr, left, right);
	        }
	        while (i < j) {
	            swap$1(arr, i, j);
	            i++;
	            j--;
	            while (compare(arr[i], t) < 0) {
	                i++;
	            }
	            while (compare(arr[j], t) > 0) {
	                j--;
	            }
	        }
	        if (compare(arr[left], t) === 0) {
	            swap$1(arr, left, j);
	        } else {
	            j++;
	            swap$1(arr, j, right);
	        }
	        if (j <= k) {
	            left = j + 1;
	        }
	        if (k <= j) {
	            right = j - 1;
	        }
	    }
	}
	function swap$1(arr, i, j) {
	    var tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}
	function defaultCompare(a, b) {
	    return a < b ? -1 : a > b ? 1 : 0;
	}

	function classifyRings(rings, maxRings) {
	    var len = rings.length;
	    if (len <= 1) {
	        return [rings];
	    }
	    var polygons = [];
	    var polygon, ccw;
	    for (var i = 0; i < len; i++) {
	        var area = calculateSignedArea(rings[i]);
	        if (area === 0) {
	            continue;
	        }
	        rings[i].area = Math.abs(area);
	        if (ccw === undefined) {
	            ccw = area < 0;
	        }
	        if (ccw === area < 0) {
	            if (polygon) {
	                polygons.push(polygon);
	            }
	            polygon = [rings[i]];
	        } else {
	            polygon.push(rings[i]);
	        }
	    }
	    if (polygon) {
	        polygons.push(polygon);
	    }
	    if (maxRings > 1) {
	        for (var j = 0; j < polygons.length; j++) {
	            if (polygons[j].length <= maxRings) {
	                continue;
	            }
	            quickselect(polygons[j], maxRings, 1, polygons[j].length - 1, compareAreas);
	            polygons[j] = polygons[j].slice(0, maxRings);
	        }
	    }
	    return polygons;
	}
	function compareAreas(a, b) {
	    return b.area - a.area;
	}

	function hasPattern(type, layers, options) {
	    var patterns = options.patternDependencies;
	    var hasPattern = false;
	    for (var i = 0, list = layers; i < list.length; i += 1) {
	        var layer = list[i];
	        var patternProperty = layer.paint.get(type + '-pattern');
	        if (!patternProperty.isConstant()) {
	            hasPattern = true;
	        }
	        var constantPattern = patternProperty.constantOr(null);
	        if (constantPattern) {
	            hasPattern = true;
	            patterns[constantPattern.to] = true;
	            patterns[constantPattern.from] = true;
	        }
	    }
	    return hasPattern;
	}
	function addPatternDependencies(type, layers, patternFeature, zoom, options) {
	    var patterns = options.patternDependencies;
	    for (var i = 0, list = layers; i < list.length; i += 1) {
	        var layer = list[i];
	        var patternProperty = layer.paint.get(type + '-pattern');
	        var patternPropertyValue = patternProperty.value;
	        if (patternPropertyValue.kind !== 'constant') {
	            var min = patternPropertyValue.evaluate({ zoom: zoom - 1 }, patternFeature, {}, options.availableImages);
	            var mid = patternPropertyValue.evaluate({ zoom: zoom }, patternFeature, {}, options.availableImages);
	            var max = patternPropertyValue.evaluate({ zoom: zoom + 1 }, patternFeature, {}, options.availableImages);
	            min = min && min.name ? min.name : min;
	            mid = mid && mid.name ? mid.name : mid;
	            max = max && max.name ? max.name : max;
	            patterns[min] = true;
	            patterns[mid] = true;
	            patterns[max] = true;
	            patternFeature.patterns[layer.id] = {
	                min: min,
	                mid: mid,
	                max: max
	            };
	        }
	    }
	    return patternFeature;
	}

	var EARCUT_MAX_RINGS = 500;
	var FillBucket = function FillBucket(options) {
	    this.zoom = options.zoom;
	    this.overscaling = options.overscaling;
	    this.layers = options.layers;
	    this.layerIds = this.layers.map(function (layer) {
	        return layer.id;
	    });
	    this.index = options.index;
	    this.hasPattern = false;
	    this.patternFeatures = [];
	    this.layoutVertexArray = new StructArrayLayout2i4();
	    this.indexArray = new StructArrayLayout3ui6();
	    this.indexArray2 = new StructArrayLayout2ui4();
	    this.programConfigurations = new ProgramConfigurationSet(options.layers, options.zoom);
	    this.segments = new SegmentVector();
	    this.segments2 = new SegmentVector();
	    this.stateDependentLayerIds = this.layers.filter(function (l) {
	        return l.isStateDependent();
	    }).map(function (l) {
	        return l.id;
	    });
	};
	FillBucket.prototype.populate = function populate(features, options, canonical) {
	    this.hasPattern = hasPattern('fill', this.layers, options);
	    var fillSortKey = this.layers[0].layout.get('fill-sort-key');
	    var bucketFeatures = [];
	    for (var i = 0, list = features; i < list.length; i += 1) {
	        var ref = list[i];
	        var feature = ref.feature;
	        var id = ref.id;
	        var index = ref.index;
	        var sourceLayerIndex = ref.sourceLayerIndex;
	        var needGeometry = this.layers[0]._featureFilter.needGeometry;
	        var evaluationFeature = toEvaluationFeature(feature, needGeometry);
	        if (!this.layers[0]._featureFilter.filter(new EvaluationParameters(this.zoom), evaluationFeature, canonical)) {
	            continue;
	        }
	        var sortKey = fillSortKey ? fillSortKey.evaluate(evaluationFeature, {}, canonical, options.availableImages) : undefined;
	        var bucketFeature = {
	            id: id,
	            properties: feature.properties,
	            type: feature.type,
	            sourceLayerIndex: sourceLayerIndex,
	            index: index,
	            geometry: needGeometry ? evaluationFeature.geometry : loadGeometry(feature),
	            patterns: {},
	            sortKey: sortKey
	        };
	        bucketFeatures.push(bucketFeature);
	    }
	    if (fillSortKey) {
	        bucketFeatures.sort(function (a, b) {
	            return a.sortKey - b.sortKey;
	        });
	    }
	    for (var i$1 = 0, list$1 = bucketFeatures; i$1 < list$1.length; i$1 += 1) {
	        var bucketFeature$1 = list$1[i$1];
	        var ref$1 = bucketFeature$1;
	        var geometry = ref$1.geometry;
	        var index$1 = ref$1.index;
	        var sourceLayerIndex$1 = ref$1.sourceLayerIndex;
	        if (this.hasPattern) {
	            var patternFeature = addPatternDependencies('fill', this.layers, bucketFeature$1, this.zoom, options);
	            this.patternFeatures.push(patternFeature);
	        } else {
	            this.addFeature(bucketFeature$1, geometry, index$1, canonical, {});
	        }
	        var feature$1 = features[index$1].feature;
	        options.featureIndex.insert(feature$1, geometry, index$1, sourceLayerIndex$1, this.index);
	    }
	};
	FillBucket.prototype.update = function update(states, vtLayer, imagePositions) {
	    if (!this.stateDependentLayers.length) {
	        return;
	    }
	    this.programConfigurations.updatePaintArrays(states, vtLayer, this.stateDependentLayers, imagePositions);
	};
	FillBucket.prototype.addFeatures = function addFeatures(options, canonical, imagePositions) {
	    for (var i = 0, list = this.patternFeatures; i < list.length; i += 1) {
	        var feature = list[i];
	        this.addFeature(feature, feature.geometry, feature.index, canonical, imagePositions);
	    }
	};
	FillBucket.prototype.isEmpty = function isEmpty() {
	    return this.layoutVertexArray.length === 0;
	};
	FillBucket.prototype.uploadPending = function uploadPending() {
	    return !this.uploaded || this.programConfigurations.needsUpload;
	};
	FillBucket.prototype.upload = function upload(context) {
	    if (!this.uploaded) {
	        this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, members$1);
	        this.indexBuffer = context.createIndexBuffer(this.indexArray);
	        this.indexBuffer2 = context.createIndexBuffer(this.indexArray2);
	    }
	    this.programConfigurations.upload(context);
	    this.uploaded = true;
	};
	FillBucket.prototype.destroy = function destroy() {
	    if (!this.layoutVertexBuffer) {
	        return;
	    }
	    this.layoutVertexBuffer.destroy();
	    this.indexBuffer.destroy();
	    this.indexBuffer2.destroy();
	    this.programConfigurations.destroy();
	    this.segments.destroy();
	    this.segments2.destroy();
	};
	FillBucket.prototype.addFeature = function addFeature(feature, geometry, index, canonical, imagePositions) {
	    for (var i$4 = 0, list$2 = classifyRings(geometry, EARCUT_MAX_RINGS); i$4 < list$2.length; i$4 += 1) {
	        var polygon = list$2[i$4];
	        var numVertices = 0;
	        for (var i$2 = 0, list = polygon; i$2 < list.length; i$2 += 1) {
	            var ring = list[i$2];
	            numVertices += ring.length;
	        }
	        var triangleSegment = this.segments.prepareSegment(numVertices, this.layoutVertexArray, this.indexArray);
	        var triangleIndex = triangleSegment.vertexLength;
	        var flattened = [];
	        var holeIndices = [];
	        for (var i$3 = 0, list$1 = polygon; i$3 < list$1.length; i$3 += 1) {
	            var ring$1 = list$1[i$3];
	            if (ring$1.length === 0) {
	                continue;
	            }
	            if (ring$1 !== polygon[0]) {
	                holeIndices.push(flattened.length / 2);
	            }
	            var lineSegment = this.segments2.prepareSegment(ring$1.length, this.layoutVertexArray, this.indexArray2);
	            var lineIndex = lineSegment.vertexLength;
	            this.layoutVertexArray.emplaceBack(ring$1[0].x, ring$1[0].y);
	            this.indexArray2.emplaceBack(lineIndex + ring$1.length - 1, lineIndex);
	            flattened.push(ring$1[0].x);
	            flattened.push(ring$1[0].y);
	            for (var i = 1; i < ring$1.length; i++) {
	                this.layoutVertexArray.emplaceBack(ring$1[i].x, ring$1[i].y);
	                this.indexArray2.emplaceBack(lineIndex + i - 1, lineIndex + i);
	                flattened.push(ring$1[i].x);
	                flattened.push(ring$1[i].y);
	            }
	            lineSegment.vertexLength += ring$1.length;
	            lineSegment.primitiveLength += ring$1.length;
	        }
	        var indices = earcut_1(flattened, holeIndices);
	        for (var i$1 = 0; i$1 < indices.length; i$1 += 3) {
	            this.indexArray.emplaceBack(triangleIndex + indices[i$1], triangleIndex + indices[i$1 + 1], triangleIndex + indices[i$1 + 2]);
	        }
	        triangleSegment.vertexLength += numVertices;
	        triangleSegment.primitiveLength += indices.length / 3;
	    }
	    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, feature, index, imagePositions, canonical);
	};
	register('FillBucket', FillBucket, {
	    omit: [
	        'layers',
	        'patternFeatures'
	    ]
	});

	var layout$4 = new Properties({ 'fill-sort-key': new DataDrivenProperty(spec['layout_fill']['fill-sort-key']) });
	var paint$4 = new Properties({
	    'fill-antialias': new DataConstantProperty(spec['paint_fill']['fill-antialias']),
	    'fill-opacity': new DataDrivenProperty(spec['paint_fill']['fill-opacity']),
	    'fill-color': new DataDrivenProperty(spec['paint_fill']['fill-color']),
	    'fill-outline-color': new DataDrivenProperty(spec['paint_fill']['fill-outline-color']),
	    'fill-translate': new DataConstantProperty(spec['paint_fill']['fill-translate']),
	    'fill-translate-anchor': new DataConstantProperty(spec['paint_fill']['fill-translate-anchor']),
	    'fill-pattern': new CrossFadedDataDrivenProperty(spec['paint_fill']['fill-pattern'])
	});
	var properties$3 = {
	    paint: paint$4,
	    layout: layout$4
	};

	var FillStyleLayer = function (StyleLayer) {
	    function FillStyleLayer(layer) {
	        StyleLayer.call(this, layer, properties$3);
	    }
	    if (StyleLayer)
	        FillStyleLayer.__proto__ = StyleLayer;
	    FillStyleLayer.prototype = Object.create(StyleLayer && StyleLayer.prototype);
	    FillStyleLayer.prototype.constructor = FillStyleLayer;
	    FillStyleLayer.prototype.recalculate = function recalculate(parameters, availableImages) {
	        StyleLayer.prototype.recalculate.call(this, parameters, availableImages);
	        var outlineColor = this.paint._values['fill-outline-color'];
	        if (outlineColor.value.kind === 'constant' && outlineColor.value.value === undefined) {
	            this.paint._values['fill-outline-color'] = this.paint._values['fill-color'];
	        }
	    };
	    FillStyleLayer.prototype.createBucket = function createBucket(parameters) {
	        return new FillBucket(parameters);
	    };
	    FillStyleLayer.prototype.queryRadius = function queryRadius() {
	        return translateDistance(this.paint.get('fill-translate'));
	    };
	    FillStyleLayer.prototype.queryIntersectsFeature = function queryIntersectsFeature(queryGeometry, feature, featureState, geometry, zoom, transform, pixelsToTileUnits) {
	        var translatedPolygon = translate(queryGeometry, this.paint.get('fill-translate'), this.paint.get('fill-translate-anchor'), transform.angle, pixelsToTileUnits);
	        return polygonIntersectsMultiPolygon(translatedPolygon, geometry);
	    };
	    FillStyleLayer.prototype.isTileClipped = function isTileClipped() {
	        return true;
	    };
	    return FillStyleLayer;
	}(StyleLayer);

	var layout$5 = createLayout([
	    {
	        name: 'a_pos',
	        components: 2,
	        type: 'Int16'
	    },
	    {
	        name: 'a_normal_ed',
	        components: 4,
	        type: 'Int16'
	    }
	], 4);
	var members$2 = layout$5.members;

	var vectortilefeature = VectorTileFeature;
	function VectorTileFeature(pbf, end, extent, keys, values) {
	    this.properties = {};
	    this.extent = extent;
	    this.type = 0;
	    this._pbf = pbf;
	    this._geometry = -1;
	    this._keys = keys;
	    this._values = values;
	    pbf.readFields(readFeature, this, end);
	}
	function readFeature(tag, feature, pbf) {
	    if (tag == 1) {
	        feature.id = pbf.readVarint();
	    } else if (tag == 2) {
	        readTag(pbf, feature);
	    } else if (tag == 3) {
	        feature.type = pbf.readVarint();
	    } else if (tag == 4) {
	        feature._geometry = pbf.pos;
	    }
	}
	function readTag(pbf, feature) {
	    var end = pbf.readVarint() + pbf.pos;
	    while (pbf.pos < end) {
	        var key = feature._keys[pbf.readVarint()], value = feature._values[pbf.readVarint()];
	        feature.properties[key] = value;
	    }
	}
	VectorTileFeature.types = [
	    'Unknown',
	    'Point',
	    'LineString',
	    'Polygon'
	];
	VectorTileFeature.prototype.loadGeometry = function () {
	    var pbf = this._pbf;
	    pbf.pos = this._geometry;
	    var end = pbf.readVarint() + pbf.pos, cmd = 1, length = 0, x = 0, y = 0, lines = [], line;
	    while (pbf.pos < end) {
	        if (length <= 0) {
	            var cmdLen = pbf.readVarint();
	            cmd = cmdLen & 7;
	            length = cmdLen >> 3;
	        }
	        length--;
	        if (cmd === 1 || cmd === 2) {
	            x += pbf.readSVarint();
	            y += pbf.readSVarint();
	            if (cmd === 1) {
	                if (line) {
	                    lines.push(line);
	                }
	                line = [];
	            }
	            line.push(new pointGeometry(x, y));
	        } else if (cmd === 7) {
	            if (line) {
	                line.push(line[0].clone());
	            }
	        } else {
	            throw new Error('unknown command ' + cmd);
	        }
	    }
	    if (line) {
	        lines.push(line);
	    }
	    return lines;
	};
	VectorTileFeature.prototype.bbox = function () {
	    var pbf = this._pbf;
	    pbf.pos = this._geometry;
	    var end = pbf.readVarint() + pbf.pos, cmd = 1, length = 0, x = 0, y = 0, x1 = Infinity, x2 = -Infinity, y1 = Infinity, y2 = -Infinity;
	    while (pbf.pos < end) {
	        if (length <= 0) {
	            var cmdLen = pbf.readVarint();
	            cmd = cmdLen & 7;
	            length = cmdLen >> 3;
	        }
	        length--;
	        if (cmd === 1 || cmd === 2) {
	            x += pbf.readSVarint();
	            y += pbf.readSVarint();
	            if (x < x1) {
	                x1 = x;
	            }
	            if (x > x2) {
	                x2 = x;
	            }
	            if (y < y1) {
	                y1 = y;
	            }
	            if (y > y2) {
	                y2 = y;
	            }
	        } else if (cmd !== 7) {
	            throw new Error('unknown command ' + cmd);
	        }
	    }
	    return [
	        x1,
	        y1,
	        x2,
	        y2
	    ];
	};
	VectorTileFeature.prototype.toGeoJSON = function (x, y, z) {
	    var size = this.extent * Math.pow(2, z), x0 = this.extent * x, y0 = this.extent * y, coords = this.loadGeometry(), type = VectorTileFeature.types[this.type], i, j;
	    function project(line) {
	        for (var j = 0; j < line.length; j++) {
	            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
	            line[j] = [
	                (p.x + x0) * 360 / size - 180,
	                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
	            ];
	        }
	    }
	    switch (this.type) {
	    case 1:
	        var points = [];
	        for (i = 0; i < coords.length; i++) {
	            points[i] = coords[i][0];
	        }
	        coords = points;
	        project(coords);
	        break;
	    case 2:
	        for (i = 0; i < coords.length; i++) {
	            project(coords[i]);
	        }
	        break;
	    case 3:
	        coords = classifyRings$1(coords);
	        for (i = 0; i < coords.length; i++) {
	            for (j = 0; j < coords[i].length; j++) {
	                project(coords[i][j]);
	            }
	        }
	        break;
	    }
	    if (coords.length === 1) {
	        coords = coords[0];
	    } else {
	        type = 'Multi' + type;
	    }
	    var result = {
	        type: 'Feature',
	        geometry: {
	            type: type,
	            coordinates: coords
	        },
	        properties: this.properties
	    };
	    if ('id' in this) {
	        result.id = this.id;
	    }
	    return result;
	};
	function classifyRings$1(rings) {
	    var len = rings.length;
	    if (len <= 1) {
	        return [rings];
	    }
	    var polygons = [], polygon, ccw;
	    for (var i = 0; i < len; i++) {
	        var area = signedArea$1(rings[i]);
	        if (area === 0) {
	            continue;
	        }
	        if (ccw === undefined) {
	            ccw = area < 0;
	        }
	        if (ccw === area < 0) {
	            if (polygon) {
	                polygons.push(polygon);
	            }
	            polygon = [rings[i]];
	        } else {
	            polygon.push(rings[i]);
	        }
	    }
	    if (polygon) {
	        polygons.push(polygon);
	    }
	    return polygons;
	}
	function signedArea$1(ring) {
	    var sum = 0;
	    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
	        p1 = ring[i];
	        p2 = ring[j];
	        sum += (p2.x - p1.x) * (p1.y + p2.y);
	    }
	    return sum;
	}

	var vectortilelayer = VectorTileLayer;
	function VectorTileLayer(pbf, end) {
	    this.version = 1;
	    this.name = null;
	    this.extent = 4096;
	    this.length = 0;
	    this._pbf = pbf;
	    this._keys = [];
	    this._values = [];
	    this._features = [];
	    pbf.readFields(readLayer, this, end);
	    this.length = this._features.length;
	}
	function readLayer(tag, layer, pbf) {
	    if (tag === 15) {
	        layer.version = pbf.readVarint();
	    } else if (tag === 1) {
	        layer.name = pbf.readString();
	    } else if (tag === 5) {
	        layer.extent = pbf.readVarint();
	    } else if (tag === 2) {
	        layer._features.push(pbf.pos);
	    } else if (tag === 3) {
	        layer._keys.push(pbf.readString());
	    } else if (tag === 4) {
	        layer._values.push(readValueMessage(pbf));
	    }
	}
	function readValueMessage(pbf) {
	    var value = null, end = pbf.readVarint() + pbf.pos;
	    while (pbf.pos < end) {
	        var tag = pbf.readVarint() >> 3;
	        value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
	    }
	    return value;
	}
	VectorTileLayer.prototype.feature = function (i) {
	    if (i < 0 || i >= this._features.length) {
	        throw new Error('feature index out of bounds');
	    }
	    this._pbf.pos = this._features[i];
	    var end = this._pbf.readVarint() + this._pbf.pos;
	    return new vectortilefeature(this._pbf, end, this.extent, this._keys, this._values);
	};

	var vectortile = VectorTile;
	function VectorTile(pbf, end) {
	    this.layers = pbf.readFields(readTile, {}, end);
	}
	function readTile(tag, layers, pbf) {
	    if (tag === 3) {
	        var layer = new vectortilelayer(pbf, pbf.readVarint() + pbf.pos);
	        if (layer.length) {
	            layers[layer.name] = layer;
	        }
	    }
	}

	var VectorTile$1 = vectortile;
	var VectorTileFeature$1 = vectortilefeature;
	var VectorTileLayer$1 = vectortilelayer;

	var vectorTile = {
		VectorTile: VectorTile$1,
		VectorTileFeature: VectorTileFeature$1,
		VectorTileLayer: VectorTileLayer$1
	};

	var vectorTileFeatureTypes = vectorTile.VectorTileFeature.types;
	var EARCUT_MAX_RINGS$1 = 500;
	var FACTOR = Math.pow(2, 13);
	function addVertex(vertexArray, x, y, nx, ny, nz, t, e) {
	    vertexArray.emplaceBack(x, y, Math.floor(nx * FACTOR) * 2 + t, ny * FACTOR * 2, nz * FACTOR * 2, Math.round(e));
	}
	var FillExtrusionBucket = function FillExtrusionBucket(options) {
	    this.zoom = options.zoom;
	    this.overscaling = options.overscaling;
	    this.layers = options.layers;
	    this.layerIds = this.layers.map(function (layer) {
	        return layer.id;
	    });
	    this.index = options.index;
	    this.hasPattern = false;
	    this.layoutVertexArray = new StructArrayLayout2i4i12();
	    this.indexArray = new StructArrayLayout3ui6();
	    this.programConfigurations = new ProgramConfigurationSet(options.layers, options.zoom);
	    this.segments = new SegmentVector();
	    this.stateDependentLayerIds = this.layers.filter(function (l) {
	        return l.isStateDependent();
	    }).map(function (l) {
	        return l.id;
	    });
	};
	FillExtrusionBucket.prototype.populate = function populate(features, options, canonical) {
	    this.features = [];
	    this.hasPattern = hasPattern('fill-extrusion', this.layers, options);
	    for (var i = 0, list = features; i < list.length; i += 1) {
	        var ref = list[i];
	        var feature = ref.feature;
	        var id = ref.id;
	        var index = ref.index;
	        var sourceLayerIndex = ref.sourceLayerIndex;
	        var needGeometry = this.layers[0]._featureFilter.needGeometry;
	        var evaluationFeature = toEvaluationFeature(feature, needGeometry);
	        if (!this.layers[0]._featureFilter.filter(new EvaluationParameters(this.zoom), evaluationFeature, canonical)) {
	            continue;
	        }
	        var bucketFeature = {
	            id: id,
	            sourceLayerIndex: sourceLayerIndex,
	            index: index,
	            geometry: needGeometry ? evaluationFeature.geometry : loadGeometry(feature),
	            properties: feature.properties,
	            type: feature.type,
	            patterns: {}
	        };
	        if (this.hasPattern) {
	            this.features.push(addPatternDependencies('fill-extrusion', this.layers, bucketFeature, this.zoom, options));
	        } else {
	            this.addFeature(bucketFeature, bucketFeature.geometry, index, canonical, {});
	        }
	        options.featureIndex.insert(feature, bucketFeature.geometry, index, sourceLayerIndex, this.index, true);
	    }
	};
	FillExtrusionBucket.prototype.addFeatures = function addFeatures(options, canonical, imagePositions) {
	    for (var i = 0, list = this.features; i < list.length; i += 1) {
	        var feature = list[i];
	        var geometry = feature.geometry;
	        this.addFeature(feature, geometry, feature.index, canonical, imagePositions);
	    }
	};
	FillExtrusionBucket.prototype.update = function update(states, vtLayer, imagePositions) {
	    if (!this.stateDependentLayers.length) {
	        return;
	    }
	    this.programConfigurations.updatePaintArrays(states, vtLayer, this.stateDependentLayers, imagePositions);
	};
	FillExtrusionBucket.prototype.isEmpty = function isEmpty() {
	    return this.layoutVertexArray.length === 0;
	};
	FillExtrusionBucket.prototype.uploadPending = function uploadPending() {
	    return !this.uploaded || this.programConfigurations.needsUpload;
	};
	FillExtrusionBucket.prototype.upload = function upload(context) {
	    if (!this.uploaded) {
	        this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, members$2);
	        this.indexBuffer = context.createIndexBuffer(this.indexArray);
	    }
	    this.programConfigurations.upload(context);
	    this.uploaded = true;
	};
	FillExtrusionBucket.prototype.destroy = function destroy() {
	    if (!this.layoutVertexBuffer) {
	        return;
	    }
	    this.layoutVertexBuffer.destroy();
	    this.indexBuffer.destroy();
	    this.programConfigurations.destroy();
	    this.segments.destroy();
	};
	FillExtrusionBucket.prototype.addFeature = function addFeature(feature, geometry, index, canonical, imagePositions) {
	    for (var i$4 = 0, list$3 = classifyRings(geometry, EARCUT_MAX_RINGS$1); i$4 < list$3.length; i$4 += 1) {
	        var polygon = list$3[i$4];
	        var numVertices = 0;
	        for (var i$1 = 0, list = polygon; i$1 < list.length; i$1 += 1) {
	            var ring = list[i$1];
	            numVertices += ring.length;
	        }
	        var segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
	        for (var i$2 = 0, list$1 = polygon; i$2 < list$1.length; i$2 += 1) {
	            var ring$1 = list$1[i$2];
	            if (ring$1.length === 0) {
	                continue;
	            }
	            if (isEntirelyOutside(ring$1)) {
	                continue;
	            }
	            var edgeDistance = 0;
	            for (var p = 0; p < ring$1.length; p++) {
	                var p1 = ring$1[p];
	                if (p >= 1) {
	                    var p2 = ring$1[p - 1];
	                    if (!isBoundaryEdge(p1, p2)) {
	                        if (segment.vertexLength + 4 > SegmentVector.MAX_VERTEX_ARRAY_LENGTH) {
	                            segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
	                        }
	                        var perp = p1.sub(p2)._perp()._unit();
	                        var dist = p2.dist(p1);
	                        if (edgeDistance + dist > 32768) {
	                            edgeDistance = 0;
	                        }
	                        addVertex(this.layoutVertexArray, p1.x, p1.y, perp.x, perp.y, 0, 0, edgeDistance);
	                        addVertex(this.layoutVertexArray, p1.x, p1.y, perp.x, perp.y, 0, 1, edgeDistance);
	                        edgeDistance += dist;
	                        addVertex(this.layoutVertexArray, p2.x, p2.y, perp.x, perp.y, 0, 0, edgeDistance);
	                        addVertex(this.layoutVertexArray, p2.x, p2.y, perp.x, perp.y, 0, 1, edgeDistance);
	                        var bottomRight = segment.vertexLength;
	                        this.indexArray.emplaceBack(bottomRight, bottomRight + 2, bottomRight + 1);
	                        this.indexArray.emplaceBack(bottomRight + 1, bottomRight + 2, bottomRight + 3);
	                        segment.vertexLength += 4;
	                        segment.primitiveLength += 2;
	                    }
	                }
	            }
	        }
	        if (segment.vertexLength + numVertices > SegmentVector.MAX_VERTEX_ARRAY_LENGTH) {
	            segment = this.segments.prepareSegment(numVertices, this.layoutVertexArray, this.indexArray);
	        }
	        if (vectorTileFeatureTypes[feature.type] !== 'Polygon') {
	            continue;
	        }
	        var flattened = [];
	        var holeIndices = [];
	        var triangleIndex = segment.vertexLength;
	        for (var i$3 = 0, list$2 = polygon; i$3 < list$2.length; i$3 += 1) {
	            var ring$2 = list$2[i$3];
	            if (ring$2.length === 0) {
	                continue;
	            }
	            if (ring$2 !== polygon[0]) {
	                holeIndices.push(flattened.length / 2);
	            }
	            for (var i = 0; i < ring$2.length; i++) {
	                var p$1 = ring$2[i];
	                addVertex(this.layoutVertexArray, p$1.x, p$1.y, 0, 0, 1, 1, 0);
	                flattened.push(p$1.x);
	                flattened.push(p$1.y);
	            }
	        }
	        var indices = earcut_1(flattened, holeIndices);
	        for (var j = 0; j < indices.length; j += 3) {
	            this.indexArray.emplaceBack(triangleIndex + indices[j], triangleIndex + indices[j + 2], triangleIndex + indices[j + 1]);
	        }
	        segment.primitiveLength += indices.length / 3;
	        segment.vertexLength += numVertices;
	    }
	    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, feature, index, imagePositions, canonical);
	};
	register('FillExtrusionBucket', FillExtrusionBucket, {
	    omit: [
	        'layers',
	        'features'
	    ]
	});
	function isBoundaryEdge(p1, p2) {
	    return p1.x === p2.x && (p1.x < 0 || p1.x > EXTENT$1) || p1.y === p2.y && (p1.y < 0 || p1.y > EXTENT$1);
	}
	function isEntirelyOutside(ring) {
	    return ring.every(function (p) {
	        return p.x < 0;
	    }) || ring.every(function (p) {
	        return p.x > EXTENT$1;
	    }) || ring.every(function (p) {
	        return p.y < 0;
	    }) || ring.every(function (p) {
	        return p.y > EXTENT$1;
	    });
	}

	var paint$5 = new Properties({
	    'fill-extrusion-opacity': new DataConstantProperty(spec['paint_fill-extrusion']['fill-extrusion-opacity']),
	    'fill-extrusion-color': new DataDrivenProperty(spec['paint_fill-extrusion']['fill-extrusion-color']),
	    'fill-extrusion-translate': new DataConstantProperty(spec['paint_fill-extrusion']['fill-extrusion-translate']),
	    'fill-extrusion-translate-anchor': new DataConstantProperty(spec['paint_fill-extrusion']['fill-extrusion-translate-anchor']),
	    'fill-extrusion-pattern': new CrossFadedDataDrivenProperty(spec['paint_fill-extrusion']['fill-extrusion-pattern']),
	    'fill-extrusion-height': new DataDrivenProperty(spec['paint_fill-extrusion']['fill-extrusion-height']),
	    'fill-extrusion-base': new DataDrivenProperty(spec['paint_fill-extrusion']['fill-extrusion-base']),
	    'fill-extrusion-vertical-gradient': new DataConstantProperty(spec['paint_fill-extrusion']['fill-extrusion-vertical-gradient'])
	});
	var properties$4 = { paint: paint$5 };

	var FillExtrusionStyleLayer = function (StyleLayer) {
	    function FillExtrusionStyleLayer(layer) {
	        StyleLayer.call(this, layer, properties$4);
	    }
	    if (StyleLayer)
	        FillExtrusionStyleLayer.__proto__ = StyleLayer;
	    FillExtrusionStyleLayer.prototype = Object.create(StyleLayer && StyleLayer.prototype);
	    FillExtrusionStyleLayer.prototype.constructor = FillExtrusionStyleLayer;
	    FillExtrusionStyleLayer.prototype.createBucket = function createBucket(parameters) {
	        return new FillExtrusionBucket(parameters);
	    };
	    FillExtrusionStyleLayer.prototype.queryRadius = function queryRadius() {
	        return translateDistance(this.paint.get('fill-extrusion-translate'));
	    };
	    FillExtrusionStyleLayer.prototype.is3D = function is3D() {
	        return true;
	    };
	    FillExtrusionStyleLayer.prototype.queryIntersectsFeature = function queryIntersectsFeature(queryGeometry, feature, featureState, geometry, zoom, transform, pixelsToTileUnits, pixelPosMatrix) {
	        var translatedPolygon = translate(queryGeometry, this.paint.get('fill-extrusion-translate'), this.paint.get('fill-extrusion-translate-anchor'), transform.angle, pixelsToTileUnits);
	        var height = this.paint.get('fill-extrusion-height').evaluate(feature, featureState);
	        var base = this.paint.get('fill-extrusion-base').evaluate(feature, featureState);
	        var projectedQueryGeometry = projectQueryGeometry$1(translatedPolygon, pixelPosMatrix, transform, 0);
	        var projected = projectExtrusion(geometry, base, height, pixelPosMatrix);
	        var projectedBase = projected[0];
	        var projectedTop = projected[1];
	        return checkIntersection(projectedBase, projectedTop, projectedQueryGeometry);
	    };
	    return FillExtrusionStyleLayer;
	}(StyleLayer);
	function dot$2(a, b) {
	    return a.x * b.x + a.y * b.y;
	}
	function getIntersectionDistance(projectedQueryGeometry, projectedFace) {
	    if (projectedQueryGeometry.length === 1) {
	        var i = 0;
	        var a = projectedFace[i++];
	        var b;
	        while (!b || a.equals(b)) {
	            b = projectedFace[i++];
	            if (!b) {
	                return Infinity;
	            }
	        }
	        for (; i < projectedFace.length; i++) {
	            var c = projectedFace[i];
	            var p = projectedQueryGeometry[0];
	            var ab = b.sub(a);
	            var ac = c.sub(a);
	            var ap = p.sub(a);
	            var dotABAB = dot$2(ab, ab);
	            var dotABAC = dot$2(ab, ac);
	            var dotACAC = dot$2(ac, ac);
	            var dotAPAB = dot$2(ap, ab);
	            var dotAPAC = dot$2(ap, ac);
	            var denom = dotABAB * dotACAC - dotABAC * dotABAC;
	            var v = (dotACAC * dotAPAB - dotABAC * dotAPAC) / denom;
	            var w = (dotABAB * dotAPAC - dotABAC * dotAPAB) / denom;
	            var u = 1 - v - w;
	            var distance = a.z * u + b.z * v + c.z * w;
	            if (isFinite(distance)) {
	                return distance;
	            }
	        }
	        return Infinity;
	    } else {
	        var closestDistance = Infinity;
	        for (var i$1 = 0, list = projectedFace; i$1 < list.length; i$1 += 1) {
	            var p$1 = list[i$1];
	            closestDistance = Math.min(closestDistance, p$1.z);
	        }
	        return closestDistance;
	    }
	}
	function checkIntersection(projectedBase, projectedTop, projectedQueryGeometry) {
	    var closestDistance = Infinity;
	    if (polygonIntersectsMultiPolygon(projectedQueryGeometry, projectedTop)) {
	        closestDistance = getIntersectionDistance(projectedQueryGeometry, projectedTop[0]);
	    }
	    for (var r = 0; r < projectedTop.length; r++) {
	        var ringTop = projectedTop[r];
	        var ringBase = projectedBase[r];
	        for (var p = 0; p < ringTop.length - 1; p++) {
	            var topA = ringTop[p];
	            var topB = ringTop[p + 1];
	            var baseA = ringBase[p];
	            var baseB = ringBase[p + 1];
	            var face = [
	                topA,
	                topB,
	                baseB,
	                baseA,
	                topA
	            ];
	            if (polygonIntersectsPolygon(projectedQueryGeometry, face)) {
	                closestDistance = Math.min(closestDistance, getIntersectionDistance(projectedQueryGeometry, face));
	            }
	        }
	    }
	    return closestDistance === Infinity ? false : closestDistance;
	}
	function projectExtrusion(geometry, zBase, zTop, m) {
	    var projectedBase = [];
	    var projectedTop = [];
	    var baseXZ = m[8] * zBase;
	    var baseYZ = m[9] * zBase;
	    var baseZZ = m[10] * zBase;
	    var baseWZ = m[11] * zBase;
	    var topXZ = m[8] * zTop;
	    var topYZ = m[9] * zTop;
	    var topZZ = m[10] * zTop;
	    var topWZ = m[11] * zTop;
	    for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
	        var r = list$1[i$1];
	        var ringBase = [];
	        var ringTop = [];
	        for (var i = 0, list = r; i < list.length; i += 1) {
	            var p = list[i];
	            var x = p.x;
	            var y = p.y;
	            var sX = m[0] * x + m[4] * y + m[12];
	            var sY = m[1] * x + m[5] * y + m[13];
	            var sZ = m[2] * x + m[6] * y + m[14];
	            var sW = m[3] * x + m[7] * y + m[15];
	            var baseX = sX + baseXZ;
	            var baseY = sY + baseYZ;
	            var baseZ = sZ + baseZZ;
	            var baseW = sW + baseWZ;
	            var topX = sX + topXZ;
	            var topY = sY + topYZ;
	            var topZ = sZ + topZZ;
	            var topW = sW + topWZ;
	            var b = new pointGeometry(baseX / baseW, baseY / baseW);
	            b.z = baseZ / baseW;
	            ringBase.push(b);
	            var t = new pointGeometry(topX / topW, topY / topW);
	            t.z = topZ / topW;
	            ringTop.push(t);
	        }
	        projectedBase.push(ringBase);
	        projectedTop.push(ringTop);
	    }
	    return [
	        projectedBase,
	        projectedTop
	    ];
	}
	function projectQueryGeometry$1(queryGeometry, pixelPosMatrix, transform, z) {
	    var projectedQueryGeometry = [];
	    for (var i = 0, list = queryGeometry; i < list.length; i += 1) {
	        var p = list[i];
	        var v = [
	            p.x,
	            p.y,
	            z,
	            1
	        ];
	        transformMat4(v, v, pixelPosMatrix);
	        projectedQueryGeometry.push(new pointGeometry(v[0] / v[3], v[1] / v[3]));
	    }
	    return projectedQueryGeometry;
	}

	var lineLayoutAttributes = createLayout([
	    {
	        name: 'a_pos_normal',
	        components: 2,
	        type: 'Int16'
	    },
	    {
	        name: 'a_data',
	        components: 4,
	        type: 'Uint8'
	    }
	], 4);
	var members$3 = lineLayoutAttributes.members;

	var lineLayoutAttributesExt = createLayout([
	    {
	        name: 'a_uv_x',
	        components: 1,
	        type: 'Float32'
	    },
	    {
	        name: 'a_split_index',
	        components: 1,
	        type: 'Float32'
	    }
	]);
	var members$4 = lineLayoutAttributesExt.members;

	var vectorTileFeatureTypes$1 = vectorTile.VectorTileFeature.types;
	var EXTRUDE_SCALE = 63;
	var COS_HALF_SHARP_CORNER = Math.cos(75 / 2 * (Math.PI / 180));
	var SHARP_CORNER_OFFSET = 15;
	var DEG_PER_TRIANGLE = 20;
	var LINE_DISTANCE_BUFFER_BITS = 15;
	var LINE_DISTANCE_SCALE = 1 / 2;
	var MAX_LINE_DISTANCE = Math.pow(2, LINE_DISTANCE_BUFFER_BITS - 1) / LINE_DISTANCE_SCALE;
	var LineBucket = function LineBucket(options) {
	    var this$1 = this;
	    this.zoom = options.zoom;
	    this.overscaling = options.overscaling;
	    this.layers = options.layers;
	    this.layerIds = this.layers.map(function (layer) {
	        return layer.id;
	    });
	    this.index = options.index;
	    this.hasPattern = false;
	    this.patternFeatures = [];
	    this.lineClipsArray = [];
	    this.gradients = {};
	    this.layers.forEach(function (layer) {
	        this$1.gradients[layer.id] = {};
	    });
	    this.layoutVertexArray = new StructArrayLayout2i4ub8();
	    this.layoutVertexArray2 = new StructArrayLayout2f8();
	    this.indexArray = new StructArrayLayout3ui6();
	    this.programConfigurations = new ProgramConfigurationSet(options.layers, options.zoom);
	    this.segments = new SegmentVector();
	    this.maxLineLength = 0;
	    this.stateDependentLayerIds = this.layers.filter(function (l) {
	        return l.isStateDependent();
	    }).map(function (l) {
	        return l.id;
	    });
	};
	LineBucket.prototype.populate = function populate(features, options, canonical) {
	    this.hasPattern = hasPattern('line', this.layers, options);
	    var lineSortKey = this.layers[0].layout.get('line-sort-key');
	    var bucketFeatures = [];
	    for (var i = 0, list = features; i < list.length; i += 1) {
	        var ref = list[i];
	        var feature = ref.feature;
	        var id = ref.id;
	        var index = ref.index;
	        var sourceLayerIndex = ref.sourceLayerIndex;
	        var needGeometry = this.layers[0]._featureFilter.needGeometry;
	        var evaluationFeature = toEvaluationFeature(feature, needGeometry);
	        if (!this.layers[0]._featureFilter.filter(new EvaluationParameters(this.zoom), evaluationFeature, canonical)) {
	            continue;
	        }
	        var sortKey = lineSortKey ? lineSortKey.evaluate(evaluationFeature, {}, canonical) : undefined;
	        var bucketFeature = {
	            id: id,
	            properties: feature.properties,
	            type: feature.type,
	            sourceLayerIndex: sourceLayerIndex,
	            index: index,
	            geometry: needGeometry ? evaluationFeature.geometry : loadGeometry(feature),
	            patterns: {},
	            sortKey: sortKey
	        };
	        bucketFeatures.push(bucketFeature);
	    }
	    if (lineSortKey) {
	        bucketFeatures.sort(function (a, b) {
	            return a.sortKey - b.sortKey;
	        });
	    }
	    for (var i$1 = 0, list$1 = bucketFeatures; i$1 < list$1.length; i$1 += 1) {
	        var bucketFeature$1 = list$1[i$1];
	        var ref$1 = bucketFeature$1;
	        var geometry = ref$1.geometry;
	        var index$1 = ref$1.index;
	        var sourceLayerIndex$1 = ref$1.sourceLayerIndex;
	        if (this.hasPattern) {
	            var patternBucketFeature = addPatternDependencies('line', this.layers, bucketFeature$1, this.zoom, options);
	            this.patternFeatures.push(patternBucketFeature);
	        } else {
	            this.addFeature(bucketFeature$1, geometry, index$1, canonical, {});
	        }
	        var feature$1 = features[index$1].feature;
	        options.featureIndex.insert(feature$1, geometry, index$1, sourceLayerIndex$1, this.index);
	    }
	};
	LineBucket.prototype.update = function update(states, vtLayer, imagePositions) {
	    if (!this.stateDependentLayers.length) {
	        return;
	    }
	    this.programConfigurations.updatePaintArrays(states, vtLayer, this.stateDependentLayers, imagePositions);
	};
	LineBucket.prototype.addFeatures = function addFeatures(options, canonical, imagePositions) {
	    for (var i = 0, list = this.patternFeatures; i < list.length; i += 1) {
	        var feature = list[i];
	        this.addFeature(feature, feature.geometry, feature.index, canonical, imagePositions);
	    }
	};
	LineBucket.prototype.isEmpty = function isEmpty() {
	    return this.layoutVertexArray.length === 0;
	};
	LineBucket.prototype.uploadPending = function uploadPending() {
	    return !this.uploaded || this.programConfigurations.needsUpload;
	};
	LineBucket.prototype.upload = function upload(context) {
	    if (!this.uploaded) {
	        if (this.layoutVertexArray2.length !== 0) {
	            this.layoutVertexBuffer2 = context.createVertexBuffer(this.layoutVertexArray2, members$4);
	        }
	        this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, members$3);
	        this.indexBuffer = context.createIndexBuffer(this.indexArray);
	    }
	    this.programConfigurations.upload(context);
	    this.uploaded = true;
	};
	LineBucket.prototype.destroy = function destroy() {
	    if (!this.layoutVertexBuffer) {
	        return;
	    }
	    this.layoutVertexBuffer.destroy();
	    this.indexBuffer.destroy();
	    this.programConfigurations.destroy();
	    this.segments.destroy();
	};
	LineBucket.prototype.lineFeatureClips = function lineFeatureClips(feature) {
	    if (!!feature.properties && feature.properties.hasOwnProperty('mapbox_clip_start') && feature.properties.hasOwnProperty('mapbox_clip_end')) {
	        var start = +feature.properties['mapbox_clip_start'];
	        var end = +feature.properties['mapbox_clip_end'];
	        return {
	            start: start,
	            end: end
	        };
	    }
	};
	LineBucket.prototype.addFeature = function addFeature(feature, geometry, index, canonical, imagePositions) {
	    var layout = this.layers[0].layout;
	    var join = layout.get('line-join').evaluate(feature, {});
	    var cap = layout.get('line-cap');
	    var miterLimit = layout.get('line-miter-limit');
	    var roundLimit = layout.get('line-round-limit');
	    this.lineClips = this.lineFeatureClips(feature);
	    for (var i = 0, list = geometry; i < list.length; i += 1) {
	        var line = list[i];
	        this.addLine(line, feature, join, cap, miterLimit, roundLimit);
	    }
	    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, feature, index, imagePositions, canonical);
	};
	LineBucket.prototype.addLine = function addLine(vertices, feature, join, cap, miterLimit, roundLimit) {
	    this.distance = 0;
	    this.scaledDistance = 0;
	    this.totalDistance = 0;
	    if (this.lineClips) {
	        this.lineClipsArray.push(this.lineClips);
	        for (var i = 0; i < vertices.length - 1; i++) {
	            this.totalDistance += vertices[i].dist(vertices[i + 1]);
	        }
	        this.updateScaledDistance();
	        this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
	    }
	    var isPolygon = vectorTileFeatureTypes$1[feature.type] === 'Polygon';
	    var len = vertices.length;
	    while (len >= 2 && vertices[len - 1].equals(vertices[len - 2])) {
	        len--;
	    }
	    var first = 0;
	    while (first < len - 1 && vertices[first].equals(vertices[first + 1])) {
	        first++;
	    }
	    if (len < (isPolygon ? 3 : 2)) {
	        return;
	    }
	    if (join === 'bevel') {
	        miterLimit = 1.05;
	    }
	    var sharpCornerOffset = this.overscaling <= 16 ? SHARP_CORNER_OFFSET * EXTENT$1 / (512 * this.overscaling) : 0;
	    var segment = this.segments.prepareSegment(len * 10, this.layoutVertexArray, this.indexArray);
	    var currentVertex;
	    var prevVertex = undefined;
	    var nextVertex = undefined;
	    var prevNormal = undefined;
	    var nextNormal = undefined;
	    this.e1 = this.e2 = -1;
	    if (isPolygon) {
	        currentVertex = vertices[len - 2];
	        nextNormal = vertices[first].sub(currentVertex)._unit()._perp();
	    }
	    for (var i$1 = first; i$1 < len; i$1++) {
	        nextVertex = i$1 === len - 1 ? isPolygon ? vertices[first + 1] : undefined : vertices[i$1 + 1];
	        if (nextVertex && vertices[i$1].equals(nextVertex)) {
	            continue;
	        }
	        if (nextNormal) {
	            prevNormal = nextNormal;
	        }
	        if (currentVertex) {
	            prevVertex = currentVertex;
	        }
	        currentVertex = vertices[i$1];
	        nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;
	        prevNormal = prevNormal || nextNormal;
	        var joinNormal = prevNormal.add(nextNormal);
	        if (joinNormal.x !== 0 || joinNormal.y !== 0) {
	            joinNormal._unit();
	        }
	        var cosAngle = prevNormal.x * nextNormal.x + prevNormal.y * nextNormal.y;
	        var cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;
	        var miterLength = cosHalfAngle !== 0 ? 1 / cosHalfAngle : Infinity;
	        var approxAngle = 2 * Math.sqrt(2 - 2 * cosHalfAngle);
	        var isSharpCorner = cosHalfAngle < COS_HALF_SHARP_CORNER && prevVertex && nextVertex;
	        var lineTurnsLeft = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x > 0;
	        if (isSharpCorner && i$1 > first) {
	            var prevSegmentLength = currentVertex.dist(prevVertex);
	            if (prevSegmentLength > 2 * sharpCornerOffset) {
	                var newPrevVertex = currentVertex.sub(currentVertex.sub(prevVertex)._mult(sharpCornerOffset / prevSegmentLength)._round());
	                this.updateDistance(prevVertex, newPrevVertex);
	                this.addCurrentVertex(newPrevVertex, prevNormal, 0, 0, segment);
	                prevVertex = newPrevVertex;
	            }
	        }
	        var middleVertex = prevVertex && nextVertex;
	        var currentJoin = middleVertex ? join : isPolygon ? 'butt' : cap;
	        if (middleVertex && currentJoin === 'round') {
	            if (miterLength < roundLimit) {
	                currentJoin = 'miter';
	            } else if (miterLength <= 2) {
	                currentJoin = 'fakeround';
	            }
	        }
	        if (currentJoin === 'miter' && miterLength > miterLimit) {
	            currentJoin = 'bevel';
	        }
	        if (currentJoin === 'bevel') {
	            if (miterLength > 2) {
	                currentJoin = 'flipbevel';
	            }
	            if (miterLength < miterLimit) {
	                currentJoin = 'miter';
	            }
	        }
	        if (prevVertex) {
	            this.updateDistance(prevVertex, currentVertex);
	        }
	        if (currentJoin === 'miter') {
	            joinNormal._mult(miterLength);
	            this.addCurrentVertex(currentVertex, joinNormal, 0, 0, segment);
	        } else if (currentJoin === 'flipbevel') {
	            if (miterLength > 100) {
	                joinNormal = nextNormal.mult(-1);
	            } else {
	                var bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();
	                joinNormal._perp()._mult(bevelLength * (lineTurnsLeft ? -1 : 1));
	            }
	            this.addCurrentVertex(currentVertex, joinNormal, 0, 0, segment);
	            this.addCurrentVertex(currentVertex, joinNormal.mult(-1), 0, 0, segment);
	        } else if (currentJoin === 'bevel' || currentJoin === 'fakeround') {
	            var offset = -Math.sqrt(miterLength * miterLength - 1);
	            var offsetA = lineTurnsLeft ? offset : 0;
	            var offsetB = lineTurnsLeft ? 0 : offset;
	            if (prevVertex) {
	                this.addCurrentVertex(currentVertex, prevNormal, offsetA, offsetB, segment);
	            }
	            if (currentJoin === 'fakeround') {
	                var n = Math.round(approxAngle * 180 / Math.PI / DEG_PER_TRIANGLE);
	                for (var m = 1; m < n; m++) {
	                    var t = m / n;
	                    if (t !== 0.5) {
	                        var t2 = t - 0.5;
	                        var A = 1.0904 + cosAngle * (-3.2452 + cosAngle * (3.55645 - cosAngle * 1.43519));
	                        var B = 0.848013 + cosAngle * (-1.06021 + cosAngle * 0.215638);
	                        t = t + t * t2 * (t - 1) * (A * t2 * t2 + B);
	                    }
	                    var extrude = nextNormal.sub(prevNormal)._mult(t)._add(prevNormal)._unit()._mult(lineTurnsLeft ? -1 : 1);
	                    this.addHalfVertex(currentVertex, extrude.x, extrude.y, false, lineTurnsLeft, 0, segment);
	                }
	            }
	            if (nextVertex) {
	                this.addCurrentVertex(currentVertex, nextNormal, -offsetA, -offsetB, segment);
	            }
	        } else if (currentJoin === 'butt') {
	            this.addCurrentVertex(currentVertex, joinNormal, 0, 0, segment);
	        } else if (currentJoin === 'square') {
	            var offset$1 = prevVertex ? 1 : -1;
	            this.addCurrentVertex(currentVertex, joinNormal, offset$1, offset$1, segment);
	        } else if (currentJoin === 'round') {
	            if (prevVertex) {
	                this.addCurrentVertex(currentVertex, prevNormal, 0, 0, segment);
	                this.addCurrentVertex(currentVertex, prevNormal, 1, 1, segment, true);
	            }
	            if (nextVertex) {
	                this.addCurrentVertex(currentVertex, nextNormal, -1, -1, segment, true);
	                this.addCurrentVertex(currentVertex, nextNormal, 0, 0, segment);
	            }
	        }
	        if (isSharpCorner && i$1 < len - 1) {
	            var nextSegmentLength = currentVertex.dist(nextVertex);
	            if (nextSegmentLength > 2 * sharpCornerOffset) {
	                var newCurrentVertex = currentVertex.add(nextVertex.sub(currentVertex)._mult(sharpCornerOffset / nextSegmentLength)._round());
	                this.updateDistance(currentVertex, newCurrentVertex);
	                this.addCurrentVertex(newCurrentVertex, nextNormal, 0, 0, segment);
	                currentVertex = newCurrentVertex;
	            }
	        }
	    }
	};
	LineBucket.prototype.addCurrentVertex = function addCurrentVertex(p, normal, endLeft, endRight, segment, round) {
	    if (round === void 0)
	        round = false;
	    var leftX = normal.x + normal.y * endLeft;
	    var leftY = normal.y - normal.x * endLeft;
	    var rightX = -normal.x + normal.y * endRight;
	    var rightY = -normal.y - normal.x * endRight;
	    this.addHalfVertex(p, leftX, leftY, round, false, endLeft, segment);
	    this.addHalfVertex(p, rightX, rightY, round, true, -endRight, segment);
	    if (this.distance > MAX_LINE_DISTANCE / 2 && this.totalDistance === 0) {
	        this.distance = 0;
	        this.addCurrentVertex(p, normal, endLeft, endRight, segment, round);
	    }
	};
	LineBucket.prototype.addHalfVertex = function addHalfVertex(ref, extrudeX, extrudeY, round, up, dir, segment) {
	    var x = ref.x;
	    var y = ref.y;
	    var totalDistance = this.lineClips ? this.scaledDistance * (MAX_LINE_DISTANCE - 1) : this.scaledDistance;
	    var linesofarScaled = totalDistance * LINE_DISTANCE_SCALE;
	    this.layoutVertexArray.emplaceBack((x << 1) + (round ? 1 : 0), (y << 1) + (up ? 1 : 0), Math.round(EXTRUDE_SCALE * extrudeX) + 128, Math.round(EXTRUDE_SCALE * extrudeY) + 128, (dir === 0 ? 0 : dir < 0 ? -1 : 1) + 1 | (linesofarScaled & 63) << 2, linesofarScaled >> 6);
	    if (this.lineClips) {
	        var progressRealigned = this.scaledDistance - this.lineClips.start;
	        var endClipRealigned = this.lineClips.end - this.lineClips.start;
	        var uvX = progressRealigned / endClipRealigned;
	        this.layoutVertexArray2.emplaceBack(uvX, this.lineClipsArray.length);
	    }
	    var e = segment.vertexLength++;
	    if (this.e1 >= 0 && this.e2 >= 0) {
	        this.indexArray.emplaceBack(this.e1, this.e2, e);
	        segment.primitiveLength++;
	    }
	    if (up) {
	        this.e2 = e;
	    } else {
	        this.e1 = e;
	    }
	};
	LineBucket.prototype.updateScaledDistance = function updateScaledDistance() {
	    this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
	};
	LineBucket.prototype.updateDistance = function updateDistance(prev, next) {
	    this.distance += prev.dist(next);
	    this.updateScaledDistance();
	};
	register('LineBucket', LineBucket, {
	    omit: [
	        'layers',
	        'patternFeatures'
	    ]
	});

	var layout$6 = new Properties({
	    'line-cap': new DataConstantProperty(spec['layout_line']['line-cap']),
	    'line-join': new DataDrivenProperty(spec['layout_line']['line-join']),
	    'line-miter-limit': new DataConstantProperty(spec['layout_line']['line-miter-limit']),
	    'line-round-limit': new DataConstantProperty(spec['layout_line']['line-round-limit']),
	    'line-sort-key': new DataDrivenProperty(spec['layout_line']['line-sort-key'])
	});
	var paint$6 = new Properties({
	    'line-opacity': new DataDrivenProperty(spec['paint_line']['line-opacity']),
	    'line-color': new DataDrivenProperty(spec['paint_line']['line-color']),
	    'line-translate': new DataConstantProperty(spec['paint_line']['line-translate']),
	    'line-translate-anchor': new DataConstantProperty(spec['paint_line']['line-translate-anchor']),
	    'line-width': new DataDrivenProperty(spec['paint_line']['line-width']),
	    'line-gap-width': new DataDrivenProperty(spec['paint_line']['line-gap-width']),
	    'line-offset': new DataDrivenProperty(spec['paint_line']['line-offset']),
	    'line-blur': new DataDrivenProperty(spec['paint_line']['line-blur']),
	    'line-dasharray': new CrossFadedProperty(spec['paint_line']['line-dasharray']),
	    'line-pattern': new CrossFadedDataDrivenProperty(spec['paint_line']['line-pattern']),
	    'line-gradient': new ColorRampProperty(spec['paint_line']['line-gradient'])
	});
	var properties$5 = {
	    paint: paint$6,
	    layout: layout$6
	};

	var LineFloorwidthProperty = function (DataDrivenProperty) {
	    function LineFloorwidthProperty() {
	        DataDrivenProperty.apply(this, arguments);
	    }
	    if (DataDrivenProperty)
	        LineFloorwidthProperty.__proto__ = DataDrivenProperty;
	    LineFloorwidthProperty.prototype = Object.create(DataDrivenProperty && DataDrivenProperty.prototype);
	    LineFloorwidthProperty.prototype.constructor = LineFloorwidthProperty;
	    LineFloorwidthProperty.prototype.possiblyEvaluate = function possiblyEvaluate(value, parameters) {
	        parameters = new EvaluationParameters(Math.floor(parameters.zoom), {
	            now: parameters.now,
	            fadeDuration: parameters.fadeDuration,
	            zoomHistory: parameters.zoomHistory,
	            transition: parameters.transition
	        });
	        return DataDrivenProperty.prototype.possiblyEvaluate.call(this, value, parameters);
	    };
	    LineFloorwidthProperty.prototype.evaluate = function evaluate(value, globals, feature, featureState) {
	        globals = extend({}, globals, { zoom: Math.floor(globals.zoom) });
	        return DataDrivenProperty.prototype.evaluate.call(this, value, globals, feature, featureState);
	    };
	    return LineFloorwidthProperty;
	}(DataDrivenProperty);
	var lineFloorwidthProperty = new LineFloorwidthProperty(properties$5.paint.properties['line-width'].specification);
	lineFloorwidthProperty.useIntegerZoom = true;
	var LineStyleLayer = function (StyleLayer) {
	    function LineStyleLayer(layer) {
	        StyleLayer.call(this, layer, properties$5);
	        this.gradientVersion = 0;
	    }
	    if (StyleLayer)
	        LineStyleLayer.__proto__ = StyleLayer;
	    LineStyleLayer.prototype = Object.create(StyleLayer && StyleLayer.prototype);
	    LineStyleLayer.prototype.constructor = LineStyleLayer;
	    LineStyleLayer.prototype._handleSpecialPaintPropertyUpdate = function _handleSpecialPaintPropertyUpdate(name) {
	        if (name === 'line-gradient') {
	            var expression = this._transitionablePaint._values['line-gradient'].value.expression;
	            this.stepInterpolant = expression._styleExpression.expression instanceof Step;
	            this.gradientVersion = (this.gradientVersion + 1) % MAX_SAFE_INTEGER;
	        }
	    };
	    LineStyleLayer.prototype.gradientExpression = function gradientExpression() {
	        return this._transitionablePaint._values['line-gradient'].value.expression;
	    };
	    LineStyleLayer.prototype.recalculate = function recalculate(parameters, availableImages) {
	        StyleLayer.prototype.recalculate.call(this, parameters, availableImages);
	        this.paint._values['line-floorwidth'] = lineFloorwidthProperty.possiblyEvaluate(this._transitioningPaint._values['line-width'].value, parameters);
	    };
	    LineStyleLayer.prototype.createBucket = function createBucket(parameters) {
	        return new LineBucket(parameters);
	    };
	    LineStyleLayer.prototype.queryRadius = function queryRadius(bucket) {
	        var lineBucket = bucket;
	        var width = getLineWidth(getMaximumPaintValue('line-width', this, lineBucket), getMaximumPaintValue('line-gap-width', this, lineBucket));
	        var offset = getMaximumPaintValue('line-offset', this, lineBucket);
	        return width / 2 + Math.abs(offset) + translateDistance(this.paint.get('line-translate'));
	    };
	    LineStyleLayer.prototype.queryIntersectsFeature = function queryIntersectsFeature(queryGeometry, feature, featureState, geometry, zoom, transform, pixelsToTileUnits) {
	        var translatedPolygon = translate(queryGeometry, this.paint.get('line-translate'), this.paint.get('line-translate-anchor'), transform.angle, pixelsToTileUnits);
	        var halfWidth = pixelsToTileUnits / 2 * getLineWidth(this.paint.get('line-width').evaluate(feature, featureState), this.paint.get('line-gap-width').evaluate(feature, featureState));
	        var lineOffset = this.paint.get('line-offset').evaluate(feature, featureState);
	        if (lineOffset) {
	            geometry = offsetLine(geometry, lineOffset * pixelsToTileUnits);
	        }
	        return polygonIntersectsBufferedMultiLine(translatedPolygon, geometry, halfWidth);
	    };
	    LineStyleLayer.prototype.isTileClipped = function isTileClipped() {
	        return true;
	    };
	    return LineStyleLayer;
	}(StyleLayer);
	function getLineWidth(lineWidth, lineGapWidth) {
	    if (lineGapWidth > 0) {
	        return lineGapWidth + 2 * lineWidth;
	    } else {
	        return lineWidth;
	    }
	}
	function offsetLine(rings, offset) {
	    var newRings = [];
	    var zero = new pointGeometry(0, 0);
	    for (var k = 0; k < rings.length; k++) {
	        var ring = rings[k];
	        var newRing = [];
	        for (var i = 0; i < ring.length; i++) {
	            var a = ring[i - 1];
	            var b = ring[i];
	            var c = ring[i + 1];
	            var aToB = i === 0 ? zero : b.sub(a)._unit()._perp();
	            var bToC = i === ring.length - 1 ? zero : c.sub(b)._unit()._perp();
	            var extrude = aToB._add(bToC)._unit();
	            var cosHalfAngle = extrude.x * bToC.x + extrude.y * bToC.y;
	            extrude._mult(1 / cosHalfAngle);
	            newRing.push(extrude._mult(offset)._add(b));
	        }
	        newRings.push(newRing);
	    }
	    return newRings;
	}

	var symbolLayoutAttributes = createLayout([
	    {
	        name: 'a_pos_offset',
	        components: 4,
	        type: 'Int16'
	    },
	    {
	        name: 'a_data',
	        components: 4,
	        type: 'Uint16'
	    },
	    {
	        name: 'a_pixeloffset',
	        components: 4,
	        type: 'Int16'
	    }
	], 4);
	var dynamicLayoutAttributes = createLayout([{
	        name: 'a_projected_pos',
	        components: 3,
	        type: 'Float32'
	    }], 4);
	var placementOpacityAttributes = createLayout([{
	        name: 'a_fade_opacity',
	        components: 1,
	        type: 'Uint32'
	    }], 4);
	var collisionVertexAttributes = createLayout([
	    {
	        name: 'a_placed',
	        components: 2,
	        type: 'Uint8'
	    },
	    {
	        name: 'a_shift',
	        components: 2,
	        type: 'Float32'
	    }
	]);
	var collisionBox = createLayout([
	    {
	        type: 'Int16',
	        name: 'anchorPointX'
	    },
	    {
	        type: 'Int16',
	        name: 'anchorPointY'
	    },
	    {
	        type: 'Int16',
	        name: 'x1'
	    },
	    {
	        type: 'Int16',
	        name: 'y1'
	    },
	    {
	        type: 'Int16',
	        name: 'x2'
	    },
	    {
	        type: 'Int16',
	        name: 'y2'
	    },
	    {
	        type: 'Uint32',
	        name: 'featureIndex'
	    },
	    {
	        type: 'Uint16',
	        name: 'sourceLayerIndex'
	    },
	    {
	        type: 'Uint16',
	        name: 'bucketIndex'
	    }
	]);
	var collisionBoxLayout = createLayout([
	    {
	        name: 'a_pos',
	        components: 2,
	        type: 'Int16'
	    },
	    {
	        name: 'a_anchor_pos',
	        components: 2,
	        type: 'Int16'
	    },
	    {
	        name: 'a_extrude',
	        components: 2,
	        type: 'Int16'
	    }
	], 4);
	var collisionCircleLayout = createLayout([
	    {
	        name: 'a_pos',
	        components: 2,
	        type: 'Float32'
	    },
	    {
	        name: 'a_radius',
	        components: 1,
	        type: 'Float32'
	    },
	    {
	        name: 'a_flags',
	        components: 2,
	        type: 'Int16'
	    }
	], 4);
	var quadTriangle = createLayout([{
	        name: 'triangle',
	        components: 3,
	        type: 'Uint16'
	    }]);
	var placement = createLayout([
	    {
	        type: 'Int16',
	        name: 'anchorX'
	    },
	    {
	        type: 'Int16',
	        name: 'anchorY'
	    },
	    {
	        type: 'Uint16',
	        name: 'glyphStartIndex'
	    },
	    {
	        type: 'Uint16',
	        name: 'numGlyphs'
	    },
	    {
	        type: 'Uint32',
	        name: 'vertexStartIndex'
	    },
	    {
	        type: 'Uint32',
	        name: 'lineStartIndex'
	    },
	    {
	        type: 'Uint32',
	        name: 'lineLength'
	    },
	    {
	        type: 'Uint16',
	        name: 'segment'
	    },
	    {
	        type: 'Uint16',
	        name: 'lowerSize'
	    },
	    {
	        type: 'Uint16',
	        name: 'upperSize'
	    },
	    {
	        type: 'Float32',
	        name: 'lineOffsetX'
	    },
	    {
	        type: 'Float32',
	        name: 'lineOffsetY'
	    },
	    {
	        type: 'Uint8',
	        name: 'writingMode'
	    },
	    {
	        type: 'Uint8',
	        name: 'placedOrientation'
	    },
	    {
	        type: 'Uint8',
	        name: 'hidden'
	    },
	    {
	        type: 'Uint32',
	        name: 'crossTileID'
	    },
	    {
	        type: 'Int16',
	        name: 'associatedIconIndex'
	    }
	]);
	var symbolInstance = createLayout([
	    {
	        type: 'Int16',
	        name: 'anchorX'
	    },
	    {
	        type: 'Int16',
	        name: 'anchorY'
	    },
	    {
	        type: 'Int16',
	        name: 'rightJustifiedTextSymbolIndex'
	    },
	    {
	        type: 'Int16',
	        name: 'centerJustifiedTextSymbolIndex'
	    },
	    {
	        type: 'Int16',
	        name: 'leftJustifiedTextSymbolIndex'
	    },
	    {
	        type: 'Int16',
	        name: 'verticalPlacedTextSymbolIndex'
	    },
	    {
	        type: 'Int16',
	        name: 'placedIconSymbolIndex'
	    },
	    {
	        type: 'Int16',
	        name: 'verticalPlacedIconSymbolIndex'
	    },
	    {
	        type: 'Uint16',
	        name: 'key'
	    },
	    {
	        type: 'Uint16',
	        name: 'textBoxStartIndex'
	    },
	    {
	        type: 'Uint16',
	        name: 'textBoxEndIndex'
	    },
	    {
	        type: 'Uint16',
	        name: 'verticalTextBoxStartIndex'
	    },
	    {
	        type: 'Uint16',
	        name: 'verticalTextBoxEndIndex'
	    },
	    {
	        type: 'Uint16',
	        name: 'iconBoxStartIndex'
	    },
	    {
	        type: 'Uint16',
	        name: 'iconBoxEndIndex'
	    },
	    {
	        type: 'Uint16',
	        name: 'verticalIconBoxStartIndex'
	    },
	    {
	        type: 'Uint16',
	        name: 'verticalIconBoxEndIndex'
	    },
	    {
	        type: 'Uint16',
	        name: 'featureIndex'
	    },
	    {
	        type: 'Uint16',
	        name: 'numHorizontalGlyphVertices'
	    },
	    {
	        type: 'Uint16',
	        name: 'numVerticalGlyphVertices'
	    },
	    {
	        type: 'Uint16',
	        name: 'numIconVertices'
	    },
	    {
	        type: 'Uint16',
	        name: 'numVerticalIconVertices'
	    },
	    {
	        type: 'Uint16',
	        name: 'useRuntimeCollisionCircles'
	    },
	    {
	        type: 'Uint32',
	        name: 'crossTileID'
	    },
	    {
	        type: 'Float32',
	        name: 'textBoxScale'
	    },
	    {
	        type: 'Float32',
	        components: 2,
	        name: 'textOffset'
	    },
	    {
	        type: 'Float32',
	        name: 'collisionCircleDiameter'
	    }
	]);
	var glyphOffset = createLayout([{
	        type: 'Float32',
	        name: 'offsetX'
	    }]);
	var lineVertex = createLayout([
	    {
	        type: 'Int16',
	        name: 'x'
	    },
	    {
	        type: 'Int16',
	        name: 'y'
	    },
	    {
	        type: 'Int16',
	        name: 'tileUnitDistanceFromAnchor'
	    }
	]);

	function transformText(text, layer, feature) {
	    var transform = layer.layout.get('text-transform').evaluate(feature, {});
	    if (transform === 'uppercase') {
	        text = text.toLocaleUpperCase();
	    } else if (transform === 'lowercase') {
	        text = text.toLocaleLowerCase();
	    }
	    if (plugin.applyArabicShaping) {
	        text = plugin.applyArabicShaping(text);
	    }
	    return text;
	}
	function transformText$1 (text, layer, feature) {
	    text.sections.forEach(function (section) {
	        section.text = transformText(section.text, layer, feature);
	    });
	    return text;
	}

	function mergeLines (features) {
	    var leftIndex = {};
	    var rightIndex = {};
	    var mergedFeatures = [];
	    var mergedIndex = 0;
	    function add(k) {
	        mergedFeatures.push(features[k]);
	        mergedIndex++;
	    }
	    function mergeFromRight(leftKey, rightKey, geom) {
	        var i = rightIndex[leftKey];
	        delete rightIndex[leftKey];
	        rightIndex[rightKey] = i;
	        mergedFeatures[i].geometry[0].pop();
	        mergedFeatures[i].geometry[0] = mergedFeatures[i].geometry[0].concat(geom[0]);
	        return i;
	    }
	    function mergeFromLeft(leftKey, rightKey, geom) {
	        var i = leftIndex[rightKey];
	        delete leftIndex[rightKey];
	        leftIndex[leftKey] = i;
	        mergedFeatures[i].geometry[0].shift();
	        mergedFeatures[i].geometry[0] = geom[0].concat(mergedFeatures[i].geometry[0]);
	        return i;
	    }
	    function getKey(text, geom, onRight) {
	        var point = onRight ? geom[0][geom[0].length - 1] : geom[0][0];
	        return text + ':' + point.x + ':' + point.y;
	    }
	    for (var k = 0; k < features.length; k++) {
	        var feature = features[k];
	        var geom = feature.geometry;
	        var text = feature.text ? feature.text.toString() : null;
	        if (!text) {
	            add(k);
	            continue;
	        }
	        var leftKey = getKey(text, geom), rightKey = getKey(text, geom, true);
	        if (leftKey in rightIndex && rightKey in leftIndex && rightIndex[leftKey] !== leftIndex[rightKey]) {
	            var j = mergeFromLeft(leftKey, rightKey, geom);
	            var i = mergeFromRight(leftKey, rightKey, mergedFeatures[j].geometry);
	            delete leftIndex[leftKey];
	            delete rightIndex[rightKey];
	            rightIndex[getKey(text, mergedFeatures[i].geometry, true)] = i;
	            mergedFeatures[j].geometry = null;
	        } else if (leftKey in rightIndex) {
	            mergeFromRight(leftKey, rightKey, geom);
	        } else if (rightKey in leftIndex) {
	            mergeFromLeft(leftKey, rightKey, geom);
	        } else {
	            add(k);
	            leftIndex[leftKey] = mergedIndex - 1;
	            rightIndex[rightKey] = mergedIndex - 1;
	        }
	    }
	    return mergedFeatures.filter(function (f) {
	        return f.geometry;
	    });
	}

	var verticalizedCharacterMap = {
	    '!': '\uFE15',
	    '#': '\uFF03',
	    '$': '\uFF04',
	    '%': '\uFF05',
	    '&': '\uFF06',
	    '(': '\uFE35',
	    ')': '\uFE36',
	    '*': '\uFF0A',
	    '+': '\uFF0B',
	    ',': '\uFE10',
	    '-': '\uFE32',
	    '.': '\u30FB',
	    '/': '\uFF0F',
	    ':': '\uFE13',
	    ';': '\uFE14',
	    '<': '\uFE3F',
	    '=': '\uFF1D',
	    '>': '\uFE40',
	    '?': '\uFE16',
	    '@': '\uFF20',
	    '[': '\uFE47',
	    '\\': '\uFF3C',
	    ']': '\uFE48',
	    '^': '\uFF3E',
	    '_': '︳',
	    '`': '\uFF40',
	    '{': '\uFE37',
	    '|': '\u2015',
	    '}': '\uFE38',
	    '~': '\uFF5E',
	    '\xA2': '\uFFE0',
	    '\xA3': '\uFFE1',
	    '\xA5': '\uFFE5',
	    '\xA6': '\uFFE4',
	    '\xAC': '\uFFE2',
	    '\xAF': '\uFFE3',
	    '\u2013': '\uFE32',
	    '\u2014': '\uFE31',
	    '\u2018': '\uFE43',
	    '\u2019': '\uFE44',
	    '\u201C': '\uFE41',
	    '\u201D': '\uFE42',
	    '\u2026': '\uFE19',
	    '\u2027': '\u30FB',
	    '\u20A9': '\uFFE6',
	    '\u3001': '\uFE11',
	    '\u3002': '\uFE12',
	    '\u3008': '\uFE3F',
	    '\u3009': '\uFE40',
	    '\u300A': '\uFE3D',
	    '\u300B': '\uFE3E',
	    '\u300C': '\uFE41',
	    '\u300D': '\uFE42',
	    '\u300E': '\uFE43',
	    '\u300F': '\uFE44',
	    '\u3010': '\uFE3B',
	    '\u3011': '\uFE3C',
	    '\u3014': '\uFE39',
	    '\u3015': '\uFE3A',
	    '\u3016': '\uFE17',
	    '\u3017': '\uFE18',
	    '\uFF01': '\uFE15',
	    '\uFF08': '\uFE35',
	    '\uFF09': '\uFE36',
	    '\uFF0C': '\uFE10',
	    '\uFF0D': '\uFE32',
	    '\uFF0E': '\u30FB',
	    '\uFF1A': '\uFE13',
	    '\uFF1B': '\uFE14',
	    '\uFF1C': '\uFE3F',
	    '\uFF1E': '\uFE40',
	    '\uFF1F': '\uFE16',
	    '\uFF3B': '\uFE47',
	    '\uFF3D': '\uFE48',
	    '＿': '︳',
	    '\uFF5B': '\uFE37',
	    '\uFF5C': '\u2015',
	    '\uFF5D': '\uFE38',
	    '\uFF5F': '\uFE35',
	    '\uFF60': '\uFE36',
	    '\uFF61': '\uFE12',
	    '\uFF62': '\uFE41',
	    '\uFF63': '\uFE42'
	};
	function verticalizePunctuation(input) {
	    var output = '';
	    for (var i = 0; i < input.length; i++) {
	        var nextCharCode = input.charCodeAt(i + 1) || null;
	        var prevCharCode = input.charCodeAt(i - 1) || null;
	        var canReplacePunctuation = (!nextCharCode || !charHasRotatedVerticalOrientation(nextCharCode) || verticalizedCharacterMap[input[i + 1]]) && (!prevCharCode || !charHasRotatedVerticalOrientation(prevCharCode) || verticalizedCharacterMap[input[i - 1]]);
	        if (canReplacePunctuation && verticalizedCharacterMap[input[i]]) {
	            output += verticalizedCharacterMap[input[i]];
	        } else {
	            output += input[i];
	        }
	    }
	    return output;
	}

	var ONE_EM = 24;

	var read = function (buffer, offset, isLE, mLen, nBytes) {
	    var e, m;
	    var eLen = nBytes * 8 - mLen - 1;
	    var eMax = (1 << eLen) - 1;
	    var eBias = eMax >> 1;
	    var nBits = -7;
	    var i = isLE ? nBytes - 1 : 0;
	    var d = isLE ? -1 : 1;
	    var s = buffer[offset + i];
	    i += d;
	    e = s & (1 << -nBits) - 1;
	    s >>= -nBits;
	    nBits += eLen;
	    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
	    }
	    m = e & (1 << -nBits) - 1;
	    e >>= -nBits;
	    nBits += mLen;
	    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
	    }
	    if (e === 0) {
	        e = 1 - eBias;
	    } else if (e === eMax) {
	        return m ? NaN : (s ? -1 : 1) * Infinity;
	    } else {
	        m = m + Math.pow(2, mLen);
	        e = e - eBias;
	    }
	    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
	};
	var write = function (buffer, value, offset, isLE, mLen, nBytes) {
	    var e, m, c;
	    var eLen = nBytes * 8 - mLen - 1;
	    var eMax = (1 << eLen) - 1;
	    var eBias = eMax >> 1;
	    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
	    var i = isLE ? 0 : nBytes - 1;
	    var d = isLE ? 1 : -1;
	    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	    value = Math.abs(value);
	    if (isNaN(value) || value === Infinity) {
	        m = isNaN(value) ? 1 : 0;
	        e = eMax;
	    } else {
	        e = Math.floor(Math.log(value) / Math.LN2);
	        if (value * (c = Math.pow(2, -e)) < 1) {
	            e--;
	            c *= 2;
	        }
	        if (e + eBias >= 1) {
	            value += rt / c;
	        } else {
	            value += rt * Math.pow(2, 1 - eBias);
	        }
	        if (value * c >= 2) {
	            e++;
	            c /= 2;
	        }
	        if (e + eBias >= eMax) {
	            m = 0;
	            e = eMax;
	        } else if (e + eBias >= 1) {
	            m = (value * c - 1) * Math.pow(2, mLen);
	            e = e + eBias;
	        } else {
	            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	            e = 0;
	        }
	    }
	    for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
	    }
	    e = e << mLen | m;
	    eLen += mLen;
	    for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
	    }
	    buffer[offset + i - d] |= s * 128;
	};

	var ieee754 = {
		read: read,
		write: write
	};

	var pbf = Pbf;

	function Pbf(buf) {
	    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
	    this.pos = 0;
	    this.type = 0;
	    this.length = this.buf.length;
	}
	Pbf.Varint = 0;
	Pbf.Fixed64 = 1;
	Pbf.Bytes = 2;
	Pbf.Fixed32 = 5;
	var SHIFT_LEFT_32 = (1 << 16) * (1 << 16), SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
	var TEXT_DECODER_MIN_LENGTH = 12;
	var utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf8');
	Pbf.prototype = {
	    destroy: function () {
	        this.buf = null;
	    },
	    readFields: function (readField, result, end) {
	        end = end || this.length;
	        while (this.pos < end) {
	            var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
	            this.type = val & 7;
	            readField(tag, result, this);
	            if (this.pos === startPos) {
	                this.skip(val);
	            }
	        }
	        return result;
	    },
	    readMessage: function (readField, result) {
	        return this.readFields(readField, result, this.readVarint() + this.pos);
	    },
	    readFixed32: function () {
	        var val = readUInt32(this.buf, this.pos);
	        this.pos += 4;
	        return val;
	    },
	    readSFixed32: function () {
	        var val = readInt32(this.buf, this.pos);
	        this.pos += 4;
	        return val;
	    },
	    readFixed64: function () {
	        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
	        this.pos += 8;
	        return val;
	    },
	    readSFixed64: function () {
	        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
	        this.pos += 8;
	        return val;
	    },
	    readFloat: function () {
	        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
	        this.pos += 4;
	        return val;
	    },
	    readDouble: function () {
	        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
	        this.pos += 8;
	        return val;
	    },
	    readVarint: function (isSigned) {
	        var buf = this.buf, val, b;
	        b = buf[this.pos++];
	        val = b & 127;
	        if (b < 128) {
	            return val;
	        }
	        b = buf[this.pos++];
	        val |= (b & 127) << 7;
	        if (b < 128) {
	            return val;
	        }
	        b = buf[this.pos++];
	        val |= (b & 127) << 14;
	        if (b < 128) {
	            return val;
	        }
	        b = buf[this.pos++];
	        val |= (b & 127) << 21;
	        if (b < 128) {
	            return val;
	        }
	        b = buf[this.pos];
	        val |= (b & 15) << 28;
	        return readVarintRemainder(val, isSigned, this);
	    },
	    readVarint64: function () {
	        return this.readVarint(true);
	    },
	    readSVarint: function () {
	        var num = this.readVarint();
	        return num % 2 === 1 ? (num + 1) / -2 : num / 2;
	    },
	    readBoolean: function () {
	        return Boolean(this.readVarint());
	    },
	    readString: function () {
	        var end = this.readVarint() + this.pos;
	        var pos = this.pos;
	        this.pos = end;
	        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
	            return readUtf8TextDecoder(this.buf, pos, end);
	        }
	        return readUtf8(this.buf, pos, end);
	    },
	    readBytes: function () {
	        var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
	        this.pos = end;
	        return buffer;
	    },
	    readPackedVarint: function (arr, isSigned) {
	        if (this.type !== Pbf.Bytes) {
	            return arr.push(this.readVarint(isSigned));
	        }
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) {
	            arr.push(this.readVarint(isSigned));
	        }
	        return arr;
	    },
	    readPackedSVarint: function (arr) {
	        if (this.type !== Pbf.Bytes) {
	            return arr.push(this.readSVarint());
	        }
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) {
	            arr.push(this.readSVarint());
	        }
	        return arr;
	    },
	    readPackedBoolean: function (arr) {
	        if (this.type !== Pbf.Bytes) {
	            return arr.push(this.readBoolean());
	        }
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) {
	            arr.push(this.readBoolean());
	        }
	        return arr;
	    },
	    readPackedFloat: function (arr) {
	        if (this.type !== Pbf.Bytes) {
	            return arr.push(this.readFloat());
	        }
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) {
	            arr.push(this.readFloat());
	        }
	        return arr;
	    },
	    readPackedDouble: function (arr) {
	        if (this.type !== Pbf.Bytes) {
	            return arr.push(this.readDouble());
	        }
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) {
	            arr.push(this.readDouble());
	        }
	        return arr;
	    },
	    readPackedFixed32: function (arr) {
	        if (this.type !== Pbf.Bytes) {
	            return arr.push(this.readFixed32());
	        }
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) {
	            arr.push(this.readFixed32());
	        }
	        return arr;
	    },
	    readPackedSFixed32: function (arr) {
	        if (this.type !== Pbf.Bytes) {
	            return arr.push(this.readSFixed32());
	        }
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) {
	            arr.push(this.readSFixed32());
	        }
	        return arr;
	    },
	    readPackedFixed64: function (arr) {
	        if (this.type !== Pbf.Bytes) {
	            return arr.push(this.readFixed64());
	        }
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) {
	            arr.push(this.readFixed64());
	        }
	        return arr;
	    },
	    readPackedSFixed64: function (arr) {
	        if (this.type !== Pbf.Bytes) {
	            return arr.push(this.readSFixed64());
	        }
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) {
	            arr.push(this.readSFixed64());
	        }
	        return arr;
	    },
	    skip: function (val) {
	        var type = val & 7;
	        if (type === Pbf.Varint) {
	            while (this.buf[this.pos++] > 127) {
	            }
	        } else if (type === Pbf.Bytes) {
	            this.pos = this.readVarint() + this.pos;
	        } else if (type === Pbf.Fixed32) {
	            this.pos += 4;
	        } else if (type === Pbf.Fixed64) {
	            this.pos += 8;
	        } else {
	            throw new Error('Unimplemented type: ' + type);
	        }
	    },
	    writeTag: function (tag, type) {
	        this.writeVarint(tag << 3 | type);
	    },
	    realloc: function (min) {
	        var length = this.length || 16;
	        while (length < this.pos + min) {
	            length *= 2;
	        }
	        if (length !== this.length) {
	            var buf = new Uint8Array(length);
	            buf.set(this.buf);
	            this.buf = buf;
	            this.length = length;
	        }
	    },
	    finish: function () {
	        this.length = this.pos;
	        this.pos = 0;
	        return this.buf.subarray(0, this.length);
	    },
	    writeFixed32: function (val) {
	        this.realloc(4);
	        writeInt32(this.buf, val, this.pos);
	        this.pos += 4;
	    },
	    writeSFixed32: function (val) {
	        this.realloc(4);
	        writeInt32(this.buf, val, this.pos);
	        this.pos += 4;
	    },
	    writeFixed64: function (val) {
	        this.realloc(8);
	        writeInt32(this.buf, val & -1, this.pos);
	        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
	        this.pos += 8;
	    },
	    writeSFixed64: function (val) {
	        this.realloc(8);
	        writeInt32(this.buf, val & -1, this.pos);
	        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
	        this.pos += 8;
	    },
	    writeVarint: function (val) {
	        val = +val || 0;
	        if (val > 268435455 || val < 0) {
	            writeBigVarint(val, this);
	            return;
	        }
	        this.realloc(4);
	        this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
	        if (val <= 127) {
	            return;
	        }
	        this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
	        if (val <= 127) {
	            return;
	        }
	        this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
	        if (val <= 127) {
	            return;
	        }
	        this.buf[this.pos++] = val >>> 7 & 127;
	    },
	    writeSVarint: function (val) {
	        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
	    },
	    writeBoolean: function (val) {
	        this.writeVarint(Boolean(val));
	    },
	    writeString: function (str) {
	        str = String(str);
	        this.realloc(str.length * 4);
	        this.pos++;
	        var startPos = this.pos;
	        this.pos = writeUtf8(this.buf, str, this.pos);
	        var len = this.pos - startPos;
	        if (len >= 128) {
	            makeRoomForExtraLength(startPos, len, this);
	        }
	        this.pos = startPos - 1;
	        this.writeVarint(len);
	        this.pos += len;
	    },
	    writeFloat: function (val) {
	        this.realloc(4);
	        ieee754.write(this.buf, val, this.pos, true, 23, 4);
	        this.pos += 4;
	    },
	    writeDouble: function (val) {
	        this.realloc(8);
	        ieee754.write(this.buf, val, this.pos, true, 52, 8);
	        this.pos += 8;
	    },
	    writeBytes: function (buffer) {
	        var len = buffer.length;
	        this.writeVarint(len);
	        this.realloc(len);
	        for (var i = 0; i < len; i++) {
	            this.buf[this.pos++] = buffer[i];
	        }
	    },
	    writeRawMessage: function (fn, obj) {
	        this.pos++;
	        var startPos = this.pos;
	        fn(obj, this);
	        var len = this.pos - startPos;
	        if (len >= 128) {
	            makeRoomForExtraLength(startPos, len, this);
	        }
	        this.pos = startPos - 1;
	        this.writeVarint(len);
	        this.pos += len;
	    },
	    writeMessage: function (tag, fn, obj) {
	        this.writeTag(tag, Pbf.Bytes);
	        this.writeRawMessage(fn, obj);
	    },
	    writePackedVarint: function (tag, arr) {
	        if (arr.length) {
	            this.writeMessage(tag, writePackedVarint, arr);
	        }
	    },
	    writePackedSVarint: function (tag, arr) {
	        if (arr.length) {
	            this.writeMessage(tag, writePackedSVarint, arr);
	        }
	    },
	    writePackedBoolean: function (tag, arr) {
	        if (arr.length) {
	            this.writeMessage(tag, writePackedBoolean, arr);
	        }
	    },
	    writePackedFloat: function (tag, arr) {
	        if (arr.length) {
	            this.writeMessage(tag, writePackedFloat, arr);
	        }
	    },
	    writePackedDouble: function (tag, arr) {
	        if (arr.length) {
	            this.writeMessage(tag, writePackedDouble, arr);
	        }
	    },
	    writePackedFixed32: function (tag, arr) {
	        if (arr.length) {
	            this.writeMessage(tag, writePackedFixed32, arr);
	        }
	    },
	    writePackedSFixed32: function (tag, arr) {
	        if (arr.length) {
	            this.writeMessage(tag, writePackedSFixed32, arr);
	        }
	    },
	    writePackedFixed64: function (tag, arr) {
	        if (arr.length) {
	            this.writeMessage(tag, writePackedFixed64, arr);
	        }
	    },
	    writePackedSFixed64: function (tag, arr) {
	        if (arr.length) {
	            this.writeMessage(tag, writePackedSFixed64, arr);
	        }
	    },
	    writeBytesField: function (tag, buffer) {
	        this.writeTag(tag, Pbf.Bytes);
	        this.writeBytes(buffer);
	    },
	    writeFixed32Field: function (tag, val) {
	        this.writeTag(tag, Pbf.Fixed32);
	        this.writeFixed32(val);
	    },
	    writeSFixed32Field: function (tag, val) {
	        this.writeTag(tag, Pbf.Fixed32);
	        this.writeSFixed32(val);
	    },
	    writeFixed64Field: function (tag, val) {
	        this.writeTag(tag, Pbf.Fixed64);
	        this.writeFixed64(val);
	    },
	    writeSFixed64Field: function (tag, val) {
	        this.writeTag(tag, Pbf.Fixed64);
	        this.writeSFixed64(val);
	    },
	    writeVarintField: function (tag, val) {
	        this.writeTag(tag, Pbf.Varint);
	        this.writeVarint(val);
	    },
	    writeSVarintField: function (tag, val) {
	        this.writeTag(tag, Pbf.Varint);
	        this.writeSVarint(val);
	    },
	    writeStringField: function (tag, str) {
	        this.writeTag(tag, Pbf.Bytes);
	        this.writeString(str);
	    },
	    writeFloatField: function (tag, val) {
	        this.writeTag(tag, Pbf.Fixed32);
	        this.writeFloat(val);
	    },
	    writeDoubleField: function (tag, val) {
	        this.writeTag(tag, Pbf.Fixed64);
	        this.writeDouble(val);
	    },
	    writeBooleanField: function (tag, val) {
	        this.writeVarintField(tag, Boolean(val));
	    }
	};
	function readVarintRemainder(l, s, p) {
	    var buf = p.buf, h, b;
	    b = buf[p.pos++];
	    h = (b & 112) >> 4;
	    if (b < 128) {
	        return toNum(l, h, s);
	    }
	    b = buf[p.pos++];
	    h |= (b & 127) << 3;
	    if (b < 128) {
	        return toNum(l, h, s);
	    }
	    b = buf[p.pos++];
	    h |= (b & 127) << 10;
	    if (b < 128) {
	        return toNum(l, h, s);
	    }
	    b = buf[p.pos++];
	    h |= (b & 127) << 17;
	    if (b < 128) {
	        return toNum(l, h, s);
	    }
	    b = buf[p.pos++];
	    h |= (b & 127) << 24;
	    if (b < 128) {
	        return toNum(l, h, s);
	    }
	    b = buf[p.pos++];
	    h |= (b & 1) << 31;
	    if (b < 128) {
	        return toNum(l, h, s);
	    }
	    throw new Error('Expected varint not more than 10 bytes');
	}
	function readPackedEnd(pbf) {
	    return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
	}
	function toNum(low, high, isSigned) {
	    if (isSigned) {
	        return high * 4294967296 + (low >>> 0);
	    }
	    return (high >>> 0) * 4294967296 + (low >>> 0);
	}
	function writeBigVarint(val, pbf) {
	    var low, high;
	    if (val >= 0) {
	        low = val % 4294967296 | 0;
	        high = val / 4294967296 | 0;
	    } else {
	        low = ~(-val % 4294967296);
	        high = ~(-val / 4294967296);
	        if (low ^ 4294967295) {
	            low = low + 1 | 0;
	        } else {
	            low = 0;
	            high = high + 1 | 0;
	        }
	    }
	    if (val >= 18446744073709552000 || val < -18446744073709552000) {
	        throw new Error('Given varint doesn\'t fit into 10 bytes');
	    }
	    pbf.realloc(10);
	    writeBigVarintLow(low, high, pbf);
	    writeBigVarintHigh(high, pbf);
	}
	function writeBigVarintLow(low, high, pbf) {
	    pbf.buf[pbf.pos++] = low & 127 | 128;
	    low >>>= 7;
	    pbf.buf[pbf.pos++] = low & 127 | 128;
	    low >>>= 7;
	    pbf.buf[pbf.pos++] = low & 127 | 128;
	    low >>>= 7;
	    pbf.buf[pbf.pos++] = low & 127 | 128;
	    low >>>= 7;
	    pbf.buf[pbf.pos] = low & 127;
	}
	function writeBigVarintHigh(high, pbf) {
	    var lsb = (high & 7) << 4;
	    pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
	    if (!high) {
	        return;
	    }
	    pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
	    if (!high) {
	        return;
	    }
	    pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
	    if (!high) {
	        return;
	    }
	    pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
	    if (!high) {
	        return;
	    }
	    pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
	    if (!high) {
	        return;
	    }
	    pbf.buf[pbf.pos++] = high & 127;
	}
	function makeRoomForExtraLength(startPos, len, pbf) {
	    var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
	    pbf.realloc(extraLen);
	    for (var i = pbf.pos - 1; i >= startPos; i--) {
	        pbf.buf[i + extraLen] = pbf.buf[i];
	    }
	}
	function writePackedVarint(arr, pbf) {
	    for (var i = 0; i < arr.length; i++) {
	        pbf.writeVarint(arr[i]);
	    }
	}
	function writePackedSVarint(arr, pbf) {
	    for (var i = 0; i < arr.length; i++) {
	        pbf.writeSVarint(arr[i]);
	    }
	}
	function writePackedFloat(arr, pbf) {
	    for (var i = 0; i < arr.length; i++) {
	        pbf.writeFloat(arr[i]);
	    }
	}
	function writePackedDouble(arr, pbf) {
	    for (var i = 0; i < arr.length; i++) {
	        pbf.writeDouble(arr[i]);
	    }
	}
	function writePackedBoolean(arr, pbf) {
	    for (var i = 0; i < arr.length; i++) {
	        pbf.writeBoolean(arr[i]);
	    }
	}
	function writePackedFixed32(arr, pbf) {
	    for (var i = 0; i < arr.length; i++) {
	        pbf.writeFixed32(arr[i]);
	    }
	}
	function writePackedSFixed32(arr, pbf) {
	    for (var i = 0; i < arr.length; i++) {
	        pbf.writeSFixed32(arr[i]);
	    }
	}
	function writePackedFixed64(arr, pbf) {
	    for (var i = 0; i < arr.length; i++) {
	        pbf.writeFixed64(arr[i]);
	    }
	}
	function writePackedSFixed64(arr, pbf) {
	    for (var i = 0; i < arr.length; i++) {
	        pbf.writeSFixed64(arr[i]);
	    }
	}
	function readUInt32(buf, pos) {
	    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
	}
	function writeInt32(buf, val, pos) {
	    buf[pos] = val;
	    buf[pos + 1] = val >>> 8;
	    buf[pos + 2] = val >>> 16;
	    buf[pos + 3] = val >>> 24;
	}
	function readInt32(buf, pos) {
	    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
	}
	function readUtf8(buf, pos, end) {
	    var str = '';
	    var i = pos;
	    while (i < end) {
	        var b0 = buf[i];
	        var c = null;
	        var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
	        if (i + bytesPerSequence > end) {
	            break;
	        }
	        var b1, b2, b3;
	        if (bytesPerSequence === 1) {
	            if (b0 < 128) {
	                c = b0;
	            }
	        } else if (bytesPerSequence === 2) {
	            b1 = buf[i + 1];
	            if ((b1 & 192) === 128) {
	                c = (b0 & 31) << 6 | b1 & 63;
	                if (c <= 127) {
	                    c = null;
	                }
	            }
	        } else if (bytesPerSequence === 3) {
	            b1 = buf[i + 1];
	            b2 = buf[i + 2];
	            if ((b1 & 192) === 128 && (b2 & 192) === 128) {
	                c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
	                if (c <= 2047 || c >= 55296 && c <= 57343) {
	                    c = null;
	                }
	            }
	        } else if (bytesPerSequence === 4) {
	            b1 = buf[i + 1];
	            b2 = buf[i + 2];
	            b3 = buf[i + 3];
	            if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
	                c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
	                if (c <= 65535 || c >= 1114112) {
	                    c = null;
	                }
	            }
	        }
	        if (c === null) {
	            c = 65533;
	            bytesPerSequence = 1;
	        } else if (c > 65535) {
	            c -= 65536;
	            str += String.fromCharCode(c >>> 10 & 1023 | 55296);
	            c = 56320 | c & 1023;
	        }
	        str += String.fromCharCode(c);
	        i += bytesPerSequence;
	    }
	    return str;
	}
	function readUtf8TextDecoder(buf, pos, end) {
	    return utf8TextDecoder.decode(buf.subarray(pos, end));
	}
	function writeUtf8(buf, str, pos) {
	    for (var i = 0, c, lead; i < str.length; i++) {
	        c = str.charCodeAt(i);
	        if (c > 55295 && c < 57344) {
	            if (lead) {
	                if (c < 56320) {
	                    buf[pos++] = 239;
	                    buf[pos++] = 191;
	                    buf[pos++] = 189;
	                    lead = c;
	                    continue;
	                } else {
	                    c = lead - 55296 << 10 | c - 56320 | 65536;
	                    lead = null;
	                }
	            } else {
	                if (c > 56319 || i + 1 === str.length) {
	                    buf[pos++] = 239;
	                    buf[pos++] = 191;
	                    buf[pos++] = 189;
	                } else {
	                    lead = c;
	                }
	                continue;
	            }
	        } else if (lead) {
	            buf[pos++] = 239;
	            buf[pos++] = 191;
	            buf[pos++] = 189;
	            lead = null;
	        }
	        if (c < 128) {
	            buf[pos++] = c;
	        } else {
	            if (c < 2048) {
	                buf[pos++] = c >> 6 | 192;
	            } else {
	                if (c < 65536) {
	                    buf[pos++] = c >> 12 | 224;
	                } else {
	                    buf[pos++] = c >> 18 | 240;
	                    buf[pos++] = c >> 12 & 63 | 128;
	                }
	                buf[pos++] = c >> 6 & 63 | 128;
	            }
	            buf[pos++] = c & 63 | 128;
	        }
	    }
	    return pos;
	}

	var border = 3;
	function readFontstacks(tag, glyphs, pbf) {
	    if (tag === 1) {
	        pbf.readMessage(readFontstack, glyphs);
	    }
	}
	function readFontstack(tag, glyphs, pbf) {
	    if (tag === 3) {
	        var ref = pbf.readMessage(readGlyph, {});
	        var id = ref.id;
	        var bitmap = ref.bitmap;
	        var width = ref.width;
	        var height = ref.height;
	        var left = ref.left;
	        var top = ref.top;
	        var advance = ref.advance;
	        glyphs.push({
	            id: id,
	            bitmap: new AlphaImage({
	                width: width + 2 * border,
	                height: height + 2 * border
	            }, bitmap),
	            metrics: {
	                width: width,
	                height: height,
	                left: left,
	                top: top,
	                advance: advance
	            }
	        });
	    }
	}
	function readGlyph(tag, glyph, pbf) {
	    if (tag === 1) {
	        glyph.id = pbf.readVarint();
	    } else if (tag === 2) {
	        glyph.bitmap = pbf.readBytes();
	    } else if (tag === 3) {
	        glyph.width = pbf.readVarint();
	    } else if (tag === 4) {
	        glyph.height = pbf.readVarint();
	    } else if (tag === 5) {
	        glyph.left = pbf.readSVarint();
	    } else if (tag === 6) {
	        glyph.top = pbf.readSVarint();
	    } else if (tag === 7) {
	        glyph.advance = pbf.readVarint();
	    }
	}
	function parseGlyphPBF (data) {
	    return new pbf(data).readFields(readFontstacks, []);
	}
	var GLYPH_PBF_BORDER = border;

	function potpack(boxes) {

	    // calculate total box area and maximum box width
	    var area = 0;
	    var maxWidth = 0;

	    for (var i$1 = 0, list = boxes; i$1 < list.length; i$1 += 1) {
	        var box = list[i$1];

	        area += box.w * box.h;
	        maxWidth = Math.max(maxWidth, box.w);
	    }

	    // sort the boxes for insertion by height, descending
	    boxes.sort(function (a, b) { return b.h - a.h; });

	    // aim for a squarish resulting container,
	    // slightly adjusted for sub-100% space utilization
	    var startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);

	    // start with a single empty space, unbounded at the bottom
	    var spaces = [{x: 0, y: 0, w: startWidth, h: Infinity}];

	    var width = 0;
	    var height = 0;

	    for (var i$2 = 0, list$1 = boxes; i$2 < list$1.length; i$2 += 1) {
	        // look through spaces backwards so that we check smaller spaces first
	        var box$1 = list$1[i$2];

	        for (var i = spaces.length - 1; i >= 0; i--) {
	            var space = spaces[i];

	            // look for empty spaces that can accommodate the current box
	            if (box$1.w > space.w || box$1.h > space.h) { continue; }

	            // found the space; add the box to its top-left corner
	            // |-------|-------|
	            // |  box  |       |
	            // |_______|       |
	            // |         space |
	            // |_______________|
	            box$1.x = space.x;
	            box$1.y = space.y;

	            height = Math.max(height, box$1.y + box$1.h);
	            width = Math.max(width, box$1.x + box$1.w);

	            if (box$1.w === space.w && box$1.h === space.h) {
	                // space matches the box exactly; remove it
	                var last = spaces.pop();
	                if (i < spaces.length) { spaces[i] = last; }

	            } else if (box$1.h === space.h) {
	                // space matches the box height; update it accordingly
	                // |-------|---------------|
	                // |  box  | updated space |
	                // |_______|_______________|
	                space.x += box$1.w;
	                space.w -= box$1.w;

	            } else if (box$1.w === space.w) {
	                // space matches the box width; update it accordingly
	                // |---------------|
	                // |      box      |
	                // |_______________|
	                // | updated space |
	                // |_______________|
	                space.y += box$1.h;
	                space.h -= box$1.h;

	            } else {
	                // otherwise the box splits the space into two spaces
	                // |-------|-----------|
	                // |  box  | new space |
	                // |_______|___________|
	                // | updated space     |
	                // |___________________|
	                spaces.push({
	                    x: space.x + box$1.w,
	                    y: space.y,
	                    w: space.w - box$1.w,
	                    h: box$1.h
	                });
	                space.y += box$1.h;
	                space.h -= box$1.h;
	            }
	            break;
	        }
	    }

	    return {
	        w: width, // container width
	        h: height, // container height
	        fill: (area / (width * height)) || 0 // space utilization
	    };
	}

	var IMAGE_PADDING = 1;
	var ImagePosition = function ImagePosition(paddedRect, ref) {
	    var pixelRatio = ref.pixelRatio;
	    var version = ref.version;
	    var stretchX = ref.stretchX;
	    var stretchY = ref.stretchY;
	    var content = ref.content;
	    this.paddedRect = paddedRect;
	    this.pixelRatio = pixelRatio;
	    this.stretchX = stretchX;
	    this.stretchY = stretchY;
	    this.content = content;
	    this.version = version;
	};
	var prototypeAccessors = {
	    tl: { configurable: true },
	    br: { configurable: true },
	    tlbr: { configurable: true },
	    displaySize: { configurable: true }
	};
	prototypeAccessors.tl.get = function () {
	    return [
	        this.paddedRect.x + IMAGE_PADDING,
	        this.paddedRect.y + IMAGE_PADDING
	    ];
	};
	prototypeAccessors.br.get = function () {
	    return [
	        this.paddedRect.x + this.paddedRect.w - IMAGE_PADDING,
	        this.paddedRect.y + this.paddedRect.h - IMAGE_PADDING
	    ];
	};
	prototypeAccessors.tlbr.get = function () {
	    return this.tl.concat(this.br);
	};
	prototypeAccessors.displaySize.get = function () {
	    return [
	        (this.paddedRect.w - IMAGE_PADDING * 2) / this.pixelRatio,
	        (this.paddedRect.h - IMAGE_PADDING * 2) / this.pixelRatio
	    ];
	};
	Object.defineProperties(ImagePosition.prototype, prototypeAccessors);
	var ImageAtlas = function ImageAtlas(icons, patterns) {
	    var iconPositions = {}, patternPositions = {};
	    this.haveRenderCallbacks = [];
	    var bins = [];
	    this.addImages(icons, iconPositions, bins);
	    this.addImages(patterns, patternPositions, bins);
	    var ref = potpack(bins);
	    var w = ref.w;
	    var h = ref.h;
	    var image = new RGBAImage({
	        width: w || 1,
	        height: h || 1
	    });
	    for (var id in icons) {
	        var src = icons[id];
	        var bin = iconPositions[id].paddedRect;
	        RGBAImage.copy(src.data, image, {
	            x: 0,
	            y: 0
	        }, {
	            x: bin.x + IMAGE_PADDING,
	            y: bin.y + IMAGE_PADDING
	        }, src.data);
	    }
	    for (var id$1 in patterns) {
	        var src$1 = patterns[id$1];
	        var bin$1 = patternPositions[id$1].paddedRect;
	        var x = bin$1.x + IMAGE_PADDING, y = bin$1.y + IMAGE_PADDING, w$1 = src$1.data.width, h$1 = src$1.data.height;
	        RGBAImage.copy(src$1.data, image, {
	            x: 0,
	            y: 0
	        }, {
	            x: x,
	            y: y
	        }, src$1.data);
	        RGBAImage.copy(src$1.data, image, {
	            x: 0,
	            y: h$1 - 1
	        }, {
	            x: x,
	            y: y - 1
	        }, {
	            width: w$1,
	            height: 1
	        });
	        RGBAImage.copy(src$1.data, image, {
	            x: 0,
	            y: 0
	        }, {
	            x: x,
	            y: y + h$1
	        }, {
	            width: w$1,
	            height: 1
	        });
	        RGBAImage.copy(src$1.data, image, {
	            x: w$1 - 1,
	            y: 0
	        }, {
	            x: x - 1,
	            y: y
	        }, {
	            width: 1,
	            height: h$1
	        });
	        RGBAImage.copy(src$1.data, image, {
	            x: 0,
	            y: 0
	        }, {
	            x: x + w$1,
	            y: y
	        }, {
	            width: 1,
	            height: h$1
	        });
	    }
	    this.image = image;
	    this.iconPositions = iconPositions;
	    this.patternPositions = patternPositions;
	};
	ImageAtlas.prototype.addImages = function addImages(images, positions, bins) {
	    for (var id in images) {
	        var src = images[id];
	        var bin = {
	            x: 0,
	            y: 0,
	            w: src.data.width + 2 * IMAGE_PADDING,
	            h: src.data.height + 2 * IMAGE_PADDING
	        };
	        bins.push(bin);
	        positions[id] = new ImagePosition(bin, src);
	        if (src.hasRenderCallback) {
	            this.haveRenderCallbacks.push(id);
	        }
	    }
	};
	ImageAtlas.prototype.patchUpdatedImages = function patchUpdatedImages(imageManager, texture) {
	    imageManager.dispatchRenderCallbacks(this.haveRenderCallbacks);
	    for (var name in imageManager.updatedImages) {
	        this.patchUpdatedImage(this.iconPositions[name], imageManager.getImage(name), texture);
	        this.patchUpdatedImage(this.patternPositions[name], imageManager.getImage(name), texture);
	    }
	};
	ImageAtlas.prototype.patchUpdatedImage = function patchUpdatedImage(position, image, texture) {
	    if (!position || !image) {
	        return;
	    }
	    if (position.version === image.version) {
	        return;
	    }
	    position.version = image.version;
	    var ref = position.tl;
	    var x = ref[0];
	    var y = ref[1];
	    texture.update(image.data, undefined, {
	        x: x,
	        y: y
	    });
	};
	register('ImagePosition', ImagePosition);
	register('ImageAtlas', ImageAtlas);

	var WritingMode = {
	    horizontal: 1,
	    vertical: 2,
	    horizontalOnly: 3
	};
	var SHAPING_DEFAULT_OFFSET = -17;
	function isEmpty(positionedLines) {
	    for (var i = 0, list = positionedLines; i < list.length; i += 1) {
	        var line = list[i];
	        if (line.positionedGlyphs.length !== 0) {
	            return false;
	        }
	    }
	    return true;
	}
	var PUAbegin = 57344;
	var PUAend = 63743;
	var SectionOptions = function SectionOptions() {
	    this.scale = 1;
	    this.fontStack = '';
	    this.imageName = null;
	};
	SectionOptions.forText = function forText(scale, fontStack) {
	    var textOptions = new SectionOptions();
	    textOptions.scale = scale || 1;
	    textOptions.fontStack = fontStack;
	    return textOptions;
	};
	SectionOptions.forImage = function forImage(imageName) {
	    var imageOptions = new SectionOptions();
	    imageOptions.imageName = imageName;
	    return imageOptions;
	};
	var TaggedString = function TaggedString() {
	    this.text = '';
	    this.sectionIndex = [];
	    this.sections = [];
	    this.imageSectionID = null;
	};
	TaggedString.fromFeature = function fromFeature(text, defaultFontStack) {
	    var result = new TaggedString();
	    for (var i = 0; i < text.sections.length; i++) {
	        var section = text.sections[i];
	        if (!section.image) {
	            result.addTextSection(section, defaultFontStack);
	        } else {
	            result.addImageSection(section);
	        }
	    }
	    return result;
	};
	TaggedString.prototype.length = function length() {
	    return this.text.length;
	};
	TaggedString.prototype.getSection = function getSection(index) {
	    return this.sections[this.sectionIndex[index]];
	};
	TaggedString.prototype.getSectionIndex = function getSectionIndex(index) {
	    return this.sectionIndex[index];
	};
	TaggedString.prototype.getCharCode = function getCharCode(index) {
	    return this.text.charCodeAt(index);
	};
	TaggedString.prototype.verticalizePunctuation = function verticalizePunctuation$1() {
	    this.text = verticalizePunctuation(this.text);
	};
	TaggedString.prototype.trim = function trim() {
	    var beginningWhitespace = 0;
	    for (var i = 0; i < this.text.length && whitespace[this.text.charCodeAt(i)]; i++) {
	        beginningWhitespace++;
	    }
	    var trailingWhitespace = this.text.length;
	    for (var i$1 = this.text.length - 1; i$1 >= 0 && i$1 >= beginningWhitespace && whitespace[this.text.charCodeAt(i$1)]; i$1--) {
	        trailingWhitespace--;
	    }
	    this.text = this.text.substring(beginningWhitespace, trailingWhitespace);
	    this.sectionIndex = this.sectionIndex.slice(beginningWhitespace, trailingWhitespace);
	};
	TaggedString.prototype.substring = function substring(start, end) {
	    var substring = new TaggedString();
	    substring.text = this.text.substring(start, end);
	    substring.sectionIndex = this.sectionIndex.slice(start, end);
	    substring.sections = this.sections;
	    return substring;
	};
	TaggedString.prototype.toString = function toString() {
	    return this.text;
	};
	TaggedString.prototype.getMaxScale = function getMaxScale() {
	    var this$1 = this;
	    return this.sectionIndex.reduce(function (max, index) {
	        return Math.max(max, this$1.sections[index].scale);
	    }, 0);
	};
	TaggedString.prototype.addTextSection = function addTextSection(section, defaultFontStack) {
	    this.text += section.text;
	    this.sections.push(SectionOptions.forText(section.scale, section.fontStack || defaultFontStack));
	    var index = this.sections.length - 1;
	    for (var i = 0; i < section.text.length; ++i) {
	        this.sectionIndex.push(index);
	    }
	};
	TaggedString.prototype.addImageSection = function addImageSection(section) {
	    var imageName = section.image ? section.image.name : '';
	    if (imageName.length === 0) {
	        warnOnce('Can\'t add FormattedSection with an empty image.');
	        return;
	    }
	    var nextImageSectionCharCode = this.getNextImageSectionCharCode();
	    if (!nextImageSectionCharCode) {
	        warnOnce('Reached maximum number of images ' + (PUAend - PUAbegin + 2));
	        return;
	    }
	    this.text += String.fromCharCode(nextImageSectionCharCode);
	    this.sections.push(SectionOptions.forImage(imageName));
	    this.sectionIndex.push(this.sections.length - 1);
	};
	TaggedString.prototype.getNextImageSectionCharCode = function getNextImageSectionCharCode() {
	    if (!this.imageSectionID) {
	        this.imageSectionID = PUAbegin;
	        return this.imageSectionID;
	    }
	    if (this.imageSectionID >= PUAend) {
	        return null;
	    }
	    return ++this.imageSectionID;
	};
	function breakLines(input, lineBreakPoints) {
	    var lines = [];
	    var text = input.text;
	    var start = 0;
	    for (var i = 0, list = lineBreakPoints; i < list.length; i += 1) {
	        var lineBreak = list[i];
	        lines.push(input.substring(start, lineBreak));
	        start = lineBreak;
	    }
	    if (start < text.length) {
	        lines.push(input.substring(start, text.length));
	    }
	    return lines;
	}
	function shapeText(text, glyphMap, glyphPositions, imagePositions, defaultFontStack, maxWidth, lineHeight, textAnchor, textJustify, spacing, translate, writingMode, allowVerticalPlacement, symbolPlacement, layoutTextSize, layoutTextSizeThisZoom) {
	    var logicalInput = TaggedString.fromFeature(text, defaultFontStack);
	    if (writingMode === WritingMode.vertical) {
	        logicalInput.verticalizePunctuation();
	    }
	    var lines;
	    var processBidirectionalText = plugin.processBidirectionalText;
	    var processStyledBidirectionalText = plugin.processStyledBidirectionalText;
	    if (processBidirectionalText && logicalInput.sections.length === 1) {
	        lines = [];
	        var untaggedLines = processBidirectionalText(logicalInput.toString(), determineLineBreaks(logicalInput, spacing, maxWidth, glyphMap, imagePositions, symbolPlacement, layoutTextSize));
	        for (var i$1 = 0, list = untaggedLines; i$1 < list.length; i$1 += 1) {
	            var line = list[i$1];
	            var taggedLine = new TaggedString();
	            taggedLine.text = line;
	            taggedLine.sections = logicalInput.sections;
	            for (var i = 0; i < line.length; i++) {
	                taggedLine.sectionIndex.push(0);
	            }
	            lines.push(taggedLine);
	        }
	    } else if (processStyledBidirectionalText) {
	        lines = [];
	        var processedLines = processStyledBidirectionalText(logicalInput.text, logicalInput.sectionIndex, determineLineBreaks(logicalInput, spacing, maxWidth, glyphMap, imagePositions, symbolPlacement, layoutTextSize));
	        for (var i$2 = 0, list$1 = processedLines; i$2 < list$1.length; i$2 += 1) {
	            var line$1 = list$1[i$2];
	            var taggedLine$1 = new TaggedString();
	            taggedLine$1.text = line$1[0];
	            taggedLine$1.sectionIndex = line$1[1];
	            taggedLine$1.sections = logicalInput.sections;
	            lines.push(taggedLine$1);
	        }
	    } else {
	        lines = breakLines(logicalInput, determineLineBreaks(logicalInput, spacing, maxWidth, glyphMap, imagePositions, symbolPlacement, layoutTextSize));
	    }
	    var positionedLines = [];
	    var shaping = {
	        positionedLines: positionedLines,
	        text: logicalInput.toString(),
	        top: translate[1],
	        bottom: translate[1],
	        left: translate[0],
	        right: translate[0],
	        writingMode: writingMode,
	        iconsInText: false,
	        verticalizable: false
	    };
	    shapeLines(shaping, glyphMap, glyphPositions, imagePositions, lines, lineHeight, textAnchor, textJustify, writingMode, spacing, allowVerticalPlacement, layoutTextSizeThisZoom);
	    if (isEmpty(positionedLines)) {
	        return false;
	    }
	    return shaping;
	}
	var whitespace = {};
	whitespace[9] = true;
	whitespace[10] = true;
	whitespace[11] = true;
	whitespace[12] = true;
	whitespace[13] = true;
	whitespace[32] = true;
	var breakable = {};
	breakable[10] = true;
	breakable[32] = true;
	breakable[38] = true;
	breakable[40] = true;
	breakable[41] = true;
	breakable[43] = true;
	breakable[45] = true;
	breakable[47] = true;
	breakable[173] = true;
	breakable[183] = true;
	breakable[8203] = true;
	breakable[8208] = true;
	breakable[8211] = true;
	breakable[8231] = true;
	function getGlyphAdvance(codePoint, section, glyphMap, imagePositions, spacing, layoutTextSize) {
	    if (!section.imageName) {
	        var positions = glyphMap[section.fontStack];
	        var glyph = positions && positions[codePoint];
	        if (!glyph) {
	            return 0;
	        }
	        return glyph.metrics.advance * section.scale + spacing;
	    } else {
	        var imagePosition = imagePositions[section.imageName];
	        if (!imagePosition) {
	            return 0;
	        }
	        return imagePosition.displaySize[0] * section.scale * ONE_EM / layoutTextSize + spacing;
	    }
	}
	function determineAverageLineWidth(logicalInput, spacing, maxWidth, glyphMap, imagePositions, layoutTextSize) {
	    var totalWidth = 0;
	    for (var index = 0; index < logicalInput.length(); index++) {
	        var section = logicalInput.getSection(index);
	        totalWidth += getGlyphAdvance(logicalInput.getCharCode(index), section, glyphMap, imagePositions, spacing, layoutTextSize);
	    }
	    var lineCount = Math.max(1, Math.ceil(totalWidth / maxWidth));
	    return totalWidth / lineCount;
	}
	function calculateBadness(lineWidth, targetWidth, penalty, isLastBreak) {
	    var raggedness = Math.pow(lineWidth - targetWidth, 2);
	    if (isLastBreak) {
	        if (lineWidth < targetWidth) {
	            return raggedness / 2;
	        } else {
	            return raggedness * 2;
	        }
	    }
	    return raggedness + Math.abs(penalty) * penalty;
	}
	function calculatePenalty(codePoint, nextCodePoint, penalizableIdeographicBreak) {
	    var penalty = 0;
	    if (codePoint === 10) {
	        penalty -= 10000;
	    }
	    if (penalizableIdeographicBreak) {
	        penalty += 150;
	    }
	    if (codePoint === 40 || codePoint === 65288) {
	        penalty += 50;
	    }
	    if (nextCodePoint === 41 || nextCodePoint === 65289) {
	        penalty += 50;
	    }
	    return penalty;
	}
	function evaluateBreak(breakIndex, breakX, targetWidth, potentialBreaks, penalty, isLastBreak) {
	    var bestPriorBreak = null;
	    var bestBreakBadness = calculateBadness(breakX, targetWidth, penalty, isLastBreak);
	    for (var i = 0, list = potentialBreaks; i < list.length; i += 1) {
	        var potentialBreak = list[i];
	        var lineWidth = breakX - potentialBreak.x;
	        var breakBadness = calculateBadness(lineWidth, targetWidth, penalty, isLastBreak) + potentialBreak.badness;
	        if (breakBadness <= bestBreakBadness) {
	            bestPriorBreak = potentialBreak;
	            bestBreakBadness = breakBadness;
	        }
	    }
	    return {
	        index: breakIndex,
	        x: breakX,
	        priorBreak: bestPriorBreak,
	        badness: bestBreakBadness
	    };
	}
	function leastBadBreaks(lastLineBreak) {
	    if (!lastLineBreak) {
	        return [];
	    }
	    return leastBadBreaks(lastLineBreak.priorBreak).concat(lastLineBreak.index);
	}
	function determineLineBreaks(logicalInput, spacing, maxWidth, glyphMap, imagePositions, symbolPlacement, layoutTextSize) {
	    if (symbolPlacement !== 'point') {
	        return [];
	    }
	    if (!logicalInput) {
	        return [];
	    }
	    var potentialLineBreaks = [];
	    var targetWidth = determineAverageLineWidth(logicalInput, spacing, maxWidth, glyphMap, imagePositions, layoutTextSize);
	    var hasServerSuggestedBreakpoints = logicalInput.text.indexOf('\u200B') >= 0;
	    var currentX = 0;
	    for (var i = 0; i < logicalInput.length(); i++) {
	        var section = logicalInput.getSection(i);
	        var codePoint = logicalInput.getCharCode(i);
	        if (!whitespace[codePoint]) {
	            currentX += getGlyphAdvance(codePoint, section, glyphMap, imagePositions, spacing, layoutTextSize);
	        }
	        if (i < logicalInput.length() - 1) {
	            var ideographicBreak = charAllowsIdeographicBreaking(codePoint);
	            if (breakable[codePoint] || ideographicBreak || section.imageName) {
	                potentialLineBreaks.push(evaluateBreak(i + 1, currentX, targetWidth, potentialLineBreaks, calculatePenalty(codePoint, logicalInput.getCharCode(i + 1), ideographicBreak && hasServerSuggestedBreakpoints), false));
	            }
	        }
	    }
	    return leastBadBreaks(evaluateBreak(logicalInput.length(), currentX, targetWidth, potentialLineBreaks, 0, true));
	}
	function getAnchorAlignment(anchor) {
	    var horizontalAlign = 0.5, verticalAlign = 0.5;
	    switch (anchor) {
	    case 'right':
	    case 'top-right':
	    case 'bottom-right':
	        horizontalAlign = 1;
	        break;
	    case 'left':
	    case 'top-left':
	    case 'bottom-left':
	        horizontalAlign = 0;
	        break;
	    }
	    switch (anchor) {
	    case 'bottom':
	    case 'bottom-right':
	    case 'bottom-left':
	        verticalAlign = 1;
	        break;
	    case 'top':
	    case 'top-right':
	    case 'top-left':
	        verticalAlign = 0;
	        break;
	    }
	    return {
	        horizontalAlign: horizontalAlign,
	        verticalAlign: verticalAlign
	    };
	}
	function shapeLines(shaping, glyphMap, glyphPositions, imagePositions, lines, lineHeight, textAnchor, textJustify, writingMode, spacing, allowVerticalPlacement, layoutTextSizeThisZoom) {
	    var x = 0;
	    var y = SHAPING_DEFAULT_OFFSET;
	    var maxLineLength = 0;
	    var maxLineHeight = 0;
	    var justify = textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;
	    var lineIndex = 0;
	    for (var i$1 = 0, list = lines; i$1 < list.length; i$1 += 1) {
	        var line = list[i$1];
	        line.trim();
	        var lineMaxScale = line.getMaxScale();
	        var maxLineOffset = (lineMaxScale - 1) * ONE_EM;
	        var positionedLine = {
	            positionedGlyphs: [],
	            lineOffset: 0
	        };
	        shaping.positionedLines[lineIndex] = positionedLine;
	        var positionedGlyphs = positionedLine.positionedGlyphs;
	        var lineOffset = 0;
	        if (!line.length()) {
	            y += lineHeight;
	            ++lineIndex;
	            continue;
	        }
	        for (var i = 0; i < line.length(); i++) {
	            var section = line.getSection(i);
	            var sectionIndex = line.getSectionIndex(i);
	            var codePoint = line.getCharCode(i);
	            var baselineOffset = 0;
	            var metrics = null;
	            var rect = null;
	            var imageName = null;
	            var verticalAdvance = ONE_EM;
	            var vertical = !(writingMode === WritingMode.horizontal || !allowVerticalPlacement && !charHasUprightVerticalOrientation(codePoint) || allowVerticalPlacement && (whitespace[codePoint] || charInComplexShapingScript(codePoint)));
	            if (!section.imageName) {
	                var positions = glyphPositions[section.fontStack];
	                var glyphPosition = positions && positions[codePoint];
	                if (glyphPosition && glyphPosition.rect) {
	                    rect = glyphPosition.rect;
	                    metrics = glyphPosition.metrics;
	                } else {
	                    var glyphs = glyphMap[section.fontStack];
	                    var glyph = glyphs && glyphs[codePoint];
	                    if (!glyph) {
	                        continue;
	                    }
	                    metrics = glyph.metrics;
	                }
	                baselineOffset = (lineMaxScale - section.scale) * ONE_EM;
	            } else {
	                var imagePosition = imagePositions[section.imageName];
	                if (!imagePosition) {
	                    continue;
	                }
	                imageName = section.imageName;
	                shaping.iconsInText = shaping.iconsInText || true;
	                rect = imagePosition.paddedRect;
	                var size = imagePosition.displaySize;
	                section.scale = section.scale * ONE_EM / layoutTextSizeThisZoom;
	                metrics = {
	                    width: size[0],
	                    height: size[1],
	                    left: IMAGE_PADDING,
	                    top: -GLYPH_PBF_BORDER,
	                    advance: vertical ? size[1] : size[0]
	                };
	                var imageOffset = ONE_EM - size[1] * section.scale;
	                baselineOffset = maxLineOffset + imageOffset;
	                verticalAdvance = metrics.advance;
	                var offset = vertical ? size[0] * section.scale - ONE_EM * lineMaxScale : size[1] * section.scale - ONE_EM * lineMaxScale;
	                if (offset > 0 && offset > lineOffset) {
	                    lineOffset = offset;
	                }
	            }
	            if (!vertical) {
	                positionedGlyphs.push({
	                    glyph: codePoint,
	                    imageName: imageName,
	                    x: x,
	                    y: y + baselineOffset,
	                    vertical: vertical,
	                    scale: section.scale,
	                    fontStack: section.fontStack,
	                    sectionIndex: sectionIndex,
	                    metrics: metrics,
	                    rect: rect
	                });
	                x += metrics.advance * section.scale + spacing;
	            } else {
	                shaping.verticalizable = true;
	                positionedGlyphs.push({
	                    glyph: codePoint,
	                    imageName: imageName,
	                    x: x,
	                    y: y + baselineOffset,
	                    vertical: vertical,
	                    scale: section.scale,
	                    fontStack: section.fontStack,
	                    sectionIndex: sectionIndex,
	                    metrics: metrics,
	                    rect: rect
	                });
	                x += verticalAdvance * section.scale + spacing;
	            }
	        }
	        if (positionedGlyphs.length !== 0) {
	            var lineLength = x - spacing;
	            maxLineLength = Math.max(lineLength, maxLineLength);
	            justifyLine(positionedGlyphs, 0, positionedGlyphs.length - 1, justify, lineOffset);
	        }
	        x = 0;
	        var currentLineHeight = lineHeight * lineMaxScale + lineOffset;
	        positionedLine.lineOffset = Math.max(lineOffset, maxLineOffset);
	        y += currentLineHeight;
	        maxLineHeight = Math.max(currentLineHeight, maxLineHeight);
	        ++lineIndex;
	    }
	    var height = y - SHAPING_DEFAULT_OFFSET;
	    var ref = getAnchorAlignment(textAnchor);
	    var horizontalAlign = ref.horizontalAlign;
	    var verticalAlign = ref.verticalAlign;
	    align$1(shaping.positionedLines, justify, horizontalAlign, verticalAlign, maxLineLength, maxLineHeight, lineHeight, height, lines.length);
	    shaping.top += -verticalAlign * height;
	    shaping.bottom = shaping.top + height;
	    shaping.left += -horizontalAlign * maxLineLength;
	    shaping.right = shaping.left + maxLineLength;
	}
	function justifyLine(positionedGlyphs, start, end, justify, lineOffset) {
	    if (!justify && !lineOffset) {
	        return;
	    }
	    var lastPositionedGlyph = positionedGlyphs[end];
	    var lastAdvance = lastPositionedGlyph.metrics.advance * lastPositionedGlyph.scale;
	    var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;
	    for (var j = start; j <= end; j++) {
	        positionedGlyphs[j].x -= lineIndent;
	        positionedGlyphs[j].y += lineOffset;
	    }
	}
	function align$1(positionedLines, justify, horizontalAlign, verticalAlign, maxLineLength, maxLineHeight, lineHeight, blockHeight, lineCount) {
	    var shiftX = (justify - horizontalAlign) * maxLineLength;
	    var shiftY = 0;
	    if (maxLineHeight !== lineHeight) {
	        shiftY = -blockHeight * verticalAlign - SHAPING_DEFAULT_OFFSET;
	    } else {
	        shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;
	    }
	    for (var i$1 = 0, list$1 = positionedLines; i$1 < list$1.length; i$1 += 1) {
	        var line = list$1[i$1];
	        for (var i = 0, list = line.positionedGlyphs; i < list.length; i += 1) {
	            var positionedGlyph = list[i];
	            positionedGlyph.x += shiftX;
	            positionedGlyph.y += shiftY;
	        }
	    }
	}
	function shapeIcon(image, iconOffset, iconAnchor) {
	    var ref = getAnchorAlignment(iconAnchor);
	    var horizontalAlign = ref.horizontalAlign;
	    var verticalAlign = ref.verticalAlign;
	    var dx = iconOffset[0];
	    var dy = iconOffset[1];
	    var x1 = dx - image.displaySize[0] * horizontalAlign;
	    var x2 = x1 + image.displaySize[0];
	    var y1 = dy - image.displaySize[1] * verticalAlign;
	    var y2 = y1 + image.displaySize[1];
	    return {
	        image: image,
	        top: y1,
	        bottom: y2,
	        left: x1,
	        right: x2
	    };
	}
	function fitIconToText(shapedIcon, shapedText, textFit, padding, iconOffset, fontScale) {
	    var image = shapedIcon.image;
	    var collisionPadding;
	    if (image.content) {
	        var content = image.content;
	        var pixelRatio = image.pixelRatio || 1;
	        collisionPadding = [
	            content[0] / pixelRatio,
	            content[1] / pixelRatio,
	            image.displaySize[0] - content[2] / pixelRatio,
	            image.displaySize[1] - content[3] / pixelRatio
	        ];
	    }
	    var textLeft = shapedText.left * fontScale;
	    var textRight = shapedText.right * fontScale;
	    var top, right, bottom, left;
	    if (textFit === 'width' || textFit === 'both') {
	        left = iconOffset[0] + textLeft - padding[3];
	        right = iconOffset[0] + textRight + padding[1];
	    } else {
	        left = iconOffset[0] + (textLeft + textRight - image.displaySize[0]) / 2;
	        right = left + image.displaySize[0];
	    }
	    var textTop = shapedText.top * fontScale;
	    var textBottom = shapedText.bottom * fontScale;
	    if (textFit === 'height' || textFit === 'both') {
	        top = iconOffset[1] + textTop - padding[0];
	        bottom = iconOffset[1] + textBottom + padding[2];
	    } else {
	        top = iconOffset[1] + (textTop + textBottom - image.displaySize[1]) / 2;
	        bottom = top + image.displaySize[1];
	    }
	    return {
	        image: image,
	        top: top,
	        right: right,
	        bottom: bottom,
	        left: left,
	        collisionPadding: collisionPadding
	    };
	}

	var Anchor = function (Point) {
	    function Anchor(x, y, angle, segment) {
	        Point.call(this, x, y);
	        this.angle = angle;
	        if (segment !== undefined) {
	            this.segment = segment;
	        }
	    }
	    if (Point)
	        Anchor.__proto__ = Point;
	    Anchor.prototype = Object.create(Point && Point.prototype);
	    Anchor.prototype.constructor = Anchor;
	    Anchor.prototype.clone = function clone() {
	        return new Anchor(this.x, this.y, this.angle, this.segment);
	    };
	    return Anchor;
	}(pointGeometry);
	register('Anchor', Anchor);

	var SIZE_PACK_FACTOR = 128;
	function getSizeData(tileZoom, value) {
	    var expression = value.expression;
	    if (expression.kind === 'constant') {
	        var layoutSize = expression.evaluate(new EvaluationParameters(tileZoom + 1));
	        return {
	            kind: 'constant',
	            layoutSize: layoutSize
	        };
	    } else if (expression.kind === 'source') {
	        return { kind: 'source' };
	    } else {
	        var zoomStops = expression.zoomStops;
	        var interpolationType = expression.interpolationType;
	        var lower = 0;
	        while (lower < zoomStops.length && zoomStops[lower] <= tileZoom) {
	            lower++;
	        }
	        lower = Math.max(0, lower - 1);
	        var upper = lower;
	        while (upper < zoomStops.length && zoomStops[upper] < tileZoom + 1) {
	            upper++;
	        }
	        upper = Math.min(zoomStops.length - 1, upper);
	        var minZoom = zoomStops[lower];
	        var maxZoom = zoomStops[upper];
	        if (expression.kind === 'composite') {
	            return {
	                kind: 'composite',
	                minZoom: minZoom,
	                maxZoom: maxZoom,
	                interpolationType: interpolationType
	            };
	        }
	        var minSize = expression.evaluate(new EvaluationParameters(minZoom));
	        var maxSize = expression.evaluate(new EvaluationParameters(maxZoom));
	        return {
	            kind: 'camera',
	            minZoom: minZoom,
	            maxZoom: maxZoom,
	            minSize: minSize,
	            maxSize: maxSize,
	            interpolationType: interpolationType
	        };
	    }
	}
	function evaluateSizeForFeature(sizeData, ref, ref$1) {
	    var uSize = ref.uSize;
	    var uSizeT = ref.uSizeT;
	    var lowerSize = ref$1.lowerSize;
	    var upperSize = ref$1.upperSize;
	    if (sizeData.kind === 'source') {
	        return lowerSize / SIZE_PACK_FACTOR;
	    } else if (sizeData.kind === 'composite') {
	        return number(lowerSize / SIZE_PACK_FACTOR, upperSize / SIZE_PACK_FACTOR, uSizeT);
	    }
	    return uSize;
	}
	function evaluateSizeForZoom(sizeData, zoom) {
	    var uSizeT = 0;
	    var uSize = 0;
	    if (sizeData.kind === 'constant') {
	        uSize = sizeData.layoutSize;
	    } else if (sizeData.kind !== 'source') {
	        var interpolationType = sizeData.interpolationType;
	        var minZoom = sizeData.minZoom;
	        var maxZoom = sizeData.maxZoom;
	        var t = !interpolationType ? 0 : clamp(Interpolate.interpolationFactor(interpolationType, zoom, minZoom, maxZoom), 0, 1);
	        if (sizeData.kind === 'camera') {
	            uSize = number(sizeData.minSize, sizeData.maxSize, t);
	        } else {
	            uSizeT = t;
	        }
	    }
	    return {
	        uSizeT: uSizeT,
	        uSize: uSize
	    };
	}

	var symbolSize = /*#__PURE__*/Object.freeze({
	__proto__: null,
	getSizeData: getSizeData,
	evaluateSizeForFeature: evaluateSizeForFeature,
	evaluateSizeForZoom: evaluateSizeForZoom,
	SIZE_PACK_FACTOR: SIZE_PACK_FACTOR
	});

	function checkMaxAngle(line, anchor, labelLength, windowSize, maxAngle) {
	    if (anchor.segment === undefined) {
	        return true;
	    }
	    var p = anchor;
	    var index = anchor.segment + 1;
	    var anchorDistance = 0;
	    while (anchorDistance > -labelLength / 2) {
	        index--;
	        if (index < 0) {
	            return false;
	        }
	        anchorDistance -= line[index].dist(p);
	        p = line[index];
	    }
	    anchorDistance += line[index].dist(line[index + 1]);
	    index++;
	    var recentCorners = [];
	    var recentAngleDelta = 0;
	    while (anchorDistance < labelLength / 2) {
	        var prev = line[index - 1];
	        var current = line[index];
	        var next = line[index + 1];
	        if (!next) {
	            return false;
	        }
	        var angleDelta = prev.angleTo(current) - current.angleTo(next);
	        angleDelta = Math.abs((angleDelta + 3 * Math.PI) % (Math.PI * 2) - Math.PI);
	        recentCorners.push({
	            distance: anchorDistance,
	            angleDelta: angleDelta
	        });
	        recentAngleDelta += angleDelta;
	        while (anchorDistance - recentCorners[0].distance > windowSize) {
	            recentAngleDelta -= recentCorners.shift().angleDelta;
	        }
	        if (recentAngleDelta > maxAngle) {
	            return false;
	        }
	        index++;
	        anchorDistance += current.dist(next);
	    }
	    return true;
	}

	function getLineLength(line) {
	    var lineLength = 0;
	    for (var k = 0; k < line.length - 1; k++) {
	        lineLength += line[k].dist(line[k + 1]);
	    }
	    return lineLength;
	}
	function getAngleWindowSize(shapedText, glyphSize, boxScale) {
	    return shapedText ? 3 / 5 * glyphSize * boxScale : 0;
	}
	function getShapedLabelLength(shapedText, shapedIcon) {
	    return Math.max(shapedText ? shapedText.right - shapedText.left : 0, shapedIcon ? shapedIcon.right - shapedIcon.left : 0);
	}
	function getCenterAnchor(line, maxAngle, shapedText, shapedIcon, glyphSize, boxScale) {
	    var angleWindowSize = getAngleWindowSize(shapedText, glyphSize, boxScale);
	    var labelLength = getShapedLabelLength(shapedText, shapedIcon) * boxScale;
	    var prevDistance = 0;
	    var centerDistance = getLineLength(line) / 2;
	    for (var i = 0; i < line.length - 1; i++) {
	        var a = line[i], b = line[i + 1];
	        var segmentDistance = a.dist(b);
	        if (prevDistance + segmentDistance > centerDistance) {
	            var t = (centerDistance - prevDistance) / segmentDistance, x = number(a.x, b.x, t), y = number(a.y, b.y, t);
	            var anchor = new Anchor(x, y, b.angleTo(a), i);
	            anchor._round();
	            if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {
	                return anchor;
	            } else {
	                return;
	            }
	        }
	        prevDistance += segmentDistance;
	    }
	}
	function getAnchors(line, spacing, maxAngle, shapedText, shapedIcon, glyphSize, boxScale, overscaling, tileExtent) {
	    var angleWindowSize = getAngleWindowSize(shapedText, glyphSize, boxScale);
	    var shapedLabelLength = getShapedLabelLength(shapedText, shapedIcon);
	    var labelLength = shapedLabelLength * boxScale;
	    var isLineContinued = line[0].x === 0 || line[0].x === tileExtent || line[0].y === 0 || line[0].y === tileExtent;
	    if (spacing - labelLength < spacing / 4) {
	        spacing = labelLength + spacing / 4;
	    }
	    var fixedExtraOffset = glyphSize * 2;
	    var offset = !isLineContinued ? (shapedLabelLength / 2 + fixedExtraOffset) * boxScale * overscaling % spacing : spacing / 2 * overscaling % spacing;
	    return resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, false, tileExtent);
	}
	function resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, placeAtMiddle, tileExtent) {
	    var halfLabelLength = labelLength / 2;
	    var lineLength = getLineLength(line);
	    var distance = 0, markedDistance = offset - spacing;
	    var anchors = [];
	    for (var i = 0; i < line.length - 1; i++) {
	        var a = line[i], b = line[i + 1];
	        var segmentDist = a.dist(b), angle = b.angleTo(a);
	        while (markedDistance + spacing < distance + segmentDist) {
	            markedDistance += spacing;
	            var t = (markedDistance - distance) / segmentDist, x = number(a.x, b.x, t), y = number(a.y, b.y, t);
	            if (x >= 0 && x < tileExtent && y >= 0 && y < tileExtent && markedDistance - halfLabelLength >= 0 && markedDistance + halfLabelLength <= lineLength) {
	                var anchor = new Anchor(x, y, angle, i);
	                anchor._round();
	                if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {
	                    anchors.push(anchor);
	                }
	            }
	        }
	        distance += segmentDist;
	    }
	    if (!placeAtMiddle && !anchors.length && !isLineContinued) {
	        anchors = resample(line, distance / 2, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, true, tileExtent);
	    }
	    return anchors;
	}

	function clipLine(lines, x1, y1, x2, y2) {
	    var clippedLines = [];
	    for (var l = 0; l < lines.length; l++) {
	        var line = lines[l];
	        var clippedLine = void 0;
	        for (var i = 0; i < line.length - 1; i++) {
	            var p0 = line[i];
	            var p1 = line[i + 1];
	            if (p0.x < x1 && p1.x < x1) {
	                continue;
	            } else if (p0.x < x1) {
	                p0 = new pointGeometry(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();
	            } else if (p1.x < x1) {
	                p1 = new pointGeometry(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();
	            }
	            if (p0.y < y1 && p1.y < y1) {
	                continue;
	            } else if (p0.y < y1) {
	                p0 = new pointGeometry(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();
	            } else if (p1.y < y1) {
	                p1 = new pointGeometry(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();
	            }
	            if (p0.x >= x2 && p1.x >= x2) {
	                continue;
	            } else if (p0.x >= x2) {
	                p0 = new pointGeometry(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();
	            } else if (p1.x >= x2) {
	                p1 = new pointGeometry(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();
	            }
	            if (p0.y >= y2 && p1.y >= y2) {
	                continue;
	            } else if (p0.y >= y2) {
	                p0 = new pointGeometry(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();
	            } else if (p1.y >= y2) {
	                p1 = new pointGeometry(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();
	            }
	            if (!clippedLine || !p0.equals(clippedLine[clippedLine.length - 1])) {
	                clippedLine = [p0];
	                clippedLines.push(clippedLine);
	            }
	            clippedLine.push(p1);
	        }
	    }
	    return clippedLines;
	}

	var border$1 = IMAGE_PADDING;
	function getIconQuads(shapedIcon, iconRotate, isSDFIcon, hasIconTextFit) {
	    var quads = [];
	    var image = shapedIcon.image;
	    var pixelRatio = image.pixelRatio;
	    var imageWidth = image.paddedRect.w - 2 * border$1;
	    var imageHeight = image.paddedRect.h - 2 * border$1;
	    var iconWidth = shapedIcon.right - shapedIcon.left;
	    var iconHeight = shapedIcon.bottom - shapedIcon.top;
	    var stretchX = image.stretchX || [[
	            0,
	            imageWidth
	        ]];
	    var stretchY = image.stretchY || [[
	            0,
	            imageHeight
	        ]];
	    var reduceRanges = function (sum, range) {
	        return sum + range[1] - range[0];
	    };
	    var stretchWidth = stretchX.reduce(reduceRanges, 0);
	    var stretchHeight = stretchY.reduce(reduceRanges, 0);
	    var fixedWidth = imageWidth - stretchWidth;
	    var fixedHeight = imageHeight - stretchHeight;
	    var stretchOffsetX = 0;
	    var stretchContentWidth = stretchWidth;
	    var stretchOffsetY = 0;
	    var stretchContentHeight = stretchHeight;
	    var fixedOffsetX = 0;
	    var fixedContentWidth = fixedWidth;
	    var fixedOffsetY = 0;
	    var fixedContentHeight = fixedHeight;
	    if (image.content && hasIconTextFit) {
	        var content = image.content;
	        stretchOffsetX = sumWithinRange(stretchX, 0, content[0]);
	        stretchOffsetY = sumWithinRange(stretchY, 0, content[1]);
	        stretchContentWidth = sumWithinRange(stretchX, content[0], content[2]);
	        stretchContentHeight = sumWithinRange(stretchY, content[1], content[3]);
	        fixedOffsetX = content[0] - stretchOffsetX;
	        fixedOffsetY = content[1] - stretchOffsetY;
	        fixedContentWidth = content[2] - content[0] - stretchContentWidth;
	        fixedContentHeight = content[3] - content[1] - stretchContentHeight;
	    }
	    var makeBox = function (left, top, right, bottom) {
	        var leftEm = getEmOffset(left.stretch - stretchOffsetX, stretchContentWidth, iconWidth, shapedIcon.left);
	        var leftPx = getPxOffset(left.fixed - fixedOffsetX, fixedContentWidth, left.stretch, stretchWidth);
	        var topEm = getEmOffset(top.stretch - stretchOffsetY, stretchContentHeight, iconHeight, shapedIcon.top);
	        var topPx = getPxOffset(top.fixed - fixedOffsetY, fixedContentHeight, top.stretch, stretchHeight);
	        var rightEm = getEmOffset(right.stretch - stretchOffsetX, stretchContentWidth, iconWidth, shapedIcon.left);
	        var rightPx = getPxOffset(right.fixed - fixedOffsetX, fixedContentWidth, right.stretch, stretchWidth);
	        var bottomEm = getEmOffset(bottom.stretch - stretchOffsetY, stretchContentHeight, iconHeight, shapedIcon.top);
	        var bottomPx = getPxOffset(bottom.fixed - fixedOffsetY, fixedContentHeight, bottom.stretch, stretchHeight);
	        var tl = new pointGeometry(leftEm, topEm);
	        var tr = new pointGeometry(rightEm, topEm);
	        var br = new pointGeometry(rightEm, bottomEm);
	        var bl = new pointGeometry(leftEm, bottomEm);
	        var pixelOffsetTL = new pointGeometry(leftPx / pixelRatio, topPx / pixelRatio);
	        var pixelOffsetBR = new pointGeometry(rightPx / pixelRatio, bottomPx / pixelRatio);
	        var angle = iconRotate * Math.PI / 180;
	        if (angle) {
	            var sin = Math.sin(angle), cos = Math.cos(angle), matrix = [
	                    cos,
	                    -sin,
	                    sin,
	                    cos
	                ];
	            tl._matMult(matrix);
	            tr._matMult(matrix);
	            bl._matMult(matrix);
	            br._matMult(matrix);
	        }
	        var x1 = left.stretch + left.fixed;
	        var x2 = right.stretch + right.fixed;
	        var y1 = top.stretch + top.fixed;
	        var y2 = bottom.stretch + bottom.fixed;
	        var subRect = {
	            x: image.paddedRect.x + border$1 + x1,
	            y: image.paddedRect.y + border$1 + y1,
	            w: x2 - x1,
	            h: y2 - y1
	        };
	        var minFontScaleX = fixedContentWidth / pixelRatio / iconWidth;
	        var minFontScaleY = fixedContentHeight / pixelRatio / iconHeight;
	        return {
	            tl: tl,
	            tr: tr,
	            bl: bl,
	            br: br,
	            tex: subRect,
	            writingMode: undefined,
	            glyphOffset: [
	                0,
	                0
	            ],
	            sectionIndex: 0,
	            pixelOffsetTL: pixelOffsetTL,
	            pixelOffsetBR: pixelOffsetBR,
	            minFontScaleX: minFontScaleX,
	            minFontScaleY: minFontScaleY,
	            isSDF: isSDFIcon
	        };
	    };
	    if (!hasIconTextFit || !image.stretchX && !image.stretchY) {
	        quads.push(makeBox({
	            fixed: 0,
	            stretch: -1
	        }, {
	            fixed: 0,
	            stretch: -1
	        }, {
	            fixed: 0,
	            stretch: imageWidth + 1
	        }, {
	            fixed: 0,
	            stretch: imageHeight + 1
	        }));
	    } else {
	        var xCuts = stretchZonesToCuts(stretchX, fixedWidth, stretchWidth);
	        var yCuts = stretchZonesToCuts(stretchY, fixedHeight, stretchHeight);
	        for (var xi = 0; xi < xCuts.length - 1; xi++) {
	            var x1 = xCuts[xi];
	            var x2 = xCuts[xi + 1];
	            for (var yi = 0; yi < yCuts.length - 1; yi++) {
	                var y1 = yCuts[yi];
	                var y2 = yCuts[yi + 1];
	                quads.push(makeBox(x1, y1, x2, y2));
	            }
	        }
	    }
	    return quads;
	}
	function sumWithinRange(ranges, min, max) {
	    var sum = 0;
	    for (var i = 0, list = ranges; i < list.length; i += 1) {
	        var range = list[i];
	        sum += Math.max(min, Math.min(max, range[1])) - Math.max(min, Math.min(max, range[0]));
	    }
	    return sum;
	}
	function stretchZonesToCuts(stretchZones, fixedSize, stretchSize) {
	    var cuts = [{
	            fixed: -border$1,
	            stretch: 0
	        }];
	    for (var i = 0, list = stretchZones; i < list.length; i += 1) {
	        var ref = list[i];
	        var c1 = ref[0];
	        var c2 = ref[1];
	        var last = cuts[cuts.length - 1];
	        cuts.push({
	            fixed: c1 - last.stretch,
	            stretch: last.stretch
	        });
	        cuts.push({
	            fixed: c1 - last.stretch,
	            stretch: last.stretch + (c2 - c1)
	        });
	    }
	    cuts.push({
	        fixed: fixedSize + border$1,
	        stretch: stretchSize
	    });
	    return cuts;
	}
	function getEmOffset(stretchOffset, stretchSize, iconSize, iconOffset) {
	    return stretchOffset / stretchSize * iconSize + iconOffset;
	}
	function getPxOffset(fixedOffset, fixedSize, stretchOffset, stretchSize) {
	    return fixedOffset - fixedSize * stretchOffset / stretchSize;
	}
	function getGlyphQuads(anchor, shaping, textOffset, layer, alongLine, feature, imageMap, allowVerticalPlacement) {
	    var textRotate = layer.layout.get('text-rotate').evaluate(feature, {}) * Math.PI / 180;
	    var quads = [];
	    for (var i$1 = 0, list$1 = shaping.positionedLines; i$1 < list$1.length; i$1 += 1) {
	        var line = list$1[i$1];
	        for (var i = 0, list = line.positionedGlyphs; i < list.length; i += 1) {
	            var positionedGlyph = list[i];
	            if (!positionedGlyph.rect) {
	                continue;
	            }
	            var textureRect = positionedGlyph.rect || {};
	            var glyphPadding = 1;
	            var rectBuffer = GLYPH_PBF_BORDER + glyphPadding;
	            var isSDF = true;
	            var pixelRatio = 1;
	            var lineOffset = 0;
	            var rotateVerticalGlyph = (alongLine || allowVerticalPlacement) && positionedGlyph.vertical;
	            var halfAdvance = positionedGlyph.metrics.advance * positionedGlyph.scale / 2;
	            if (allowVerticalPlacement && shaping.verticalizable) {
	                var scaledGlyphOffset = (positionedGlyph.scale - 1) * ONE_EM;
	                var imageOffset = (ONE_EM - positionedGlyph.metrics.width * positionedGlyph.scale) / 2;
	                lineOffset = line.lineOffset / 2 - (positionedGlyph.imageName ? -imageOffset : scaledGlyphOffset);
	            }
	            if (positionedGlyph.imageName) {
	                var image = imageMap[positionedGlyph.imageName];
	                isSDF = image.sdf;
	                pixelRatio = image.pixelRatio;
	                rectBuffer = IMAGE_PADDING / pixelRatio;
	            }
	            var glyphOffset = alongLine ? [
	                positionedGlyph.x + halfAdvance,
	                positionedGlyph.y
	            ] : [
	                0,
	                0
	            ];
	            var builtInOffset = alongLine ? [
	                0,
	                0
	            ] : [
	                positionedGlyph.x + halfAdvance + textOffset[0],
	                positionedGlyph.y + textOffset[1] - lineOffset
	            ];
	            var verticalizedLabelOffset = [
	                0,
	                0
	            ];
	            if (rotateVerticalGlyph) {
	                verticalizedLabelOffset = builtInOffset;
	                builtInOffset = [
	                    0,
	                    0
	                ];
	            }
	            var x1 = (positionedGlyph.metrics.left - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];
	            var y1 = (-positionedGlyph.metrics.top - rectBuffer) * positionedGlyph.scale + builtInOffset[1];
	            var x2 = x1 + textureRect.w * positionedGlyph.scale / pixelRatio;
	            var y2 = y1 + textureRect.h * positionedGlyph.scale / pixelRatio;
	            var tl = new pointGeometry(x1, y1);
	            var tr = new pointGeometry(x2, y1);
	            var bl = new pointGeometry(x1, y2);
	            var br = new pointGeometry(x2, y2);
	            if (rotateVerticalGlyph) {
	                var center = new pointGeometry(-halfAdvance, halfAdvance - SHAPING_DEFAULT_OFFSET);
	                var verticalRotation = -Math.PI / 2;
	                var xHalfWidthOffsetCorrection = ONE_EM / 2 - halfAdvance;
	                var yImageOffsetCorrection = positionedGlyph.imageName ? xHalfWidthOffsetCorrection : 0;
	                var halfWidthOffsetCorrection = new pointGeometry(5 - SHAPING_DEFAULT_OFFSET - xHalfWidthOffsetCorrection, -yImageOffsetCorrection);
	                var verticalOffsetCorrection = new (Function.prototype.bind.apply(pointGeometry, [null].concat(verticalizedLabelOffset)))();
	                tl._rotateAround(verticalRotation, center)._add(halfWidthOffsetCorrection)._add(verticalOffsetCorrection);
	                tr._rotateAround(verticalRotation, center)._add(halfWidthOffsetCorrection)._add(verticalOffsetCorrection);
	                bl._rotateAround(verticalRotation, center)._add(halfWidthOffsetCorrection)._add(verticalOffsetCorrection);
	                br._rotateAround(verticalRotation, center)._add(halfWidthOffsetCorrection)._add(verticalOffsetCorrection);
	            }
	            if (textRotate) {
	                var sin = Math.sin(textRotate), cos = Math.cos(textRotate), matrix = [
	                        cos,
	                        -sin,
	                        sin,
	                        cos
	                    ];
	                tl._matMult(matrix);
	                tr._matMult(matrix);
	                bl._matMult(matrix);
	                br._matMult(matrix);
	            }
	            var pixelOffsetTL = new pointGeometry(0, 0);
	            var pixelOffsetBR = new pointGeometry(0, 0);
	            var minFontScaleX = 0;
	            var minFontScaleY = 0;
	            quads.push({
	                tl: tl,
	                tr: tr,
	                bl: bl,
	                br: br,
	                tex: textureRect,
	                writingMode: shaping.writingMode,
	                glyphOffset: glyphOffset,
	                sectionIndex: positionedGlyph.sectionIndex,
	                isSDF: isSDF,
	                pixelOffsetTL: pixelOffsetTL,
	                pixelOffsetBR: pixelOffsetBR,
	                minFontScaleX: minFontScaleX,
	                minFontScaleY: minFontScaleY
	            });
	        }
	    }
	    return quads;
	}

	var CollisionFeature = function CollisionFeature(collisionBoxArray, anchor, featureIndex, sourceLayerIndex, bucketIndex, shaped, boxScale, padding, alignLine, rotate) {
	    this.boxStartIndex = collisionBoxArray.length;
	    if (alignLine) {
	        var top = shaped.top;
	        var bottom = shaped.bottom;
	        var collisionPadding = shaped.collisionPadding;
	        if (collisionPadding) {
	            top -= collisionPadding[1];
	            bottom += collisionPadding[3];
	        }
	        var height = bottom - top;
	        if (height > 0) {
	            height = Math.max(10, height);
	            this.circleDiameter = height;
	        }
	    } else {
	        var y1 = shaped.top * boxScale - padding;
	        var y2 = shaped.bottom * boxScale + padding;
	        var x1 = shaped.left * boxScale - padding;
	        var x2 = shaped.right * boxScale + padding;
	        var collisionPadding$1 = shaped.collisionPadding;
	        if (collisionPadding$1) {
	            x1 -= collisionPadding$1[0] * boxScale;
	            y1 -= collisionPadding$1[1] * boxScale;
	            x2 += collisionPadding$1[2] * boxScale;
	            y2 += collisionPadding$1[3] * boxScale;
	        }
	        if (rotate) {
	            var tl = new pointGeometry(x1, y1);
	            var tr = new pointGeometry(x2, y1);
	            var bl = new pointGeometry(x1, y2);
	            var br = new pointGeometry(x2, y2);
	            var rotateRadians = rotate * Math.PI / 180;
	            tl._rotate(rotateRadians);
	            tr._rotate(rotateRadians);
	            bl._rotate(rotateRadians);
	            br._rotate(rotateRadians);
	            x1 = Math.min(tl.x, tr.x, bl.x, br.x);
	            x2 = Math.max(tl.x, tr.x, bl.x, br.x);
	            y1 = Math.min(tl.y, tr.y, bl.y, br.y);
	            y2 = Math.max(tl.y, tr.y, bl.y, br.y);
	        }
	        collisionBoxArray.emplaceBack(anchor.x, anchor.y, x1, y1, x2, y2, featureIndex, sourceLayerIndex, bucketIndex);
	    }
	    this.boxEndIndex = collisionBoxArray.length;
	};

	var TinyQueue = function TinyQueue(data, compare) {
	    if (data === void 0)
	        data = [];
	    if (compare === void 0)
	        compare = defaultCompare$1;
	    this.data = data;
	    this.length = this.data.length;
	    this.compare = compare;
	    if (this.length > 0) {
	        for (var i = (this.length >> 1) - 1; i >= 0; i--) {
	            this._down(i);
	        }
	    }
	};
	TinyQueue.prototype.push = function push(item) {
	    this.data.push(item);
	    this.length++;
	    this._up(this.length - 1);
	};
	TinyQueue.prototype.pop = function pop() {
	    if (this.length === 0) {
	        return undefined;
	    }
	    var top = this.data[0];
	    var bottom = this.data.pop();
	    this.length--;
	    if (this.length > 0) {
	        this.data[0] = bottom;
	        this._down(0);
	    }
	    return top;
	};
	TinyQueue.prototype.peek = function peek() {
	    return this.data[0];
	};
	TinyQueue.prototype._up = function _up(pos) {
	    var ref = this;
	    var data = ref.data;
	    var compare = ref.compare;
	    var item = data[pos];
	    while (pos > 0) {
	        var parent = pos - 1 >> 1;
	        var current = data[parent];
	        if (compare(item, current) >= 0) {
	            break;
	        }
	        data[pos] = current;
	        pos = parent;
	    }
	    data[pos] = item;
	};
	TinyQueue.prototype._down = function _down(pos) {
	    var ref = this;
	    var data = ref.data;
	    var compare = ref.compare;
	    var halfLength = this.length >> 1;
	    var item = data[pos];
	    while (pos < halfLength) {
	        var left = (pos << 1) + 1;
	        var best = data[left];
	        var right = left + 1;
	        if (right < this.length && compare(data[right], best) < 0) {
	            left = right;
	            best = data[right];
	        }
	        if (compare(best, item) >= 0) {
	            break;
	        }
	        data[pos] = best;
	        pos = left;
	    }
	    data[pos] = item;
	};
	function defaultCompare$1(a, b) {
	    return a < b ? -1 : a > b ? 1 : 0;
	}

	function findPoleOfInaccessibility (polygonRings, precision, debug) {
	    if (precision === void 0)
	        precision = 1;
	    if (debug === void 0)
	        debug = false;
	    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
	    var outerRing = polygonRings[0];
	    for (var i = 0; i < outerRing.length; i++) {
	        var p = outerRing[i];
	        if (!i || p.x < minX) {
	            minX = p.x;
	        }
	        if (!i || p.y < minY) {
	            minY = p.y;
	        }
	        if (!i || p.x > maxX) {
	            maxX = p.x;
	        }
	        if (!i || p.y > maxY) {
	            maxY = p.y;
	        }
	    }
	    var width = maxX - minX;
	    var height = maxY - minY;
	    var cellSize = Math.min(width, height);
	    var h = cellSize / 2;
	    var cellQueue = new TinyQueue([], compareMax);
	    if (cellSize === 0) {
	        return new pointGeometry(minX, minY);
	    }
	    for (var x = minX; x < maxX; x += cellSize) {
	        for (var y = minY; y < maxY; y += cellSize) {
	            cellQueue.push(new Cell(x + h, y + h, h, polygonRings));
	        }
	    }
	    var bestCell = getCentroidCell(polygonRings);
	    var numProbes = cellQueue.length;
	    while (cellQueue.length) {
	        var cell = cellQueue.pop();
	        if (cell.d > bestCell.d || !bestCell.d) {
	            bestCell = cell;
	            if (debug) {
	                console.log('found best %d after %d probes', Math.round(10000 * cell.d) / 10000, numProbes);
	            }
	        }
	        if (cell.max - bestCell.d <= precision) {
	            continue;
	        }
	        h = cell.h / 2;
	        cellQueue.push(new Cell(cell.p.x - h, cell.p.y - h, h, polygonRings));
	        cellQueue.push(new Cell(cell.p.x + h, cell.p.y - h, h, polygonRings));
	        cellQueue.push(new Cell(cell.p.x - h, cell.p.y + h, h, polygonRings));
	        cellQueue.push(new Cell(cell.p.x + h, cell.p.y + h, h, polygonRings));
	        numProbes += 4;
	    }
	    if (debug) {
	        console.log('num probes: ' + numProbes);
	        console.log('best distance: ' + bestCell.d);
	    }
	    return bestCell.p;
	}
	function compareMax(a, b) {
	    return b.max - a.max;
	}
	function Cell(x, y, h, polygon) {
	    this.p = new pointGeometry(x, y);
	    this.h = h;
	    this.d = pointToPolygonDist(this.p, polygon);
	    this.max = this.d + this.h * Math.SQRT2;
	}
	function pointToPolygonDist(p, polygon) {
	    var inside = false;
	    var minDistSq = Infinity;
	    for (var k = 0; k < polygon.length; k++) {
	        var ring = polygon[k];
	        for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
	            var a = ring[i];
	            var b = ring[j];
	            if (a.y > p.y !== b.y > p.y && p.x < (b.x - a.x) * (p.y - a.y) / (b.y - a.y) + a.x) {
	                inside = !inside;
	            }
	            minDistSq = Math.min(minDistSq, distToSegmentSquared(p, a, b));
	        }
	    }
	    return (inside ? 1 : -1) * Math.sqrt(minDistSq);
	}
	function getCentroidCell(polygon) {
	    var area = 0;
	    var x = 0;
	    var y = 0;
	    var points = polygon[0];
	    for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {
	        var a = points[i];
	        var b = points[j];
	        var f = a.x * b.y - b.x * a.y;
	        x += (a.x + b.x) * f;
	        y += (a.y + b.y) * f;
	        area += f * 3;
	    }
	    return new Cell(x / area, y / area, 0, polygon);
	}

	var baselineOffset = 7;
	var INVALID_TEXT_OFFSET = Number.POSITIVE_INFINITY;
	function evaluateVariableOffset(anchor, offset) {
	    function fromRadialOffset(anchor, radialOffset) {
	        var x = 0, y = 0;
	        if (radialOffset < 0) {
	            radialOffset = 0;
	        }
	        var hypotenuse = radialOffset / Math.sqrt(2);
	        switch (anchor) {
	        case 'top-right':
	        case 'top-left':
	            y = hypotenuse - baselineOffset;
	            break;
	        case 'bottom-right':
	        case 'bottom-left':
	            y = -hypotenuse + baselineOffset;
	            break;
	        case 'bottom':
	            y = -radialOffset + baselineOffset;
	            break;
	        case 'top':
	            y = radialOffset - baselineOffset;
	            break;
	        }
	        switch (anchor) {
	        case 'top-right':
	        case 'bottom-right':
	            x = -hypotenuse;
	            break;
	        case 'top-left':
	        case 'bottom-left':
	            x = hypotenuse;
	            break;
	        case 'left':
	            x = radialOffset;
	            break;
	        case 'right':
	            x = -radialOffset;
	            break;
	        }
	        return [
	            x,
	            y
	        ];
	    }
	    function fromTextOffset(anchor, offsetX, offsetY) {
	        var x = 0, y = 0;
	        offsetX = Math.abs(offsetX);
	        offsetY = Math.abs(offsetY);
	        switch (anchor) {
	        case 'top-right':
	        case 'top-left':
	        case 'top':
	            y = offsetY - baselineOffset;
	            break;
	        case 'bottom-right':
	        case 'bottom-left':
	        case 'bottom':
	            y = -offsetY + baselineOffset;
	            break;
	        }
	        switch (anchor) {
	        case 'top-right':
	        case 'bottom-right':
	        case 'right':
	            x = -offsetX;
	            break;
	        case 'top-left':
	        case 'bottom-left':
	        case 'left':
	            x = offsetX;
	            break;
	        }
	        return [
	            x,
	            y
	        ];
	    }
	    return offset[1] !== INVALID_TEXT_OFFSET ? fromTextOffset(anchor, offset[0], offset[1]) : fromRadialOffset(anchor, offset[0]);
	}
	function performSymbolLayout(bucket, glyphMap, glyphPositions, imageMap, imagePositions, showCollisionBoxes, canonical) {
	    bucket.createArrays();
	    var tileSize = 512 * bucket.overscaling;
	    bucket.tilePixelRatio = EXTENT$1 / tileSize;
	    bucket.compareText = {};
	    bucket.iconsNeedLinear = false;
	    var layout = bucket.layers[0].layout;
	    var unevaluatedLayoutValues = bucket.layers[0]._unevaluatedLayout._values;
	    var sizes = {};
	    if (bucket.textSizeData.kind === 'composite') {
	        var ref = bucket.textSizeData;
	        var minZoom = ref.minZoom;
	        var maxZoom = ref.maxZoom;
	        sizes.compositeTextSizes = [
	            unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(minZoom), canonical),
	            unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(maxZoom), canonical)
	        ];
	    }
	    if (bucket.iconSizeData.kind === 'composite') {
	        var ref$1 = bucket.iconSizeData;
	        var minZoom$1 = ref$1.minZoom;
	        var maxZoom$1 = ref$1.maxZoom;
	        sizes.compositeIconSizes = [
	            unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(minZoom$1), canonical),
	            unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(maxZoom$1), canonical)
	        ];
	    }
	    sizes.layoutTextSize = unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(bucket.zoom + 1), canonical);
	    sizes.layoutIconSize = unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(bucket.zoom + 1), canonical);
	    sizes.textMaxSize = unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(18));
	    var lineHeight = layout.get('text-line-height') * ONE_EM;
	    var textAlongLine = layout.get('text-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point';
	    var keepUpright = layout.get('text-keep-upright');
	    var textSize = layout.get('text-size');
	    var loop = function () {
	        var feature = list[i$1];
	        var fontstack = layout.get('text-font').evaluate(feature, {}, canonical).join(',');
	        var layoutTextSizeThisZoom = textSize.evaluate(feature, {}, canonical);
	        var layoutTextSize = sizes.layoutTextSize.evaluate(feature, {}, canonical);
	        var layoutIconSize = sizes.layoutIconSize.evaluate(feature, {}, canonical);
	        var shapedTextOrientations = {
	            horizontal: {},
	            vertical: undefined
	        };
	        var text = feature.text;
	        var textOffset = [
	            0,
	            0
	        ];
	        if (text) {
	            var unformattedText = text.toString();
	            var spacing = layout.get('text-letter-spacing').evaluate(feature, {}, canonical) * ONE_EM;
	            var spacingIfAllowed = allowsLetterSpacing(unformattedText) ? spacing : 0;
	            var textAnchor = layout.get('text-anchor').evaluate(feature, {}, canonical);
	            var variableTextAnchor = layout.get('text-variable-anchor');
	            if (!variableTextAnchor) {
	                var radialOffset = layout.get('text-radial-offset').evaluate(feature, {}, canonical);
	                if (radialOffset) {
	                    textOffset = evaluateVariableOffset(textAnchor, [
	                        radialOffset * ONE_EM,
	                        INVALID_TEXT_OFFSET
	                    ]);
	                } else {
	                    textOffset = layout.get('text-offset').evaluate(feature, {}, canonical).map(function (t) {
	                        return t * ONE_EM;
	                    });
	                }
	            }
	            var textJustify = textAlongLine ? 'center' : layout.get('text-justify').evaluate(feature, {}, canonical);
	            var symbolPlacement = layout.get('symbol-placement');
	            var maxWidth = symbolPlacement === 'point' ? layout.get('text-max-width').evaluate(feature, {}, canonical) * ONE_EM : 0;
	            var addVerticalShapingForPointLabelIfNeeded = function () {
	                if (bucket.allowVerticalPlacement && allowsVerticalWritingMode(unformattedText)) {
	                    shapedTextOrientations.vertical = shapeText(text, glyphMap, glyphPositions, imagePositions, fontstack, maxWidth, lineHeight, textAnchor, 'left', spacingIfAllowed, textOffset, WritingMode.vertical, true, symbolPlacement, layoutTextSize, layoutTextSizeThisZoom);
	                }
	            };
	            if (!textAlongLine && variableTextAnchor) {
	                var justifications = textJustify === 'auto' ? variableTextAnchor.map(function (a) {
	                    return getAnchorJustification(a);
	                }) : [textJustify];
	                var singleLine = false;
	                for (var i = 0; i < justifications.length; i++) {
	                    var justification = justifications[i];
	                    if (shapedTextOrientations.horizontal[justification]) {
	                        continue;
	                    }
	                    if (singleLine) {
	                        shapedTextOrientations.horizontal[justification] = shapedTextOrientations.horizontal[0];
	                    } else {
	                        var shaping = shapeText(text, glyphMap, glyphPositions, imagePositions, fontstack, maxWidth, lineHeight, 'center', justification, spacingIfAllowed, textOffset, WritingMode.horizontal, false, symbolPlacement, layoutTextSize, layoutTextSizeThisZoom);
	                        if (shaping) {
	                            shapedTextOrientations.horizontal[justification] = shaping;
	                            singleLine = shaping.positionedLines.length === 1;
	                        }
	                    }
	                }
	                addVerticalShapingForPointLabelIfNeeded();
	            } else {
	                if (textJustify === 'auto') {
	                    textJustify = getAnchorJustification(textAnchor);
	                }
	                var shaping$1 = shapeText(text, glyphMap, glyphPositions, imagePositions, fontstack, maxWidth, lineHeight, textAnchor, textJustify, spacingIfAllowed, textOffset, WritingMode.horizontal, false, symbolPlacement, layoutTextSize, layoutTextSizeThisZoom);
	                if (shaping$1) {
	                    shapedTextOrientations.horizontal[textJustify] = shaping$1;
	                }
	                addVerticalShapingForPointLabelIfNeeded();
	                if (allowsVerticalWritingMode(unformattedText) && textAlongLine && keepUpright) {
	                    shapedTextOrientations.vertical = shapeText(text, glyphMap, glyphPositions, imagePositions, fontstack, maxWidth, lineHeight, textAnchor, textJustify, spacingIfAllowed, textOffset, WritingMode.vertical, false, symbolPlacement, layoutTextSize, layoutTextSizeThisZoom);
	                }
	            }
	        }
	        var shapedIcon = void 0;
	        var isSDFIcon = false;
	        if (feature.icon && feature.icon.name) {
	            var image = imageMap[feature.icon.name];
	            if (image) {
	                shapedIcon = shapeIcon(imagePositions[feature.icon.name], layout.get('icon-offset').evaluate(feature, {}, canonical), layout.get('icon-anchor').evaluate(feature, {}, canonical));
	                isSDFIcon = image.sdf;
	                if (bucket.sdfIcons === undefined) {
	                    bucket.sdfIcons = image.sdf;
	                } else if (bucket.sdfIcons !== image.sdf) {
	                    warnOnce('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer');
	                }
	                if (image.pixelRatio !== bucket.pixelRatio) {
	                    bucket.iconsNeedLinear = true;
	                } else if (layout.get('icon-rotate').constantOr(1) !== 0) {
	                    bucket.iconsNeedLinear = true;
	                }
	            }
	        }
	        var shapedText = getDefaultHorizontalShaping(shapedTextOrientations.horizontal) || shapedTextOrientations.vertical;
	        bucket.iconsInText = shapedText ? shapedText.iconsInText : false;
	        if (shapedText || shapedIcon) {
	            addFeature(bucket, feature, shapedTextOrientations, shapedIcon, imageMap, sizes, layoutTextSize, layoutIconSize, textOffset, isSDFIcon, canonical);
	        }
	    };
	    for (var i$1 = 0, list = bucket.features; i$1 < list.length; i$1 += 1)
	        loop();
	    if (showCollisionBoxes) {
	        bucket.generateCollisionDebugBuffers();
	    }
	}
	function getAnchorJustification(anchor) {
	    switch (anchor) {
	    case 'right':
	    case 'top-right':
	    case 'bottom-right':
	        return 'right';
	    case 'left':
	    case 'top-left':
	    case 'bottom-left':
	        return 'left';
	    }
	    return 'center';
	}
	function addFeature(bucket, feature, shapedTextOrientations, shapedIcon, imageMap, sizes, layoutTextSize, layoutIconSize, textOffset, isSDFIcon, canonical) {
	    var textMaxSize = sizes.textMaxSize.evaluate(feature, {});
	    if (textMaxSize === undefined) {
	        textMaxSize = layoutTextSize;
	    }
	    var layout = bucket.layers[0].layout;
	    var iconOffset = layout.get('icon-offset').evaluate(feature, {}, canonical);
	    var defaultHorizontalShaping = getDefaultHorizontalShaping(shapedTextOrientations.horizontal);
	    var glyphSize = 24, fontScale = layoutTextSize / glyphSize, textBoxScale = bucket.tilePixelRatio * fontScale, textMaxBoxScale = bucket.tilePixelRatio * textMaxSize / glyphSize, iconBoxScale = bucket.tilePixelRatio * layoutIconSize, symbolMinDistance = bucket.tilePixelRatio * layout.get('symbol-spacing'), textPadding = layout.get('text-padding') * bucket.tilePixelRatio, iconPadding = layout.get('icon-padding') * bucket.tilePixelRatio, textMaxAngle = layout.get('text-max-angle') / 180 * Math.PI, textAlongLine = layout.get('text-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point', iconAlongLine = layout.get('icon-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point', symbolPlacement = layout.get('symbol-placement'), textRepeatDistance = symbolMinDistance / 2;
	    var iconTextFit = layout.get('icon-text-fit');
	    var verticallyShapedIcon;
	    if (shapedIcon && iconTextFit !== 'none') {
	        if (bucket.allowVerticalPlacement && shapedTextOrientations.vertical) {
	            verticallyShapedIcon = fitIconToText(shapedIcon, shapedTextOrientations.vertical, iconTextFit, layout.get('icon-text-fit-padding'), iconOffset, fontScale);
	        }
	        if (defaultHorizontalShaping) {
	            shapedIcon = fitIconToText(shapedIcon, defaultHorizontalShaping, iconTextFit, layout.get('icon-text-fit-padding'), iconOffset, fontScale);
	        }
	    }
	    var addSymbolAtAnchor = function (line, anchor) {
	        if (anchor.x < 0 || anchor.x >= EXTENT$1 || anchor.y < 0 || anchor.y >= EXTENT$1) {
	            return;
	        }
	        addSymbol(bucket, anchor, line, shapedTextOrientations, shapedIcon, imageMap, verticallyShapedIcon, bucket.layers[0], bucket.collisionBoxArray, feature.index, feature.sourceLayerIndex, bucket.index, textBoxScale, textPadding, textAlongLine, textOffset, iconBoxScale, iconPadding, iconAlongLine, iconOffset, feature, sizes, isSDFIcon, canonical, layoutTextSize);
	    };
	    if (symbolPlacement === 'line') {
	        for (var i$1 = 0, list$1 = clipLine(feature.geometry, 0, 0, EXTENT$1, EXTENT$1); i$1 < list$1.length; i$1 += 1) {
	            var line = list$1[i$1];
	            var anchors = getAnchors(line, symbolMinDistance, textMaxAngle, shapedTextOrientations.vertical || defaultHorizontalShaping, shapedIcon, glyphSize, textMaxBoxScale, bucket.overscaling, EXTENT$1);
	            for (var i = 0, list = anchors; i < list.length; i += 1) {
	                var anchor = list[i];
	                var shapedText = defaultHorizontalShaping;
	                if (!shapedText || !anchorIsTooClose(bucket, shapedText.text, textRepeatDistance, anchor)) {
	                    addSymbolAtAnchor(line, anchor);
	                }
	            }
	        }
	    } else if (symbolPlacement === 'line-center') {
	        for (var i$2 = 0, list$2 = feature.geometry; i$2 < list$2.length; i$2 += 1) {
	            var line$1 = list$2[i$2];
	            if (line$1.length > 1) {
	                var anchor$1 = getCenterAnchor(line$1, textMaxAngle, shapedTextOrientations.vertical || defaultHorizontalShaping, shapedIcon, glyphSize, textMaxBoxScale);
	                if (anchor$1) {
	                    addSymbolAtAnchor(line$1, anchor$1);
	                }
	            }
	        }
	    } else if (feature.type === 'Polygon') {
	        for (var i$3 = 0, list$3 = classifyRings(feature.geometry, 0); i$3 < list$3.length; i$3 += 1) {
	            var polygon = list$3[i$3];
	            var poi = findPoleOfInaccessibility(polygon, 16);
	            addSymbolAtAnchor(polygon[0], new Anchor(poi.x, poi.y, 0));
	        }
	    } else if (feature.type === 'LineString') {
	        for (var i$4 = 0, list$4 = feature.geometry; i$4 < list$4.length; i$4 += 1) {
	            var line$2 = list$4[i$4];
	            addSymbolAtAnchor(line$2, new Anchor(line$2[0].x, line$2[0].y, 0));
	        }
	    } else if (feature.type === 'Point') {
	        for (var i$6 = 0, list$6 = feature.geometry; i$6 < list$6.length; i$6 += 1) {
	            var points = list$6[i$6];
	            for (var i$5 = 0, list$5 = points; i$5 < list$5.length; i$5 += 1) {
	                var point = list$5[i$5];
	                addSymbolAtAnchor([point], new Anchor(point.x, point.y, 0));
	            }
	        }
	    }
	}
	var MAX_GLYPH_ICON_SIZE = 255;
	var MAX_PACKED_SIZE = MAX_GLYPH_ICON_SIZE * SIZE_PACK_FACTOR;
	function addTextVertices(bucket, anchor, shapedText, imageMap, layer, textAlongLine, feature, textOffset, lineArray, writingMode, placementTypes, placedTextSymbolIndices, placedIconIndex, sizes, canonical) {
	    var glyphQuads = getGlyphQuads(anchor, shapedText, textOffset, layer, textAlongLine, feature, imageMap, bucket.allowVerticalPlacement);
	    var sizeData = bucket.textSizeData;
	    var textSizeData = null;
	    if (sizeData.kind === 'source') {
	        textSizeData = [SIZE_PACK_FACTOR * layer.layout.get('text-size').evaluate(feature, {})];
	        if (textSizeData[0] > MAX_PACKED_SIZE) {
	            warnOnce(bucket.layerIds[0] + ': Value for "text-size" is >= ' + MAX_GLYPH_ICON_SIZE + '. Reduce your "text-size".');
	        }
	    } else if (sizeData.kind === 'composite') {
	        textSizeData = [
	            SIZE_PACK_FACTOR * sizes.compositeTextSizes[0].evaluate(feature, {}, canonical),
	            SIZE_PACK_FACTOR * sizes.compositeTextSizes[1].evaluate(feature, {}, canonical)
	        ];
	        if (textSizeData[0] > MAX_PACKED_SIZE || textSizeData[1] > MAX_PACKED_SIZE) {
	            warnOnce(bucket.layerIds[0] + ': Value for "text-size" is >= ' + MAX_GLYPH_ICON_SIZE + '. Reduce your "text-size".');
	        }
	    }
	    bucket.addSymbols(bucket.text, glyphQuads, textSizeData, textOffset, textAlongLine, feature, writingMode, anchor, lineArray.lineStartIndex, lineArray.lineLength, placedIconIndex, canonical);
	    for (var i = 0, list = placementTypes; i < list.length; i += 1) {
	        var placementType = list[i];
	        placedTextSymbolIndices[placementType] = bucket.text.placedSymbolArray.length - 1;
	    }
	    return glyphQuads.length * 4;
	}
	function getDefaultHorizontalShaping(horizontalShaping) {
	    for (var justification in horizontalShaping) {
	        return horizontalShaping[justification];
	    }
	    return null;
	}
	function addSymbol(bucket, anchor, line, shapedTextOrientations, shapedIcon, imageMap, verticallyShapedIcon, layer, collisionBoxArray, featureIndex, sourceLayerIndex, bucketIndex, textBoxScale, textPadding, textAlongLine, textOffset, iconBoxScale, iconPadding, iconAlongLine, iconOffset, feature, sizes, isSDFIcon, canonical, layoutTextSize) {
	    var assign;
	    var lineArray = bucket.addToLineVertexArray(anchor, line);
	    var textCollisionFeature, iconCollisionFeature, verticalTextCollisionFeature, verticalIconCollisionFeature;
	    var numIconVertices = 0;
	    var numVerticalIconVertices = 0;
	    var numHorizontalGlyphVertices = 0;
	    var numVerticalGlyphVertices = 0;
	    var placedIconSymbolIndex = -1;
	    var verticalPlacedIconSymbolIndex = -1;
	    var placedTextSymbolIndices = {};
	    var key = murmurhashJs('');
	    var textOffset0 = 0;
	    var textOffset1 = 0;
	    if (layer._unevaluatedLayout.getValue('text-radial-offset') === undefined) {
	        assign = layer.layout.get('text-offset').evaluate(feature, {}, canonical).map(function (t) {
	            return t * ONE_EM;
	        }), textOffset0 = assign[0], textOffset1 = assign[1];
	    } else {
	        textOffset0 = layer.layout.get('text-radial-offset').evaluate(feature, {}, canonical) * ONE_EM;
	        textOffset1 = INVALID_TEXT_OFFSET;
	    }
	    if (bucket.allowVerticalPlacement && shapedTextOrientations.vertical) {
	        var textRotation = layer.layout.get('text-rotate').evaluate(feature, {}, canonical);
	        var verticalTextRotation = textRotation + 90;
	        var verticalShaping = shapedTextOrientations.vertical;
	        verticalTextCollisionFeature = new CollisionFeature(collisionBoxArray, anchor, featureIndex, sourceLayerIndex, bucketIndex, verticalShaping, textBoxScale, textPadding, textAlongLine, verticalTextRotation);
	        if (verticallyShapedIcon) {
	            verticalIconCollisionFeature = new CollisionFeature(collisionBoxArray, anchor, featureIndex, sourceLayerIndex, bucketIndex, verticallyShapedIcon, iconBoxScale, iconPadding, textAlongLine, verticalTextRotation);
	        }
	    }
	    if (shapedIcon) {
	        var iconRotate = layer.layout.get('icon-rotate').evaluate(feature, {});
	        var hasIconTextFit = layer.layout.get('icon-text-fit') !== 'none';
	        var iconQuads = getIconQuads(shapedIcon, iconRotate, isSDFIcon, hasIconTextFit);
	        var verticalIconQuads = verticallyShapedIcon ? getIconQuads(verticallyShapedIcon, iconRotate, isSDFIcon, hasIconTextFit) : undefined;
	        iconCollisionFeature = new CollisionFeature(collisionBoxArray, anchor, featureIndex, sourceLayerIndex, bucketIndex, shapedIcon, iconBoxScale, iconPadding, false, iconRotate);
	        numIconVertices = iconQuads.length * 4;
	        var sizeData = bucket.iconSizeData;
	        var iconSizeData = null;
	        if (sizeData.kind === 'source') {
	            iconSizeData = [SIZE_PACK_FACTOR * layer.layout.get('icon-size').evaluate(feature, {})];
	            if (iconSizeData[0] > MAX_PACKED_SIZE) {
	                warnOnce(bucket.layerIds[0] + ': Value for "icon-size" is >= ' + MAX_GLYPH_ICON_SIZE + '. Reduce your "icon-size".');
	            }
	        } else if (sizeData.kind === 'composite') {
	            iconSizeData = [
	                SIZE_PACK_FACTOR * sizes.compositeIconSizes[0].evaluate(feature, {}, canonical),
	                SIZE_PACK_FACTOR * sizes.compositeIconSizes[1].evaluate(feature, {}, canonical)
	            ];
	            if (iconSizeData[0] > MAX_PACKED_SIZE || iconSizeData[1] > MAX_PACKED_SIZE) {
	                warnOnce(bucket.layerIds[0] + ': Value for "icon-size" is >= ' + MAX_GLYPH_ICON_SIZE + '. Reduce your "icon-size".');
	            }
	        }
	        bucket.addSymbols(bucket.icon, iconQuads, iconSizeData, iconOffset, iconAlongLine, feature, false, anchor, lineArray.lineStartIndex, lineArray.lineLength, -1, canonical);
	        placedIconSymbolIndex = bucket.icon.placedSymbolArray.length - 1;
	        if (verticalIconQuads) {
	            numVerticalIconVertices = verticalIconQuads.length * 4;
	            bucket.addSymbols(bucket.icon, verticalIconQuads, iconSizeData, iconOffset, iconAlongLine, feature, WritingMode.vertical, anchor, lineArray.lineStartIndex, lineArray.lineLength, -1, canonical);
	            verticalPlacedIconSymbolIndex = bucket.icon.placedSymbolArray.length - 1;
	        }
	    }
	    for (var justification in shapedTextOrientations.horizontal) {
	        var shaping = shapedTextOrientations.horizontal[justification];
	        if (!textCollisionFeature) {
	            key = murmurhashJs(shaping.text);
	            var textRotate = layer.layout.get('text-rotate').evaluate(feature, {}, canonical);
	            textCollisionFeature = new CollisionFeature(collisionBoxArray, anchor, featureIndex, sourceLayerIndex, bucketIndex, shaping, textBoxScale, textPadding, textAlongLine, textRotate);
	        }
	        var singleLine = shaping.positionedLines.length === 1;
	        numHorizontalGlyphVertices += addTextVertices(bucket, anchor, shaping, imageMap, layer, textAlongLine, feature, textOffset, lineArray, shapedTextOrientations.vertical ? WritingMode.horizontal : WritingMode.horizontalOnly, singleLine ? Object.keys(shapedTextOrientations.horizontal) : [justification], placedTextSymbolIndices, placedIconSymbolIndex, sizes, canonical);
	        if (singleLine) {
	            break;
	        }
	    }
	    if (shapedTextOrientations.vertical) {
	        numVerticalGlyphVertices += addTextVertices(bucket, anchor, shapedTextOrientations.vertical, imageMap, layer, textAlongLine, feature, textOffset, lineArray, WritingMode.vertical, ['vertical'], placedTextSymbolIndices, verticalPlacedIconSymbolIndex, sizes, canonical);
	    }
	    var textBoxStartIndex = textCollisionFeature ? textCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;
	    var textBoxEndIndex = textCollisionFeature ? textCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;
	    var verticalTextBoxStartIndex = verticalTextCollisionFeature ? verticalTextCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;
	    var verticalTextBoxEndIndex = verticalTextCollisionFeature ? verticalTextCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;
	    var iconBoxStartIndex = iconCollisionFeature ? iconCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;
	    var iconBoxEndIndex = iconCollisionFeature ? iconCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;
	    var verticalIconBoxStartIndex = verticalIconCollisionFeature ? verticalIconCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;
	    var verticalIconBoxEndIndex = verticalIconCollisionFeature ? verticalIconCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;
	    var collisionCircleDiameter = -1;
	    var getCollisionCircleHeight = function (feature, prevHeight) {
	        if (feature && feature.circleDiameter) {
	            return Math.max(feature.circleDiameter, prevHeight);
	        }
	        return prevHeight;
	    };
	    collisionCircleDiameter = getCollisionCircleHeight(textCollisionFeature, collisionCircleDiameter);
	    collisionCircleDiameter = getCollisionCircleHeight(verticalTextCollisionFeature, collisionCircleDiameter);
	    collisionCircleDiameter = getCollisionCircleHeight(iconCollisionFeature, collisionCircleDiameter);
	    collisionCircleDiameter = getCollisionCircleHeight(verticalIconCollisionFeature, collisionCircleDiameter);
	    var useRuntimeCollisionCircles = collisionCircleDiameter > -1 ? 1 : 0;
	    if (useRuntimeCollisionCircles) {
	        collisionCircleDiameter *= layoutTextSize / ONE_EM;
	    }
	    if (bucket.glyphOffsetArray.length >= SymbolBucket.MAX_GLYPHS) {
	        warnOnce('Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907');
	    }
	    if (feature.sortKey !== undefined) {
	        bucket.addToSortKeyRanges(bucket.symbolInstances.length, feature.sortKey);
	    }
	    bucket.symbolInstances.emplaceBack(anchor.x, anchor.y, placedTextSymbolIndices.right >= 0 ? placedTextSymbolIndices.right : -1, placedTextSymbolIndices.center >= 0 ? placedTextSymbolIndices.center : -1, placedTextSymbolIndices.left >= 0 ? placedTextSymbolIndices.left : -1, placedTextSymbolIndices.vertical || -1, placedIconSymbolIndex, verticalPlacedIconSymbolIndex, key, textBoxStartIndex, textBoxEndIndex, verticalTextBoxStartIndex, verticalTextBoxEndIndex, iconBoxStartIndex, iconBoxEndIndex, verticalIconBoxStartIndex, verticalIconBoxEndIndex, featureIndex, numHorizontalGlyphVertices, numVerticalGlyphVertices, numIconVertices, numVerticalIconVertices, useRuntimeCollisionCircles, 0, textBoxScale, textOffset0, textOffset1, collisionCircleDiameter);
	}
	function anchorIsTooClose(bucket, text, repeatDistance, anchor) {
	    var compareText = bucket.compareText;
	    if (!(text in compareText)) {
	        compareText[text] = [];
	    } else {
	        var otherAnchors = compareText[text];
	        for (var k = otherAnchors.length - 1; k >= 0; k--) {
	            if (anchor.dist(otherAnchors[k]) < repeatDistance) {
	                return true;
	            }
	        }
	    }
	    compareText[text].push(anchor);
	    return false;
	}

	var vectorTileFeatureTypes$2 = vectorTile.VectorTileFeature.types;
	var shaderOpacityAttributes = [{
	        name: 'a_fade_opacity',
	        components: 1,
	        type: 'Uint8',
	        offset: 0
	    }];
	function addVertex$1(array, anchorX, anchorY, ox, oy, tx, ty, sizeVertex, isSDF, pixelOffsetX, pixelOffsetY, minFontScaleX, minFontScaleY) {
	    var aSizeX = sizeVertex ? Math.min(MAX_PACKED_SIZE, Math.round(sizeVertex[0])) : 0;
	    var aSizeY = sizeVertex ? Math.min(MAX_PACKED_SIZE, Math.round(sizeVertex[1])) : 0;
	    array.emplaceBack(anchorX, anchorY, Math.round(ox * 32), Math.round(oy * 32), tx, ty, (aSizeX << 1) + (isSDF ? 1 : 0), aSizeY, pixelOffsetX * 16, pixelOffsetY * 16, minFontScaleX * 256, minFontScaleY * 256);
	}
	function addDynamicAttributes(dynamicLayoutVertexArray, p, angle) {
	    dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
	    dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
	    dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
	    dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
	}
	function containsRTLText(formattedText) {
	    for (var i = 0, list = formattedText.sections; i < list.length; i += 1) {
	        var section = list[i];
	        if (stringContainsRTLText(section.text)) {
	            return true;
	        }
	    }
	    return false;
	}
	var SymbolBuffers = function SymbolBuffers(programConfigurations) {
	    this.layoutVertexArray = new StructArrayLayout4i4ui4i24();
	    this.indexArray = new StructArrayLayout3ui6();
	    this.programConfigurations = programConfigurations;
	    this.segments = new SegmentVector();
	    this.dynamicLayoutVertexArray = new StructArrayLayout3f12();
	    this.opacityVertexArray = new StructArrayLayout1ul4();
	    this.placedSymbolArray = new PlacedSymbolArray();
	};
	SymbolBuffers.prototype.isEmpty = function isEmpty() {
	    return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
	};
	SymbolBuffers.prototype.upload = function upload(context, dynamicIndexBuffer, upload$1, update) {
	    if (this.isEmpty()) {
	        return;
	    }
	    if (upload$1) {
	        this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, symbolLayoutAttributes.members);
	        this.indexBuffer = context.createIndexBuffer(this.indexArray, dynamicIndexBuffer);
	        this.dynamicLayoutVertexBuffer = context.createVertexBuffer(this.dynamicLayoutVertexArray, dynamicLayoutAttributes.members, true);
	        this.opacityVertexBuffer = context.createVertexBuffer(this.opacityVertexArray, shaderOpacityAttributes, true);
	        this.opacityVertexBuffer.itemSize = 1;
	    }
	    if (upload$1 || update) {
	        this.programConfigurations.upload(context);
	    }
	};
	SymbolBuffers.prototype.destroy = function destroy() {
	    if (!this.layoutVertexBuffer) {
	        return;
	    }
	    this.layoutVertexBuffer.destroy();
	    this.indexBuffer.destroy();
	    this.programConfigurations.destroy();
	    this.segments.destroy();
	    this.dynamicLayoutVertexBuffer.destroy();
	    this.opacityVertexBuffer.destroy();
	};
	register('SymbolBuffers', SymbolBuffers);
	var CollisionBuffers = function CollisionBuffers(LayoutArray, layoutAttributes, IndexArray) {
	    this.layoutVertexArray = new LayoutArray();
	    this.layoutAttributes = layoutAttributes;
	    this.indexArray = new IndexArray();
	    this.segments = new SegmentVector();
	    this.collisionVertexArray = new StructArrayLayout2ub2f12();
	};
	CollisionBuffers.prototype.upload = function upload(context) {
	    this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes);
	    this.indexBuffer = context.createIndexBuffer(this.indexArray);
	    this.collisionVertexBuffer = context.createVertexBuffer(this.collisionVertexArray, collisionVertexAttributes.members, true);
	};
	CollisionBuffers.prototype.destroy = function destroy() {
	    if (!this.layoutVertexBuffer) {
	        return;
	    }
	    this.layoutVertexBuffer.destroy();
	    this.indexBuffer.destroy();
	    this.segments.destroy();
	    this.collisionVertexBuffer.destroy();
	};
	register('CollisionBuffers', CollisionBuffers);
	var SymbolBucket = function SymbolBucket(options) {
	    this.collisionBoxArray = options.collisionBoxArray;
	    this.zoom = options.zoom;
	    this.overscaling = options.overscaling;
	    this.layers = options.layers;
	    this.layerIds = this.layers.map(function (layer) {
	        return layer.id;
	    });
	    this.index = options.index;
	    this.pixelRatio = options.pixelRatio;
	    this.sourceLayerIndex = options.sourceLayerIndex;
	    this.hasPattern = false;
	    this.hasRTLText = false;
	    this.sortKeyRanges = [];
	    this.collisionCircleArray = [];
	    this.placementInvProjMatrix = identity([]);
	    this.placementViewportMatrix = identity([]);
	    var layer = this.layers[0];
	    var unevaluatedLayoutValues = layer._unevaluatedLayout._values;
	    this.textSizeData = getSizeData(this.zoom, unevaluatedLayoutValues['text-size']);
	    this.iconSizeData = getSizeData(this.zoom, unevaluatedLayoutValues['icon-size']);
	    var layout = this.layers[0].layout;
	    var sortKey = layout.get('symbol-sort-key');
	    var zOrder = layout.get('symbol-z-order');
	    this.canOverlap = layout.get('text-allow-overlap') || layout.get('icon-allow-overlap') || layout.get('text-ignore-placement') || layout.get('icon-ignore-placement');
	    this.sortFeaturesByKey = zOrder !== 'viewport-y' && sortKey.constantOr(1) !== undefined;
	    var zOrderByViewportY = zOrder === 'viewport-y' || zOrder === 'auto' && !this.sortFeaturesByKey;
	    this.sortFeaturesByY = zOrderByViewportY && this.canOverlap;
	    if (layout.get('symbol-placement') === 'point') {
	        this.writingModes = layout.get('text-writing-mode').map(function (wm) {
	            return WritingMode[wm];
	        });
	    }
	    this.stateDependentLayerIds = this.layers.filter(function (l) {
	        return l.isStateDependent();
	    }).map(function (l) {
	        return l.id;
	    });
	    this.sourceID = options.sourceID;
	};
	SymbolBucket.prototype.createArrays = function createArrays() {
	    this.text = new SymbolBuffers(new ProgramConfigurationSet(this.layers, this.zoom, function (property) {
	        return /^text/.test(property);
	    }));
	    this.icon = new SymbolBuffers(new ProgramConfigurationSet(this.layers, this.zoom, function (property) {
	        return /^icon/.test(property);
	    }));
	    this.glyphOffsetArray = new GlyphOffsetArray();
	    this.lineVertexArray = new SymbolLineVertexArray();
	    this.symbolInstances = new SymbolInstanceArray();
	};
	SymbolBucket.prototype.calculateGlyphDependencies = function calculateGlyphDependencies(text, stack, textAlongLine, allowVerticalPlacement, doesAllowVerticalWritingMode) {
	    for (var i = 0; i < text.length; i++) {
	        stack[text.charCodeAt(i)] = true;
	        if ((textAlongLine || allowVerticalPlacement) && doesAllowVerticalWritingMode) {
	            var verticalChar = verticalizedCharacterMap[text.charAt(i)];
	            if (verticalChar) {
	                stack[verticalChar.charCodeAt(0)] = true;
	            }
	        }
	    }
	};
	SymbolBucket.prototype.populate = function populate(features, options, canonical) {
	    var layer = this.layers[0];
	    var layout = layer.layout;
	    var textFont = layout.get('text-font');
	    var textField = layout.get('text-field');
	    var iconImage = layout.get('icon-image');
	    var hasText = (textField.value.kind !== 'constant' || textField.value.value instanceof Formatted && !textField.value.value.isEmpty() || textField.value.value.toString().length > 0) && (textFont.value.kind !== 'constant' || textFont.value.value.length > 0);
	    var hasIcon = iconImage.value.kind !== 'constant' || !!iconImage.value.value || Object.keys(iconImage.parameters).length > 0;
	    var symbolSortKey = layout.get('symbol-sort-key');
	    this.features = [];
	    if (!hasText && !hasIcon) {
	        return;
	    }
	    var icons = options.iconDependencies;
	    var stacks = options.glyphDependencies;
	    var availableImages = options.availableImages;
	    var globalProperties = new EvaluationParameters(this.zoom);
	    for (var i$1 = 0, list$1 = features; i$1 < list$1.length; i$1 += 1) {
	        var ref = list$1[i$1];
	        var feature = ref.feature;
	        var id = ref.id;
	        var index = ref.index;
	        var sourceLayerIndex = ref.sourceLayerIndex;
	        var needGeometry = layer._featureFilter.needGeometry;
	        var evaluationFeature = toEvaluationFeature(feature, needGeometry);
	        if (!layer._featureFilter.filter(globalProperties, evaluationFeature, canonical)) {
	            continue;
	        }
	        if (!needGeometry) {
	            evaluationFeature.geometry = loadGeometry(feature);
	        }
	        var text = void 0;
	        if (hasText) {
	            var resolvedTokens = layer.getValueAndResolveTokens('text-field', evaluationFeature, canonical, availableImages);
	            var formattedText = Formatted.factory(resolvedTokens);
	            if (containsRTLText(formattedText)) {
	                this.hasRTLText = true;
	            }
	            if (!this.hasRTLText || getRTLTextPluginStatus() === 'unavailable' || this.hasRTLText && plugin.isParsed()) {
	                text = transformText$1(formattedText, layer, evaluationFeature);
	            }
	        }
	        var icon = void 0;
	        if (hasIcon) {
	            var resolvedTokens$1 = layer.getValueAndResolveTokens('icon-image', evaluationFeature, canonical, availableImages);
	            if (resolvedTokens$1 instanceof ResolvedImage) {
	                icon = resolvedTokens$1;
	            } else {
	                icon = ResolvedImage.fromString(resolvedTokens$1);
	            }
	        }
	        if (!text && !icon) {
	            continue;
	        }
	        var sortKey = this.sortFeaturesByKey ? symbolSortKey.evaluate(evaluationFeature, {}, canonical) : undefined;
	        var symbolFeature = {
	            id: id,
	            text: text,
	            icon: icon,
	            index: index,
	            sourceLayerIndex: sourceLayerIndex,
	            geometry: evaluationFeature.geometry,
	            properties: feature.properties,
	            type: vectorTileFeatureTypes$2[feature.type],
	            sortKey: sortKey
	        };
	        this.features.push(symbolFeature);
	        if (icon) {
	            icons[icon.name] = true;
	        }
	        if (text) {
	            var fontStack = textFont.evaluate(evaluationFeature, {}, canonical).join(',');
	            var textAlongLine = layout.get('text-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point';
	            this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(WritingMode.vertical) >= 0;
	            for (var i = 0, list = text.sections; i < list.length; i += 1) {
	                var section = list[i];
	                if (!section.image) {
	                    var doesAllowVerticalWritingMode = allowsVerticalWritingMode(text.toString());
	                    var sectionFont = section.fontStack || fontStack;
	                    var sectionStack = stacks[sectionFont] = stacks[sectionFont] || {};
	                    this.calculateGlyphDependencies(section.text, sectionStack, textAlongLine, this.allowVerticalPlacement, doesAllowVerticalWritingMode);
	                } else {
	                    icons[section.image.name] = true;
	                }
	            }
	        }
	    }
	    if (layout.get('symbol-placement') === 'line') {
	        this.features = mergeLines(this.features);
	    }
	    if (this.sortFeaturesByKey) {
	        this.features.sort(function (a, b) {
	            return a.sortKey - b.sortKey;
	        });
	    }
	};
	SymbolBucket.prototype.update = function update(states, vtLayer, imagePositions) {
	    if (!this.stateDependentLayers.length) {
	        return;
	    }
	    this.text.programConfigurations.updatePaintArrays(states, vtLayer, this.layers, imagePositions);
	    this.icon.programConfigurations.updatePaintArrays(states, vtLayer, this.layers, imagePositions);
	};
	SymbolBucket.prototype.isEmpty = function isEmpty() {
	    return this.symbolInstances.length === 0 && !this.hasRTLText;
	};
	SymbolBucket.prototype.uploadPending = function uploadPending() {
	    return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
	};
	SymbolBucket.prototype.upload = function upload(context) {
	    if (!this.uploaded && this.hasDebugData()) {
	        this.textCollisionBox.upload(context);
	        this.iconCollisionBox.upload(context);
	    }
	    this.text.upload(context, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload);
	    this.icon.upload(context, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload);
	    this.uploaded = true;
	};
	SymbolBucket.prototype.destroyDebugData = function destroyDebugData() {
	    this.textCollisionBox.destroy();
	    this.iconCollisionBox.destroy();
	};
	SymbolBucket.prototype.destroy = function destroy() {
	    this.text.destroy();
	    this.icon.destroy();
	    if (this.hasDebugData()) {
	        this.destroyDebugData();
	    }
	};
	SymbolBucket.prototype.addToLineVertexArray = function addToLineVertexArray(anchor, line) {
	    var lineStartIndex = this.lineVertexArray.length;
	    if (anchor.segment !== undefined) {
	        var sumForwardLength = anchor.dist(line[anchor.segment + 1]);
	        var sumBackwardLength = anchor.dist(line[anchor.segment]);
	        var vertices = {};
	        for (var i = anchor.segment + 1; i < line.length; i++) {
	            vertices[i] = {
	                x: line[i].x,
	                y: line[i].y,
	                tileUnitDistanceFromAnchor: sumForwardLength
	            };
	            if (i < line.length - 1) {
	                sumForwardLength += line[i + 1].dist(line[i]);
	            }
	        }
	        for (var i$1 = anchor.segment || 0; i$1 >= 0; i$1--) {
	            vertices[i$1] = {
	                x: line[i$1].x,
	                y: line[i$1].y,
	                tileUnitDistanceFromAnchor: sumBackwardLength
	            };
	            if (i$1 > 0) {
	                sumBackwardLength += line[i$1 - 1].dist(line[i$1]);
	            }
	        }
	        for (var i$2 = 0; i$2 < line.length; i$2++) {
	            var vertex = vertices[i$2];
	            this.lineVertexArray.emplaceBack(vertex.x, vertex.y, vertex.tileUnitDistanceFromAnchor);
	        }
	    }
	    return {
	        lineStartIndex: lineStartIndex,
	        lineLength: this.lineVertexArray.length - lineStartIndex
	    };
	};
	SymbolBucket.prototype.addSymbols = function addSymbols(arrays, quads, sizeVertex, lineOffset, alongLine, feature, writingMode, labelAnchor, lineStartIndex, lineLength, associatedIconIndex, canonical) {
	    var indexArray = arrays.indexArray;
	    var layoutVertexArray = arrays.layoutVertexArray;
	    var segment = arrays.segments.prepareSegment(4 * quads.length, layoutVertexArray, indexArray, this.canOverlap ? feature.sortKey : undefined);
	    var glyphOffsetArrayStart = this.glyphOffsetArray.length;
	    var vertexStartIndex = segment.vertexLength;
	    var angle = this.allowVerticalPlacement && writingMode === WritingMode.vertical ? Math.PI / 2 : 0;
	    var sections = feature.text && feature.text.sections;
	    for (var i = 0; i < quads.length; i++) {
	        var ref = quads[i];
	        var tl = ref.tl;
	        var tr = ref.tr;
	        var bl = ref.bl;
	        var br = ref.br;
	        var tex = ref.tex;
	        var pixelOffsetTL = ref.pixelOffsetTL;
	        var pixelOffsetBR = ref.pixelOffsetBR;
	        var minFontScaleX = ref.minFontScaleX;
	        var minFontScaleY = ref.minFontScaleY;
	        var glyphOffset = ref.glyphOffset;
	        var isSDF = ref.isSDF;
	        var sectionIndex = ref.sectionIndex;
	        var index = segment.vertexLength;
	        var y = glyphOffset[1];
	        addVertex$1(layoutVertexArray, labelAnchor.x, labelAnchor.y, tl.x, y + tl.y, tex.x, tex.y, sizeVertex, isSDF, pixelOffsetTL.x, pixelOffsetTL.y, minFontScaleX, minFontScaleY);
	        addVertex$1(layoutVertexArray, labelAnchor.x, labelAnchor.y, tr.x, y + tr.y, tex.x + tex.w, tex.y, sizeVertex, isSDF, pixelOffsetBR.x, pixelOffsetTL.y, minFontScaleX, minFontScaleY);
	        addVertex$1(layoutVertexArray, labelAnchor.x, labelAnchor.y, bl.x, y + bl.y, tex.x, tex.y + tex.h, sizeVertex, isSDF, pixelOffsetTL.x, pixelOffsetBR.y, minFontScaleX, minFontScaleY);
	        addVertex$1(layoutVertexArray, labelAnchor.x, labelAnchor.y, br.x, y + br.y, tex.x + tex.w, tex.y + tex.h, sizeVertex, isSDF, pixelOffsetBR.x, pixelOffsetBR.y, minFontScaleX, minFontScaleY);
	        addDynamicAttributes(arrays.dynamicLayoutVertexArray, labelAnchor, angle);
	        indexArray.emplaceBack(index, index + 1, index + 2);
	        indexArray.emplaceBack(index + 1, index + 2, index + 3);
	        segment.vertexLength += 4;
	        segment.primitiveLength += 2;
	        this.glyphOffsetArray.emplaceBack(glyphOffset[0]);
	        if (i === quads.length - 1 || sectionIndex !== quads[i + 1].sectionIndex) {
	            arrays.programConfigurations.populatePaintArrays(layoutVertexArray.length, feature, feature.index, {}, canonical, sections && sections[sectionIndex]);
	        }
	    }
	    arrays.placedSymbolArray.emplaceBack(labelAnchor.x, labelAnchor.y, glyphOffsetArrayStart, this.glyphOffsetArray.length - glyphOffsetArrayStart, vertexStartIndex, lineStartIndex, lineLength, labelAnchor.segment, sizeVertex ? sizeVertex[0] : 0, sizeVertex ? sizeVertex[1] : 0, lineOffset[0], lineOffset[1], writingMode, 0, false, 0, associatedIconIndex);
	};
	SymbolBucket.prototype._addCollisionDebugVertex = function _addCollisionDebugVertex(layoutVertexArray, collisionVertexArray, point, anchorX, anchorY, extrude) {
	    collisionVertexArray.emplaceBack(0, 0);
	    return layoutVertexArray.emplaceBack(point.x, point.y, anchorX, anchorY, Math.round(extrude.x), Math.round(extrude.y));
	};
	SymbolBucket.prototype.addCollisionDebugVertices = function addCollisionDebugVertices(x1, y1, x2, y2, arrays, boxAnchorPoint, symbolInstance) {
	    var segment = arrays.segments.prepareSegment(4, arrays.layoutVertexArray, arrays.indexArray);
	    var index = segment.vertexLength;
	    var layoutVertexArray = arrays.layoutVertexArray;
	    var collisionVertexArray = arrays.collisionVertexArray;
	    var anchorX = symbolInstance.anchorX;
	    var anchorY = symbolInstance.anchorY;
	    this._addCollisionDebugVertex(layoutVertexArray, collisionVertexArray, boxAnchorPoint, anchorX, anchorY, new pointGeometry(x1, y1));
	    this._addCollisionDebugVertex(layoutVertexArray, collisionVertexArray, boxAnchorPoint, anchorX, anchorY, new pointGeometry(x2, y1));
	    this._addCollisionDebugVertex(layoutVertexArray, collisionVertexArray, boxAnchorPoint, anchorX, anchorY, new pointGeometry(x2, y2));
	    this._addCollisionDebugVertex(layoutVertexArray, collisionVertexArray, boxAnchorPoint, anchorX, anchorY, new pointGeometry(x1, y2));
	    segment.vertexLength += 4;
	    var indexArray = arrays.indexArray;
	    indexArray.emplaceBack(index, index + 1);
	    indexArray.emplaceBack(index + 1, index + 2);
	    indexArray.emplaceBack(index + 2, index + 3);
	    indexArray.emplaceBack(index + 3, index);
	    segment.primitiveLength += 4;
	};
	SymbolBucket.prototype.addDebugCollisionBoxes = function addDebugCollisionBoxes(startIndex, endIndex, symbolInstance, isText) {
	    for (var b = startIndex; b < endIndex; b++) {
	        var box = this.collisionBoxArray.get(b);
	        var x1 = box.x1;
	        var y1 = box.y1;
	        var x2 = box.x2;
	        var y2 = box.y2;
	        this.addCollisionDebugVertices(x1, y1, x2, y2, isText ? this.textCollisionBox : this.iconCollisionBox, box.anchorPoint, symbolInstance);
	    }
	};
	SymbolBucket.prototype.generateCollisionDebugBuffers = function generateCollisionDebugBuffers() {
	    if (this.hasDebugData()) {
	        this.destroyDebugData();
	    }
	    this.textCollisionBox = new CollisionBuffers(StructArrayLayout2i2i2i12, collisionBoxLayout.members, StructArrayLayout2ui4);
	    this.iconCollisionBox = new CollisionBuffers(StructArrayLayout2i2i2i12, collisionBoxLayout.members, StructArrayLayout2ui4);
	    for (var i = 0; i < this.symbolInstances.length; i++) {
	        var symbolInstance = this.symbolInstances.get(i);
	        this.addDebugCollisionBoxes(symbolInstance.textBoxStartIndex, symbolInstance.textBoxEndIndex, symbolInstance, true);
	        this.addDebugCollisionBoxes(symbolInstance.verticalTextBoxStartIndex, symbolInstance.verticalTextBoxEndIndex, symbolInstance, true);
	        this.addDebugCollisionBoxes(symbolInstance.iconBoxStartIndex, symbolInstance.iconBoxEndIndex, symbolInstance, false);
	        this.addDebugCollisionBoxes(symbolInstance.verticalIconBoxStartIndex, symbolInstance.verticalIconBoxEndIndex, symbolInstance, false);
	    }
	};
	SymbolBucket.prototype._deserializeCollisionBoxesForSymbol = function _deserializeCollisionBoxesForSymbol(collisionBoxArray, textStartIndex, textEndIndex, verticalTextStartIndex, verticalTextEndIndex, iconStartIndex, iconEndIndex, verticalIconStartIndex, verticalIconEndIndex) {
	    var collisionArrays = {};
	    for (var k = textStartIndex; k < textEndIndex; k++) {
	        var box = collisionBoxArray.get(k);
	        collisionArrays.textBox = {
	            x1: box.x1,
	            y1: box.y1,
	            x2: box.x2,
	            y2: box.y2,
	            anchorPointX: box.anchorPointX,
	            anchorPointY: box.anchorPointY
	        };
	        collisionArrays.textFeatureIndex = box.featureIndex;
	        break;
	    }
	    for (var k$1 = verticalTextStartIndex; k$1 < verticalTextEndIndex; k$1++) {
	        var box$1 = collisionBoxArray.get(k$1);
	        collisionArrays.verticalTextBox = {
	            x1: box$1.x1,
	            y1: box$1.y1,
	            x2: box$1.x2,
	            y2: box$1.y2,
	            anchorPointX: box$1.anchorPointX,
	            anchorPointY: box$1.anchorPointY
	        };
	        collisionArrays.verticalTextFeatureIndex = box$1.featureIndex;
	        break;
	    }
	    for (var k$2 = iconStartIndex; k$2 < iconEndIndex; k$2++) {
	        var box$2 = collisionBoxArray.get(k$2);
	        collisionArrays.iconBox = {
	            x1: box$2.x1,
	            y1: box$2.y1,
	            x2: box$2.x2,
	            y2: box$2.y2,
	            anchorPointX: box$2.anchorPointX,
	            anchorPointY: box$2.anchorPointY
	        };
	        collisionArrays.iconFeatureIndex = box$2.featureIndex;
	        break;
	    }
	    for (var k$3 = verticalIconStartIndex; k$3 < verticalIconEndIndex; k$3++) {
	        var box$3 = collisionBoxArray.get(k$3);
	        collisionArrays.verticalIconBox = {
	            x1: box$3.x1,
	            y1: box$3.y1,
	            x2: box$3.x2,
	            y2: box$3.y2,
	            anchorPointX: box$3.anchorPointX,
	            anchorPointY: box$3.anchorPointY
	        };
	        collisionArrays.verticalIconFeatureIndex = box$3.featureIndex;
	        break;
	    }
	    return collisionArrays;
	};
	SymbolBucket.prototype.deserializeCollisionBoxes = function deserializeCollisionBoxes(collisionBoxArray) {
	    this.collisionArrays = [];
	    for (var i = 0; i < this.symbolInstances.length; i++) {
	        var symbolInstance = this.symbolInstances.get(i);
	        this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(collisionBoxArray, symbolInstance.textBoxStartIndex, symbolInstance.textBoxEndIndex, symbolInstance.verticalTextBoxStartIndex, symbolInstance.verticalTextBoxEndIndex, symbolInstance.iconBoxStartIndex, symbolInstance.iconBoxEndIndex, symbolInstance.verticalIconBoxStartIndex, symbolInstance.verticalIconBoxEndIndex));
	    }
	};
	SymbolBucket.prototype.hasTextData = function hasTextData() {
	    return this.text.segments.get().length > 0;
	};
	SymbolBucket.prototype.hasIconData = function hasIconData() {
	    return this.icon.segments.get().length > 0;
	};
	SymbolBucket.prototype.hasDebugData = function hasDebugData() {
	    return this.textCollisionBox && this.iconCollisionBox;
	};
	SymbolBucket.prototype.hasTextCollisionBoxData = function hasTextCollisionBoxData() {
	    return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
	};
	SymbolBucket.prototype.hasIconCollisionBoxData = function hasIconCollisionBoxData() {
	    return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
	};
	SymbolBucket.prototype.addIndicesForPlacedSymbol = function addIndicesForPlacedSymbol(iconOrText, placedSymbolIndex) {
	    var placedSymbol = iconOrText.placedSymbolArray.get(placedSymbolIndex);
	    var endIndex = placedSymbol.vertexStartIndex + placedSymbol.numGlyphs * 4;
	    for (var vertexIndex = placedSymbol.vertexStartIndex; vertexIndex < endIndex; vertexIndex += 4) {
	        iconOrText.indexArray.emplaceBack(vertexIndex, vertexIndex + 1, vertexIndex + 2);
	        iconOrText.indexArray.emplaceBack(vertexIndex + 1, vertexIndex + 2, vertexIndex + 3);
	    }
	};
	SymbolBucket.prototype.getSortedSymbolIndexes = function getSortedSymbolIndexes(angle) {
	    if (this.sortedAngle === angle && this.symbolInstanceIndexes !== undefined) {
	        return this.symbolInstanceIndexes;
	    }
	    var sin = Math.sin(angle);
	    var cos = Math.cos(angle);
	    var rotatedYs = [];
	    var featureIndexes = [];
	    var result = [];
	    for (var i = 0; i < this.symbolInstances.length; ++i) {
	        result.push(i);
	        var symbolInstance = this.symbolInstances.get(i);
	        rotatedYs.push(Math.round(sin * symbolInstance.anchorX + cos * symbolInstance.anchorY) | 0);
	        featureIndexes.push(symbolInstance.featureIndex);
	    }
	    result.sort(function (aIndex, bIndex) {
	        return rotatedYs[aIndex] - rotatedYs[bIndex] || featureIndexes[bIndex] - featureIndexes[aIndex];
	    });
	    return result;
	};
	SymbolBucket.prototype.addToSortKeyRanges = function addToSortKeyRanges(symbolInstanceIndex, sortKey) {
	    var last = this.sortKeyRanges[this.sortKeyRanges.length - 1];
	    if (last && last.sortKey === sortKey) {
	        last.symbolInstanceEnd = symbolInstanceIndex + 1;
	    } else {
	        this.sortKeyRanges.push({
	            sortKey: sortKey,
	            symbolInstanceStart: symbolInstanceIndex,
	            symbolInstanceEnd: symbolInstanceIndex + 1
	        });
	    }
	};
	SymbolBucket.prototype.sortFeatures = function sortFeatures(angle) {
	    var this$1 = this;
	    if (!this.sortFeaturesByY) {
	        return;
	    }
	    if (this.sortedAngle === angle) {
	        return;
	    }
	    if (this.text.segments.get().length > 1 || this.icon.segments.get().length > 1) {
	        return;
	    }
	    this.symbolInstanceIndexes = this.getSortedSymbolIndexes(angle);
	    this.sortedAngle = angle;
	    this.text.indexArray.clear();
	    this.icon.indexArray.clear();
	    this.featureSortOrder = [];
	    for (var i$1 = 0, list = this.symbolInstanceIndexes; i$1 < list.length; i$1 += 1) {
	        var i = list[i$1];
	        var symbolInstance = this.symbolInstances.get(i);
	        this.featureSortOrder.push(symbolInstance.featureIndex);
	        [
	            symbolInstance.rightJustifiedTextSymbolIndex,
	            symbolInstance.centerJustifiedTextSymbolIndex,
	            symbolInstance.leftJustifiedTextSymbolIndex
	        ].forEach(function (index, i, array) {
	            if (index >= 0 && array.indexOf(index) === i) {
	                this$1.addIndicesForPlacedSymbol(this$1.text, index);
	            }
	        });
	        if (symbolInstance.verticalPlacedTextSymbolIndex >= 0) {
	            this.addIndicesForPlacedSymbol(this.text, symbolInstance.verticalPlacedTextSymbolIndex);
	        }
	        if (symbolInstance.placedIconSymbolIndex >= 0) {
	            this.addIndicesForPlacedSymbol(this.icon, symbolInstance.placedIconSymbolIndex);
	        }
	        if (symbolInstance.verticalPlacedIconSymbolIndex >= 0) {
	            this.addIndicesForPlacedSymbol(this.icon, symbolInstance.verticalPlacedIconSymbolIndex);
	        }
	    }
	    if (this.text.indexBuffer) {
	        this.text.indexBuffer.updateData(this.text.indexArray);
	    }
	    if (this.icon.indexBuffer) {
	        this.icon.indexBuffer.updateData(this.icon.indexArray);
	    }
	};
	register('SymbolBucket', SymbolBucket, {
	    omit: [
	        'layers',
	        'collisionBoxArray',
	        'features',
	        'compareText'
	    ]
	});
	SymbolBucket.MAX_GLYPHS = 65535;
	SymbolBucket.addDynamicAttributes = addDynamicAttributes;

	function resolveTokens(properties, text) {
	    return text.replace(/{([^{}]+)}/g, function (match, key) {
	        return key in properties ? String(properties[key]) : '';
	    });
	}

	var layout$7 = new Properties({
	    'symbol-placement': new DataConstantProperty(spec['layout_symbol']['symbol-placement']),
	    'symbol-spacing': new DataConstantProperty(spec['layout_symbol']['symbol-spacing']),
	    'symbol-avoid-edges': new DataConstantProperty(spec['layout_symbol']['symbol-avoid-edges']),
	    'symbol-sort-key': new DataDrivenProperty(spec['layout_symbol']['symbol-sort-key']),
	    'symbol-z-order': new DataConstantProperty(spec['layout_symbol']['symbol-z-order']),
	    'icon-allow-overlap': new DataConstantProperty(spec['layout_symbol']['icon-allow-overlap']),
	    'icon-ignore-placement': new DataConstantProperty(spec['layout_symbol']['icon-ignore-placement']),
	    'icon-optional': new DataConstantProperty(spec['layout_symbol']['icon-optional']),
	    'icon-rotation-alignment': new DataConstantProperty(spec['layout_symbol']['icon-rotation-alignment']),
	    'icon-size': new DataDrivenProperty(spec['layout_symbol']['icon-size']),
	    'icon-text-fit': new DataConstantProperty(spec['layout_symbol']['icon-text-fit']),
	    'icon-text-fit-padding': new DataConstantProperty(spec['layout_symbol']['icon-text-fit-padding']),
	    'icon-image': new DataDrivenProperty(spec['layout_symbol']['icon-image']),
	    'icon-rotate': new DataDrivenProperty(spec['layout_symbol']['icon-rotate']),
	    'icon-padding': new DataConstantProperty(spec['layout_symbol']['icon-padding']),
	    'icon-keep-upright': new DataConstantProperty(spec['layout_symbol']['icon-keep-upright']),
	    'icon-offset': new DataDrivenProperty(spec['layout_symbol']['icon-offset']),
	    'icon-anchor': new DataDrivenProperty(spec['layout_symbol']['icon-anchor']),
	    'icon-pitch-alignment': new DataConstantProperty(spec['layout_symbol']['icon-pitch-alignment']),
	    'text-pitch-alignment': new DataConstantProperty(spec['layout_symbol']['text-pitch-alignment']),
	    'text-rotation-alignment': new DataConstantProperty(spec['layout_symbol']['text-rotation-alignment']),
	    'text-field': new DataDrivenProperty(spec['layout_symbol']['text-field']),
	    'text-font': new DataDrivenProperty(spec['layout_symbol']['text-font']),
	    'text-size': new DataDrivenProperty(spec['layout_symbol']['text-size']),
	    'text-max-width': new DataDrivenProperty(spec['layout_symbol']['text-max-width']),
	    'text-line-height': new DataConstantProperty(spec['layout_symbol']['text-line-height']),
	    'text-letter-spacing': new DataDrivenProperty(spec['layout_symbol']['text-letter-spacing']),
	    'text-justify': new DataDrivenProperty(spec['layout_symbol']['text-justify']),
	    'text-radial-offset': new DataDrivenProperty(spec['layout_symbol']['text-radial-offset']),
	    'text-variable-anchor': new DataConstantProperty(spec['layout_symbol']['text-variable-anchor']),
	    'text-anchor': new DataDrivenProperty(spec['layout_symbol']['text-anchor']),
	    'text-max-angle': new DataConstantProperty(spec['layout_symbol']['text-max-angle']),
	    'text-writing-mode': new DataConstantProperty(spec['layout_symbol']['text-writing-mode']),
	    'text-rotate': new DataDrivenProperty(spec['layout_symbol']['text-rotate']),
	    'text-padding': new DataConstantProperty(spec['layout_symbol']['text-padding']),
	    'text-keep-upright': new DataConstantProperty(spec['layout_symbol']['text-keep-upright']),
	    'text-transform': new DataDrivenProperty(spec['layout_symbol']['text-transform']),
	    'text-offset': new DataDrivenProperty(spec['layout_symbol']['text-offset']),
	    'text-allow-overlap': new DataConstantProperty(spec['layout_symbol']['text-allow-overlap']),
	    'text-ignore-placement': new DataConstantProperty(spec['layout_symbol']['text-ignore-placement']),
	    'text-optional': new DataConstantProperty(spec['layout_symbol']['text-optional'])
	});
	var paint$7 = new Properties({
	    'icon-opacity': new DataDrivenProperty(spec['paint_symbol']['icon-opacity']),
	    'icon-color': new DataDrivenProperty(spec['paint_symbol']['icon-color']),
	    'icon-halo-color': new DataDrivenProperty(spec['paint_symbol']['icon-halo-color']),
	    'icon-halo-width': new DataDrivenProperty(spec['paint_symbol']['icon-halo-width']),
	    'icon-halo-blur': new DataDrivenProperty(spec['paint_symbol']['icon-halo-blur']),
	    'icon-translate': new DataConstantProperty(spec['paint_symbol']['icon-translate']),
	    'icon-translate-anchor': new DataConstantProperty(spec['paint_symbol']['icon-translate-anchor']),
	    'text-opacity': new DataDrivenProperty(spec['paint_symbol']['text-opacity']),
	    'text-color': new DataDrivenProperty(spec['paint_symbol']['text-color'], {
	        runtimeType: ColorType,
	        getOverride: function (o) {
	            return o.textColor;
	        },
	        hasOverride: function (o) {
	            return !!o.textColor;
	        }
	    }),
	    'text-halo-color': new DataDrivenProperty(spec['paint_symbol']['text-halo-color']),
	    'text-halo-width': new DataDrivenProperty(spec['paint_symbol']['text-halo-width']),
	    'text-halo-blur': new DataDrivenProperty(spec['paint_symbol']['text-halo-blur']),
	    'text-translate': new DataConstantProperty(spec['paint_symbol']['text-translate']),
	    'text-translate-anchor': new DataConstantProperty(spec['paint_symbol']['text-translate-anchor'])
	});
	var properties$6 = {
	    paint: paint$7,
	    layout: layout$7
	};

	var FormatSectionOverride = function FormatSectionOverride(defaultValue) {
	    this.type = defaultValue.property.overrides ? defaultValue.property.overrides.runtimeType : NullType;
	    this.defaultValue = defaultValue;
	};
	FormatSectionOverride.prototype.evaluate = function evaluate(ctx) {
	    if (ctx.formattedSection) {
	        var overrides = this.defaultValue.property.overrides;
	        if (overrides && overrides.hasOverride(ctx.formattedSection)) {
	            return overrides.getOverride(ctx.formattedSection);
	        }
	    }
	    if (ctx.feature && ctx.featureState) {
	        return this.defaultValue.evaluate(ctx.feature, ctx.featureState);
	    }
	    return this.defaultValue.property.specification.default;
	};
	FormatSectionOverride.prototype.eachChild = function eachChild(fn) {
	    if (!this.defaultValue.isConstant()) {
	        var expr = this.defaultValue.value;
	        fn(expr._styleExpression.expression);
	    }
	};
	FormatSectionOverride.prototype.outputDefined = function outputDefined() {
	    return false;
	};
	FormatSectionOverride.prototype.serialize = function serialize() {
	    return null;
	};
	register('FormatSectionOverride', FormatSectionOverride, { omit: ['defaultValue'] });

	var SymbolStyleLayer = function (StyleLayer) {
	    function SymbolStyleLayer(layer) {
	        StyleLayer.call(this, layer, properties$6);
	    }
	    if (StyleLayer)
	        SymbolStyleLayer.__proto__ = StyleLayer;
	    SymbolStyleLayer.prototype = Object.create(StyleLayer && StyleLayer.prototype);
	    SymbolStyleLayer.prototype.constructor = SymbolStyleLayer;
	    SymbolStyleLayer.prototype.recalculate = function recalculate(parameters, availableImages) {
	        StyleLayer.prototype.recalculate.call(this, parameters, availableImages);
	        if (this.layout.get('icon-rotation-alignment') === 'auto') {
	            if (this.layout.get('symbol-placement') !== 'point') {
	                this.layout._values['icon-rotation-alignment'] = 'map';
	            } else {
	                this.layout._values['icon-rotation-alignment'] = 'viewport';
	            }
	        }
	        if (this.layout.get('text-rotation-alignment') === 'auto') {
	            if (this.layout.get('symbol-placement') !== 'point') {
	                this.layout._values['text-rotation-alignment'] = 'map';
	            } else {
	                this.layout._values['text-rotation-alignment'] = 'viewport';
	            }
	        }
	        if (this.layout.get('text-pitch-alignment') === 'auto') {
	            this.layout._values['text-pitch-alignment'] = this.layout.get('text-rotation-alignment');
	        }
	        if (this.layout.get('icon-pitch-alignment') === 'auto') {
	            this.layout._values['icon-pitch-alignment'] = this.layout.get('icon-rotation-alignment');
	        }
	        if (this.layout.get('symbol-placement') === 'point') {
	            var writingModes = this.layout.get('text-writing-mode');
	            if (writingModes) {
	                var deduped = [];
	                for (var i = 0, list = writingModes; i < list.length; i += 1) {
	                    var m = list[i];
	                    if (deduped.indexOf(m) < 0) {
	                        deduped.push(m);
	                    }
	                }
	                this.layout._values['text-writing-mode'] = deduped;
	            } else {
	                this.layout._values['text-writing-mode'] = ['horizontal'];
	            }
	        }
	        this._setPaintOverrides();
	    };
	    SymbolStyleLayer.prototype.getValueAndResolveTokens = function getValueAndResolveTokens(name, feature, canonical, availableImages) {
	        var value = this.layout.get(name).evaluate(feature, {}, canonical, availableImages);
	        var unevaluated = this._unevaluatedLayout._values[name];
	        if (!unevaluated.isDataDriven() && !isExpression(unevaluated.value) && value) {
	            return resolveTokens(feature.properties, value);
	        }
	        return value;
	    };
	    SymbolStyleLayer.prototype.createBucket = function createBucket(parameters) {
	        return new SymbolBucket(parameters);
	    };
	    SymbolStyleLayer.prototype.queryRadius = function queryRadius() {
	        return 0;
	    };
	    SymbolStyleLayer.prototype.queryIntersectsFeature = function queryIntersectsFeature() {
	        return false;
	    };
	    SymbolStyleLayer.prototype._setPaintOverrides = function _setPaintOverrides() {
	        for (var i = 0, list = properties$6.paint.overridableProperties; i < list.length; i += 1) {
	            var overridable = list[i];
	            if (!SymbolStyleLayer.hasPaintOverride(this.layout, overridable)) {
	                continue;
	            }
	            var overriden = this.paint.get(overridable);
	            var override = new FormatSectionOverride(overriden);
	            var styleExpression = new StyleExpression(override, overriden.property.specification);
	            var expression = null;
	            if (overriden.value.kind === 'constant' || overriden.value.kind === 'source') {
	                expression = new ZoomConstantExpression('source', styleExpression);
	            } else {
	                expression = new ZoomDependentExpression('composite', styleExpression, overriden.value.zoomStops, overriden.value._interpolationType);
	            }
	            this.paint._values[overridable] = new PossiblyEvaluatedPropertyValue(overriden.property, expression, overriden.parameters);
	        }
	    };
	    SymbolStyleLayer.prototype._handleOverridablePaintPropertyUpdate = function _handleOverridablePaintPropertyUpdate(name, oldValue, newValue) {
	        if (!this.layout || oldValue.isDataDriven() || newValue.isDataDriven()) {
	            return false;
	        }
	        return SymbolStyleLayer.hasPaintOverride(this.layout, name);
	    };
	    SymbolStyleLayer.hasPaintOverride = function hasPaintOverride(layout, propertyName) {
	        var textField = layout.get('text-field');
	        var property = properties$6.paint.properties[propertyName];
	        var hasOverrides = false;
	        var checkSections = function (sections) {
	            for (var i = 0, list = sections; i < list.length; i += 1) {
	                var section = list[i];
	                if (property.overrides && property.overrides.hasOverride(section)) {
	                    hasOverrides = true;
	                    return;
	                }
	            }
	        };
	        if (textField.value.kind === 'constant' && textField.value.value instanceof Formatted) {
	            checkSections(textField.value.value.sections);
	        } else if (textField.value.kind === 'source') {
	            var checkExpression = function (expression) {
	                if (hasOverrides) {
	                    return;
	                }
	                if (expression instanceof Literal && typeOf(expression.value) === FormattedType) {
	                    var formatted = expression.value;
	                    checkSections(formatted.sections);
	                } else if (expression instanceof FormatExpression) {
	                    checkSections(expression.sections);
	                } else {
	                    expression.eachChild(checkExpression);
	                }
	            };
	            var expr = textField.value;
	            if (expr._styleExpression) {
	                checkExpression(expr._styleExpression.expression);
	            }
	        }
	        return hasOverrides;
	    };
	    return SymbolStyleLayer;
	}(StyleLayer);

	var paint$8 = new Properties({
	    'background-color': new DataConstantProperty(spec['paint_background']['background-color']),
	    'background-pattern': new CrossFadedProperty(spec['paint_background']['background-pattern']),
	    'background-opacity': new DataConstantProperty(spec['paint_background']['background-opacity'])
	});
	var properties$7 = { paint: paint$8 };

	var BackgroundStyleLayer = function (StyleLayer) {
	    function BackgroundStyleLayer(layer) {
	        StyleLayer.call(this, layer, properties$7);
	    }
	    if (StyleLayer)
	        BackgroundStyleLayer.__proto__ = StyleLayer;
	    BackgroundStyleLayer.prototype = Object.create(StyleLayer && StyleLayer.prototype);
	    BackgroundStyleLayer.prototype.constructor = BackgroundStyleLayer;
	    return BackgroundStyleLayer;
	}(StyleLayer);

	var paint$9 = new Properties({
	    'raster-opacity': new DataConstantProperty(spec['paint_raster']['raster-opacity']),
	    'raster-hue-rotate': new DataConstantProperty(spec['paint_raster']['raster-hue-rotate']),
	    'raster-brightness-min': new DataConstantProperty(spec['paint_raster']['raster-brightness-min']),
	    'raster-brightness-max': new DataConstantProperty(spec['paint_raster']['raster-brightness-max']),
	    'raster-saturation': new DataConstantProperty(spec['paint_raster']['raster-saturation']),
	    'raster-contrast': new DataConstantProperty(spec['paint_raster']['raster-contrast']),
	    'raster-resampling': new DataConstantProperty(spec['paint_raster']['raster-resampling']),
	    'raster-fade-duration': new DataConstantProperty(spec['paint_raster']['raster-fade-duration'])
	});
	var properties$8 = { paint: paint$9 };

	var RasterStyleLayer = function (StyleLayer) {
	    function RasterStyleLayer(layer) {
	        StyleLayer.call(this, layer, properties$8);
	    }
	    if (StyleLayer)
	        RasterStyleLayer.__proto__ = StyleLayer;
	    RasterStyleLayer.prototype = Object.create(StyleLayer && StyleLayer.prototype);
	    RasterStyleLayer.prototype.constructor = RasterStyleLayer;
	    return RasterStyleLayer;
	}(StyleLayer);

	function validateCustomStyleLayer(layerObject) {
	    var errors = [];
	    var id = layerObject.id;
	    if (id === undefined) {
	        errors.push({ message: 'layers.' + id + ': missing required property "id"' });
	    }
	    if (layerObject.render === undefined) {
	        errors.push({ message: 'layers.' + id + ': missing required method "render"' });
	    }
	    if (layerObject.renderingMode && layerObject.renderingMode !== '2d' && layerObject.renderingMode !== '3d') {
	        errors.push({ message: 'layers.' + id + ': property "renderingMode" must be either "2d" or "3d"' });
	    }
	    return errors;
	}
	var CustomStyleLayer = function (StyleLayer) {
	    function CustomStyleLayer(implementation) {
	        StyleLayer.call(this, implementation, {});
	        this.implementation = implementation;
	    }
	    if (StyleLayer)
	        CustomStyleLayer.__proto__ = StyleLayer;
	    CustomStyleLayer.prototype = Object.create(StyleLayer && StyleLayer.prototype);
	    CustomStyleLayer.prototype.constructor = CustomStyleLayer;
	    CustomStyleLayer.prototype.is3D = function is3D() {
	        return this.implementation.renderingMode === '3d';
	    };
	    CustomStyleLayer.prototype.hasOffscreenPass = function hasOffscreenPass() {
	        return this.implementation.prerender !== undefined;
	    };
	    CustomStyleLayer.prototype.recalculate = function recalculate() {
	    };
	    CustomStyleLayer.prototype.updateTransitions = function updateTransitions() {
	    };
	    CustomStyleLayer.prototype.hasTransition = function hasTransition() {
	    };
	    CustomStyleLayer.prototype.serialize = function serialize() {
	    };
	    CustomStyleLayer.prototype.onAdd = function onAdd(map) {
	        if (this.implementation.onAdd) {
	            this.implementation.onAdd(map, map.painter.context.gl);
	        }
	    };
	    CustomStyleLayer.prototype.onRemove = function onRemove(map) {
	        if (this.implementation.onRemove) {
	            this.implementation.onRemove(map, map.painter.context.gl);
	        }
	    };
	    return CustomStyleLayer;
	}(StyleLayer);

	var subclasses = {
	    circle: CircleStyleLayer,
	    heatmap: HeatmapStyleLayer,
	    hillshade: HillshadeStyleLayer,
	    fill: FillStyleLayer,
	    'fill-extrusion': FillExtrusionStyleLayer,
	    line: LineStyleLayer,
	    symbol: SymbolStyleLayer,
	    background: BackgroundStyleLayer,
	    raster: RasterStyleLayer
	};
	function createStyleLayer(layer) {
	    if (layer.type === 'custom') {
	        return new CustomStyleLayer(layer);
	    } else {
	        return new subclasses[layer.type](layer);
	    }
	}

	var HTMLImageElement = window$1.HTMLImageElement;
	var HTMLCanvasElement = window$1.HTMLCanvasElement;
	var HTMLVideoElement = window$1.HTMLVideoElement;
	var ImageData$1 = window$1.ImageData;
	var ImageBitmap$1 = window$1.ImageBitmap;
	var Texture = function Texture(context, image, format, options) {
	    this.context = context;
	    this.format = format;
	    this.texture = context.gl.createTexture();
	    this.update(image, options);
	};
	Texture.prototype.update = function update(image, options, position) {
	    var width = image.width;
	    var height = image.height;
	    var resize = (!this.size || this.size[0] !== width || this.size[1] !== height) && !position;
	    var ref = this;
	    var context = ref.context;
	    var gl = context.gl;
	    this.useMipmap = Boolean(options && options.useMipmap);
	    gl.bindTexture(gl.TEXTURE_2D, this.texture);
	    context.pixelStoreUnpackFlipY.set(false);
	    context.pixelStoreUnpack.set(1);
	    context.pixelStoreUnpackPremultiplyAlpha.set(this.format === gl.RGBA && (!options || options.premultiply !== false));
	    if (resize) {
	        this.size = [
	            width,
	            height
	        ];
	        if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement || image instanceof ImageData$1 || ImageBitmap$1 && image instanceof ImageBitmap$1) {
	            gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, gl.UNSIGNED_BYTE, image);
	        } else {
	            gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, gl.UNSIGNED_BYTE, image.data);
	        }
	    } else {
	        var ref$1 = position || {
	            x: 0,
	            y: 0
	        };
	        var x = ref$1.x;
	        var y = ref$1.y;
	        if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement || image instanceof ImageData$1 || ImageBitmap$1 && image instanceof ImageBitmap$1) {
	            gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, gl.RGBA, gl.UNSIGNED_BYTE, image);
	        } else {
	            gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, image.data);
	        }
	    }
	    if (this.useMipmap && this.isSizePowerOfTwo()) {
	        gl.generateMipmap(gl.TEXTURE_2D);
	    }
	};
	Texture.prototype.bind = function bind(filter, wrap, minFilter) {
	    var ref = this;
	    var context = ref.context;
	    var gl = context.gl;
	    gl.bindTexture(gl.TEXTURE_2D, this.texture);
	    if (minFilter === gl.LINEAR_MIPMAP_NEAREST && !this.isSizePowerOfTwo()) {
	        minFilter = gl.LINEAR;
	    }
	    if (filter !== this.filter) {
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter || filter);
	        this.filter = filter;
	    }
	    if (wrap !== this.wrap) {
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);
	        this.wrap = wrap;
	    }
	};
	Texture.prototype.isSizePowerOfTwo = function isSizePowerOfTwo() {
	    return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 === 0;
	};
	Texture.prototype.destroy = function destroy() {
	    var ref = this.context;
	    var gl = ref.gl;
	    gl.deleteTexture(this.texture);
	    this.texture = null;
	};

	var ThrottledInvoker = function ThrottledInvoker(callback) {
	    var this$1 = this;
	    this._callback = callback;
	    this._triggered = false;
	    if (typeof MessageChannel !== 'undefined') {
	        this._channel = new MessageChannel();
	        this._channel.port2.onmessage = function () {
	            this$1._triggered = false;
	            this$1._callback();
	        };
	    }
	};
	ThrottledInvoker.prototype.trigger = function trigger() {
	    var this$1 = this;
	    if (!this._triggered) {
	        this._triggered = true;
	        if (this._channel) {
	            this._channel.port1.postMessage(true);
	        } else {
	            setTimeout(function () {
	                this$1._triggered = false;
	                this$1._callback();
	            }, 0);
	        }
	    }
	};
	ThrottledInvoker.prototype.remove = function remove() {
	    delete this._channel;
	    this._callback = function () {
	    };
	};

	var Actor = function Actor(target, parent, mapId) {
	    this.target = target;
	    this.parent = parent;
	    this.mapId = mapId;
	    this.callbacks = {};
	    this.tasks = {};
	    this.taskQueue = [];
	    this.cancelCallbacks = {};
	    bindAll([
	        'receive',
	        'process'
	    ], this);
	    this.invoker = new ThrottledInvoker(this.process);
	    this.target.addEventListener('message', this.receive, false);
	    this.globalScope = isWorker() ? target : window$1;
	};
	Actor.prototype.send = function send(type, data, callback, targetMapId, mustQueue) {
	    var this$1 = this;
	    if (mustQueue === void 0)
	        mustQueue = false;
	    var id = Math.round(Math.random() * 1000000000000000000).toString(36).substring(0, 10);
	    if (callback) {
	        this.callbacks[id] = callback;
	    }
	    var buffers = isSafari(this.globalScope) ? undefined : [];
	    this.target.postMessage({
	        id: id,
	        type: type,
	        hasCallback: !!callback,
	        targetMapId: targetMapId,
	        mustQueue: mustQueue,
	        sourceMapId: this.mapId,
	        data: serialize(data, buffers)
	    }, buffers);
	    return {
	        cancel: function () {
	            if (callback) {
	                delete this$1.callbacks[id];
	            }
	            this$1.target.postMessage({
	                id: id,
	                type: '<cancel>',
	                targetMapId: targetMapId,
	                sourceMapId: this$1.mapId
	            });
	        }
	    };
	};
	Actor.prototype.receive = function receive(message) {
	    var data = message.data, id = data.id;
	    if (!id) {
	        return;
	    }
	    if (data.targetMapId && this.mapId !== data.targetMapId) {
	        return;
	    }
	    if (data.type === '<cancel>') {
	        delete this.tasks[id];
	        var cancel = this.cancelCallbacks[id];
	        delete this.cancelCallbacks[id];
	        if (cancel) {
	            cancel();
	        }
	    } else {
	        if (isWorker() || data.mustQueue) {
	            this.tasks[id] = data;
	            this.taskQueue.push(id);
	            this.invoker.trigger();
	        } else {
	            this.processTask(id, data);
	        }
	    }
	};
	Actor.prototype.process = function process() {
	    if (!this.taskQueue.length) {
	        return;
	    }
	    var id = this.taskQueue.shift();
	    var task = this.tasks[id];
	    delete this.tasks[id];
	    if (this.taskQueue.length) {
	        this.invoker.trigger();
	    }
	    if (!task) {
	        return;
	    }
	    this.processTask(id, task);
	};
	Actor.prototype.processTask = function processTask(id, task) {
	    var this$1 = this;
	    if (task.type === '<response>') {
	        var callback = this.callbacks[id];
	        delete this.callbacks[id];
	        if (callback) {
	            if (task.error) {
	                callback(deserialize(task.error));
	            } else {
	                callback(null, deserialize(task.data));
	            }
	        }
	    } else {
	        var completed = false;
	        var buffers = isSafari(this.globalScope) ? undefined : [];
	        var done = task.hasCallback ? function (err, data) {
	            completed = true;
	            delete this$1.cancelCallbacks[id];
	            this$1.target.postMessage({
	                id: id,
	                type: '<response>',
	                sourceMapId: this$1.mapId,
	                error: err ? serialize(err) : null,
	                data: serialize(data, buffers)
	            }, buffers);
	        } : function (_) {
	            completed = true;
	        };
	        var callback$1 = null;
	        var params = deserialize(task.data);
	        if (this.parent[task.type]) {
	            callback$1 = this.parent[task.type](task.sourceMapId, params, done);
	        } else if (this.parent.getWorkerSource) {
	            var keys = task.type.split('.');
	            var scope = this.parent.getWorkerSource(task.sourceMapId, keys[0], params.source);
	            callback$1 = scope[keys[1]](params, done);
	        } else {
	            done(new Error('Could not find function ' + task.type));
	        }
	        if (!completed && callback$1 && callback$1.cancel) {
	            this.cancelCallbacks[id] = callback$1.cancel;
	        }
	    }
	};
	Actor.prototype.remove = function remove() {
	    this.invoker.remove();
	    this.target.removeEventListener('message', this.receive, false);
	};

	/**
	 * getTileBBox
	 *
	 * @param    {Number}  x  Tile coordinate x
	 * @param    {Number}  y  Tile coordinate y
	 * @param    {Number}  z  Tile zoom
	 * @returns  {String}  String of the bounding box
	 */
	function getTileBBox(x, y, z) {
	    // for Google/OSM tile scheme we need to alter the y
	    y = (Math.pow(2, z) - y - 1);

	    var min = getMercCoords(x * 256, y * 256, z),
	        max = getMercCoords((x + 1) * 256, (y + 1) * 256, z);

	    return min[0] + ',' + min[1] + ',' + max[0] + ',' + max[1];
	}


	/**
	 * getMercCoords
	 *
	 * @param    {Number}  x  Pixel coordinate x
	 * @param    {Number}  y  Pixel coordinate y
	 * @param    {Number}  z  Tile zoom
	 * @returns  {Array}   [x, y]
	 */
	function getMercCoords(x, y, z) {
	    var resolution = (2 * Math.PI * 6378137 / 256) / Math.pow(2, z),
	        merc_x = (x * resolution - 2 * Math.PI  * 6378137 / 2.0),
	        merc_y = (y * resolution - 2 * Math.PI  * 6378137 / 2.0);

	    return [merc_x, merc_y];
	}

	var LngLatBounds = function LngLatBounds(sw, ne) {
	    if (!sw) ; else if (ne) {
	        this.setSouthWest(sw).setNorthEast(ne);
	    } else if (sw.length === 4) {
	        this.setSouthWest([
	            sw[0],
	            sw[1]
	        ]).setNorthEast([
	            sw[2],
	            sw[3]
	        ]);
	    } else {
	        this.setSouthWest(sw[0]).setNorthEast(sw[1]);
	    }
	};
	LngLatBounds.prototype.setNorthEast = function setNorthEast(ne) {
	    this._ne = ne instanceof LngLat ? new LngLat(ne.lng, ne.lat) : LngLat.convert(ne);
	    return this;
	};
	LngLatBounds.prototype.setSouthWest = function setSouthWest(sw) {
	    this._sw = sw instanceof LngLat ? new LngLat(sw.lng, sw.lat) : LngLat.convert(sw);
	    return this;
	};
	LngLatBounds.prototype.extend = function extend(obj) {
	    var sw = this._sw, ne = this._ne;
	    var sw2, ne2;
	    if (obj instanceof LngLat) {
	        sw2 = obj;
	        ne2 = obj;
	    } else if (obj instanceof LngLatBounds) {
	        sw2 = obj._sw;
	        ne2 = obj._ne;
	        if (!sw2 || !ne2) {
	            return this;
	        }
	    } else {
	        if (Array.isArray(obj)) {
	            if (obj.length === 4 || obj.every(Array.isArray)) {
	                var lngLatBoundsObj = obj;
	                return this.extend(LngLatBounds.convert(lngLatBoundsObj));
	            } else {
	                var lngLatObj = obj;
	                return this.extend(LngLat.convert(lngLatObj));
	            }
	        }
	        return this;
	    }
	    if (!sw && !ne) {
	        this._sw = new LngLat(sw2.lng, sw2.lat);
	        this._ne = new LngLat(ne2.lng, ne2.lat);
	    } else {
	        sw.lng = Math.min(sw2.lng, sw.lng);
	        sw.lat = Math.min(sw2.lat, sw.lat);
	        ne.lng = Math.max(ne2.lng, ne.lng);
	        ne.lat = Math.max(ne2.lat, ne.lat);
	    }
	    return this;
	};
	LngLatBounds.prototype.getCenter = function getCenter() {
	    return new LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
	};
	LngLatBounds.prototype.getSouthWest = function getSouthWest() {
	    return this._sw;
	};
	LngLatBounds.prototype.getNorthEast = function getNorthEast() {
	    return this._ne;
	};
	LngLatBounds.prototype.getNorthWest = function getNorthWest() {
	    return new LngLat(this.getWest(), this.getNorth());
	};
	LngLatBounds.prototype.getSouthEast = function getSouthEast() {
	    return new LngLat(this.getEast(), this.getSouth());
	};
	LngLatBounds.prototype.getWest = function getWest() {
	    return this._sw.lng;
	};
	LngLatBounds.prototype.getSouth = function getSouth() {
	    return this._sw.lat;
	};
	LngLatBounds.prototype.getEast = function getEast() {
	    return this._ne.lng;
	};
	LngLatBounds.prototype.getNorth = function getNorth() {
	    return this._ne.lat;
	};
	LngLatBounds.prototype.toArray = function toArray() {
	    return [
	        this._sw.toArray(),
	        this._ne.toArray()
	    ];
	};
	LngLatBounds.prototype.toString = function toString() {
	    return 'LngLatBounds(' + this._sw.toString() + ', ' + this._ne.toString() + ')';
	};
	LngLatBounds.prototype.isEmpty = function isEmpty() {
	    return !(this._sw && this._ne);
	};
	LngLatBounds.prototype.contains = function contains(lnglat) {
	    var ref = LngLat.convert(lnglat);
	    var lng = ref.lng;
	    var lat = ref.lat;
	    var containsLatitude = this._sw.lat <= lat && lat <= this._ne.lat;
	    var containsLongitude = this._sw.lng <= lng && lng <= this._ne.lng;
	    if (this._sw.lng > this._ne.lng) {
	        containsLongitude = this._sw.lng >= lng && lng >= this._ne.lng;
	    }
	    return containsLatitude && containsLongitude;
	};
	LngLatBounds.convert = function convert(input) {
	    if (!input || input instanceof LngLatBounds) {
	        return input;
	    }
	    return new LngLatBounds(input);
	};

	var earthRadius = 6371008.8;
	var LngLat = function LngLat(lng, lat) {
	    if (isNaN(lng) || isNaN(lat)) {
	        throw new Error('Invalid LngLat object: (' + lng + ', ' + lat + ')');
	    }
	    this.lng = +lng;
	    this.lat = +lat;
	    if (this.lat > 90 || this.lat < -90) {
	        throw new Error('Invalid LngLat latitude value: must be between -90 and 90');
	    }
	};
	LngLat.prototype.wrap = function wrap$1() {
	    return new LngLat(wrap(this.lng, -180, 180), this.lat);
	};
	LngLat.prototype.toArray = function toArray() {
	    return [
	        this.lng,
	        this.lat
	    ];
	};
	LngLat.prototype.toString = function toString() {
	    return 'LngLat(' + this.lng + ', ' + this.lat + ')';
	};
	LngLat.prototype.distanceTo = function distanceTo(lngLat) {
	    var rad = Math.PI / 180;
	    var lat1 = this.lat * rad;
	    var lat2 = lngLat.lat * rad;
	    var a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((lngLat.lng - this.lng) * rad);
	    var maxMeters = earthRadius * Math.acos(Math.min(a, 1));
	    return maxMeters;
	};
	LngLat.prototype.toBounds = function toBounds(radius) {
	    if (radius === void 0)
	        radius = 0;
	    var earthCircumferenceInMetersAtEquator = 40075017;
	    var latAccuracy = 360 * radius / earthCircumferenceInMetersAtEquator, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
	    return new LngLatBounds(new LngLat(this.lng - lngAccuracy, this.lat - latAccuracy), new LngLat(this.lng + lngAccuracy, this.lat + latAccuracy));
	};
	LngLat.convert = function convert(input) {
	    if (input instanceof LngLat) {
	        return input;
	    }
	    if (Array.isArray(input) && (input.length === 2 || input.length === 3)) {
	        return new LngLat(Number(input[0]), Number(input[1]));
	    }
	    if (!Array.isArray(input) && typeof input === 'object' && input !== null) {
	        return new LngLat(Number('lng' in input ? input.lng : input.lon), Number(input.lat));
	    }
	    throw new Error('`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]');
	};

	var earthCircumfrence = 2 * Math.PI * earthRadius;
	function circumferenceAtLatitude(latitude) {
	    return earthCircumfrence * Math.cos(latitude * Math.PI / 180);
	}
	function mercatorXfromLng$1(lng) {
	    return (180 + lng) / 360;
	}
	function mercatorYfromLat$1(lat) {
	    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
	}
	function mercatorZfromAltitude(altitude, lat) {
	    return altitude / circumferenceAtLatitude(lat);
	}
	function lngFromMercatorX(x) {
	    return x * 360 - 180;
	}
	function latFromMercatorY(y) {
	    var y2 = 180 - y * 360;
	    return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
	}
	function altitudeFromMercatorZ(z, y) {
	    return z * circumferenceAtLatitude(latFromMercatorY(y));
	}
	function mercatorScale(lat) {
	    return 1 / Math.cos(lat * Math.PI / 180);
	}
	var MercatorCoordinate = function MercatorCoordinate(x, y, z) {
	    if (z === void 0)
	        z = 0;
	    this.x = +x;
	    this.y = +y;
	    this.z = +z;
	};
	MercatorCoordinate.fromLngLat = function fromLngLat(lngLatLike, altitude) {
	    if (altitude === void 0)
	        altitude = 0;
	    var lngLat = LngLat.convert(lngLatLike);
	    return new MercatorCoordinate(mercatorXfromLng$1(lngLat.lng), mercatorYfromLat$1(lngLat.lat), mercatorZfromAltitude(altitude, lngLat.lat));
	};
	MercatorCoordinate.prototype.toLngLat = function toLngLat() {
	    return new LngLat(lngFromMercatorX(this.x), latFromMercatorY(this.y));
	};
	MercatorCoordinate.prototype.toAltitude = function toAltitude() {
	    return altitudeFromMercatorZ(this.z, this.y);
	};
	MercatorCoordinate.prototype.meterInMercatorCoordinateUnits = function meterInMercatorCoordinateUnits() {
	    return 1 / earthCircumfrence * mercatorScale(latFromMercatorY(this.y));
	};

	var CanonicalTileID = function CanonicalTileID(z, x, y) {
	    this.z = z;
	    this.x = x;
	    this.y = y;
	    this.key = calculateKey(0, z, z, x, y);
	};
	CanonicalTileID.prototype.equals = function equals(id) {
	    return this.z === id.z && this.x === id.x && this.y === id.y;
	};
	CanonicalTileID.prototype.url = function url(urls, scheme) {
	    var bbox = getTileBBox(this.x, this.y, this.z);
	    var quadkey = getQuadkey(this.z, this.x, this.y);
	    return urls[(this.x + this.y) % urls.length].replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace('{z}', String(this.z)).replace('{x}', String(this.x)).replace('{y}', String(scheme === 'tms' ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace('{quadkey}', quadkey).replace('{bbox-epsg-3857}', bbox);
	};
	CanonicalTileID.prototype.getTilePoint = function getTilePoint(coord) {
	    var tilesAtZoom = Math.pow(2, this.z);
	    return new pointGeometry((coord.x * tilesAtZoom - this.x) * EXTENT$1, (coord.y * tilesAtZoom - this.y) * EXTENT$1);
	};
	CanonicalTileID.prototype.toString = function toString() {
	    return this.z + '/' + this.x + '/' + this.y;
	};
	var UnwrappedTileID = function UnwrappedTileID(wrap, canonical) {
	    this.wrap = wrap;
	    this.canonical = canonical;
	    this.key = calculateKey(wrap, canonical.z, canonical.z, canonical.x, canonical.y);
	};
	var OverscaledTileID = function OverscaledTileID(overscaledZ, wrap, z, x, y) {
	    this.overscaledZ = overscaledZ;
	    this.wrap = wrap;
	    this.canonical = new CanonicalTileID(z, +x, +y);
	    this.key = calculateKey(wrap, overscaledZ, z, x, y);
	};
	OverscaledTileID.prototype.equals = function equals(id) {
	    return this.overscaledZ === id.overscaledZ && this.wrap === id.wrap && this.canonical.equals(id.canonical);
	};
	OverscaledTileID.prototype.scaledTo = function scaledTo(targetZ) {
	    var zDifference = this.canonical.z - targetZ;
	    if (targetZ > this.canonical.z) {
	        return new OverscaledTileID(targetZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
	    } else {
	        return new OverscaledTileID(targetZ, this.wrap, targetZ, this.canonical.x >> zDifference, this.canonical.y >> zDifference);
	    }
	};
	OverscaledTileID.prototype.calculateScaledKey = function calculateScaledKey(targetZ, withWrap) {
	    var zDifference = this.canonical.z - targetZ;
	    if (targetZ > this.canonical.z) {
	        return calculateKey(this.wrap * +withWrap, targetZ, this.canonical.z, this.canonical.x, this.canonical.y);
	    } else {
	        return calculateKey(this.wrap * +withWrap, targetZ, targetZ, this.canonical.x >> zDifference, this.canonical.y >> zDifference);
	    }
	};
	OverscaledTileID.prototype.isChildOf = function isChildOf(parent) {
	    if (parent.wrap !== this.wrap) {
	        return false;
	    }
	    var zDifference = this.canonical.z - parent.canonical.z;
	    return parent.overscaledZ === 0 || parent.overscaledZ < this.overscaledZ && parent.canonical.x === this.canonical.x >> zDifference && parent.canonical.y === this.canonical.y >> zDifference;
	};
	OverscaledTileID.prototype.children = function children(sourceMaxZoom) {
	    if (this.overscaledZ >= sourceMaxZoom) {
	        return [new OverscaledTileID(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
	    }
	    var z = this.canonical.z + 1;
	    var x = this.canonical.x * 2;
	    var y = this.canonical.y * 2;
	    return [
	        new OverscaledTileID(z, this.wrap, z, x, y),
	        new OverscaledTileID(z, this.wrap, z, x + 1, y),
	        new OverscaledTileID(z, this.wrap, z, x, y + 1),
	        new OverscaledTileID(z, this.wrap, z, x + 1, y + 1)
	    ];
	};
	OverscaledTileID.prototype.isLessThan = function isLessThan(rhs) {
	    if (this.wrap < rhs.wrap) {
	        return true;
	    }
	    if (this.wrap > rhs.wrap) {
	        return false;
	    }
	    if (this.overscaledZ < rhs.overscaledZ) {
	        return true;
	    }
	    if (this.overscaledZ > rhs.overscaledZ) {
	        return false;
	    }
	    if (this.canonical.x < rhs.canonical.x) {
	        return true;
	    }
	    if (this.canonical.x > rhs.canonical.x) {
	        return false;
	    }
	    if (this.canonical.y < rhs.canonical.y) {
	        return true;
	    }
	    return false;
	};
	OverscaledTileID.prototype.wrapped = function wrapped() {
	    return new OverscaledTileID(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
	};
	OverscaledTileID.prototype.unwrapTo = function unwrapTo(wrap) {
	    return new OverscaledTileID(this.overscaledZ, wrap, this.canonical.z, this.canonical.x, this.canonical.y);
	};
	OverscaledTileID.prototype.overscaleFactor = function overscaleFactor() {
	    return Math.pow(2, this.overscaledZ - this.canonical.z);
	};
	OverscaledTileID.prototype.toUnwrapped = function toUnwrapped() {
	    return new UnwrappedTileID(this.wrap, this.canonical);
	};
	OverscaledTileID.prototype.toString = function toString() {
	    return this.overscaledZ + '/' + this.canonical.x + '/' + this.canonical.y;
	};
	OverscaledTileID.prototype.getTilePoint = function getTilePoint(coord) {
	    return this.canonical.getTilePoint(new MercatorCoordinate(coord.x - this.wrap, coord.y));
	};
	function calculateKey(wrap, overscaledZ, z, x, y) {
	    wrap *= 2;
	    if (wrap < 0) {
	        wrap = wrap * -1 - 1;
	    }
	    var dim = 1 << z;
	    return (dim * dim * wrap + dim * y + x).toString(36) + z.toString(36) + overscaledZ.toString(36);
	}
	function getQuadkey(z, x, y) {
	    var quadkey = '', mask;
	    for (var i = z; i > 0; i--) {
	        mask = 1 << i - 1;
	        quadkey += (x & mask ? 1 : 0) + (y & mask ? 2 : 0);
	    }
	    return quadkey;
	}
	register('CanonicalTileID', CanonicalTileID);
	register('OverscaledTileID', OverscaledTileID, { omit: ['posMatrix'] });

	var DEMData = function DEMData(uid, data, encoding) {
	    this.uid = uid;
	    if (data.height !== data.width) {
	        throw new RangeError('DEM tiles must be square');
	    }
	    if (encoding && encoding !== 'mapbox' && encoding !== 'terrarium') {
	        return warnOnce('"' + encoding + '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".');
	    }
	    this.stride = data.height;
	    var dim = this.dim = data.height - 2;
	    this.data = new Uint32Array(data.data.buffer);
	    this.encoding = encoding || 'mapbox';
	    for (var x = 0; x < dim; x++) {
	        this.data[this._idx(-1, x)] = this.data[this._idx(0, x)];
	        this.data[this._idx(dim, x)] = this.data[this._idx(dim - 1, x)];
	        this.data[this._idx(x, -1)] = this.data[this._idx(x, 0)];
	        this.data[this._idx(x, dim)] = this.data[this._idx(x, dim - 1)];
	    }
	    this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)];
	    this.data[this._idx(dim, -1)] = this.data[this._idx(dim - 1, 0)];
	    this.data[this._idx(-1, dim)] = this.data[this._idx(0, dim - 1)];
	    this.data[this._idx(dim, dim)] = this.data[this._idx(dim - 1, dim - 1)];
	};
	DEMData.prototype.get = function get(x, y) {
	    var pixels = new Uint8Array(this.data.buffer);
	    var index = this._idx(x, y) * 4;
	    var unpack = this.encoding === 'terrarium' ? this._unpackTerrarium : this._unpackMapbox;
	    return unpack(pixels[index], pixels[index + 1], pixels[index + 2]);
	};
	DEMData.prototype.getUnpackVector = function getUnpackVector() {
	    return this.encoding === 'terrarium' ? [
	        256,
	        1,
	        1 / 256,
	        32768
	    ] : [
	        6553.6,
	        25.6,
	        0.1,
	        10000
	    ];
	};
	DEMData.prototype._idx = function _idx(x, y) {
	    if (x < -1 || x >= this.dim + 1 || y < -1 || y >= this.dim + 1) {
	        throw new RangeError('out of range source coordinates for DEM data');
	    }
	    return (y + 1) * this.stride + (x + 1);
	};
	DEMData.prototype._unpackMapbox = function _unpackMapbox(r, g, b) {
	    return (r * 256 * 256 + g * 256 + b) / 10 - 10000;
	};
	DEMData.prototype._unpackTerrarium = function _unpackTerrarium(r, g, b) {
	    return r * 256 + g + b / 256 - 32768;
	};
	DEMData.prototype.getPixels = function getPixels() {
	    return new RGBAImage({
	        width: this.stride,
	        height: this.stride
	    }, new Uint8Array(this.data.buffer));
	};
	DEMData.prototype.backfillBorder = function backfillBorder(borderTile, dx, dy) {
	    if (this.dim !== borderTile.dim) {
	        throw new Error('dem dimension mismatch');
	    }
	    var xMin = dx * this.dim, xMax = dx * this.dim + this.dim, yMin = dy * this.dim, yMax = dy * this.dim + this.dim;
	    switch (dx) {
	    case -1:
	        xMin = xMax - 1;
	        break;
	    case 1:
	        xMax = xMin + 1;
	        break;
	    }
	    switch (dy) {
	    case -1:
	        yMin = yMax - 1;
	        break;
	    case 1:
	        yMax = yMin + 1;
	        break;
	    }
	    var ox = -dx * this.dim;
	    var oy = -dy * this.dim;
	    for (var y = yMin; y < yMax; y++) {
	        for (var x = xMin; x < xMax; x++) {
	            this.data[this._idx(x, y)] = borderTile.data[this._idx(x + ox, y + oy)];
	        }
	    }
	};
	register('DEMData', DEMData);

	function deserialize$1(input, style) {
	    var output = {};
	    if (!style) {
	        return output;
	    }
	    var loop = function () {
	        var bucket = list$1[i$1];
	        var layers = bucket.layerIds.map(function (id) {
	            return style.getLayer(id);
	        }).filter(Boolean);
	        if (layers.length === 0) {
	            return;
	        }
	        bucket.layers = layers;
	        if (bucket.stateDependentLayerIds) {
	            bucket.stateDependentLayers = bucket.stateDependentLayerIds.map(function (lId) {
	                return layers.filter(function (l) {
	                    return l.id === lId;
	                })[0];
	            });
	        }
	        for (var i = 0, list = layers; i < list.length; i += 1) {
	            var layer = list[i];
	            output[layer.id] = bucket;
	        }
	    };
	    for (var i$1 = 0, list$1 = input; i$1 < list$1.length; i$1 += 1)
	        loop();
	    return output;
	}

	var DictionaryCoder = function DictionaryCoder(strings) {
	    this._stringToNumber = {};
	    this._numberToString = [];
	    for (var i = 0; i < strings.length; i++) {
	        var string = strings[i];
	        this._stringToNumber[string] = i;
	        this._numberToString[i] = string;
	    }
	};
	DictionaryCoder.prototype.encode = function encode(string) {
	    return this._stringToNumber[string];
	};
	DictionaryCoder.prototype.decode = function decode(n) {
	    return this._numberToString[n];
	};

	var Feature = function Feature(vectorTileFeature, z, x, y, id) {
	    this.type = 'Feature';
	    this._vectorTileFeature = vectorTileFeature;
	    vectorTileFeature._z = z;
	    vectorTileFeature._x = x;
	    vectorTileFeature._y = y;
	    this.properties = vectorTileFeature.properties;
	    this.id = id;
	};
	var prototypeAccessors$1 = { geometry: { configurable: true } };
	prototypeAccessors$1.geometry.get = function () {
	    if (this._geometry === undefined) {
	        this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry;
	    }
	    return this._geometry;
	};
	prototypeAccessors$1.geometry.set = function (g) {
	    this._geometry = g;
	};
	Feature.prototype.toJSON = function toJSON() {
	    var json = { geometry: this.geometry };
	    for (var i in this) {
	        if (i === '_geometry' || i === '_vectorTileFeature') {
	            continue;
	        }
	        json[i] = this[i];
	    }
	    return json;
	};
	Object.defineProperties(Feature.prototype, prototypeAccessors$1);

	var SourceFeatureState = function SourceFeatureState() {
	    this.state = {};
	    this.stateChanges = {};
	    this.deletedStates = {};
	};
	SourceFeatureState.prototype.updateState = function updateState(sourceLayer, featureId, newState) {
	    var feature = String(featureId);
	    this.stateChanges[sourceLayer] = this.stateChanges[sourceLayer] || {};
	    this.stateChanges[sourceLayer][feature] = this.stateChanges[sourceLayer][feature] || {};
	    extend(this.stateChanges[sourceLayer][feature], newState);
	    if (this.deletedStates[sourceLayer] === null) {
	        this.deletedStates[sourceLayer] = {};
	        for (var ft in this.state[sourceLayer]) {
	            if (ft !== feature) {
	                this.deletedStates[sourceLayer][ft] = null;
	            }
	        }
	    } else {
	        var featureDeletionQueued = this.deletedStates[sourceLayer] && this.deletedStates[sourceLayer][feature] === null;
	        if (featureDeletionQueued) {
	            this.deletedStates[sourceLayer][feature] = {};
	            for (var prop in this.state[sourceLayer][feature]) {
	                if (!newState[prop]) {
	                    this.deletedStates[sourceLayer][feature][prop] = null;
	                }
	            }
	        } else {
	            for (var key in newState) {
	                var deletionInQueue = this.deletedStates[sourceLayer] && this.deletedStates[sourceLayer][feature] && this.deletedStates[sourceLayer][feature][key] === null;
	                if (deletionInQueue) {
	                    delete this.deletedStates[sourceLayer][feature][key];
	                }
	            }
	        }
	    }
	};
	SourceFeatureState.prototype.removeFeatureState = function removeFeatureState(sourceLayer, featureId, key) {
	    var sourceLayerDeleted = this.deletedStates[sourceLayer] === null;
	    if (sourceLayerDeleted) {
	        return;
	    }
	    var feature = String(featureId);
	    this.deletedStates[sourceLayer] = this.deletedStates[sourceLayer] || {};
	    if (key && featureId !== undefined) {
	        if (this.deletedStates[sourceLayer][feature] !== null) {
	            this.deletedStates[sourceLayer][feature] = this.deletedStates[sourceLayer][feature] || {};
	            this.deletedStates[sourceLayer][feature][key] = null;
	        }
	    } else if (featureId !== undefined) {
	        var updateInQueue = this.stateChanges[sourceLayer] && this.stateChanges[sourceLayer][feature];
	        if (updateInQueue) {
	            this.deletedStates[sourceLayer][feature] = {};
	            for (key in this.stateChanges[sourceLayer][feature]) {
	                this.deletedStates[sourceLayer][feature][key] = null;
	            }
	        } else {
	            this.deletedStates[sourceLayer][feature] = null;
	        }
	    } else {
	        this.deletedStates[sourceLayer] = null;
	    }
	};
	SourceFeatureState.prototype.getState = function getState(sourceLayer, featureId) {
	    var feature = String(featureId);
	    var base = this.state[sourceLayer] || {};
	    var changes = this.stateChanges[sourceLayer] || {};
	    var reconciledState = extend({}, base[feature], changes[feature]);
	    if (this.deletedStates[sourceLayer] === null) {
	        return {};
	    } else if (this.deletedStates[sourceLayer]) {
	        var featureDeletions = this.deletedStates[sourceLayer][featureId];
	        if (featureDeletions === null) {
	            return {};
	        }
	        for (var prop in featureDeletions) {
	            delete reconciledState[prop];
	        }
	    }
	    return reconciledState;
	};
	SourceFeatureState.prototype.initializeTileState = function initializeTileState(tile, painter) {
	    tile.setFeatureState(this.state, painter);
	};
	SourceFeatureState.prototype.coalesceChanges = function coalesceChanges(tiles, painter) {
	    var featuresChanged = {};
	    for (var sourceLayer in this.stateChanges) {
	        this.state[sourceLayer] = this.state[sourceLayer] || {};
	        var layerStates = {};
	        for (var feature in this.stateChanges[sourceLayer]) {
	            if (!this.state[sourceLayer][feature]) {
	                this.state[sourceLayer][feature] = {};
	            }
	            extend(this.state[sourceLayer][feature], this.stateChanges[sourceLayer][feature]);
	            layerStates[feature] = this.state[sourceLayer][feature];
	        }
	        featuresChanged[sourceLayer] = layerStates;
	    }
	    for (var sourceLayer$1 in this.deletedStates) {
	        this.state[sourceLayer$1] = this.state[sourceLayer$1] || {};
	        var layerStates$1 = {};
	        if (this.deletedStates[sourceLayer$1] === null) {
	            for (var ft in this.state[sourceLayer$1]) {
	                layerStates$1[ft] = {};
	                this.state[sourceLayer$1][ft] = {};
	            }
	        } else {
	            for (var feature$1 in this.deletedStates[sourceLayer$1]) {
	                var deleteWholeFeatureState = this.deletedStates[sourceLayer$1][feature$1] === null;
	                if (deleteWholeFeatureState) {
	                    this.state[sourceLayer$1][feature$1] = {};
	                } else {
	                    for (var i = 0, list = Object.keys(this.deletedStates[sourceLayer$1][feature$1]); i < list.length; i += 1) {
	                        var key = list[i];
	                        delete this.state[sourceLayer$1][feature$1][key];
	                    }
	                }
	                layerStates$1[feature$1] = this.state[sourceLayer$1][feature$1];
	            }
	        }
	        featuresChanged[sourceLayer$1] = featuresChanged[sourceLayer$1] || {};
	        extend(featuresChanged[sourceLayer$1], layerStates$1);
	    }
	    this.stateChanges = {};
	    this.deletedStates = {};
	    if (Object.keys(featuresChanged).length === 0) {
	        return;
	    }
	    for (var id in tiles) {
	        var tile = tiles[id];
	        tile.setFeatureState(featuresChanged, painter);
	    }
	};

	var FeatureIndex = function FeatureIndex(tileID, promoteId) {
	    this.tileID = tileID;
	    this.x = tileID.canonical.x;
	    this.y = tileID.canonical.y;
	    this.z = tileID.canonical.z;
	    this.grid = new gridIndex(EXTENT$1, 16, 0);
	    this.grid3D = new gridIndex(EXTENT$1, 16, 0);
	    this.featureIndexArray = new FeatureIndexArray();
	    this.promoteId = promoteId;
	};
	FeatureIndex.prototype.insert = function insert(feature, geometry, featureIndex, sourceLayerIndex, bucketIndex, is3D) {
	    var key = this.featureIndexArray.length;
	    this.featureIndexArray.emplaceBack(featureIndex, sourceLayerIndex, bucketIndex);
	    var grid = is3D ? this.grid3D : this.grid;
	    for (var r = 0; r < geometry.length; r++) {
	        var ring = geometry[r];
	        var bbox = [
	            Infinity,
	            Infinity,
	            -Infinity,
	            -Infinity
	        ];
	        for (var i = 0; i < ring.length; i++) {
	            var p = ring[i];
	            bbox[0] = Math.min(bbox[0], p.x);
	            bbox[1] = Math.min(bbox[1], p.y);
	            bbox[2] = Math.max(bbox[2], p.x);
	            bbox[3] = Math.max(bbox[3], p.y);
	        }
	        if (bbox[0] < EXTENT$1 && bbox[1] < EXTENT$1 && bbox[2] >= 0 && bbox[3] >= 0) {
	            grid.insert(key, bbox[0], bbox[1], bbox[2], bbox[3]);
	        }
	    }
	};
	FeatureIndex.prototype.loadVTLayers = function loadVTLayers() {
	    if (!this.vtLayers) {
	        this.vtLayers = new vectorTile.VectorTile(new pbf(this.rawTileData)).layers;
	        this.sourceLayerCoder = new DictionaryCoder(this.vtLayers ? Object.keys(this.vtLayers).sort() : ['_geojsonTileLayer']);
	    }
	    return this.vtLayers;
	};
	FeatureIndex.prototype.query = function query(args, styleLayers, serializedLayers, sourceFeatureState) {
	    var this$1 = this;
	    this.loadVTLayers();
	    var params = args.params || {}, pixelsToTileUnits = EXTENT$1 / args.tileSize / args.scale, filter = createFilter(params.filter);
	    var queryGeometry = args.queryGeometry;
	    var queryPadding = args.queryPadding * pixelsToTileUnits;
	    var bounds = getBounds(queryGeometry);
	    var matching = this.grid.query(bounds.minX - queryPadding, bounds.minY - queryPadding, bounds.maxX + queryPadding, bounds.maxY + queryPadding);
	    var cameraBounds = getBounds(args.cameraQueryGeometry);
	    var matching3D = this.grid3D.query(cameraBounds.minX - queryPadding, cameraBounds.minY - queryPadding, cameraBounds.maxX + queryPadding, cameraBounds.maxY + queryPadding, function (bx1, by1, bx2, by2) {
	        return polygonIntersectsBox(args.cameraQueryGeometry, bx1 - queryPadding, by1 - queryPadding, bx2 + queryPadding, by2 + queryPadding);
	    });
	    for (var i = 0, list = matching3D; i < list.length; i += 1) {
	        var key = list[i];
	        matching.push(key);
	    }
	    matching.sort(topDownFeatureComparator);
	    var result = {};
	    var previousIndex;
	    var loop = function (k) {
	        var index = matching[k];
	        if (index === previousIndex) {
	            return;
	        }
	        previousIndex = index;
	        var match = this$1.featureIndexArray.get(index);
	        var featureGeometry = null;
	        this$1.loadMatchingFeature(result, match.bucketIndex, match.sourceLayerIndex, match.featureIndex, filter, params.layers, params.availableImages, styleLayers, serializedLayers, sourceFeatureState, function (feature, styleLayer, featureState) {
	            if (!featureGeometry) {
	                featureGeometry = loadGeometry(feature);
	            }
	            return styleLayer.queryIntersectsFeature(queryGeometry, feature, featureState, featureGeometry, this$1.z, args.transform, pixelsToTileUnits, args.pixelPosMatrix);
	        });
	    };
	    for (var k = 0; k < matching.length; k++)
	        loop(k);
	    return result;
	};
	FeatureIndex.prototype.loadMatchingFeature = function loadMatchingFeature(result, bucketIndex, sourceLayerIndex, featureIndex, filter, filterLayerIDs, availableImages, styleLayers, serializedLayers, sourceFeatureState, intersectionTest) {
	    var layerIDs = this.bucketLayerIDs[bucketIndex];
	    if (filterLayerIDs && !arraysIntersect(filterLayerIDs, layerIDs)) {
	        return;
	    }
	    var sourceLayerName = this.sourceLayerCoder.decode(sourceLayerIndex);
	    var sourceLayer = this.vtLayers[sourceLayerName];
	    var feature = sourceLayer.feature(featureIndex);
	    if (filter.needGeometry) {
	        var evaluationFeature = toEvaluationFeature(feature, true);
	        if (!filter.filter(new EvaluationParameters(this.tileID.overscaledZ), evaluationFeature, this.tileID.canonical)) {
	            return;
	        }
	    } else if (!filter.filter(new EvaluationParameters(this.tileID.overscaledZ), feature)) {
	        return;
	    }
	    var id = this.getId(feature, sourceLayerName);
	    for (var l = 0; l < layerIDs.length; l++) {
	        var layerID = layerIDs[l];
	        if (filterLayerIDs && filterLayerIDs.indexOf(layerID) < 0) {
	            continue;
	        }
	        var styleLayer = styleLayers[layerID];
	        if (!styleLayer) {
	            continue;
	        }
	        var featureState = {};
	        if (id !== undefined && sourceFeatureState) {
	            featureState = sourceFeatureState.getState(styleLayer.sourceLayer || '_geojsonTileLayer', id);
	        }
	        var serializedLayer = extend({}, serializedLayers[layerID]);
	        serializedLayer.paint = evaluateProperties(serializedLayer.paint, styleLayer.paint, feature, featureState, availableImages);
	        serializedLayer.layout = evaluateProperties(serializedLayer.layout, styleLayer.layout, feature, featureState, availableImages);
	        var intersectionZ = !intersectionTest || intersectionTest(feature, styleLayer, featureState);
	        if (!intersectionZ) {
	            continue;
	        }
	        var geojsonFeature = new Feature(feature, this.z, this.x, this.y, id);
	        geojsonFeature.layer = serializedLayer;
	        var layerResult = result[layerID];
	        if (layerResult === undefined) {
	            layerResult = result[layerID] = [];
	        }
	        layerResult.push({
	            featureIndex: featureIndex,
	            feature: geojsonFeature,
	            intersectionZ: intersectionZ
	        });
	    }
	};
	FeatureIndex.prototype.lookupSymbolFeatures = function lookupSymbolFeatures(symbolFeatureIndexes, serializedLayers, bucketIndex, sourceLayerIndex, filterSpec, filterLayerIDs, availableImages, styleLayers) {
	    var result = {};
	    this.loadVTLayers();
	    var filter = createFilter(filterSpec);
	    for (var i = 0, list = symbolFeatureIndexes; i < list.length; i += 1) {
	        var symbolFeatureIndex = list[i];
	        this.loadMatchingFeature(result, bucketIndex, sourceLayerIndex, symbolFeatureIndex, filter, filterLayerIDs, availableImages, styleLayers, serializedLayers);
	    }
	    return result;
	};
	FeatureIndex.prototype.hasLayer = function hasLayer(id) {
	    for (var i$1 = 0, list$1 = this.bucketLayerIDs; i$1 < list$1.length; i$1 += 1) {
	        var layerIDs = list$1[i$1];
	        for (var i = 0, list = layerIDs; i < list.length; i += 1) {
	            var layerID = list[i];
	            if (id === layerID) {
	                return true;
	            }
	        }
	    }
	    return false;
	};
	FeatureIndex.prototype.getId = function getId(feature, sourceLayerId) {
	    var id = feature.id;
	    if (this.promoteId) {
	        var propName = typeof this.promoteId === 'string' ? this.promoteId : this.promoteId[sourceLayerId];
	        id = feature.properties[propName];
	        if (typeof id === 'boolean') {
	            id = Number(id);
	        }
	    }
	    return id;
	};
	register('FeatureIndex', FeatureIndex, {
	    omit: [
	        'rawTileData',
	        'sourceLayerCoder'
	    ]
	});
	function evaluateProperties(serializedProperties, styleLayerProperties, feature, featureState, availableImages) {
	    return mapObject(serializedProperties, function (property, key) {
	        var prop = styleLayerProperties instanceof PossiblyEvaluated ? styleLayerProperties.get(key) : null;
	        return prop && prop.evaluate ? prop.evaluate(feature, featureState, availableImages) : prop;
	    });
	}
	function getBounds(geometry) {
	    var minX = Infinity;
	    var minY = Infinity;
	    var maxX = -Infinity;
	    var maxY = -Infinity;
	    for (var i = 0, list = geometry; i < list.length; i += 1) {
	        var p = list[i];
	        minX = Math.min(minX, p.x);
	        minY = Math.min(minY, p.y);
	        maxX = Math.max(maxX, p.x);
	        maxY = Math.max(maxY, p.y);
	    }
	    return {
	        minX: minX,
	        minY: minY,
	        maxX: maxX,
	        maxY: maxY
	    };
	}
	function topDownFeatureComparator(a, b) {
	    return b - a;
	}

	var CLOCK_SKEW_RETRY_TIMEOUT = 30000;
	var Tile = function Tile(tileID, size) {
	    this.tileID = tileID;
	    this.uid = uniqueId();
	    this.uses = 0;
	    this.tileSize = size;
	    this.buckets = {};
	    this.expirationTime = null;
	    this.queryPadding = 0;
	    this.hasSymbolBuckets = false;
	    this.hasRTLText = false;
	    this.dependencies = {};
	    this.expiredRequestCount = 0;
	    this.state = 'loading';
	};
	Tile.prototype.registerFadeDuration = function registerFadeDuration(duration) {
	    var fadeEndTime = duration + this.timeAdded;
	    if (fadeEndTime < exported.now()) {
	        return;
	    }
	    if (this.fadeEndTime && fadeEndTime < this.fadeEndTime) {
	        return;
	    }
	    this.fadeEndTime = fadeEndTime;
	};
	Tile.prototype.wasRequested = function wasRequested() {
	    return this.state === 'errored' || this.state === 'loaded' || this.state === 'reloading';
	};
	Tile.prototype.loadVectorData = function loadVectorData(data, painter, justReloaded) {
	    if (this.hasData()) {
	        this.unloadVectorData();
	    }
	    this.state = 'loaded';
	    if (!data) {
	        this.collisionBoxArray = new CollisionBoxArray();
	        return;
	    }
	    if (data.featureIndex) {
	        this.latestFeatureIndex = data.featureIndex;
	        if (data.rawTileData) {
	            this.latestRawTileData = data.rawTileData;
	            this.latestFeatureIndex.rawTileData = data.rawTileData;
	        } else if (this.latestRawTileData) {
	            this.latestFeatureIndex.rawTileData = this.latestRawTileData;
	        }
	    }
	    this.collisionBoxArray = data.collisionBoxArray;
	    this.buckets = deserialize$1(data.buckets, painter.style);
	    this.hasSymbolBuckets = false;
	    for (var id in this.buckets) {
	        var bucket = this.buckets[id];
	        if (bucket instanceof SymbolBucket) {
	            this.hasSymbolBuckets = true;
	            if (justReloaded) {
	                bucket.justReloaded = true;
	            } else {
	                break;
	            }
	        }
	    }
	    this.hasRTLText = false;
	    if (this.hasSymbolBuckets) {
	        for (var id$1 in this.buckets) {
	            var bucket$1 = this.buckets[id$1];
	            if (bucket$1 instanceof SymbolBucket) {
	                if (bucket$1.hasRTLText) {
	                    this.hasRTLText = true;
	                    lazyLoadRTLTextPlugin();
	                    break;
	                }
	            }
	        }
	    }
	    this.queryPadding = 0;
	    for (var id$2 in this.buckets) {
	        var bucket$2 = this.buckets[id$2];
	        this.queryPadding = Math.max(this.queryPadding, painter.style.getLayer(id$2).queryRadius(bucket$2));
	    }
	    if (data.imageAtlas) {
	        this.imageAtlas = data.imageAtlas;
	    }
	    if (data.glyphAtlasImage) {
	        this.glyphAtlasImage = data.glyphAtlasImage;
	    }
	};
	Tile.prototype.unloadVectorData = function unloadVectorData() {
	    for (var id in this.buckets) {
	        this.buckets[id].destroy();
	    }
	    this.buckets = {};
	    if (this.imageAtlasTexture) {
	        this.imageAtlasTexture.destroy();
	    }
	    if (this.imageAtlas) {
	        this.imageAtlas = null;
	    }
	    if (this.glyphAtlasTexture) {
	        this.glyphAtlasTexture.destroy();
	    }
	    this.latestFeatureIndex = null;
	    this.state = 'unloaded';
	};
	Tile.prototype.getBucket = function getBucket(layer) {
	    return this.buckets[layer.id];
	};
	Tile.prototype.upload = function upload(context) {
	    for (var id in this.buckets) {
	        var bucket = this.buckets[id];
	        if (bucket.uploadPending()) {
	            bucket.upload(context);
	        }
	    }
	    var gl = context.gl;
	    if (this.imageAtlas && !this.imageAtlas.uploaded) {
	        this.imageAtlasTexture = new Texture(context, this.imageAtlas.image, gl.RGBA);
	        this.imageAtlas.uploaded = true;
	    }
	    if (this.glyphAtlasImage) {
	        this.glyphAtlasTexture = new Texture(context, this.glyphAtlasImage, gl.ALPHA);
	        this.glyphAtlasImage = null;
	    }
	};
	Tile.prototype.prepare = function prepare(imageManager) {
	    if (this.imageAtlas) {
	        this.imageAtlas.patchUpdatedImages(imageManager, this.imageAtlasTexture);
	    }
	};
	Tile.prototype.queryRenderedFeatures = function queryRenderedFeatures(layers, serializedLayers, sourceFeatureState, queryGeometry, cameraQueryGeometry, scale, params, transform, maxPitchScaleFactor, pixelPosMatrix) {
	    if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) {
	        return {};
	    }
	    return this.latestFeatureIndex.query({
	        queryGeometry: queryGeometry,
	        cameraQueryGeometry: cameraQueryGeometry,
	        scale: scale,
	        tileSize: this.tileSize,
	        pixelPosMatrix: pixelPosMatrix,
	        transform: transform,
	        params: params,
	        queryPadding: this.queryPadding * maxPitchScaleFactor
	    }, layers, serializedLayers, sourceFeatureState);
	};
	Tile.prototype.querySourceFeatures = function querySourceFeatures(result, params) {
	    var featureIndex = this.latestFeatureIndex;
	    if (!featureIndex || !featureIndex.rawTileData) {
	        return;
	    }
	    var vtLayers = featureIndex.loadVTLayers();
	    var sourceLayer = params ? params.sourceLayer : '';
	    var layer = vtLayers._geojsonTileLayer || vtLayers[sourceLayer];
	    if (!layer) {
	        return;
	    }
	    var filter = createFilter(params && params.filter);
	    var ref = this.tileID.canonical;
	    var z = ref.z;
	    var x = ref.x;
	    var y = ref.y;
	    var coord = {
	        z: z,
	        x: x,
	        y: y
	    };
	    for (var i = 0; i < layer.length; i++) {
	        var feature = layer.feature(i);
	        if (filter.needGeometry) {
	            var evaluationFeature = toEvaluationFeature(feature, true);
	            if (!filter.filter(new EvaluationParameters(this.tileID.overscaledZ), evaluationFeature, this.tileID.canonical)) {
	                continue;
	            }
	        } else if (!filter.filter(new EvaluationParameters(this.tileID.overscaledZ), feature)) {
	            continue;
	        }
	        var id = featureIndex.getId(feature, sourceLayer);
	        var geojsonFeature = new Feature(feature, z, x, y, id);
	        geojsonFeature.tile = coord;
	        result.push(geojsonFeature);
	    }
	};
	Tile.prototype.hasData = function hasData() {
	    return this.state === 'loaded' || this.state === 'reloading' || this.state === 'expired';
	};
	Tile.prototype.patternsLoaded = function patternsLoaded() {
	    return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
	};
	Tile.prototype.setExpiryData = function setExpiryData(data) {
	    var prior = this.expirationTime;
	    if (data.cacheControl) {
	        var parsedCC = parseCacheControl(data.cacheControl);
	        if (parsedCC['max-age']) {
	            this.expirationTime = Date.now() + parsedCC['max-age'] * 1000;
	        }
	    } else if (data.expires) {
	        this.expirationTime = new Date(data.expires).getTime();
	    }
	    if (this.expirationTime) {
	        var now = Date.now();
	        var isExpired = false;
	        if (this.expirationTime > now) {
	            isExpired = false;
	        } else if (!prior) {
	            isExpired = true;
	        } else if (this.expirationTime < prior) {
	            isExpired = true;
	        } else {
	            var delta = this.expirationTime - prior;
	            if (!delta) {
	                isExpired = true;
	            } else {
	                this.expirationTime = now + Math.max(delta, CLOCK_SKEW_RETRY_TIMEOUT);
	            }
	        }
	        if (isExpired) {
	            this.expiredRequestCount++;
	            this.state = 'expired';
	        } else {
	            this.expiredRequestCount = 0;
	        }
	    }
	};
	Tile.prototype.getExpiryTimeout = function getExpiryTimeout() {
	    if (this.expirationTime) {
	        if (this.expiredRequestCount) {
	            return 1000 * (1 << Math.min(this.expiredRequestCount - 1, 31));
	        } else {
	            return Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
	        }
	    }
	};
	Tile.prototype.setFeatureState = function setFeatureState(states, painter) {
	    if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(states).length === 0) {
	        return;
	    }
	    var vtLayers = this.latestFeatureIndex.loadVTLayers();
	    for (var id in this.buckets) {
	        if (!painter.style.hasLayer(id)) {
	            continue;
	        }
	        var bucket = this.buckets[id];
	        var sourceLayerId = bucket.layers[0]['sourceLayer'] || '_geojsonTileLayer';
	        var sourceLayer = vtLayers[sourceLayerId];
	        var sourceLayerStates = states[sourceLayerId];
	        if (!sourceLayer || !sourceLayerStates || Object.keys(sourceLayerStates).length === 0) {
	            continue;
	        }
	        bucket.update(sourceLayerStates, sourceLayer, this.imageAtlas && this.imageAtlas.patternPositions || {});
	        var layer = painter && painter.style && painter.style.getLayer(id);
	        if (layer) {
	            this.queryPadding = Math.max(this.queryPadding, layer.queryRadius(bucket));
	        }
	    }
	};
	Tile.prototype.holdingForFade = function holdingForFade() {
	    return this.symbolFadeHoldUntil !== undefined;
	};
	Tile.prototype.symbolFadeFinished = function symbolFadeFinished() {
	    return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < exported.now();
	};
	Tile.prototype.clearFadeHold = function clearFadeHold() {
	    this.symbolFadeHoldUntil = undefined;
	};
	Tile.prototype.setHoldDuration = function setHoldDuration(duration) {
	    this.symbolFadeHoldUntil = exported.now() + duration;
	};
	Tile.prototype.setDependencies = function setDependencies(namespace, dependencies) {
	    var index = {};
	    for (var i = 0, list = dependencies; i < list.length; i += 1) {
	        var dep = list[i];
	        index[dep] = true;
	    }
	    this.dependencies[namespace] = index;
	};
	Tile.prototype.hasDependency = function hasDependency(namespaces, keys) {
	    for (var i$1 = 0, list$1 = namespaces; i$1 < list$1.length; i$1 += 1) {
	        var namespace = list$1[i$1];
	        var dependencies = this.dependencies[namespace];
	        if (dependencies) {
	            for (var i = 0, list = keys; i < list.length; i += 1) {
	                var key = list[i];
	                if (dependencies[key]) {
	                    return true;
	                }
	            }
	        }
	    }
	    return false;
	};

	var refProperties = [
	    'type',
	    'source',
	    'source-layer',
	    'minzoom',
	    'maxzoom',
	    'filter',
	    'layout'
	];

	var performance = window$1.performance;
	var RequestPerformance = function RequestPerformance(request) {
	    this._marks = {
	        start: [
	            request.url,
	            'start'
	        ].join('#'),
	        end: [
	            request.url,
	            'end'
	        ].join('#'),
	        measure: request.url.toString()
	    };
	    performance.mark(this._marks.start);
	};
	RequestPerformance.prototype.finish = function finish() {
	    performance.mark(this._marks.end);
	    var resourceTimingData = performance.getEntriesByName(this._marks.measure);
	    if (resourceTimingData.length === 0) {
	        performance.measure(this._marks.measure, this._marks.start, this._marks.end);
	        resourceTimingData = performance.getEntriesByName(this._marks.measure);
	        performance.clearMarks(this._marks.start);
	        performance.clearMarks(this._marks.end);
	        performance.clearMeasures(this._marks.measure);
	    }
	    return resourceTimingData;
	};

	exports.Actor = Actor;
	exports.AlphaImage = AlphaImage;
	exports.CanonicalTileID = CanonicalTileID;
	exports.CollisionBoxArray = CollisionBoxArray;
	exports.Color = Color;
	exports.DEMData = DEMData;
	exports.DataConstantProperty = DataConstantProperty;
	exports.DictionaryCoder = DictionaryCoder;
	exports.EXTENT = EXTENT$1;
	exports.ErrorEvent = ErrorEvent;
	exports.EvaluationParameters = EvaluationParameters;
	exports.Event = Event;
	exports.Evented = Evented;
	exports.FeatureIndex = FeatureIndex;
	exports.FillBucket = FillBucket;
	exports.FillExtrusionBucket = FillExtrusionBucket;
	exports.ImageAtlas = ImageAtlas;
	exports.ImagePosition = ImagePosition;
	exports.LineBucket = LineBucket;
	exports.LngLat = LngLat;
	exports.LngLatBounds = LngLatBounds;
	exports.MercatorCoordinate = MercatorCoordinate;
	exports.ONE_EM = ONE_EM;
	exports.OverscaledTileID = OverscaledTileID;
	exports.Point = pointGeometry;
	exports.Point$1 = pointGeometry;
	exports.Properties = Properties;
	exports.Protobuf = pbf;
	exports.RGBAImage = RGBAImage;
	exports.RequestManager = RequestManager;
	exports.RequestPerformance = RequestPerformance;
	exports.ResourceType = ResourceType;
	exports.SegmentVector = SegmentVector;
	exports.SourceFeatureState = SourceFeatureState;
	exports.StructArrayLayout1ui2 = StructArrayLayout1ui2;
	exports.StructArrayLayout2f1f2i16 = StructArrayLayout2f1f2i16;
	exports.StructArrayLayout2i4 = StructArrayLayout2i4;
	exports.StructArrayLayout3ui6 = StructArrayLayout3ui6;
	exports.StructArrayLayout4i8 = StructArrayLayout4i8;
	exports.SymbolBucket = SymbolBucket;
	exports.Texture = Texture;
	exports.Tile = Tile;
	exports.Transitionable = Transitionable;
	exports.Uniform1f = Uniform1f;
	exports.Uniform1i = Uniform1i;
	exports.Uniform2f = Uniform2f;
	exports.Uniform3f = Uniform3f;
	exports.Uniform4f = Uniform4f;
	exports.UniformColor = UniformColor;
	exports.UniformMatrix4f = UniformMatrix4f;
	exports.UnwrappedTileID = UnwrappedTileID;
	exports.ValidationError = ValidationError;
	exports.WritingMode = WritingMode;
	exports.ZoomHistory = ZoomHistory;
	exports.add = add;
	exports.addDynamicAttributes = addDynamicAttributes;
	exports.asyncAll = asyncAll;
	exports.bezier = bezier;
	exports.bindAll = bindAll;
	exports.browser = exported;
	exports.cacheEntryPossiblyAdded = cacheEntryPossiblyAdded;
	exports.clamp = clamp;
	exports.clearTileCache = clearTileCache;
	exports.clipLine = clipLine;
	exports.clone = clone$1;
	exports.clone$1 = clone;
	exports.clone$2 = clone$2;
	exports.collisionCircleLayout = collisionCircleLayout;
	exports.config = config;
	exports.create = create$2;
	exports.create$1 = create$1;
	exports.create$2 = create;
	exports.createCommonjsModule = createCommonjsModule;
	exports.createExpression = createExpression;
	exports.createLayout = createLayout;
	exports.createStyleLayer = createStyleLayer;
	exports.cross = cross;
	exports.deepEqual = deepEqual;
	exports.dot = dot;
	exports.dot$1 = dot$1;
	exports.ease = ease;
	exports.emitValidationErrors = emitValidationErrors;
	exports.endsWith = endsWith;
	exports.enforceCacheSizeLimit = enforceCacheSizeLimit;
	exports.evaluateSizeForFeature = evaluateSizeForFeature;
	exports.evaluateSizeForZoom = evaluateSizeForZoom;
	exports.evaluateVariableOffset = evaluateVariableOffset;
	exports.evented = evented;
	exports.extend = extend;
	exports.featureFilter = createFilter;
	exports.filterObject = filterObject;
	exports.fromRotation = fromRotation;
	exports.getAnchorAlignment = getAnchorAlignment;
	exports.getAnchorJustification = getAnchorJustification;
	exports.getArrayBuffer = getArrayBuffer;
	exports.getImage = getImage;
	exports.getJSON = getJSON;
	exports.getRTLTextPluginStatus = getRTLTextPluginStatus;
	exports.getReferrer = getReferrer;
	exports.getVideo = getVideo;
	exports.identity = identity;
	exports.invert = invert;
	exports.isChar = unicodeBlockLookup;
	exports.isMapboxURL = isMapboxURL;
	exports.keysDifference = keysDifference;
	exports.makeRequest = makeRequest;
	exports.mapObject = mapObject;
	exports.mercatorXfromLng = mercatorXfromLng$1;
	exports.mercatorYfromLat = mercatorYfromLat$1;
	exports.mercatorZfromAltitude = mercatorZfromAltitude;
	exports.mul = mul;
	exports.multiply = multiply;
	exports.mvt = vectorTile;
	exports.nextPowerOfTwo = nextPowerOfTwo;
	exports.normalize = normalize;
	exports.number = number;
	exports.offscreenCanvasSupported = offscreenCanvasSupported;
	exports.ortho = ortho;
	exports.parseGlyphPBF = parseGlyphPBF;
	exports.pbf = pbf;
	exports.performSymbolLayout = performSymbolLayout;
	exports.perspective = perspective;
	exports.pick = pick;
	exports.plugin = plugin;
	exports.polygonIntersectsPolygon = polygonIntersectsPolygon;
	exports.postMapLoadEvent = postMapLoadEvent;
	exports.postTurnstileEvent = postTurnstileEvent;
	exports.potpack = potpack;
	exports.refProperties = refProperties;
	exports.register = register;
	exports.registerForPluginStateChange = registerForPluginStateChange;
	exports.renderColorRamp = renderColorRamp;
	exports.rotate = rotate;
	exports.rotateX = rotateX;
	exports.rotateZ = rotateZ;
	exports.scale = scale;
	exports.scale$1 = scale$2;
	exports.scale$2 = scale$1;
	exports.setCacheLimits = setCacheLimits;
	exports.setRTLTextPlugin = setRTLTextPlugin;
	exports.sphericalToCartesian = sphericalToCartesian;
	exports.sqrLen = sqrLen;
	exports.styleSpec = spec;
	exports.sub = sub;
	exports.symbolSize = symbolSize;
	exports.transformMat3 = transformMat3;
	exports.transformMat4 = transformMat4;
	exports.translate = translate$1;
	exports.triggerPluginCompletionEvent = triggerPluginCompletionEvent;
	exports.uniqueId = uniqueId;
	exports.validateCustomStyleLayer = validateCustomStyleLayer;
	exports.validateLight = validateLight$1;
	exports.validateStyle = validateStyle;
	exports.values = values;
	exports.vectorTile = vectorTile;
	exports.version = version;
	exports.warnOnce = warnOnce;
	exports.webpSupported = exported$1;
	exports.window = window$1;
	exports.wrap = wrap;

	});

	define(['./shared'], function (performance) {
	function stringify(obj) {
	    var type = typeof obj;
	    if (type === 'number' || type === 'boolean' || type === 'string' || obj === undefined || obj === null) {
	        return JSON.stringify(obj);
	    }
	    if (Array.isArray(obj)) {
	        var str$1 = '[';
	        for (var i$1 = 0, list = obj; i$1 < list.length; i$1 += 1) {
	            var val = list[i$1];
	            str$1 += stringify(val) + ',';
	        }
	        return str$1 + ']';
	    }
	    var keys = Object.keys(obj).sort();
	    var str = '{';
	    for (var i = 0; i < keys.length; i++) {
	        str += JSON.stringify(keys[i]) + ':' + stringify(obj[keys[i]]) + ',';
	    }
	    return str + '}';
	}
	function getKey(layer) {
	    var key = '';
	    for (var i = 0, list = performance.refProperties; i < list.length; i += 1) {
	        var k = list[i];
	        key += '/' + stringify(layer[k]);
	    }
	    return key;
	}
	function groupByLayout(layers, cachedKeys) {
	    var groups = {};
	    for (var i = 0; i < layers.length; i++) {
	        var k = cachedKeys && cachedKeys[layers[i].id] || getKey(layers[i]);
	        if (cachedKeys) {
	            cachedKeys[layers[i].id] = k;
	        }
	        var group = groups[k];
	        if (!group) {
	            group = groups[k] = [];
	        }
	        group.push(layers[i]);
	    }
	    var result = [];
	    for (var k$1 in groups) {
	        result.push(groups[k$1]);
	    }
	    return result;
	}

	var StyleLayerIndex = function StyleLayerIndex(layerConfigs) {
	    this.keyCache = {};
	    if (layerConfigs) {
	        this.replace(layerConfigs);
	    }
	};
	StyleLayerIndex.prototype.replace = function replace(layerConfigs) {
	    this._layerConfigs = {};
	    this._layers = {};
	    this.update(layerConfigs, []);
	};
	StyleLayerIndex.prototype.update = function update(layerConfigs, removedIds) {
	    var this$1 = this;
	    for (var i = 0, list = layerConfigs; i < list.length; i += 1) {
	        var layerConfig = list[i];
	        this._layerConfigs[layerConfig.id] = layerConfig;
	        var layer = this._layers[layerConfig.id] = performance.createStyleLayer(layerConfig);
	        layer._featureFilter = performance.featureFilter(layer.filter);
	        if (this.keyCache[layerConfig.id]) {
	            delete this.keyCache[layerConfig.id];
	        }
	    }
	    for (var i$1 = 0, list$1 = removedIds; i$1 < list$1.length; i$1 += 1) {
	        var id = list$1[i$1];
	        delete this.keyCache[id];
	        delete this._layerConfigs[id];
	        delete this._layers[id];
	    }
	    this.familiesBySource = {};
	    var groups = groupByLayout(performance.values(this._layerConfigs), this.keyCache);
	    for (var i$2 = 0, list$2 = groups; i$2 < list$2.length; i$2 += 1) {
	        var layerConfigs$1 = list$2[i$2];
	        var layers = layerConfigs$1.map(function (layerConfig) {
	            return this$1._layers[layerConfig.id];
	        });
	        var layer$1 = layers[0];
	        if (layer$1.visibility === 'none') {
	            continue;
	        }
	        var sourceId = layer$1.source || '';
	        var sourceGroup = this.familiesBySource[sourceId];
	        if (!sourceGroup) {
	            sourceGroup = this.familiesBySource[sourceId] = {};
	        }
	        var sourceLayerId = layer$1.sourceLayer || '_geojsonTileLayer';
	        var sourceLayerFamilies = sourceGroup[sourceLayerId];
	        if (!sourceLayerFamilies) {
	            sourceLayerFamilies = sourceGroup[sourceLayerId] = [];
	        }
	        sourceLayerFamilies.push(layers);
	    }
	};

	var padding = 1;
	var GlyphAtlas = function GlyphAtlas(stacks) {
	    var positions = {};
	    var bins = [];
	    for (var stack in stacks) {
	        var glyphs = stacks[stack];
	        var stackPositions = positions[stack] = {};
	        for (var id in glyphs) {
	            var src = glyphs[+id];
	            if (!src || src.bitmap.width === 0 || src.bitmap.height === 0) {
	                continue;
	            }
	            var bin = {
	                x: 0,
	                y: 0,
	                w: src.bitmap.width + 2 * padding,
	                h: src.bitmap.height + 2 * padding
	            };
	            bins.push(bin);
	            stackPositions[id] = {
	                rect: bin,
	                metrics: src.metrics
	            };
	        }
	    }
	    var ref = performance.potpack(bins);
	    var w = ref.w;
	    var h = ref.h;
	    var image = new performance.AlphaImage({
	        width: w || 1,
	        height: h || 1
	    });
	    for (var stack$1 in stacks) {
	        var glyphs$1 = stacks[stack$1];
	        for (var id$1 in glyphs$1) {
	            var src$1 = glyphs$1[+id$1];
	            if (!src$1 || src$1.bitmap.width === 0 || src$1.bitmap.height === 0) {
	                continue;
	            }
	            var bin$1 = positions[stack$1][id$1].rect;
	            performance.AlphaImage.copy(src$1.bitmap, image, {
	                x: 0,
	                y: 0
	            }, {
	                x: bin$1.x + padding,
	                y: bin$1.y + padding
	            }, src$1.bitmap);
	        }
	    }
	    this.image = image;
	    this.positions = positions;
	};
	performance.register('GlyphAtlas', GlyphAtlas);

	var WorkerTile = function WorkerTile(params) {
	    this.tileID = new performance.OverscaledTileID(params.tileID.overscaledZ, params.tileID.wrap, params.tileID.canonical.z, params.tileID.canonical.x, params.tileID.canonical.y);
	    this.uid = params.uid;
	    this.zoom = params.zoom;
	    this.pixelRatio = params.pixelRatio;
	    this.tileSize = params.tileSize;
	    this.source = params.source;
	    this.overscaling = this.tileID.overscaleFactor();
	    this.showCollisionBoxes = params.showCollisionBoxes;
	    this.collectResourceTiming = !!params.collectResourceTiming;
	    this.returnDependencies = !!params.returnDependencies;
	    this.promoteId = params.promoteId;
	};
	WorkerTile.prototype.parse = function parse(data, layerIndex, availableImages, actor, callback) {
	    var this$1 = this;
	    this.status = 'parsing';
	    this.data = data;
	    this.collisionBoxArray = new performance.CollisionBoxArray();
	    var sourceLayerCoder = new performance.DictionaryCoder(Object.keys(data.layers).sort());
	    var featureIndex = new performance.FeatureIndex(this.tileID, this.promoteId);
	    featureIndex.bucketLayerIDs = [];
	    var buckets = {};
	    var options = {
	        featureIndex: featureIndex,
	        iconDependencies: {},
	        patternDependencies: {},
	        glyphDependencies: {},
	        availableImages: availableImages
	    };
	    var layerFamilies = layerIndex.familiesBySource[this.source];
	    for (var sourceLayerId in layerFamilies) {
	        var sourceLayer = data.layers[sourceLayerId];
	        if (!sourceLayer) {
	            continue;
	        }
	        if (sourceLayer.version === 1) {
	            performance.warnOnce('Vector tile source "' + this.source + '" layer "' + sourceLayerId + '" ' + 'does not use vector tile spec v2 and therefore may have some rendering errors.');
	        }
	        var sourceLayerIndex = sourceLayerCoder.encode(sourceLayerId);
	        var features = [];
	        for (var index = 0; index < sourceLayer.length; index++) {
	            var feature = sourceLayer.feature(index);
	            var id = featureIndex.getId(feature, sourceLayerId);
	            features.push({
	                feature: feature,
	                id: id,
	                index: index,
	                sourceLayerIndex: sourceLayerIndex
	            });
	        }
	        for (var i = 0, list = layerFamilies[sourceLayerId]; i < list.length; i += 1) {
	            var family = list[i];
	            var layer = family[0];
	            if (layer.minzoom && this.zoom < Math.floor(layer.minzoom)) {
	                continue;
	            }
	            if (layer.maxzoom && this.zoom >= layer.maxzoom) {
	                continue;
	            }
	            if (layer.visibility === 'none') {
	                continue;
	            }
	            recalculateLayers(family, this.zoom, availableImages);
	            var bucket = buckets[layer.id] = layer.createBucket({
	                index: featureIndex.bucketLayerIDs.length,
	                layers: family,
	                zoom: this.zoom,
	                pixelRatio: this.pixelRatio,
	                overscaling: this.overscaling,
	                collisionBoxArray: this.collisionBoxArray,
	                sourceLayerIndex: sourceLayerIndex,
	                sourceID: this.source
	            });
	            bucket.populate(features, options, this.tileID.canonical);
	            featureIndex.bucketLayerIDs.push(family.map(function (l) {
	                return l.id;
	            }));
	        }
	    }
	    var error;
	    var glyphMap;
	    var iconMap;
	    var patternMap;
	    var stacks = performance.mapObject(options.glyphDependencies, function (glyphs) {
	        return Object.keys(glyphs).map(Number);
	    });
	    if (Object.keys(stacks).length) {
	        actor.send('getGlyphs', {
	            uid: this.uid,
	            stacks: stacks
	        }, function (err, result) {
	            if (!error) {
	                error = err;
	                glyphMap = result;
	                maybePrepare.call(this$1);
	            }
	        });
	    } else {
	        glyphMap = {};
	    }
	    var icons = Object.keys(options.iconDependencies);
	    if (icons.length) {
	        actor.send('getImages', {
	            icons: icons,
	            source: this.source,
	            tileID: this.tileID,
	            type: 'icons'
	        }, function (err, result) {
	            if (!error) {
	                error = err;
	                iconMap = result;
	                maybePrepare.call(this$1);
	            }
	        });
	    } else {
	        iconMap = {};
	    }
	    var patterns = Object.keys(options.patternDependencies);
	    if (patterns.length) {
	        actor.send('getImages', {
	            icons: patterns,
	            source: this.source,
	            tileID: this.tileID,
	            type: 'patterns'
	        }, function (err, result) {
	            if (!error) {
	                error = err;
	                patternMap = result;
	                maybePrepare.call(this$1);
	            }
	        });
	    } else {
	        patternMap = {};
	    }
	    maybePrepare.call(this);
	    function maybePrepare() {
	        if (error) {
	            return callback(error);
	        } else if (glyphMap && iconMap && patternMap) {
	            var glyphAtlas = new GlyphAtlas(glyphMap);
	            var imageAtlas = new performance.ImageAtlas(iconMap, patternMap);
	            for (var key in buckets) {
	                var bucket = buckets[key];
	                if (bucket instanceof performance.SymbolBucket) {
	                    recalculateLayers(bucket.layers, this.zoom, availableImages);
	                    performance.performSymbolLayout(bucket, glyphMap, glyphAtlas.positions, iconMap, imageAtlas.iconPositions, this.showCollisionBoxes, this.tileID.canonical);
	                } else if (bucket.hasPattern && (bucket instanceof performance.LineBucket || bucket instanceof performance.FillBucket || bucket instanceof performance.FillExtrusionBucket)) {
	                    recalculateLayers(bucket.layers, this.zoom, availableImages);
	                    bucket.addFeatures(options, this.tileID.canonical, imageAtlas.patternPositions);
	                }
	            }
	            this.status = 'done';
	            callback(null, {
	                buckets: performance.values(buckets).filter(function (b) {
	                    return !b.isEmpty();
	                }),
	                featureIndex: featureIndex,
	                collisionBoxArray: this.collisionBoxArray,
	                glyphAtlasImage: glyphAtlas.image,
	                imageAtlas: imageAtlas,
	                glyphMap: this.returnDependencies ? glyphMap : null,
	                iconMap: this.returnDependencies ? iconMap : null,
	                glyphPositions: this.returnDependencies ? glyphAtlas.positions : null
	            });
	        }
	    }
	};
	function recalculateLayers(layers, zoom, availableImages) {
	    var parameters = new performance.EvaluationParameters(zoom);
	    for (var i = 0, list = layers; i < list.length; i += 1) {
	        var layer = list[i];
	        layer.recalculate(parameters, availableImages);
	    }
	}

	function loadVectorTile(params, callback) {
	    var request = performance.getArrayBuffer(params.request, function (err, data, cacheControl, expires) {
	        if (err) {
	            callback(err);
	        } else if (data) {
	            callback(null, {
	                vectorTile: new performance.vectorTile.VectorTile(new performance.pbf(data)),
	                rawData: data,
	                cacheControl: cacheControl,
	                expires: expires
	            });
	        }
	    });
	    return function () {
	        request.cancel();
	        callback();
	    };
	}
	var VectorTileWorkerSource = function VectorTileWorkerSource(actor, layerIndex, availableImages, loadVectorData) {
	    this.actor = actor;
	    this.layerIndex = layerIndex;
	    this.availableImages = availableImages;
	    this.loadVectorData = loadVectorData || loadVectorTile;
	    this.loading = {};
	    this.loaded = {};
	};
	VectorTileWorkerSource.prototype.loadTile = function loadTile(params, callback) {
	    var this$1 = this;
	    var uid = params.uid;
	    if (!this.loading) {
	        this.loading = {};
	    }
	    var perf = params && params.request && params.request.collectResourceTiming ? new performance.RequestPerformance(params.request) : false;
	    var workerTile = this.loading[uid] = new WorkerTile(params);
	    workerTile.abort = this.loadVectorData(params, function (err, response) {
	        delete this$1.loading[uid];
	        if (err || !response) {
	            workerTile.status = 'done';
	            this$1.loaded[uid] = workerTile;
	            return callback(err);
	        }
	        var rawTileData = response.rawData;
	        var cacheControl = {};
	        if (response.expires) {
	            cacheControl.expires = response.expires;
	        }
	        if (response.cacheControl) {
	            cacheControl.cacheControl = response.cacheControl;
	        }
	        var resourceTiming = {};
	        if (perf) {
	            var resourceTimingData = perf.finish();
	            if (resourceTimingData) {
	                resourceTiming.resourceTiming = JSON.parse(JSON.stringify(resourceTimingData));
	            }
	        }
	        workerTile.vectorTile = response.vectorTile;
	        workerTile.parse(response.vectorTile, this$1.layerIndex, this$1.availableImages, this$1.actor, function (err, result) {
	            if (err || !result) {
	                return callback(err);
	            }
	            callback(null, performance.extend({ rawTileData: rawTileData.slice(0) }, result, cacheControl, resourceTiming));
	        });
	        this$1.loaded = this$1.loaded || {};
	        this$1.loaded[uid] = workerTile;
	    });
	};
	VectorTileWorkerSource.prototype.reloadTile = function reloadTile(params, callback) {
	    var this$1 = this;
	    var loaded = this.loaded, uid = params.uid, vtSource = this;
	    if (loaded && loaded[uid]) {
	        var workerTile = loaded[uid];
	        workerTile.showCollisionBoxes = params.showCollisionBoxes;
	        var done = function (err, data) {
	            var reloadCallback = workerTile.reloadCallback;
	            if (reloadCallback) {
	                delete workerTile.reloadCallback;
	                workerTile.parse(workerTile.vectorTile, vtSource.layerIndex, this$1.availableImages, vtSource.actor, reloadCallback);
	            }
	            callback(err, data);
	        };
	        if (workerTile.status === 'parsing') {
	            workerTile.reloadCallback = done;
	        } else if (workerTile.status === 'done') {
	            if (workerTile.vectorTile) {
	                workerTile.parse(workerTile.vectorTile, this.layerIndex, this.availableImages, this.actor, done);
	            } else {
	                done();
	            }
	        }
	    }
	};
	VectorTileWorkerSource.prototype.abortTile = function abortTile(params, callback) {
	    var loading = this.loading, uid = params.uid;
	    if (loading && loading[uid] && loading[uid].abort) {
	        loading[uid].abort();
	        delete loading[uid];
	    }
	    callback();
	};
	VectorTileWorkerSource.prototype.removeTile = function removeTile(params, callback) {
	    var loaded = this.loaded, uid = params.uid;
	    if (loaded && loaded[uid]) {
	        delete loaded[uid];
	    }
	    callback();
	};

	var ImageBitmap = performance.window.ImageBitmap;
	var RasterDEMTileWorkerSource = function RasterDEMTileWorkerSource() {
	    this.loaded = {};
	};
	RasterDEMTileWorkerSource.prototype.loadTile = function loadTile(params, callback) {
	    var uid = params.uid;
	    var encoding = params.encoding;
	    var rawImageData = params.rawImageData;
	    var imagePixels = ImageBitmap && rawImageData instanceof ImageBitmap ? this.getImageData(rawImageData) : rawImageData;
	    var dem = new performance.DEMData(uid, imagePixels, encoding);
	    this.loaded = this.loaded || {};
	    this.loaded[uid] = dem;
	    callback(null, dem);
	};
	RasterDEMTileWorkerSource.prototype.getImageData = function getImageData(imgBitmap) {
	    if (!this.offscreenCanvas || !this.offscreenCanvasContext) {
	        this.offscreenCanvas = new OffscreenCanvas(imgBitmap.width, imgBitmap.height);
	        this.offscreenCanvasContext = this.offscreenCanvas.getContext('2d');
	    }
	    this.offscreenCanvas.width = imgBitmap.width;
	    this.offscreenCanvas.height = imgBitmap.height;
	    this.offscreenCanvasContext.drawImage(imgBitmap, 0, 0, imgBitmap.width, imgBitmap.height);
	    var imgData = this.offscreenCanvasContext.getImageData(-1, -1, imgBitmap.width + 2, imgBitmap.height + 2);
	    this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
	    return new performance.RGBAImage({
	        width: imgData.width,
	        height: imgData.height
	    }, imgData.data);
	};
	RasterDEMTileWorkerSource.prototype.removeTile = function removeTile(params) {
	    var loaded = this.loaded, uid = params.uid;
	    if (loaded && loaded[uid]) {
	        delete loaded[uid];
	    }
	};

	var geojsonRewind = rewind;
	function rewind(gj, outer) {
	    var type = gj && gj.type, i;
	    if (type === 'FeatureCollection') {
	        for (i = 0; i < gj.features.length; i++) {
	            rewind(gj.features[i], outer);
	        }
	    } else if (type === 'GeometryCollection') {
	        for (i = 0; i < gj.geometries.length; i++) {
	            rewind(gj.geometries[i], outer);
	        }
	    } else if (type === 'Feature') {
	        rewind(gj.geometry, outer);
	    } else if (type === 'Polygon') {
	        rewindRings(gj.coordinates, outer);
	    } else if (type === 'MultiPolygon') {
	        for (i = 0; i < gj.coordinates.length; i++) {
	            rewindRings(gj.coordinates[i], outer);
	        }
	    }
	    return gj;
	}
	function rewindRings(rings, outer) {
	    if (rings.length === 0) {
	        return;
	    }
	    rewindRing(rings[0], outer);
	    for (var i = 1; i < rings.length; i++) {
	        rewindRing(rings[i], !outer);
	    }
	}
	function rewindRing(ring, dir) {
	    var area = 0, err = 0;
	    for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
	        var k = (ring[i][0] - ring[j][0]) * (ring[j][1] + ring[i][1]);
	        var m = area + k;
	        err += Math.abs(area) >= Math.abs(k) ? area - m + k : k - m + area;
	        area = m;
	    }
	    if (area + err >= 0 !== !!dir) {
	        ring.reverse();
	    }
	}

	var toGeoJSON = performance.vectorTile.VectorTileFeature.prototype.toGeoJSON;
	var FeatureWrapper = function FeatureWrapper(feature) {
	    this._feature = feature;
	    this.extent = performance.EXTENT;
	    this.type = feature.type;
	    this.properties = feature.tags;
	    if ('id' in feature && !isNaN(feature.id)) {
	        this.id = parseInt(feature.id, 10);
	    }
	};
	FeatureWrapper.prototype.loadGeometry = function loadGeometry() {
	    if (this._feature.type === 1) {
	        var geometry = [];
	        for (var i = 0, list = this._feature.geometry; i < list.length; i += 1) {
	            var point = list[i];
	            geometry.push([new performance.Point$1(point[0], point[1])]);
	        }
	        return geometry;
	    } else {
	        var geometry$1 = [];
	        for (var i$2 = 0, list$2 = this._feature.geometry; i$2 < list$2.length; i$2 += 1) {
	            var ring = list$2[i$2];
	            var newRing = [];
	            for (var i$1 = 0, list$1 = ring; i$1 < list$1.length; i$1 += 1) {
	                var point$1 = list$1[i$1];
	                newRing.push(new performance.Point$1(point$1[0], point$1[1]));
	            }
	            geometry$1.push(newRing);
	        }
	        return geometry$1;
	    }
	};
	FeatureWrapper.prototype.toGeoJSON = function toGeoJSON$1(x, y, z) {
	    return toGeoJSON.call(this, x, y, z);
	};
	var GeoJSONWrapper = function GeoJSONWrapper(features) {
	    this.layers = { '_geojsonTileLayer': this };
	    this.name = '_geojsonTileLayer';
	    this.extent = performance.EXTENT;
	    this.length = features.length;
	    this._features = features;
	};
	GeoJSONWrapper.prototype.feature = function feature(i) {
	    return new FeatureWrapper(this._features[i]);
	};

	var VectorTileFeature = performance.vectorTile.VectorTileFeature;
	var geojson_wrapper = GeoJSONWrapper$1;
	function GeoJSONWrapper$1(features, options) {
	    this.options = options || {};
	    this.features = features;
	    this.length = features.length;
	}
	GeoJSONWrapper$1.prototype.feature = function (i) {
	    return new FeatureWrapper$1(this.features[i], this.options.extent);
	};
	function FeatureWrapper$1(feature, extent) {
	    this.id = typeof feature.id === 'number' ? feature.id : undefined;
	    this.type = feature.type;
	    this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry;
	    this.properties = feature.tags;
	    this.extent = extent || 4096;
	}
	FeatureWrapper$1.prototype.loadGeometry = function () {
	    var rings = this.rawGeometry;
	    this.geometry = [];
	    for (var i = 0; i < rings.length; i++) {
	        var ring = rings[i];
	        var newRing = [];
	        for (var j = 0; j < ring.length; j++) {
	            newRing.push(new performance.Point$1(ring[j][0], ring[j][1]));
	        }
	        this.geometry.push(newRing);
	    }
	    return this.geometry;
	};
	FeatureWrapper$1.prototype.bbox = function () {
	    if (!this.geometry) {
	        this.loadGeometry();
	    }
	    var rings = this.geometry;
	    var x1 = Infinity;
	    var x2 = -Infinity;
	    var y1 = Infinity;
	    var y2 = -Infinity;
	    for (var i = 0; i < rings.length; i++) {
	        var ring = rings[i];
	        for (var j = 0; j < ring.length; j++) {
	            var coord = ring[j];
	            x1 = Math.min(x1, coord.x);
	            x2 = Math.max(x2, coord.x);
	            y1 = Math.min(y1, coord.y);
	            y2 = Math.max(y2, coord.y);
	        }
	    }
	    return [
	        x1,
	        y1,
	        x2,
	        y2
	    ];
	};
	FeatureWrapper$1.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON;

	var vtPbf = fromVectorTileJs;
	var fromVectorTileJs_1 = fromVectorTileJs;
	var fromGeojsonVt_1 = fromGeojsonVt;
	var GeoJSONWrapper_1 = geojson_wrapper;
	function fromVectorTileJs(tile) {
	    var out = new performance.pbf();
	    writeTile(tile, out);
	    return out.finish();
	}
	function fromGeojsonVt(layers, options) {
	    options = options || {};
	    var l = {};
	    for (var k in layers) {
	        l[k] = new geojson_wrapper(layers[k].features, options);
	        l[k].name = k;
	        l[k].version = options.version;
	        l[k].extent = options.extent;
	    }
	    return fromVectorTileJs({ layers: l });
	}
	function writeTile(tile, pbf) {
	    for (var key in tile.layers) {
	        pbf.writeMessage(3, writeLayer, tile.layers[key]);
	    }
	}
	function writeLayer(layer, pbf) {
	    pbf.writeVarintField(15, layer.version || 1);
	    pbf.writeStringField(1, layer.name || '');
	    pbf.writeVarintField(5, layer.extent || 4096);
	    var i;
	    var context = {
	        keys: [],
	        values: [],
	        keycache: {},
	        valuecache: {}
	    };
	    for (i = 0; i < layer.length; i++) {
	        context.feature = layer.feature(i);
	        pbf.writeMessage(2, writeFeature, context);
	    }
	    var keys = context.keys;
	    for (i = 0; i < keys.length; i++) {
	        pbf.writeStringField(3, keys[i]);
	    }
	    var values = context.values;
	    for (i = 0; i < values.length; i++) {
	        pbf.writeMessage(4, writeValue, values[i]);
	    }
	}
	function writeFeature(context, pbf) {
	    var feature = context.feature;
	    if (feature.id !== undefined) {
	        pbf.writeVarintField(1, feature.id);
	    }
	    pbf.writeMessage(2, writeProperties, context);
	    pbf.writeVarintField(3, feature.type);
	    pbf.writeMessage(4, writeGeometry, feature);
	}
	function writeProperties(context, pbf) {
	    var feature = context.feature;
	    var keys = context.keys;
	    var values = context.values;
	    var keycache = context.keycache;
	    var valuecache = context.valuecache;
	    for (var key in feature.properties) {
	        var value = feature.properties[key];
	        var keyIndex = keycache[key];
	        if (value === null) {
	            continue;
	        }
	        if (typeof keyIndex === 'undefined') {
	            keys.push(key);
	            keyIndex = keys.length - 1;
	            keycache[key] = keyIndex;
	        }
	        pbf.writeVarint(keyIndex);
	        var type = typeof value;
	        if (type !== 'string' && type !== 'boolean' && type !== 'number') {
	            value = JSON.stringify(value);
	        }
	        var valueKey = type + ':' + value;
	        var valueIndex = valuecache[valueKey];
	        if (typeof valueIndex === 'undefined') {
	            values.push(value);
	            valueIndex = values.length - 1;
	            valuecache[valueKey] = valueIndex;
	        }
	        pbf.writeVarint(valueIndex);
	    }
	}
	function command(cmd, length) {
	    return (length << 3) + (cmd & 7);
	}
	function zigzag(num) {
	    return num << 1 ^ num >> 31;
	}
	function writeGeometry(feature, pbf) {
	    var geometry = feature.loadGeometry();
	    var type = feature.type;
	    var x = 0;
	    var y = 0;
	    var rings = geometry.length;
	    for (var r = 0; r < rings; r++) {
	        var ring = geometry[r];
	        var count = 1;
	        if (type === 1) {
	            count = ring.length;
	        }
	        pbf.writeVarint(command(1, count));
	        var lineCount = type === 3 ? ring.length - 1 : ring.length;
	        for (var i = 0; i < lineCount; i++) {
	            if (i === 1 && type !== 1) {
	                pbf.writeVarint(command(2, lineCount - 1));
	            }
	            var dx = ring[i].x - x;
	            var dy = ring[i].y - y;
	            pbf.writeVarint(zigzag(dx));
	            pbf.writeVarint(zigzag(dy));
	            x += dx;
	            y += dy;
	        }
	        if (type === 3) {
	            pbf.writeVarint(command(7, 1));
	        }
	    }
	}
	function writeValue(value, pbf) {
	    var type = typeof value;
	    if (type === 'string') {
	        pbf.writeStringField(1, value);
	    } else if (type === 'boolean') {
	        pbf.writeBooleanField(7, value);
	    } else if (type === 'number') {
	        if (value % 1 !== 0) {
	            pbf.writeDoubleField(3, value);
	        } else if (value < 0) {
	            pbf.writeSVarintField(6, value);
	        } else {
	            pbf.writeVarintField(5, value);
	        }
	    }
	}
	vtPbf.fromVectorTileJs = fromVectorTileJs_1;
	vtPbf.fromGeojsonVt = fromGeojsonVt_1;
	vtPbf.GeoJSONWrapper = GeoJSONWrapper_1;

	function sortKD(ids, coords, nodeSize, left, right, depth) {
	    if (right - left <= nodeSize) {
	        return;
	    }
	    var m = left + right >> 1;
	    select(ids, coords, m, left, right, depth % 2);
	    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);
	    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);
	}
	function select(ids, coords, k, left, right, inc) {
	    while (right > left) {
	        if (right - left > 600) {
	            var n = right - left + 1;
	            var m = k - left + 1;
	            var z = Math.log(n);
	            var s = 0.5 * Math.exp(2 * z / 3);
	            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
	            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
	            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
	            select(ids, coords, k, newLeft, newRight, inc);
	        }
	        var t = coords[2 * k + inc];
	        var i = left;
	        var j = right;
	        swapItem(ids, coords, left, k);
	        if (coords[2 * right + inc] > t) {
	            swapItem(ids, coords, left, right);
	        }
	        while (i < j) {
	            swapItem(ids, coords, i, j);
	            i++;
	            j--;
	            while (coords[2 * i + inc] < t) {
	                i++;
	            }
	            while (coords[2 * j + inc] > t) {
	                j--;
	            }
	        }
	        if (coords[2 * left + inc] === t) {
	            swapItem(ids, coords, left, j);
	        } else {
	            j++;
	            swapItem(ids, coords, j, right);
	        }
	        if (j <= k) {
	            left = j + 1;
	        }
	        if (k <= j) {
	            right = j - 1;
	        }
	    }
	}
	function swapItem(ids, coords, i, j) {
	    swap(ids, i, j);
	    swap(coords, 2 * i, 2 * j);
	    swap(coords, 2 * i + 1, 2 * j + 1);
	}
	function swap(arr, i, j) {
	    var tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}

	function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {
	    var stack = [
	        0,
	        ids.length - 1,
	        0
	    ];
	    var result = [];
	    var x, y;
	    while (stack.length) {
	        var axis = stack.pop();
	        var right = stack.pop();
	        var left = stack.pop();
	        if (right - left <= nodeSize) {
	            for (var i = left; i <= right; i++) {
	                x = coords[2 * i];
	                y = coords[2 * i + 1];
	                if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
	                    result.push(ids[i]);
	                }
	            }
	            continue;
	        }
	        var m = Math.floor((left + right) / 2);
	        x = coords[2 * m];
	        y = coords[2 * m + 1];
	        if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
	            result.push(ids[m]);
	        }
	        var nextAxis = (axis + 1) % 2;
	        if (axis === 0 ? minX <= x : minY <= y) {
	            stack.push(left);
	            stack.push(m - 1);
	            stack.push(nextAxis);
	        }
	        if (axis === 0 ? maxX >= x : maxY >= y) {
	            stack.push(m + 1);
	            stack.push(right);
	            stack.push(nextAxis);
	        }
	    }
	    return result;
	}

	function within(ids, coords, qx, qy, r, nodeSize) {
	    var stack = [
	        0,
	        ids.length - 1,
	        0
	    ];
	    var result = [];
	    var r2 = r * r;
	    while (stack.length) {
	        var axis = stack.pop();
	        var right = stack.pop();
	        var left = stack.pop();
	        if (right - left <= nodeSize) {
	            for (var i = left; i <= right; i++) {
	                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) {
	                    result.push(ids[i]);
	                }
	            }
	            continue;
	        }
	        var m = Math.floor((left + right) / 2);
	        var x = coords[2 * m];
	        var y = coords[2 * m + 1];
	        if (sqDist(x, y, qx, qy) <= r2) {
	            result.push(ids[m]);
	        }
	        var nextAxis = (axis + 1) % 2;
	        if (axis === 0 ? qx - r <= x : qy - r <= y) {
	            stack.push(left);
	            stack.push(m - 1);
	            stack.push(nextAxis);
	        }
	        if (axis === 0 ? qx + r >= x : qy + r >= y) {
	            stack.push(m + 1);
	            stack.push(right);
	            stack.push(nextAxis);
	        }
	    }
	    return result;
	}
	function sqDist(ax, ay, bx, by) {
	    var dx = ax - bx;
	    var dy = ay - by;
	    return dx * dx + dy * dy;
	}

	var defaultGetX = function (p) {
	    return p[0];
	};
	var defaultGetY = function (p) {
	    return p[1];
	};
	var KDBush = function KDBush(points, getX, getY, nodeSize, ArrayType) {
	    if (getX === void 0)
	        getX = defaultGetX;
	    if (getY === void 0)
	        getY = defaultGetY;
	    if (nodeSize === void 0)
	        nodeSize = 64;
	    if (ArrayType === void 0)
	        ArrayType = Float64Array;
	    this.nodeSize = nodeSize;
	    this.points = points;
	    var IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;
	    var ids = this.ids = new IndexArrayType(points.length);
	    var coords = this.coords = new ArrayType(points.length * 2);
	    for (var i = 0; i < points.length; i++) {
	        ids[i] = i;
	        coords[2 * i] = getX(points[i]);
	        coords[2 * i + 1] = getY(points[i]);
	    }
	    sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);
	};
	KDBush.prototype.range = function range$1(minX, minY, maxX, maxY) {
	    return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);
	};
	KDBush.prototype.within = function within$1(x, y, r) {
	    return within(this.ids, this.coords, x, y, r, this.nodeSize);
	};

	var defaultOptions = {
	    minZoom: 0,
	    maxZoom: 16,
	    minPoints: 2,
	    radius: 40,
	    extent: 512,
	    nodeSize: 64,
	    log: false,
	    generateId: false,
	    reduce: null,
	    map: function (props) {
	        return props;
	    }
	};
	var fround = Math.fround || function (tmp) {
	    return function (x) {
	        tmp[0] = +x;
	        return tmp[0];
	    };
	}(new Float32Array(1));
	var Supercluster = function Supercluster(options) {
	    this.options = extend(Object.create(defaultOptions), options);
	    this.trees = new Array(this.options.maxZoom + 1);
	};
	Supercluster.prototype.load = function load(points) {
	    var ref = this.options;
	    var log = ref.log;
	    var minZoom = ref.minZoom;
	    var maxZoom = ref.maxZoom;
	    var nodeSize = ref.nodeSize;
	    if (log) {
	        console.time('total time');
	    }
	    var timerId = 'prepare ' + points.length + ' points';
	    if (log) {
	        console.time(timerId);
	    }
	    this.points = points;
	    var clusters = [];
	    for (var i = 0; i < points.length; i++) {
	        if (!points[i].geometry) {
	            continue;
	        }
	        clusters.push(createPointCluster(points[i], i));
	    }
	    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);
	    if (log) {
	        console.timeEnd(timerId);
	    }
	    for (var z = maxZoom; z >= minZoom; z--) {
	        var now = +Date.now();
	        clusters = this._cluster(clusters, z);
	        this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);
	        if (log) {
	            console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);
	        }
	    }
	    if (log) {
	        console.timeEnd('total time');
	    }
	    return this;
	};
	Supercluster.prototype.getClusters = function getClusters(bbox, zoom) {
	    var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;
	    var minLat = Math.max(-90, Math.min(90, bbox[1]));
	    var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;
	    var maxLat = Math.max(-90, Math.min(90, bbox[3]));
	    if (bbox[2] - bbox[0] >= 360) {
	        minLng = -180;
	        maxLng = 180;
	    } else if (minLng > maxLng) {
	        var easternHem = this.getClusters([
	            minLng,
	            minLat,
	            180,
	            maxLat
	        ], zoom);
	        var westernHem = this.getClusters([
	            -180,
	            minLat,
	            maxLng,
	            maxLat
	        ], zoom);
	        return easternHem.concat(westernHem);
	    }
	    var tree = this.trees[this._limitZoom(zoom)];
	    var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));
	    var clusters = [];
	    for (var i = 0, list = ids; i < list.length; i += 1) {
	        var id = list[i];
	        var c = tree.points[id];
	        clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
	    }
	    return clusters;
	};
	Supercluster.prototype.getChildren = function getChildren(clusterId) {
	    var originId = this._getOriginId(clusterId);
	    var originZoom = this._getOriginZoom(clusterId);
	    var errorMsg = 'No cluster with the specified id.';
	    var index = this.trees[originZoom];
	    if (!index) {
	        throw new Error(errorMsg);
	    }
	    var origin = index.points[originId];
	    if (!origin) {
	        throw new Error(errorMsg);
	    }
	    var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));
	    var ids = index.within(origin.x, origin.y, r);
	    var children = [];
	    for (var i = 0, list = ids; i < list.length; i += 1) {
	        var id = list[i];
	        var c = index.points[id];
	        if (c.parentId === clusterId) {
	            children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
	        }
	    }
	    if (children.length === 0) {
	        throw new Error(errorMsg);
	    }
	    return children;
	};
	Supercluster.prototype.getLeaves = function getLeaves(clusterId, limit, offset) {
	    limit = limit || 10;
	    offset = offset || 0;
	    var leaves = [];
	    this._appendLeaves(leaves, clusterId, limit, offset, 0);
	    return leaves;
	};
	Supercluster.prototype.getTile = function getTile(z, x, y) {
	    var tree = this.trees[this._limitZoom(z)];
	    var z2 = Math.pow(2, z);
	    var ref = this.options;
	    var extent = ref.extent;
	    var radius = ref.radius;
	    var p = radius / extent;
	    var top = (y - p) / z2;
	    var bottom = (y + 1 + p) / z2;
	    var tile = { features: [] };
	    this._addTileFeatures(tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom), tree.points, x, y, z2, tile);
	    if (x === 0) {
	        this._addTileFeatures(tree.range(1 - p / z2, top, 1, bottom), tree.points, z2, y, z2, tile);
	    }
	    if (x === z2 - 1) {
	        this._addTileFeatures(tree.range(0, top, p / z2, bottom), tree.points, -1, y, z2, tile);
	    }
	    return tile.features.length ? tile : null;
	};
	Supercluster.prototype.getClusterExpansionZoom = function getClusterExpansionZoom(clusterId) {
	    var expansionZoom = this._getOriginZoom(clusterId) - 1;
	    while (expansionZoom <= this.options.maxZoom) {
	        var children = this.getChildren(clusterId);
	        expansionZoom++;
	        if (children.length !== 1) {
	            break;
	        }
	        clusterId = children[0].properties.cluster_id;
	    }
	    return expansionZoom;
	};
	Supercluster.prototype._appendLeaves = function _appendLeaves(result, clusterId, limit, offset, skipped) {
	    var children = this.getChildren(clusterId);
	    for (var i = 0, list = children; i < list.length; i += 1) {
	        var child = list[i];
	        var props = child.properties;
	        if (props && props.cluster) {
	            if (skipped + props.point_count <= offset) {
	                skipped += props.point_count;
	            } else {
	                skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);
	            }
	        } else if (skipped < offset) {
	            skipped++;
	        } else {
	            result.push(child);
	        }
	        if (result.length === limit) {
	            break;
	        }
	    }
	    return skipped;
	};
	Supercluster.prototype._addTileFeatures = function _addTileFeatures(ids, points, x, y, z2, tile) {
	    for (var i$1 = 0, list = ids; i$1 < list.length; i$1 += 1) {
	        var i = list[i$1];
	        var c = points[i];
	        var isCluster = c.numPoints;
	        var tags = void 0, px = void 0, py = void 0;
	        if (isCluster) {
	            tags = getClusterProperties(c);
	            px = c.x;
	            py = c.y;
	        } else {
	            var p = this.points[c.index];
	            tags = p.properties;
	            px = lngX(p.geometry.coordinates[0]);
	            py = latY(p.geometry.coordinates[1]);
	        }
	        var f = {
	            type: 1,
	            geometry: [[
	                    Math.round(this.options.extent * (px * z2 - x)),
	                    Math.round(this.options.extent * (py * z2 - y))
	                ]],
	            tags: tags
	        };
	        var id = void 0;
	        if (isCluster) {
	            id = c.id;
	        } else if (this.options.generateId) {
	            id = c.index;
	        } else if (this.points[c.index].id) {
	            id = this.points[c.index].id;
	        }
	        if (id !== undefined) {
	            f.id = id;
	        }
	        tile.features.push(f);
	    }
	};
	Supercluster.prototype._limitZoom = function _limitZoom(z) {
	    return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));
	};
	Supercluster.prototype._cluster = function _cluster(points, zoom) {
	    var clusters = [];
	    var ref = this.options;
	    var radius = ref.radius;
	    var extent = ref.extent;
	    var reduce = ref.reduce;
	    var minPoints = ref.minPoints;
	    var r = radius / (extent * Math.pow(2, zoom));
	    for (var i = 0; i < points.length; i++) {
	        var p = points[i];
	        if (p.zoom <= zoom) {
	            continue;
	        }
	        p.zoom = zoom;
	        var tree = this.trees[zoom + 1];
	        var neighborIds = tree.within(p.x, p.y, r);
	        var numPointsOrigin = p.numPoints || 1;
	        var numPoints = numPointsOrigin;
	        for (var i$1 = 0, list = neighborIds; i$1 < list.length; i$1 += 1) {
	            var neighborId = list[i$1];
	            var b = tree.points[neighborId];
	            if (b.zoom > zoom) {
	                numPoints += b.numPoints || 1;
	            }
	        }
	        if (numPoints >= minPoints) {
	            var wx = p.x * numPointsOrigin;
	            var wy = p.y * numPointsOrigin;
	            var clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;
	            var id = (i << 5) + (zoom + 1) + this.points.length;
	            for (var i$2 = 0, list$1 = neighborIds; i$2 < list$1.length; i$2 += 1) {
	                var neighborId$1 = list$1[i$2];
	                var b$1 = tree.points[neighborId$1];
	                if (b$1.zoom <= zoom) {
	                    continue;
	                }
	                b$1.zoom = zoom;
	                var numPoints2 = b$1.numPoints || 1;
	                wx += b$1.x * numPoints2;
	                wy += b$1.y * numPoints2;
	                b$1.parentId = id;
	                if (reduce) {
	                    if (!clusterProperties) {
	                        clusterProperties = this._map(p, true);
	                    }
	                    reduce(clusterProperties, this._map(b$1));
	                }
	            }
	            p.parentId = id;
	            clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));
	        } else {
	            clusters.push(p);
	            if (numPoints > 1) {
	                for (var i$3 = 0, list$2 = neighborIds; i$3 < list$2.length; i$3 += 1) {
	                    var neighborId$2 = list$2[i$3];
	                    var b$2 = tree.points[neighborId$2];
	                    if (b$2.zoom <= zoom) {
	                        continue;
	                    }
	                    b$2.zoom = zoom;
	                    clusters.push(b$2);
	                }
	            }
	        }
	    }
	    return clusters;
	};
	Supercluster.prototype._getOriginId = function _getOriginId(clusterId) {
	    return clusterId - this.points.length >> 5;
	};
	Supercluster.prototype._getOriginZoom = function _getOriginZoom(clusterId) {
	    return (clusterId - this.points.length) % 32;
	};
	Supercluster.prototype._map = function _map(point, clone) {
	    if (point.numPoints) {
	        return clone ? extend({}, point.properties) : point.properties;
	    }
	    var original = this.points[point.index].properties;
	    var result = this.options.map(original);
	    return clone && result === original ? extend({}, result) : result;
	};
	function createCluster(x, y, id, numPoints, properties) {
	    return {
	        x: fround(x),
	        y: fround(y),
	        zoom: Infinity,
	        id: id,
	        parentId: -1,
	        numPoints: numPoints,
	        properties: properties
	    };
	}
	function createPointCluster(p, id) {
	    var ref = p.geometry.coordinates;
	    var x = ref[0];
	    var y = ref[1];
	    return {
	        x: fround(lngX(x)),
	        y: fround(latY(y)),
	        zoom: Infinity,
	        index: id,
	        parentId: -1
	    };
	}
	function getClusterJSON(cluster) {
	    return {
	        type: 'Feature',
	        id: cluster.id,
	        properties: getClusterProperties(cluster),
	        geometry: {
	            type: 'Point',
	            coordinates: [
	                xLng(cluster.x),
	                yLat(cluster.y)
	            ]
	        }
	    };
	}
	function getClusterProperties(cluster) {
	    var count = cluster.numPoints;
	    var abbrev = count >= 10000 ? Math.round(count / 1000) + 'k' : count >= 1000 ? Math.round(count / 100) / 10 + 'k' : count;
	    return extend(extend({}, cluster.properties), {
	        cluster: true,
	        cluster_id: cluster.id,
	        point_count: count,
	        point_count_abbreviated: abbrev
	    });
	}
	function lngX(lng) {
	    return lng / 360 + 0.5;
	}
	function latY(lat) {
	    var sin = Math.sin(lat * Math.PI / 180);
	    var y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
	    return y < 0 ? 0 : y > 1 ? 1 : y;
	}
	function xLng(x) {
	    return (x - 0.5) * 360;
	}
	function yLat(y) {
	    var y2 = (180 - y * 360) * Math.PI / 180;
	    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;
	}
	function extend(dest, src) {
	    for (var id in src) {
	        dest[id] = src[id];
	    }
	    return dest;
	}
	function getX(p) {
	    return p.x;
	}
	function getY(p) {
	    return p.y;
	}

	function simplify(coords, first, last, sqTolerance) {
	    var maxSqDist = sqTolerance;
	    var mid = last - first >> 1;
	    var minPosToMid = last - first;
	    var index;
	    var ax = coords[first];
	    var ay = coords[first + 1];
	    var bx = coords[last];
	    var by = coords[last + 1];
	    for (var i = first + 3; i < last; i += 3) {
	        var d = getSqSegDist(coords[i], coords[i + 1], ax, ay, bx, by);
	        if (d > maxSqDist) {
	            index = i;
	            maxSqDist = d;
	        } else if (d === maxSqDist) {
	            var posToMid = Math.abs(i - mid);
	            if (posToMid < minPosToMid) {
	                index = i;
	                minPosToMid = posToMid;
	            }
	        }
	    }
	    if (maxSqDist > sqTolerance) {
	        if (index - first > 3) {
	            simplify(coords, first, index, sqTolerance);
	        }
	        coords[index + 2] = maxSqDist;
	        if (last - index > 3) {
	            simplify(coords, index, last, sqTolerance);
	        }
	    }
	}
	function getSqSegDist(px, py, x, y, bx, by) {
	    var dx = bx - x;
	    var dy = by - y;
	    if (dx !== 0 || dy !== 0) {
	        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);
	        if (t > 1) {
	            x = bx;
	            y = by;
	        } else if (t > 0) {
	            x += dx * t;
	            y += dy * t;
	        }
	    }
	    dx = px - x;
	    dy = py - y;
	    return dx * dx + dy * dy;
	}

	function createFeature(id, type, geom, tags) {
	    var feature = {
	        id: typeof id === 'undefined' ? null : id,
	        type: type,
	        geometry: geom,
	        tags: tags,
	        minX: Infinity,
	        minY: Infinity,
	        maxX: -Infinity,
	        maxY: -Infinity
	    };
	    calcBBox(feature);
	    return feature;
	}
	function calcBBox(feature) {
	    var geom = feature.geometry;
	    var type = feature.type;
	    if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {
	        calcLineBBox(feature, geom);
	    } else if (type === 'Polygon' || type === 'MultiLineString') {
	        for (var i = 0; i < geom.length; i++) {
	            calcLineBBox(feature, geom[i]);
	        }
	    } else if (type === 'MultiPolygon') {
	        for (i = 0; i < geom.length; i++) {
	            for (var j = 0; j < geom[i].length; j++) {
	                calcLineBBox(feature, geom[i][j]);
	            }
	        }
	    }
	}
	function calcLineBBox(feature, geom) {
	    for (var i = 0; i < geom.length; i += 3) {
	        feature.minX = Math.min(feature.minX, geom[i]);
	        feature.minY = Math.min(feature.minY, geom[i + 1]);
	        feature.maxX = Math.max(feature.maxX, geom[i]);
	        feature.maxY = Math.max(feature.maxY, geom[i + 1]);
	    }
	}

	function convert(data, options) {
	    var features = [];
	    if (data.type === 'FeatureCollection') {
	        for (var i = 0; i < data.features.length; i++) {
	            convertFeature(features, data.features[i], options, i);
	        }
	    } else if (data.type === 'Feature') {
	        convertFeature(features, data, options);
	    } else {
	        convertFeature(features, { geometry: data }, options);
	    }
	    return features;
	}
	function convertFeature(features, geojson, options, index) {
	    if (!geojson.geometry) {
	        return;
	    }
	    var coords = geojson.geometry.coordinates;
	    var type = geojson.geometry.type;
	    var tolerance = Math.pow(options.tolerance / ((1 << options.maxZoom) * options.extent), 2);
	    var geometry = [];
	    var id = geojson.id;
	    if (options.promoteId) {
	        id = geojson.properties[options.promoteId];
	    } else if (options.generateId) {
	        id = index || 0;
	    }
	    if (type === 'Point') {
	        convertPoint(coords, geometry);
	    } else if (type === 'MultiPoint') {
	        for (var i = 0; i < coords.length; i++) {
	            convertPoint(coords[i], geometry);
	        }
	    } else if (type === 'LineString') {
	        convertLine(coords, geometry, tolerance, false);
	    } else if (type === 'MultiLineString') {
	        if (options.lineMetrics) {
	            for (i = 0; i < coords.length; i++) {
	                geometry = [];
	                convertLine(coords[i], geometry, tolerance, false);
	                features.push(createFeature(id, 'LineString', geometry, geojson.properties));
	            }
	            return;
	        } else {
	            convertLines(coords, geometry, tolerance, false);
	        }
	    } else if (type === 'Polygon') {
	        convertLines(coords, geometry, tolerance, true);
	    } else if (type === 'MultiPolygon') {
	        for (i = 0; i < coords.length; i++) {
	            var polygon = [];
	            convertLines(coords[i], polygon, tolerance, true);
	            geometry.push(polygon);
	        }
	    } else if (type === 'GeometryCollection') {
	        for (i = 0; i < geojson.geometry.geometries.length; i++) {
	            convertFeature(features, {
	                id: id,
	                geometry: geojson.geometry.geometries[i],
	                properties: geojson.properties
	            }, options, index);
	        }
	        return;
	    } else {
	        throw new Error('Input data is not a valid GeoJSON object.');
	    }
	    features.push(createFeature(id, type, geometry, geojson.properties));
	}
	function convertPoint(coords, out) {
	    out.push(projectX(coords[0]));
	    out.push(projectY(coords[1]));
	    out.push(0);
	}
	function convertLine(ring, out, tolerance, isPolygon) {
	    var x0, y0;
	    var size = 0;
	    for (var j = 0; j < ring.length; j++) {
	        var x = projectX(ring[j][0]);
	        var y = projectY(ring[j][1]);
	        out.push(x);
	        out.push(y);
	        out.push(0);
	        if (j > 0) {
	            if (isPolygon) {
	                size += (x0 * y - x * y0) / 2;
	            } else {
	                size += Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2));
	            }
	        }
	        x0 = x;
	        y0 = y;
	    }
	    var last = out.length - 3;
	    out[2] = 1;
	    simplify(out, 0, last, tolerance);
	    out[last + 2] = 1;
	    out.size = Math.abs(size);
	    out.start = 0;
	    out.end = out.size;
	}
	function convertLines(rings, out, tolerance, isPolygon) {
	    for (var i = 0; i < rings.length; i++) {
	        var geom = [];
	        convertLine(rings[i], geom, tolerance, isPolygon);
	        out.push(geom);
	    }
	}
	function projectX(x) {
	    return x / 360 + 0.5;
	}
	function projectY(y) {
	    var sin = Math.sin(y * Math.PI / 180);
	    var y2 = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
	    return y2 < 0 ? 0 : y2 > 1 ? 1 : y2;
	}

	function clip(features, scale, k1, k2, axis, minAll, maxAll, options) {
	    k1 /= scale;
	    k2 /= scale;
	    if (minAll >= k1 && maxAll < k2) {
	        return features;
	    } else if (maxAll < k1 || minAll >= k2) {
	        return null;
	    }
	    var clipped = [];
	    for (var i = 0; i < features.length; i++) {
	        var feature = features[i];
	        var geometry = feature.geometry;
	        var type = feature.type;
	        var min = axis === 0 ? feature.minX : feature.minY;
	        var max = axis === 0 ? feature.maxX : feature.maxY;
	        if (min >= k1 && max < k2) {
	            clipped.push(feature);
	            continue;
	        } else if (max < k1 || min >= k2) {
	            continue;
	        }
	        var newGeometry = [];
	        if (type === 'Point' || type === 'MultiPoint') {
	            clipPoints(geometry, newGeometry, k1, k2, axis);
	        } else if (type === 'LineString') {
	            clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);
	        } else if (type === 'MultiLineString') {
	            clipLines(geometry, newGeometry, k1, k2, axis, false);
	        } else if (type === 'Polygon') {
	            clipLines(geometry, newGeometry, k1, k2, axis, true);
	        } else if (type === 'MultiPolygon') {
	            for (var j = 0; j < geometry.length; j++) {
	                var polygon = [];
	                clipLines(geometry[j], polygon, k1, k2, axis, true);
	                if (polygon.length) {
	                    newGeometry.push(polygon);
	                }
	            }
	        }
	        if (newGeometry.length) {
	            if (options.lineMetrics && type === 'LineString') {
	                for (j = 0; j < newGeometry.length; j++) {
	                    clipped.push(createFeature(feature.id, type, newGeometry[j], feature.tags));
	                }
	                continue;
	            }
	            if (type === 'LineString' || type === 'MultiLineString') {
	                if (newGeometry.length === 1) {
	                    type = 'LineString';
	                    newGeometry = newGeometry[0];
	                } else {
	                    type = 'MultiLineString';
	                }
	            }
	            if (type === 'Point' || type === 'MultiPoint') {
	                type = newGeometry.length === 3 ? 'Point' : 'MultiPoint';
	            }
	            clipped.push(createFeature(feature.id, type, newGeometry, feature.tags));
	        }
	    }
	    return clipped.length ? clipped : null;
	}
	function clipPoints(geom, newGeom, k1, k2, axis) {
	    for (var i = 0; i < geom.length; i += 3) {
	        var a = geom[i + axis];
	        if (a >= k1 && a <= k2) {
	            newGeom.push(geom[i]);
	            newGeom.push(geom[i + 1]);
	            newGeom.push(geom[i + 2]);
	        }
	    }
	}
	function clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {
	    var slice = newSlice(geom);
	    var intersect = axis === 0 ? intersectX : intersectY;
	    var len = geom.start;
	    var segLen, t;
	    for (var i = 0; i < geom.length - 3; i += 3) {
	        var ax = geom[i];
	        var ay = geom[i + 1];
	        var az = geom[i + 2];
	        var bx = geom[i + 3];
	        var by = geom[i + 4];
	        var a = axis === 0 ? ax : ay;
	        var b = axis === 0 ? bx : by;
	        var exited = false;
	        if (trackMetrics) {
	            segLen = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));
	        }
	        if (a < k1) {
	            if (b > k1) {
	                t = intersect(slice, ax, ay, bx, by, k1);
	                if (trackMetrics) {
	                    slice.start = len + segLen * t;
	                }
	            }
	        } else if (a > k2) {
	            if (b < k2) {
	                t = intersect(slice, ax, ay, bx, by, k2);
	                if (trackMetrics) {
	                    slice.start = len + segLen * t;
	                }
	            }
	        } else {
	            addPoint(slice, ax, ay, az);
	        }
	        if (b < k1 && a >= k1) {
	            t = intersect(slice, ax, ay, bx, by, k1);
	            exited = true;
	        }
	        if (b > k2 && a <= k2) {
	            t = intersect(slice, ax, ay, bx, by, k2);
	            exited = true;
	        }
	        if (!isPolygon && exited) {
	            if (trackMetrics) {
	                slice.end = len + segLen * t;
	            }
	            newGeom.push(slice);
	            slice = newSlice(geom);
	        }
	        if (trackMetrics) {
	            len += segLen;
	        }
	    }
	    var last = geom.length - 3;
	    ax = geom[last];
	    ay = geom[last + 1];
	    az = geom[last + 2];
	    a = axis === 0 ? ax : ay;
	    if (a >= k1 && a <= k2) {
	        addPoint(slice, ax, ay, az);
	    }
	    last = slice.length - 3;
	    if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {
	        addPoint(slice, slice[0], slice[1], slice[2]);
	    }
	    if (slice.length) {
	        newGeom.push(slice);
	    }
	}
	function newSlice(line) {
	    var slice = [];
	    slice.size = line.size;
	    slice.start = line.start;
	    slice.end = line.end;
	    return slice;
	}
	function clipLines(geom, newGeom, k1, k2, axis, isPolygon) {
	    for (var i = 0; i < geom.length; i++) {
	        clipLine(geom[i], newGeom, k1, k2, axis, isPolygon, false);
	    }
	}
	function addPoint(out, x, y, z) {
	    out.push(x);
	    out.push(y);
	    out.push(z);
	}
	function intersectX(out, ax, ay, bx, by, x) {
	    var t = (x - ax) / (bx - ax);
	    out.push(x);
	    out.push(ay + (by - ay) * t);
	    out.push(1);
	    return t;
	}
	function intersectY(out, ax, ay, bx, by, y) {
	    var t = (y - ay) / (by - ay);
	    out.push(ax + (bx - ax) * t);
	    out.push(y);
	    out.push(1);
	    return t;
	}

	function wrap(features, options) {
	    var buffer = options.buffer / options.extent;
	    var merged = features;
	    var left = clip(features, 1, -1 - buffer, buffer, 0, -1, 2, options);
	    var right = clip(features, 1, 1 - buffer, 2 + buffer, 0, -1, 2, options);
	    if (left || right) {
	        merged = clip(features, 1, -buffer, 1 + buffer, 0, -1, 2, options) || [];
	        if (left) {
	            merged = shiftFeatureCoords(left, 1).concat(merged);
	        }
	        if (right) {
	            merged = merged.concat(shiftFeatureCoords(right, -1));
	        }
	    }
	    return merged;
	}
	function shiftFeatureCoords(features, offset) {
	    var newFeatures = [];
	    for (var i = 0; i < features.length; i++) {
	        var feature = features[i], type = feature.type;
	        var newGeometry;
	        if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {
	            newGeometry = shiftCoords(feature.geometry, offset);
	        } else if (type === 'MultiLineString' || type === 'Polygon') {
	            newGeometry = [];
	            for (var j = 0; j < feature.geometry.length; j++) {
	                newGeometry.push(shiftCoords(feature.geometry[j], offset));
	            }
	        } else if (type === 'MultiPolygon') {
	            newGeometry = [];
	            for (j = 0; j < feature.geometry.length; j++) {
	                var newPolygon = [];
	                for (var k = 0; k < feature.geometry[j].length; k++) {
	                    newPolygon.push(shiftCoords(feature.geometry[j][k], offset));
	                }
	                newGeometry.push(newPolygon);
	            }
	        }
	        newFeatures.push(createFeature(feature.id, type, newGeometry, feature.tags));
	    }
	    return newFeatures;
	}
	function shiftCoords(points, offset) {
	    var newPoints = [];
	    newPoints.size = points.size;
	    if (points.start !== undefined) {
	        newPoints.start = points.start;
	        newPoints.end = points.end;
	    }
	    for (var i = 0; i < points.length; i += 3) {
	        newPoints.push(points[i] + offset, points[i + 1], points[i + 2]);
	    }
	    return newPoints;
	}

	function transformTile(tile, extent) {
	    if (tile.transformed) {
	        return tile;
	    }
	    var z2 = 1 << tile.z, tx = tile.x, ty = tile.y, i, j, k;
	    for (i = 0; i < tile.features.length; i++) {
	        var feature = tile.features[i], geom = feature.geometry, type = feature.type;
	        feature.geometry = [];
	        if (type === 1) {
	            for (j = 0; j < geom.length; j += 2) {
	                feature.geometry.push(transformPoint(geom[j], geom[j + 1], extent, z2, tx, ty));
	            }
	        } else {
	            for (j = 0; j < geom.length; j++) {
	                var ring = [];
	                for (k = 0; k < geom[j].length; k += 2) {
	                    ring.push(transformPoint(geom[j][k], geom[j][k + 1], extent, z2, tx, ty));
	                }
	                feature.geometry.push(ring);
	            }
	        }
	    }
	    tile.transformed = true;
	    return tile;
	}
	function transformPoint(x, y, extent, z2, tx, ty) {
	    return [
	        Math.round(extent * (x * z2 - tx)),
	        Math.round(extent * (y * z2 - ty))
	    ];
	}

	function createTile(features, z, tx, ty, options) {
	    var tolerance = z === options.maxZoom ? 0 : options.tolerance / ((1 << z) * options.extent);
	    var tile = {
	        features: [],
	        numPoints: 0,
	        numSimplified: 0,
	        numFeatures: 0,
	        source: null,
	        x: tx,
	        y: ty,
	        z: z,
	        transformed: false,
	        minX: 2,
	        minY: 1,
	        maxX: -1,
	        maxY: 0
	    };
	    for (var i = 0; i < features.length; i++) {
	        tile.numFeatures++;
	        addFeature(tile, features[i], tolerance, options);
	        var minX = features[i].minX;
	        var minY = features[i].minY;
	        var maxX = features[i].maxX;
	        var maxY = features[i].maxY;
	        if (minX < tile.minX) {
	            tile.minX = minX;
	        }
	        if (minY < tile.minY) {
	            tile.minY = minY;
	        }
	        if (maxX > tile.maxX) {
	            tile.maxX = maxX;
	        }
	        if (maxY > tile.maxY) {
	            tile.maxY = maxY;
	        }
	    }
	    return tile;
	}
	function addFeature(tile, feature, tolerance, options) {
	    var geom = feature.geometry, type = feature.type, simplified = [];
	    if (type === 'Point' || type === 'MultiPoint') {
	        for (var i = 0; i < geom.length; i += 3) {
	            simplified.push(geom[i]);
	            simplified.push(geom[i + 1]);
	            tile.numPoints++;
	            tile.numSimplified++;
	        }
	    } else if (type === 'LineString') {
	        addLine(simplified, geom, tile, tolerance, false, false);
	    } else if (type === 'MultiLineString' || type === 'Polygon') {
	        for (i = 0; i < geom.length; i++) {
	            addLine(simplified, geom[i], tile, tolerance, type === 'Polygon', i === 0);
	        }
	    } else if (type === 'MultiPolygon') {
	        for (var k = 0; k < geom.length; k++) {
	            var polygon = geom[k];
	            for (i = 0; i < polygon.length; i++) {
	                addLine(simplified, polygon[i], tile, tolerance, true, i === 0);
	            }
	        }
	    }
	    if (simplified.length) {
	        var tags = feature.tags || null;
	        if (type === 'LineString' && options.lineMetrics) {
	            tags = {};
	            for (var key in feature.tags) {
	                tags[key] = feature.tags[key];
	            }
	            tags['mapbox_clip_start'] = geom.start / geom.size;
	            tags['mapbox_clip_end'] = geom.end / geom.size;
	        }
	        var tileFeature = {
	            geometry: simplified,
	            type: type === 'Polygon' || type === 'MultiPolygon' ? 3 : type === 'LineString' || type === 'MultiLineString' ? 2 : 1,
	            tags: tags
	        };
	        if (feature.id !== null) {
	            tileFeature.id = feature.id;
	        }
	        tile.features.push(tileFeature);
	    }
	}
	function addLine(result, geom, tile, tolerance, isPolygon, isOuter) {
	    var sqTolerance = tolerance * tolerance;
	    if (tolerance > 0 && geom.size < (isPolygon ? sqTolerance : tolerance)) {
	        tile.numPoints += geom.length / 3;
	        return;
	    }
	    var ring = [];
	    for (var i = 0; i < geom.length; i += 3) {
	        if (tolerance === 0 || geom[i + 2] > sqTolerance) {
	            tile.numSimplified++;
	            ring.push(geom[i]);
	            ring.push(geom[i + 1]);
	        }
	        tile.numPoints++;
	    }
	    if (isPolygon) {
	        rewind$1(ring, isOuter);
	    }
	    result.push(ring);
	}
	function rewind$1(ring, clockwise) {
	    var area = 0;
	    for (var i = 0, len = ring.length, j = len - 2; i < len; j = i, i += 2) {
	        area += (ring[i] - ring[j]) * (ring[i + 1] + ring[j + 1]);
	    }
	    if (area > 0 === clockwise) {
	        for (i = 0, len = ring.length; i < len / 2; i += 2) {
	            var x = ring[i];
	            var y = ring[i + 1];
	            ring[i] = ring[len - 2 - i];
	            ring[i + 1] = ring[len - 1 - i];
	            ring[len - 2 - i] = x;
	            ring[len - 1 - i] = y;
	        }
	    }
	}

	function geojsonvt(data, options) {
	    return new GeoJSONVT(data, options);
	}
	function GeoJSONVT(data, options) {
	    options = this.options = extend$1(Object.create(this.options), options);
	    var debug = options.debug;
	    if (debug) {
	        console.time('preprocess data');
	    }
	    if (options.maxZoom < 0 || options.maxZoom > 24) {
	        throw new Error('maxZoom should be in the 0-24 range');
	    }
	    if (options.promoteId && options.generateId) {
	        throw new Error('promoteId and generateId cannot be used together.');
	    }
	    var features = convert(data, options);
	    this.tiles = {};
	    this.tileCoords = [];
	    if (debug) {
	        console.timeEnd('preprocess data');
	        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);
	        console.time('generate tiles');
	        this.stats = {};
	        this.total = 0;
	    }
	    features = wrap(features, options);
	    if (features.length) {
	        this.splitTile(features, 0, 0, 0);
	    }
	    if (debug) {
	        if (features.length) {
	            console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);
	        }
	        console.timeEnd('generate tiles');
	        console.log('tiles generated:', this.total, JSON.stringify(this.stats));
	    }
	}
	GeoJSONVT.prototype.options = {
	    maxZoom: 14,
	    indexMaxZoom: 5,
	    indexMaxPoints: 100000,
	    tolerance: 3,
	    extent: 4096,
	    buffer: 64,
	    lineMetrics: false,
	    promoteId: null,
	    generateId: false,
	    debug: 0
	};
	GeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {
	    var stack = [
	            features,
	            z,
	            x,
	            y
	        ], options = this.options, debug = options.debug;
	    while (stack.length) {
	        y = stack.pop();
	        x = stack.pop();
	        z = stack.pop();
	        features = stack.pop();
	        var z2 = 1 << z, id = toID(z, x, y), tile = this.tiles[id];
	        if (!tile) {
	            if (debug > 1) {
	                console.time('creation');
	            }
	            tile = this.tiles[id] = createTile(features, z, x, y, options);
	            this.tileCoords.push({
	                z: z,
	                x: x,
	                y: y
	            });
	            if (debug) {
	                if (debug > 1) {
	                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)', z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);
	                    console.timeEnd('creation');
	                }
	                var key = 'z' + z;
	                this.stats[key] = (this.stats[key] || 0) + 1;
	                this.total++;
	            }
	        }
	        tile.source = features;
	        if (!cz) {
	            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) {
	                continue;
	            }
	        } else {
	            if (z === options.maxZoom || z === cz) {
	                continue;
	            }
	            var m = 1 << cz - z;
	            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) {
	                continue;
	            }
	        }
	        tile.source = null;
	        if (features.length === 0) {
	            continue;
	        }
	        if (debug > 1) {
	            console.time('clipping');
	        }
	        var k1 = 0.5 * options.buffer / options.extent, k2 = 0.5 - k1, k3 = 0.5 + k1, k4 = 1 + k1, tl, bl, tr, br, left, right;
	        tl = bl = tr = br = null;
	        left = clip(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, options);
	        right = clip(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, options);
	        features = null;
	        if (left) {
	            tl = clip(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);
	            bl = clip(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);
	            left = null;
	        }
	        if (right) {
	            tr = clip(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);
	            br = clip(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);
	            right = null;
	        }
	        if (debug > 1) {
	            console.timeEnd('clipping');
	        }
	        stack.push(tl || [], z + 1, x * 2, y * 2);
	        stack.push(bl || [], z + 1, x * 2, y * 2 + 1);
	        stack.push(tr || [], z + 1, x * 2 + 1, y * 2);
	        stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);
	    }
	};
	GeoJSONVT.prototype.getTile = function (z, x, y) {
	    var options = this.options, extent = options.extent, debug = options.debug;
	    if (z < 0 || z > 24) {
	        return null;
	    }
	    var z2 = 1 << z;
	    x = (x % z2 + z2) % z2;
	    var id = toID(z, x, y);
	    if (this.tiles[id]) {
	        return transformTile(this.tiles[id], extent);
	    }
	    if (debug > 1) {
	        console.log('drilling down to z%d-%d-%d', z, x, y);
	    }
	    var z0 = z, x0 = x, y0 = y, parent;
	    while (!parent && z0 > 0) {
	        z0--;
	        x0 = Math.floor(x0 / 2);
	        y0 = Math.floor(y0 / 2);
	        parent = this.tiles[toID(z0, x0, y0)];
	    }
	    if (!parent || !parent.source) {
	        return null;
	    }
	    if (debug > 1) {
	        console.log('found parent tile z%d-%d-%d', z0, x0, y0);
	    }
	    if (debug > 1) {
	        console.time('drilling down');
	    }
	    this.splitTile(parent.source, z0, x0, y0, z, x, y);
	    if (debug > 1) {
	        console.timeEnd('drilling down');
	    }
	    return this.tiles[id] ? transformTile(this.tiles[id], extent) : null;
	};
	function toID(z, x, y) {
	    return ((1 << z) * y + x) * 32 + z;
	}
	function extend$1(dest, src) {
	    for (var i in src) {
	        dest[i] = src[i];
	    }
	    return dest;
	}

	function loadGeoJSONTile(params, callback) {
	    var canonical = params.tileID.canonical;
	    if (!this._geoJSONIndex) {
	        return callback(null, null);
	    }
	    var geoJSONTile = this._geoJSONIndex.getTile(canonical.z, canonical.x, canonical.y);
	    if (!geoJSONTile) {
	        return callback(null, null);
	    }
	    var geojsonWrapper = new GeoJSONWrapper(geoJSONTile.features);
	    var pbf = vtPbf(geojsonWrapper);
	    if (pbf.byteOffset !== 0 || pbf.byteLength !== pbf.buffer.byteLength) {
	        pbf = new Uint8Array(pbf);
	    }
	    callback(null, {
	        vectorTile: geojsonWrapper,
	        rawData: pbf.buffer
	    });
	}
	var GeoJSONWorkerSource = function (VectorTileWorkerSource) {
	    function GeoJSONWorkerSource(actor, layerIndex, availableImages, loadGeoJSON) {
	        VectorTileWorkerSource.call(this, actor, layerIndex, availableImages, loadGeoJSONTile);
	        if (loadGeoJSON) {
	            this.loadGeoJSON = loadGeoJSON;
	        }
	    }
	    if (VectorTileWorkerSource)
	        GeoJSONWorkerSource.__proto__ = VectorTileWorkerSource;
	    GeoJSONWorkerSource.prototype = Object.create(VectorTileWorkerSource && VectorTileWorkerSource.prototype);
	    GeoJSONWorkerSource.prototype.constructor = GeoJSONWorkerSource;
	    GeoJSONWorkerSource.prototype.loadData = function loadData(params, callback) {
	        if (this._pendingCallback) {
	            this._pendingCallback(null, { abandoned: true });
	        }
	        this._pendingCallback = callback;
	        this._pendingLoadDataParams = params;
	        if (this._state && this._state !== 'Idle') {
	            this._state = 'NeedsLoadData';
	        } else {
	            this._state = 'Coalescing';
	            this._loadData();
	        }
	    };
	    GeoJSONWorkerSource.prototype._loadData = function _loadData() {
	        var this$1 = this;
	        if (!this._pendingCallback || !this._pendingLoadDataParams) {
	            return;
	        }
	        var callback = this._pendingCallback;
	        var params = this._pendingLoadDataParams;
	        delete this._pendingCallback;
	        delete this._pendingLoadDataParams;
	        var perf = params && params.request && params.request.collectResourceTiming ? new performance.RequestPerformance(params.request) : false;
	        this.loadGeoJSON(params, function (err, data) {
	            if (err || !data) {
	                return callback(err);
	            } else if (typeof data !== 'object') {
	                return callback(new Error('Input data given to \'' + params.source + '\' is not a valid GeoJSON object.'));
	            } else {
	                geojsonRewind(data, true);
	                try {
	                    if (params.filter) {
	                        var compiled = performance.createExpression(params.filter, {
	                            type: 'boolean',
	                            'property-type': 'data-driven',
	                            overridable: false,
	                            transition: false
	                        });
	                        if (compiled.result === 'error') {
	                            throw new Error(compiled.value.map(function (err) {
	                                return err.key + ': ' + err.message;
	                            }).join(', '));
	                        }
	                        var features = data.features.filter(function (feature) {
	                            return compiled.value.evaluate({ zoom: 0 }, feature);
	                        });
	                        data = {
	                            type: 'FeatureCollection',
	                            features: features
	                        };
	                    }
	                    this$1._geoJSONIndex = params.cluster ? new Supercluster(getSuperclusterOptions(params)).load(data.features) : geojsonvt(data, params.geojsonVtOptions);
	                } catch (err) {
	                    return callback(err);
	                }
	                this$1.loaded = {};
	                var result = {};
	                if (perf) {
	                    var resourceTimingData = perf.finish();
	                    if (resourceTimingData) {
	                        result.resourceTiming = {};
	                        result.resourceTiming[params.source] = JSON.parse(JSON.stringify(resourceTimingData));
	                    }
	                }
	                callback(null, result);
	            }
	        });
	    };
	    GeoJSONWorkerSource.prototype.coalesce = function coalesce() {
	        if (this._state === 'Coalescing') {
	            this._state = 'Idle';
	        } else if (this._state === 'NeedsLoadData') {
	            this._state = 'Coalescing';
	            this._loadData();
	        }
	    };
	    GeoJSONWorkerSource.prototype.reloadTile = function reloadTile(params, callback) {
	        var loaded = this.loaded, uid = params.uid;
	        if (loaded && loaded[uid]) {
	            return VectorTileWorkerSource.prototype.reloadTile.call(this, params, callback);
	        } else {
	            return this.loadTile(params, callback);
	        }
	    };
	    GeoJSONWorkerSource.prototype.loadGeoJSON = function loadGeoJSON(params, callback) {
	        if (params.request) {
	            performance.getJSON(params.request, callback);
	        } else if (typeof params.data === 'string') {
	            try {
	                return callback(null, JSON.parse(params.data));
	            } catch (e) {
	                return callback(new Error('Input data given to \'' + params.source + '\' is not a valid GeoJSON object.'));
	            }
	        } else {
	            return callback(new Error('Input data given to \'' + params.source + '\' is not a valid GeoJSON object.'));
	        }
	    };
	    GeoJSONWorkerSource.prototype.removeSource = function removeSource(params, callback) {
	        if (this._pendingCallback) {
	            this._pendingCallback(null, { abandoned: true });
	        }
	        callback();
	    };
	    GeoJSONWorkerSource.prototype.getClusterExpansionZoom = function getClusterExpansionZoom(params, callback) {
	        try {
	            callback(null, this._geoJSONIndex.getClusterExpansionZoom(params.clusterId));
	        } catch (e) {
	            callback(e);
	        }
	    };
	    GeoJSONWorkerSource.prototype.getClusterChildren = function getClusterChildren(params, callback) {
	        try {
	            callback(null, this._geoJSONIndex.getChildren(params.clusterId));
	        } catch (e) {
	            callback(e);
	        }
	    };
	    GeoJSONWorkerSource.prototype.getClusterLeaves = function getClusterLeaves(params, callback) {
	        try {
	            callback(null, this._geoJSONIndex.getLeaves(params.clusterId, params.limit, params.offset));
	        } catch (e) {
	            callback(e);
	        }
	    };
	    return GeoJSONWorkerSource;
	}(VectorTileWorkerSource);
	function getSuperclusterOptions(ref) {
	    var superclusterOptions = ref.superclusterOptions;
	    var clusterProperties = ref.clusterProperties;
	    if (!clusterProperties || !superclusterOptions) {
	        return superclusterOptions;
	    }
	    var mapExpressions = {};
	    var reduceExpressions = {};
	    var globals = {
	        accumulated: null,
	        zoom: 0
	    };
	    var feature = { properties: null };
	    var propertyNames = Object.keys(clusterProperties);
	    for (var i = 0, list = propertyNames; i < list.length; i += 1) {
	        var key = list[i];
	        var ref$1 = clusterProperties[key];
	        var operator = ref$1[0];
	        var mapExpression = ref$1[1];
	        var mapExpressionParsed = performance.createExpression(mapExpression);
	        var reduceExpressionParsed = performance.createExpression(typeof operator === 'string' ? [
	            operator,
	            ['accumulated'],
	            [
	                'get',
	                key
	            ]
	        ] : operator);
	        mapExpressions[key] = mapExpressionParsed.value;
	        reduceExpressions[key] = reduceExpressionParsed.value;
	    }
	    superclusterOptions.map = function (pointProperties) {
	        feature.properties = pointProperties;
	        var properties = {};
	        for (var i = 0, list = propertyNames; i < list.length; i += 1) {
	            var key = list[i];
	            properties[key] = mapExpressions[key].evaluate(globals, feature);
	        }
	        return properties;
	    };
	    superclusterOptions.reduce = function (accumulated, clusterProperties) {
	        feature.properties = clusterProperties;
	        for (var i = 0, list = propertyNames; i < list.length; i += 1) {
	            var key = list[i];
	            globals.accumulated = accumulated[key];
	            accumulated[key] = reduceExpressions[key].evaluate(globals, feature);
	        }
	    };
	    return superclusterOptions;
	}

	var Worker = function Worker(self) {
	    var this$1 = this;
	    this.self = self;
	    this.actor = new performance.Actor(self, this);
	    this.layerIndexes = {};
	    this.availableImages = {};
	    this.workerSourceTypes = {
	        vector: VectorTileWorkerSource,
	        geojson: GeoJSONWorkerSource
	    };
	    this.workerSources = {};
	    this.demWorkerSources = {};
	    this.self.registerWorkerSource = function (name, WorkerSource) {
	        if (this$1.workerSourceTypes[name]) {
	            throw new Error('Worker source with name "' + name + '" already registered.');
	        }
	        this$1.workerSourceTypes[name] = WorkerSource;
	    };
	    this.self.registerRTLTextPlugin = function (rtlTextPlugin) {
	        if (performance.plugin.isParsed()) {
	            throw new Error('RTL text plugin already registered.');
	        }
	        performance.plugin['applyArabicShaping'] = rtlTextPlugin.applyArabicShaping;
	        performance.plugin['processBidirectionalText'] = rtlTextPlugin.processBidirectionalText;
	        performance.plugin['processStyledBidirectionalText'] = rtlTextPlugin.processStyledBidirectionalText;
	    };
	};
	Worker.prototype.setReferrer = function setReferrer(mapID, referrer) {
	    this.referrer = referrer;
	};
	Worker.prototype.setImages = function setImages(mapId, images, callback) {
	    this.availableImages[mapId] = images;
	    for (var workerSource in this.workerSources[mapId]) {
	        var ws = this.workerSources[mapId][workerSource];
	        for (var source in ws) {
	            ws[source].availableImages = images;
	        }
	    }
	    callback();
	};
	Worker.prototype.setLayers = function setLayers(mapId, layers, callback) {
	    this.getLayerIndex(mapId).replace(layers);
	    callback();
	};
	Worker.prototype.updateLayers = function updateLayers(mapId, params, callback) {
	    this.getLayerIndex(mapId).update(params.layers, params.removedIds);
	    callback();
	};
	Worker.prototype.loadTile = function loadTile(mapId, params, callback) {
	    this.getWorkerSource(mapId, params.type, params.source).loadTile(params, callback);
	};
	Worker.prototype.loadDEMTile = function loadDEMTile(mapId, params, callback) {
	    this.getDEMWorkerSource(mapId, params.source).loadTile(params, callback);
	};
	Worker.prototype.reloadTile = function reloadTile(mapId, params, callback) {
	    this.getWorkerSource(mapId, params.type, params.source).reloadTile(params, callback);
	};
	Worker.prototype.abortTile = function abortTile(mapId, params, callback) {
	    this.getWorkerSource(mapId, params.type, params.source).abortTile(params, callback);
	};
	Worker.prototype.removeTile = function removeTile(mapId, params, callback) {
	    this.getWorkerSource(mapId, params.type, params.source).removeTile(params, callback);
	};
	Worker.prototype.removeDEMTile = function removeDEMTile(mapId, params) {
	    this.getDEMWorkerSource(mapId, params.source).removeTile(params);
	};
	Worker.prototype.removeSource = function removeSource(mapId, params, callback) {
	    if (!this.workerSources[mapId] || !this.workerSources[mapId][params.type] || !this.workerSources[mapId][params.type][params.source]) {
	        return;
	    }
	    var worker = this.workerSources[mapId][params.type][params.source];
	    delete this.workerSources[mapId][params.type][params.source];
	    if (worker.removeSource !== undefined) {
	        worker.removeSource(params, callback);
	    } else {
	        callback();
	    }
	};
	Worker.prototype.loadWorkerSource = function loadWorkerSource(map, params, callback) {
	    try {
	        this.self.importScripts(params.url);
	        callback();
	    } catch (e) {
	        callback(e.toString());
	    }
	};
	Worker.prototype.syncRTLPluginState = function syncRTLPluginState(map, state, callback) {
	    try {
	        performance.plugin.setState(state);
	        var pluginURL = performance.plugin.getPluginURL();
	        if (performance.plugin.isLoaded() && !performance.plugin.isParsed() && pluginURL != null) {
	            this.self.importScripts(pluginURL);
	            var complete = performance.plugin.isParsed();
	            var error = complete ? undefined : new Error('RTL Text Plugin failed to import scripts from ' + pluginURL);
	            callback(error, complete);
	        }
	    } catch (e) {
	        callback(e.toString());
	    }
	};
	Worker.prototype.getAvailableImages = function getAvailableImages(mapId) {
	    var availableImages = this.availableImages[mapId];
	    if (!availableImages) {
	        availableImages = [];
	    }
	    return availableImages;
	};
	Worker.prototype.getLayerIndex = function getLayerIndex(mapId) {
	    var layerIndexes = this.layerIndexes[mapId];
	    if (!layerIndexes) {
	        layerIndexes = this.layerIndexes[mapId] = new StyleLayerIndex();
	    }
	    return layerIndexes;
	};
	Worker.prototype.getWorkerSource = function getWorkerSource(mapId, type, source) {
	    var this$1 = this;
	    if (!this.workerSources[mapId]) {
	        this.workerSources[mapId] = {};
	    }
	    if (!this.workerSources[mapId][type]) {
	        this.workerSources[mapId][type] = {};
	    }
	    if (!this.workerSources[mapId][type][source]) {
	        var actor = {
	            send: function (type, data, callback) {
	                this$1.actor.send(type, data, callback, mapId);
	            }
	        };
	        this.workerSources[mapId][type][source] = new this.workerSourceTypes[type](actor, this.getLayerIndex(mapId), this.getAvailableImages(mapId));
	    }
	    return this.workerSources[mapId][type][source];
	};
	Worker.prototype.getDEMWorkerSource = function getDEMWorkerSource(mapId, source) {
	    if (!this.demWorkerSources[mapId]) {
	        this.demWorkerSources[mapId] = {};
	    }
	    if (!this.demWorkerSources[mapId][source]) {
	        this.demWorkerSources[mapId][source] = new RasterDEMTileWorkerSource();
	    }
	    return this.demWorkerSources[mapId][source];
	};
	Worker.prototype.enforceCacheSizeLimit = function enforceCacheSizeLimit$1(mapId, limit) {
	    performance.enforceCacheSizeLimit(limit);
	};
	if (typeof WorkerGlobalScope !== 'undefined' && typeof self !== 'undefined' && self instanceof WorkerGlobalScope) {
	    self.worker = new Worker(self);
	}

	return Worker;

	});

	define(['./shared'], function (performance) {
	var mapboxGlSupported = performance.createCommonjsModule(function (module) {
	if ( module.exports) {
	    module.exports = isSupported;
	} else if (window) {
	    window.mapboxgl = window.mapboxgl || {};
	    window.mapboxgl.supported = isSupported;
	    window.mapboxgl.notSupportedReason = notSupportedReason;
	}
	function isSupported(options) {
	    return !notSupportedReason(options);
	}
	function notSupportedReason(options) {
	    if (!isBrowser()) {
	        return 'not a browser';
	    }
	    if (!isArraySupported()) {
	        return 'insufficent Array support';
	    }
	    if (!isFunctionSupported()) {
	        return 'insufficient Function support';
	    }
	    if (!isObjectSupported()) {
	        return 'insufficient Object support';
	    }
	    if (!isJSONSupported()) {
	        return 'insufficient JSON support';
	    }
	    if (!isWorkerSupported()) {
	        return 'insufficient worker support';
	    }
	    if (!isUint8ClampedArraySupported()) {
	        return 'insufficient Uint8ClampedArray support';
	    }
	    if (!isArrayBufferSupported()) {
	        return 'insufficient ArrayBuffer support';
	    }
	    if (!isCanvasGetImageDataSupported()) {
	        return 'insufficient Canvas/getImageData support';
	    }
	    if (!isWebGLSupportedCached(options && options.failIfMajorPerformanceCaveat)) {
	        return 'insufficient WebGL support';
	    }
	}
	function isBrowser() {
	    return typeof window !== 'undefined' && typeof document !== 'undefined';
	}
	function isArraySupported() {
	    return Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray;
	}
	function isFunctionSupported() {
	    return Function.prototype && Function.prototype.bind;
	}
	function isObjectSupported() {
	    return Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions;
	}
	function isJSONSupported() {
	    return 'JSON' in window && 'parse' in JSON && 'stringify' in JSON;
	}
	function isWorkerSupported() {
	    if (!('Worker' in window && 'Blob' in window && 'URL' in window)) {
	        return false;
	    }
	    var blob = new Blob([''], { type: 'text/javascript' });
	    var workerURL = URL.createObjectURL(blob);
	    var supported;
	    var worker;
	    try {
	        worker = new Worker(workerURL);
	        supported = true;
	    } catch (e) {
	        supported = false;
	    }
	    if (worker) {
	        worker.terminate();
	    }
	    URL.revokeObjectURL(workerURL);
	    return supported;
	}
	function isUint8ClampedArraySupported() {
	    return 'Uint8ClampedArray' in window;
	}
	function isArrayBufferSupported() {
	    return ArrayBuffer.isView;
	}
	function isCanvasGetImageDataSupported() {
	    var canvas = document.createElement('canvas');
	    canvas.width = canvas.height = 1;
	    var context = canvas.getContext('2d');
	    if (!context) {
	        return false;
	    }
	    var imageData = context.getImageData(0, 0, 1, 1);
	    return imageData && imageData.width === canvas.width;
	}
	var isWebGLSupportedCache = {};
	function isWebGLSupportedCached(failIfMajorPerformanceCaveat) {
	    if (isWebGLSupportedCache[failIfMajorPerformanceCaveat] === undefined) {
	        isWebGLSupportedCache[failIfMajorPerformanceCaveat] = isWebGLSupported(failIfMajorPerformanceCaveat);
	    }
	    return isWebGLSupportedCache[failIfMajorPerformanceCaveat];
	}
	isSupported.webGLContextAttributes = {
	    antialias: false,
	    alpha: true,
	    stencil: true,
	    depth: true
	};
	function getWebGLContext(failIfMajorPerformanceCaveat) {
	    var canvas = document.createElement('canvas');
	    var attributes = Object.create(isSupported.webGLContextAttributes);
	    attributes.failIfMajorPerformanceCaveat = failIfMajorPerformanceCaveat;
	    if (canvas.probablySupportsContext) {
	        return canvas.probablySupportsContext('webgl', attributes) || canvas.probablySupportsContext('experimental-webgl', attributes);
	    } else if (canvas.supportsContext) {
	        return canvas.supportsContext('webgl', attributes) || canvas.supportsContext('experimental-webgl', attributes);
	    } else {
	        return canvas.getContext('webgl', attributes) || canvas.getContext('experimental-webgl', attributes);
	    }
	}
	function isWebGLSupported(failIfMajorPerformanceCaveat) {
	    var gl = getWebGLContext(failIfMajorPerformanceCaveat);
	    if (!gl) {
	        return false;
	    }
	    var shader = gl.createShader(gl.VERTEX_SHADER);
	    if (!shader || gl.isContextLost()) {
	        return false;
	    }
	    gl.shaderSource(shader, 'void main() {}');
	    gl.compileShader(shader);
	    return gl.getShaderParameter(shader, gl.COMPILE_STATUS) === true;
	}
	});

	var DOM = {};
	DOM.create = function (tagName, className, container) {
	    var el = performance.window.document.createElement(tagName);
	    if (className !== undefined) {
	        el.className = className;
	    }
	    if (container) {
	        container.appendChild(el);
	    }
	    return el;
	};
	DOM.createNS = function (namespaceURI, tagName) {
	    var el = performance.window.document.createElementNS(namespaceURI, tagName);
	    return el;
	};
	var docStyle = performance.window.document && performance.window.document.documentElement.style;
	function testProp(props) {
	    if (!docStyle) {
	        return props[0];
	    }
	    for (var i = 0; i < props.length; i++) {
	        if (props[i] in docStyle) {
	            return props[i];
	        }
	    }
	    return props[0];
	}
	var selectProp = testProp([
	    'userSelect',
	    'MozUserSelect',
	    'WebkitUserSelect',
	    'msUserSelect'
	]);
	var userSelect;
	DOM.disableDrag = function () {
	    if (docStyle && selectProp) {
	        userSelect = docStyle[selectProp];
	        docStyle[selectProp] = 'none';
	    }
	};
	DOM.enableDrag = function () {
	    if (docStyle && selectProp) {
	        docStyle[selectProp] = userSelect;
	    }
	};
	var transformProp = testProp([
	    'transform',
	    'WebkitTransform'
	]);
	DOM.setTransform = function (el, value) {
	    el.style[transformProp] = value;
	};
	var passiveSupported = false;
	try {
	    var options$1 = Object.defineProperty({}, 'passive', {
	        get: function get() {
	            passiveSupported = true;
	        }
	    });
	    performance.window.addEventListener('test', options$1, options$1);
	    performance.window.removeEventListener('test', options$1, options$1);
	} catch (err) {
	    passiveSupported = false;
	}
	DOM.addEventListener = function (target, type, callback, options) {
	    if (options === void 0)
	        options = {};
	    if ('passive' in options && passiveSupported) {
	        target.addEventListener(type, callback, options);
	    } else {
	        target.addEventListener(type, callback, options.capture);
	    }
	};
	DOM.removeEventListener = function (target, type, callback, options) {
	    if (options === void 0)
	        options = {};
	    if ('passive' in options && passiveSupported) {
	        target.removeEventListener(type, callback, options);
	    } else {
	        target.removeEventListener(type, callback, options.capture);
	    }
	};
	var suppressClick = function (e) {
	    e.preventDefault();
	    e.stopPropagation();
	    performance.window.removeEventListener('click', suppressClick, true);
	};
	DOM.suppressClick = function () {
	    performance.window.addEventListener('click', suppressClick, true);
	    performance.window.setTimeout(function () {
	        performance.window.removeEventListener('click', suppressClick, true);
	    }, 0);
	};
	DOM.mousePos = function (el, e) {
	    var rect = el.getBoundingClientRect();
	    return new performance.Point(e.clientX - rect.left - el.clientLeft, e.clientY - rect.top - el.clientTop);
	};
	DOM.touchPos = function (el, touches) {
	    var rect = el.getBoundingClientRect(), points = [];
	    for (var i = 0; i < touches.length; i++) {
	        points.push(new performance.Point(touches[i].clientX - rect.left - el.clientLeft, touches[i].clientY - rect.top - el.clientTop));
	    }
	    return points;
	};
	DOM.mouseButton = function (e) {
	    if (typeof performance.window.InstallTrigger !== 'undefined' && e.button === 2 && e.ctrlKey && performance.window.navigator.platform.toUpperCase().indexOf('MAC') >= 0) {
	        return 0;
	    }
	    return e.button;
	};
	DOM.remove = function (node) {
	    if (node.parentNode) {
	        node.parentNode.removeChild(node);
	    }
	};

	function loadSprite (baseURL, requestManager, callback) {
	    var json, image, error;
	    var format = performance.browser.devicePixelRatio > 1 ? '@2x' : '';
	    var jsonRequest = performance.getJSON(requestManager.transformRequest(requestManager.normalizeSpriteURL(baseURL, format, '.json'), performance.ResourceType.SpriteJSON), function (err, data) {
	        jsonRequest = null;
	        if (!error) {
	            error = err;
	            json = data;
	            maybeComplete();
	        }
	    });
	    var imageRequest = performance.getImage(requestManager.transformRequest(requestManager.normalizeSpriteURL(baseURL, format, '.png'), performance.ResourceType.SpriteImage), function (err, img) {
	        imageRequest = null;
	        if (!error) {
	            error = err;
	            image = img;
	            maybeComplete();
	        }
	    });
	    function maybeComplete() {
	        if (error) {
	            callback(error);
	        } else if (json && image) {
	            var imageData = performance.browser.getImageData(image);
	            var result = {};
	            for (var id in json) {
	                var ref = json[id];
	                var width = ref.width;
	                var height = ref.height;
	                var x = ref.x;
	                var y = ref.y;
	                var sdf = ref.sdf;
	                var pixelRatio = ref.pixelRatio;
	                var stretchX = ref.stretchX;
	                var stretchY = ref.stretchY;
	                var content = ref.content;
	                var data = new performance.RGBAImage({
	                    width: width,
	                    height: height
	                });
	                performance.RGBAImage.copy(imageData, data, {
	                    x: x,
	                    y: y
	                }, {
	                    x: 0,
	                    y: 0
	                }, {
	                    width: width,
	                    height: height
	                });
	                result[id] = {
	                    data: data,
	                    pixelRatio: pixelRatio,
	                    sdf: sdf,
	                    stretchX: stretchX,
	                    stretchY: stretchY,
	                    content: content
	                };
	            }
	            callback(null, result);
	        }
	    }
	    return {
	        cancel: function cancel() {
	            if (jsonRequest) {
	                jsonRequest.cancel();
	                jsonRequest = null;
	            }
	            if (imageRequest) {
	                imageRequest.cancel();
	                imageRequest = null;
	            }
	        }
	    };
	}

	function renderStyleImage(image) {
	    var userImage = image.userImage;
	    if (userImage && userImage.render) {
	        var updated = userImage.render();
	        if (updated) {
	            image.data.replace(new Uint8Array(userImage.data.buffer));
	            return true;
	        }
	    }
	    return false;
	}

	var padding = 1;
	var ImageManager = function (Evented) {
	    function ImageManager() {
	        Evented.call(this);
	        this.images = {};
	        this.updatedImages = {};
	        this.callbackDispatchedThisFrame = {};
	        this.loaded = false;
	        this.requestors = [];
	        this.patterns = {};
	        this.atlasImage = new performance.RGBAImage({
	            width: 1,
	            height: 1
	        });
	        this.dirty = true;
	    }
	    if (Evented)
	        ImageManager.__proto__ = Evented;
	    ImageManager.prototype = Object.create(Evented && Evented.prototype);
	    ImageManager.prototype.constructor = ImageManager;
	    ImageManager.prototype.isLoaded = function isLoaded() {
	        return this.loaded;
	    };
	    ImageManager.prototype.setLoaded = function setLoaded(loaded) {
	        if (this.loaded === loaded) {
	            return;
	        }
	        this.loaded = loaded;
	        if (loaded) {
	            for (var i = 0, list = this.requestors; i < list.length; i += 1) {
	                var ref = list[i];
	                var ids = ref.ids;
	                var callback = ref.callback;
	                this._notify(ids, callback);
	            }
	            this.requestors = [];
	        }
	    };
	    ImageManager.prototype.getImage = function getImage(id) {
	        return this.images[id];
	    };
	    ImageManager.prototype.addImage = function addImage(id, image) {
	        if (this._validate(id, image)) {
	            this.images[id] = image;
	        }
	    };
	    ImageManager.prototype._validate = function _validate(id, image) {
	        var valid = true;
	        if (!this._validateStretch(image.stretchX, image.data && image.data.width)) {
	            this.fire(new performance.ErrorEvent(new Error('Image "' + id + '" has invalid "stretchX" value')));
	            valid = false;
	        }
	        if (!this._validateStretch(image.stretchY, image.data && image.data.height)) {
	            this.fire(new performance.ErrorEvent(new Error('Image "' + id + '" has invalid "stretchY" value')));
	            valid = false;
	        }
	        if (!this._validateContent(image.content, image)) {
	            this.fire(new performance.ErrorEvent(new Error('Image "' + id + '" has invalid "content" value')));
	            valid = false;
	        }
	        return valid;
	    };
	    ImageManager.prototype._validateStretch = function _validateStretch(stretch, size) {
	        if (!stretch) {
	            return true;
	        }
	        var last = 0;
	        for (var i = 0, list = stretch; i < list.length; i += 1) {
	            var part = list[i];
	            if (part[0] < last || part[1] < part[0] || size < part[1]) {
	                return false;
	            }
	            last = part[1];
	        }
	        return true;
	    };
	    ImageManager.prototype._validateContent = function _validateContent(content, image) {
	        if (!content) {
	            return true;
	        }
	        if (content.length !== 4) {
	            return false;
	        }
	        if (content[0] < 0 || image.data.width < content[0]) {
	            return false;
	        }
	        if (content[1] < 0 || image.data.height < content[1]) {
	            return false;
	        }
	        if (content[2] < 0 || image.data.width < content[2]) {
	            return false;
	        }
	        if (content[3] < 0 || image.data.height < content[3]) {
	            return false;
	        }
	        if (content[2] < content[0]) {
	            return false;
	        }
	        if (content[3] < content[1]) {
	            return false;
	        }
	        return true;
	    };
	    ImageManager.prototype.updateImage = function updateImage(id, image) {
	        var oldImage = this.images[id];
	        image.version = oldImage.version + 1;
	        this.images[id] = image;
	        this.updatedImages[id] = true;
	    };
	    ImageManager.prototype.removeImage = function removeImage(id) {
	        var image = this.images[id];
	        delete this.images[id];
	        delete this.patterns[id];
	        if (image.userImage && image.userImage.onRemove) {
	            image.userImage.onRemove();
	        }
	    };
	    ImageManager.prototype.listImages = function listImages() {
	        return Object.keys(this.images);
	    };
	    ImageManager.prototype.getImages = function getImages(ids, callback) {
	        var hasAllDependencies = true;
	        if (!this.isLoaded()) {
	            for (var i = 0, list = ids; i < list.length; i += 1) {
	                var id = list[i];
	                if (!this.images[id]) {
	                    hasAllDependencies = false;
	                }
	            }
	        }
	        if (this.isLoaded() || hasAllDependencies) {
	            this._notify(ids, callback);
	        } else {
	            this.requestors.push({
	                ids: ids,
	                callback: callback
	            });
	        }
	    };
	    ImageManager.prototype._notify = function _notify(ids, callback) {
	        var response = {};
	        for (var i = 0, list = ids; i < list.length; i += 1) {
	            var id = list[i];
	            if (!this.images[id]) {
	                this.fire(new performance.Event('styleimagemissing', { id: id }));
	            }
	            var image = this.images[id];
	            if (image) {
	                response[id] = {
	                    data: image.data.clone(),
	                    pixelRatio: image.pixelRatio,
	                    sdf: image.sdf,
	                    version: image.version,
	                    stretchX: image.stretchX,
	                    stretchY: image.stretchY,
	                    content: image.content,
	                    hasRenderCallback: Boolean(image.userImage && image.userImage.render)
	                };
	            } else {
	                performance.warnOnce('Image "' + id + '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.');
	            }
	        }
	        callback(null, response);
	    };
	    ImageManager.prototype.getPixelSize = function getPixelSize() {
	        var ref = this.atlasImage;
	        var width = ref.width;
	        var height = ref.height;
	        return {
	            width: width,
	            height: height
	        };
	    };
	    ImageManager.prototype.getPattern = function getPattern(id) {
	        var pattern = this.patterns[id];
	        var image = this.getImage(id);
	        if (!image) {
	            return null;
	        }
	        if (pattern && pattern.position.version === image.version) {
	            return pattern.position;
	        }
	        if (!pattern) {
	            var w = image.data.width + padding * 2;
	            var h = image.data.height + padding * 2;
	            var bin = {
	                w: w,
	                h: h,
	                x: 0,
	                y: 0
	            };
	            var position = new performance.ImagePosition(bin, image);
	            this.patterns[id] = {
	                bin: bin,
	                position: position
	            };
	        } else {
	            pattern.position.version = image.version;
	        }
	        this._updatePatternAtlas();
	        return this.patterns[id].position;
	    };
	    ImageManager.prototype.bind = function bind(context) {
	        var gl = context.gl;
	        if (!this.atlasTexture) {
	            this.atlasTexture = new performance.Texture(context, this.atlasImage, gl.RGBA);
	        } else if (this.dirty) {
	            this.atlasTexture.update(this.atlasImage);
	            this.dirty = false;
	        }
	        this.atlasTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
	    };
	    ImageManager.prototype._updatePatternAtlas = function _updatePatternAtlas() {
	        var bins = [];
	        for (var id in this.patterns) {
	            bins.push(this.patterns[id].bin);
	        }
	        var ref = performance.potpack(bins);
	        var w = ref.w;
	        var h = ref.h;
	        var dst = this.atlasImage;
	        dst.resize({
	            width: w || 1,
	            height: h || 1
	        });
	        for (var id$1 in this.patterns) {
	            var ref$1 = this.patterns[id$1];
	            var bin = ref$1.bin;
	            var x = bin.x + padding;
	            var y = bin.y + padding;
	            var src = this.images[id$1].data;
	            var w$1 = src.width;
	            var h$1 = src.height;
	            performance.RGBAImage.copy(src, dst, {
	                x: 0,
	                y: 0
	            }, {
	                x: x,
	                y: y
	            }, {
	                width: w$1,
	                height: h$1
	            });
	            performance.RGBAImage.copy(src, dst, {
	                x: 0,
	                y: h$1 - 1
	            }, {
	                x: x,
	                y: y - 1
	            }, {
	                width: w$1,
	                height: 1
	            });
	            performance.RGBAImage.copy(src, dst, {
	                x: 0,
	                y: 0
	            }, {
	                x: x,
	                y: y + h$1
	            }, {
	                width: w$1,
	                height: 1
	            });
	            performance.RGBAImage.copy(src, dst, {
	                x: w$1 - 1,
	                y: 0
	            }, {
	                x: x - 1,
	                y: y
	            }, {
	                width: 1,
	                height: h$1
	            });
	            performance.RGBAImage.copy(src, dst, {
	                x: 0,
	                y: 0
	            }, {
	                x: x + w$1,
	                y: y
	            }, {
	                width: 1,
	                height: h$1
	            });
	        }
	        this.dirty = true;
	    };
	    ImageManager.prototype.beginFrame = function beginFrame() {
	        this.callbackDispatchedThisFrame = {};
	    };
	    ImageManager.prototype.dispatchRenderCallbacks = function dispatchRenderCallbacks(ids) {
	        for (var i = 0, list = ids; i < list.length; i += 1) {
	            var id = list[i];
	            if (this.callbackDispatchedThisFrame[id]) {
	                continue;
	            }
	            this.callbackDispatchedThisFrame[id] = true;
	            var image = this.images[id];
	            var updated = renderStyleImage(image);
	            if (updated) {
	                this.updateImage(id, image);
	            }
	        }
	    };
	    return ImageManager;
	}(performance.Evented);

	function loadGlyphRange (fontstack, range, urlTemplate, requestManager, callback) {
	    var begin = range * 256;
	    var end = begin + 255;
	    var request = requestManager.transformRequest(requestManager.normalizeGlyphsURL(urlTemplate).replace('{fontstack}', fontstack).replace('{range}', begin + '-' + end), performance.ResourceType.Glyphs);
	    performance.getArrayBuffer(request, function (err, data) {
	        if (err) {
	            callback(err);
	        } else if (data) {
	            var glyphs = {};
	            for (var i = 0, list = performance.parseGlyphPBF(data); i < list.length; i += 1) {
	                var glyph = list[i];
	                glyphs[glyph.id] = glyph;
	            }
	            callback(null, glyphs);
	        }
	    });
	}

	var tinySdf = TinySDF;
	var default_1 = TinySDF;
	var INF = 100000000000000000000;
	function TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {
	    this.fontSize = fontSize || 24;
	    this.buffer = buffer === undefined ? 3 : buffer;
	    this.cutoff = cutoff || 0.25;
	    this.fontFamily = fontFamily || 'sans-serif';
	    this.fontWeight = fontWeight || 'normal';
	    this.radius = radius || 8;
	    var size = this.size = this.fontSize + this.buffer * 2;
	    var gridSize = size + this.buffer * 2;
	    this.canvas = document.createElement('canvas');
	    this.canvas.width = this.canvas.height = size;
	    this.ctx = this.canvas.getContext('2d');
	    this.ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;
	    this.ctx.textAlign = 'left';
	    this.ctx.fillStyle = 'black';
	    this.gridOuter = new Float64Array(gridSize * gridSize);
	    this.gridInner = new Float64Array(gridSize * gridSize);
	    this.f = new Float64Array(gridSize);
	    this.z = new Float64Array(gridSize + 1);
	    this.v = new Uint16Array(gridSize);
	    this.useMetrics = this.ctx.measureText('A').actualBoundingBoxLeft !== undefined;
	    this.middle = Math.round(size / 2 * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));
	}
	function prepareGrids(imgData, width, height, glyphWidth, glyphHeight, gridOuter, gridInner) {
	    gridOuter.fill(INF, 0, width * height);
	    gridInner.fill(0, 0, width * height);
	    var offset = (width - glyphWidth) / 2;
	    for (var y = 0; y < glyphHeight; y++) {
	        for (var x = 0; x < glyphWidth; x++) {
	            var j = (y + offset) * width + x + offset;
	            var a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255;
	            if (a === 1) {
	                gridOuter[j] = 0;
	                gridInner[j] = INF;
	            } else if (a === 0) {
	                gridOuter[j] = INF;
	                gridInner[j] = 0;
	            } else {
	                var b = Math.max(0, 0.5 - a);
	                var c = Math.max(0, a - 0.5);
	                gridOuter[j] = b * b;
	                gridInner[j] = c * c;
	            }
	        }
	    }
	}
	function extractAlpha(alphaChannel, width, height, gridOuter, gridInner, radius, cutoff) {
	    for (var i = 0; i < width * height; i++) {
	        var d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
	        alphaChannel[i] = Math.round(255 - 255 * (d / radius + cutoff));
	    }
	}
	TinySDF.prototype._draw = function (char, getMetrics) {
	    var textMetrics = this.ctx.measureText(char);
	    var advance = textMetrics.width;
	    var doubleBuffer = 2 * this.buffer;
	    var width, glyphWidth, height, glyphHeight, top;
	    var imgTop, imgLeft, baselinePosition;
	    if (getMetrics && this.useMetrics) {
	        top = Math.floor(textMetrics.actualBoundingBoxAscent);
	        baselinePosition = this.buffer + Math.ceil(textMetrics.actualBoundingBoxAscent);
	        imgTop = this.buffer;
	        imgLeft = this.buffer;
	        glyphWidth = Math.min(this.size, Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft));
	        glyphHeight = Math.min(this.size - imgTop, Math.ceil(textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent));
	        width = glyphWidth + doubleBuffer;
	        height = glyphHeight + doubleBuffer;
	        this.ctx.textBaseline = 'alphabetic';
	    } else {
	        width = glyphWidth = this.size;
	        height = glyphHeight = this.size;
	        top = 19 * this.fontSize / 24;
	        imgTop = imgLeft = 0;
	        baselinePosition = this.middle;
	        this.ctx.textBaseline = 'middle';
	    }
	    var imgData;
	    if (glyphWidth && glyphHeight) {
	        this.ctx.clearRect(imgLeft, imgTop, glyphWidth, glyphHeight);
	        this.ctx.fillText(char, this.buffer, baselinePosition);
	        imgData = this.ctx.getImageData(imgLeft, imgTop, glyphWidth, glyphHeight);
	    }
	    var alphaChannel = new Uint8ClampedArray(width * height);
	    prepareGrids(imgData, width, height, glyphWidth, glyphHeight, this.gridOuter, this.gridInner);
	    edt(this.gridOuter, width, height, this.f, this.v, this.z);
	    edt(this.gridInner, width, height, this.f, this.v, this.z);
	    extractAlpha(alphaChannel, width, height, this.gridOuter, this.gridInner, this.radius, this.cutoff);
	    return {
	        data: alphaChannel,
	        metrics: {
	            width: glyphWidth,
	            height: glyphHeight,
	            sdfWidth: width,
	            sdfHeight: height,
	            top: top,
	            left: 0,
	            advance: advance
	        }
	    };
	};
	TinySDF.prototype.draw = function (char) {
	    return this._draw(char, false).data;
	};
	TinySDF.prototype.drawWithMetrics = function (char) {
	    return this._draw(char, true);
	};
	function edt(data, width, height, f, v, z) {
	    for (var x = 0; x < width; x++) {
	        edt1d(data, x, width, height, f, v, z);
	    }
	    for (var y = 0; y < height; y++) {
	        edt1d(data, y * width, 1, width, f, v, z);
	    }
	}
	function edt1d(grid, offset, stride, length, f, v, z) {
	    var q, k, s, r;
	    v[0] = 0;
	    z[0] = -INF;
	    z[1] = INF;
	    for (q = 0; q < length; q++) {
	        f[q] = grid[offset + q * stride];
	    }
	    for (q = 1, k = 0, s = 0; q < length; q++) {
	        do {
	            r = v[k];
	            s = (f[q] - f[r] + q * q - r * r) / (q - r) / 2;
	        } while (s <= z[k] && --k > -1);
	        k++;
	        v[k] = q;
	        z[k] = s;
	        z[k + 1] = INF;
	    }
	    for (q = 0, k = 0; q < length; q++) {
	        while (z[k + 1] < q) {
	            k++;
	        }
	        r = v[k];
	        grid[offset + q * stride] = f[r] + (q - r) * (q - r);
	    }
	}
	tinySdf.default = default_1;

	var GlyphManager = function GlyphManager(requestManager, localIdeographFontFamily) {
	    this.requestManager = requestManager;
	    this.localIdeographFontFamily = localIdeographFontFamily;
	    this.entries = {};
	};
	GlyphManager.prototype.setURL = function setURL(url) {
	    this.url = url;
	};
	GlyphManager.prototype.getGlyphs = function getGlyphs(glyphs, callback) {
	    var this$1 = this;
	    var all = [];
	    for (var stack in glyphs) {
	        for (var i = 0, list = glyphs[stack]; i < list.length; i += 1) {
	            var id = list[i];
	            all.push({
	                stack: stack,
	                id: id
	            });
	        }
	    }
	    performance.asyncAll(all, function (ref, callback) {
	        var stack = ref.stack;
	        var id = ref.id;
	        var entry = this$1.entries[stack];
	        if (!entry) {
	            entry = this$1.entries[stack] = {
	                glyphs: {},
	                requests: {},
	                ranges: {}
	            };
	        }
	        var glyph = entry.glyphs[id];
	        if (glyph !== undefined) {
	            callback(null, {
	                stack: stack,
	                id: id,
	                glyph: glyph
	            });
	            return;
	        }
	        glyph = this$1._tinySDF(entry, stack, id);
	        if (glyph) {
	            entry.glyphs[id] = glyph;
	            callback(null, {
	                stack: stack,
	                id: id,
	                glyph: glyph
	            });
	            return;
	        }
	        var range = Math.floor(id / 256);
	        if (range * 256 > 65535) {
	            callback(new Error('glyphs > 65535 not supported'));
	            return;
	        }
	        if (entry.ranges[range]) {
	            callback(null, {
	                stack: stack,
	                id: id,
	                glyph: glyph
	            });
	            return;
	        }
	        var requests = entry.requests[range];
	        if (!requests) {
	            requests = entry.requests[range] = [];
	            GlyphManager.loadGlyphRange(stack, range, this$1.url, this$1.requestManager, function (err, response) {
	                if (response) {
	                    for (var id in response) {
	                        if (!this$1._doesCharSupportLocalGlyph(+id)) {
	                            entry.glyphs[+id] = response[+id];
	                        }
	                    }
	                    entry.ranges[range] = true;
	                }
	                for (var i = 0, list = requests; i < list.length; i += 1) {
	                    var cb = list[i];
	                    cb(err, response);
	                }
	                delete entry.requests[range];
	            });
	        }
	        requests.push(function (err, result) {
	            if (err) {
	                callback(err);
	            } else if (result) {
	                callback(null, {
	                    stack: stack,
	                    id: id,
	                    glyph: result[id] || null
	                });
	            }
	        });
	    }, function (err, glyphs) {
	        if (err) {
	            callback(err);
	        } else if (glyphs) {
	            var result = {};
	            for (var i = 0, list = glyphs; i < list.length; i += 1) {
	                var ref = list[i];
	                var stack = ref.stack;
	                var id = ref.id;
	                var glyph = ref.glyph;
	                (result[stack] || (result[stack] = {}))[id] = glyph && {
	                    id: glyph.id,
	                    bitmap: glyph.bitmap.clone(),
	                    metrics: glyph.metrics
	                };
	            }
	            callback(null, result);
	        }
	    });
	};
	GlyphManager.prototype._doesCharSupportLocalGlyph = function _doesCharSupportLocalGlyph(id) {
	    return !!this.localIdeographFontFamily && (performance.isChar['CJK Unified Ideographs'](id) || performance.isChar['Hangul Syllables'](id) || performance.isChar['Hiragana'](id) || performance.isChar['Katakana'](id));
	};
	GlyphManager.prototype._tinySDF = function _tinySDF(entry, stack, id) {
	    var family = this.localIdeographFontFamily;
	    if (!family) {
	        return;
	    }
	    if (!this._doesCharSupportLocalGlyph(id)) {
	        return;
	    }
	    var tinySDF = entry.tinySDF;
	    if (!tinySDF) {
	        var fontWeight = '400';
	        if (/bold/i.test(stack)) {
	            fontWeight = '900';
	        } else if (/medium/i.test(stack)) {
	            fontWeight = '500';
	        } else if (/light/i.test(stack)) {
	            fontWeight = '200';
	        }
	        tinySDF = entry.tinySDF = new GlyphManager.TinySDF(24, 3, 8, 0.25, family, fontWeight);
	    }
	    return {
	        id: id,
	        bitmap: new performance.AlphaImage({
	            width: 30,
	            height: 30
	        }, tinySDF.draw(String.fromCharCode(id))),
	        metrics: {
	            width: 24,
	            height: 24,
	            left: 0,
	            top: -8,
	            advance: 24
	        }
	    };
	};
	GlyphManager.loadGlyphRange = loadGlyphRange;
	GlyphManager.TinySDF = tinySdf;

	var LightPositionProperty = function LightPositionProperty() {
	    this.specification = performance.styleSpec.light.position;
	};
	LightPositionProperty.prototype.possiblyEvaluate = function possiblyEvaluate(value, parameters) {
	    return performance.sphericalToCartesian(value.expression.evaluate(parameters));
	};
	LightPositionProperty.prototype.interpolate = function interpolate$1(a, b, t) {
	    return {
	        x: performance.number(a.x, b.x, t),
	        y: performance.number(a.y, b.y, t),
	        z: performance.number(a.z, b.z, t)
	    };
	};
	var properties = new performance.Properties({
	    'anchor': new performance.DataConstantProperty(performance.styleSpec.light.anchor),
	    'position': new LightPositionProperty(),
	    'color': new performance.DataConstantProperty(performance.styleSpec.light.color),
	    'intensity': new performance.DataConstantProperty(performance.styleSpec.light.intensity)
	});
	var TRANSITION_SUFFIX = '-transition';
	var Light = function (Evented) {
	    function Light(lightOptions) {
	        Evented.call(this);
	        this._transitionable = new performance.Transitionable(properties);
	        this.setLight(lightOptions);
	        this._transitioning = this._transitionable.untransitioned();
	    }
	    if (Evented)
	        Light.__proto__ = Evented;
	    Light.prototype = Object.create(Evented && Evented.prototype);
	    Light.prototype.constructor = Light;
	    Light.prototype.getLight = function getLight() {
	        return this._transitionable.serialize();
	    };
	    Light.prototype.setLight = function setLight(light, options) {
	        if (options === void 0)
	            options = {};
	        if (this._validate(performance.validateLight, light, options)) {
	            return;
	        }
	        for (var name in light) {
	            var value = light[name];
	            if (performance.endsWith(name, TRANSITION_SUFFIX)) {
	                this._transitionable.setTransition(name.slice(0, -TRANSITION_SUFFIX.length), value);
	            } else {
	                this._transitionable.setValue(name, value);
	            }
	        }
	    };
	    Light.prototype.updateTransitions = function updateTransitions(parameters) {
	        this._transitioning = this._transitionable.transitioned(parameters, this._transitioning);
	    };
	    Light.prototype.hasTransition = function hasTransition() {
	        return this._transitioning.hasTransition();
	    };
	    Light.prototype.recalculate = function recalculate(parameters) {
	        this.properties = this._transitioning.possiblyEvaluate(parameters);
	    };
	    Light.prototype._validate = function _validate(validate, value, options) {
	        if (options && options.validate === false) {
	            return false;
	        }
	        return performance.emitValidationErrors(this, validate.call(performance.validateStyle, performance.extend({
	            value: value,
	            style: {
	                glyphs: true,
	                sprite: true
	            },
	            styleSpec: performance.styleSpec
	        })));
	    };
	    return Light;
	}(performance.Evented);

	var LineAtlas = function LineAtlas(width, height) {
	    this.width = width;
	    this.height = height;
	    this.nextRow = 0;
	    this.data = new Uint8Array(this.width * this.height);
	    this.dashEntry = {};
	};
	LineAtlas.prototype.getDash = function getDash(dasharray, round) {
	    var key = dasharray.join(',') + String(round);
	    if (!this.dashEntry[key]) {
	        this.dashEntry[key] = this.addDash(dasharray, round);
	    }
	    return this.dashEntry[key];
	};
	LineAtlas.prototype.getDashRanges = function getDashRanges(dasharray, lineAtlasWidth, stretch) {
	    var oddDashArray = dasharray.length % 2 === 1;
	    var ranges = [];
	    var left = oddDashArray ? -dasharray[dasharray.length - 1] * stretch : 0;
	    var right = dasharray[0] * stretch;
	    var isDash = true;
	    ranges.push({
	        left: left,
	        right: right,
	        isDash: isDash,
	        zeroLength: dasharray[0] === 0
	    });
	    var currentDashLength = dasharray[0];
	    for (var i = 1; i < dasharray.length; i++) {
	        isDash = !isDash;
	        var dashLength = dasharray[i];
	        left = currentDashLength * stretch;
	        currentDashLength += dashLength;
	        right = currentDashLength * stretch;
	        ranges.push({
	            left: left,
	            right: right,
	            isDash: isDash,
	            zeroLength: dashLength === 0
	        });
	    }
	    return ranges;
	};
	LineAtlas.prototype.addRoundDash = function addRoundDash(ranges, stretch, n) {
	    var halfStretch = stretch / 2;
	    for (var y = -n; y <= n; y++) {
	        var row = this.nextRow + n + y;
	        var index = this.width * row;
	        var currIndex = 0;
	        var range = ranges[currIndex];
	        for (var x = 0; x < this.width; x++) {
	            if (x / range.right > 1) {
	                range = ranges[++currIndex];
	            }
	            var distLeft = Math.abs(x - range.left);
	            var distRight = Math.abs(x - range.right);
	            var minDist = Math.min(distLeft, distRight);
	            var signedDistance = void 0;
	            var distMiddle = y / n * (halfStretch + 1);
	            if (range.isDash) {
	                var distEdge = halfStretch - Math.abs(distMiddle);
	                signedDistance = Math.sqrt(minDist * minDist + distEdge * distEdge);
	            } else {
	                signedDistance = halfStretch - Math.sqrt(minDist * minDist + distMiddle * distMiddle);
	            }
	            this.data[index + x] = Math.max(0, Math.min(255, signedDistance + 128));
	        }
	    }
	};
	LineAtlas.prototype.addRegularDash = function addRegularDash(ranges) {
	    for (var i = ranges.length - 1; i >= 0; --i) {
	        var part = ranges[i];
	        var next = ranges[i + 1];
	        if (part.zeroLength) {
	            ranges.splice(i, 1);
	        } else if (next && next.isDash === part.isDash) {
	            next.left = part.left;
	            ranges.splice(i, 1);
	        }
	    }
	    var first = ranges[0];
	    var last = ranges[ranges.length - 1];
	    if (first.isDash === last.isDash) {
	        first.left = last.left - this.width;
	        last.right = first.right + this.width;
	    }
	    var index = this.width * this.nextRow;
	    var currIndex = 0;
	    var range = ranges[currIndex];
	    for (var x = 0; x < this.width; x++) {
	        if (x / range.right > 1) {
	            range = ranges[++currIndex];
	        }
	        var distLeft = Math.abs(x - range.left);
	        var distRight = Math.abs(x - range.right);
	        var minDist = Math.min(distLeft, distRight);
	        var signedDistance = range.isDash ? minDist : -minDist;
	        this.data[index + x] = Math.max(0, Math.min(255, signedDistance + 128));
	    }
	};
	LineAtlas.prototype.addDash = function addDash(dasharray, round) {
	    var n = round ? 7 : 0;
	    var height = 2 * n + 1;
	    if (this.nextRow + height > this.height) {
	        performance.warnOnce('LineAtlas out of space');
	        return null;
	    }
	    var length = 0;
	    for (var i = 0; i < dasharray.length; i++) {
	        length += dasharray[i];
	    }
	    if (length !== 0) {
	        var stretch = this.width / length;
	        var ranges = this.getDashRanges(dasharray, this.width, stretch);
	        if (round) {
	            this.addRoundDash(ranges, stretch, n);
	        } else {
	            this.addRegularDash(ranges);
	        }
	    }
	    var dashEntry = {
	        y: (this.nextRow + n + 0.5) / this.height,
	        height: 2 * n / this.height,
	        width: length
	    };
	    this.nextRow += height;
	    this.dirty = true;
	    return dashEntry;
	};
	LineAtlas.prototype.bind = function bind(context) {
	    var gl = context.gl;
	    if (!this.texture) {
	        this.texture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_2D, this.texture);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this.width, this.height, 0, gl.ALPHA, gl.UNSIGNED_BYTE, this.data);
	    } else {
	        gl.bindTexture(gl.TEXTURE_2D, this.texture);
	        if (this.dirty) {
	            this.dirty = false;
	            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.ALPHA, gl.UNSIGNED_BYTE, this.data);
	        }
	    }
	};

	var Dispatcher = function Dispatcher(workerPool, parent) {
	    this.workerPool = workerPool;
	    this.actors = [];
	    this.currentActor = 0;
	    this.id = performance.uniqueId();
	    var workers = this.workerPool.acquire(this.id);
	    for (var i = 0; i < workers.length; i++) {
	        var worker = workers[i];
	        var actor = new Dispatcher.Actor(worker, parent, this.id);
	        actor.name = 'Worker ' + i;
	        this.actors.push(actor);
	    }
	};
	Dispatcher.prototype.broadcast = function broadcast(type, data, cb) {
	    cb = cb || function () {
	    };
	    performance.asyncAll(this.actors, function (actor, done) {
	        actor.send(type, data, done);
	    }, cb);
	};
	Dispatcher.prototype.getActor = function getActor() {
	    this.currentActor = (this.currentActor + 1) % this.actors.length;
	    return this.actors[this.currentActor];
	};
	Dispatcher.prototype.remove = function remove() {
	    this.actors.forEach(function (actor) {
	        actor.remove();
	    });
	    this.actors = [];
	    this.workerPool.release(this.id);
	};
	Dispatcher.Actor = performance.Actor;

	function loadTileJSON (options, requestManager, callback) {
	    var loaded = function (err, tileJSON) {
	        if (err) {
	            return callback(err);
	        } else if (tileJSON) {
	            var result = performance.pick(performance.extend(tileJSON, options), [
	                'tiles',
	                'minzoom',
	                'maxzoom',
	                'attribution',
	                'mapbox_logo',
	                'bounds',
	                'scheme',
	                'tileSize',
	                'encoding'
	            ]);
	            if (tileJSON.vector_layers) {
	                result.vectorLayers = tileJSON.vector_layers;
	                result.vectorLayerIds = result.vectorLayers.map(function (layer) {
	                    return layer.id;
	                });
	            }
	            result.tiles = requestManager.canonicalizeTileset(result, options.url);
	            callback(null, result);
	        }
	    };
	    if (options.url) {
	        return performance.getJSON(requestManager.transformRequest(requestManager.normalizeSourceURL(options.url), performance.ResourceType.Source), loaded);
	    } else {
	        return performance.browser.frame(function () {
	            return loaded(null, options);
	        });
	    }
	}

	var TileBounds = function TileBounds(bounds, minzoom, maxzoom) {
	    this.bounds = performance.LngLatBounds.convert(this.validateBounds(bounds));
	    this.minzoom = minzoom || 0;
	    this.maxzoom = maxzoom || 24;
	};
	TileBounds.prototype.validateBounds = function validateBounds(bounds) {
	    if (!Array.isArray(bounds) || bounds.length !== 4) {
	        return [
	            -180,
	            -90,
	            180,
	            90
	        ];
	    }
	    return [
	        Math.max(-180, bounds[0]),
	        Math.max(-90, bounds[1]),
	        Math.min(180, bounds[2]),
	        Math.min(90, bounds[3])
	    ];
	};
	TileBounds.prototype.contains = function contains(tileID) {
	    var worldSize = Math.pow(2, tileID.z);
	    var level = {
	        minX: Math.floor(performance.mercatorXfromLng(this.bounds.getWest()) * worldSize),
	        minY: Math.floor(performance.mercatorYfromLat(this.bounds.getNorth()) * worldSize),
	        maxX: Math.ceil(performance.mercatorXfromLng(this.bounds.getEast()) * worldSize),
	        maxY: Math.ceil(performance.mercatorYfromLat(this.bounds.getSouth()) * worldSize)
	    };
	    var hit = tileID.x >= level.minX && tileID.x < level.maxX && tileID.y >= level.minY && tileID.y < level.maxY;
	    return hit;
	};

	var VectorTileSource = function (Evented) {
	    function VectorTileSource(id, options, dispatcher, eventedParent) {
	        Evented.call(this);
	        this.id = id;
	        this.dispatcher = dispatcher;
	        this.type = 'vector';
	        this.minzoom = 0;
	        this.maxzoom = 22;
	        this.scheme = 'xyz';
	        this.tileSize = 512;
	        this.reparseOverscaled = true;
	        this.isTileClipped = true;
	        this._loaded = false;
	        performance.extend(this, performance.pick(options, [
	            'url',
	            'scheme',
	            'tileSize',
	            'promoteId'
	        ]));
	        this._options = performance.extend({ type: 'vector' }, options);
	        this._collectResourceTiming = options.collectResourceTiming;
	        if (this.tileSize !== 512) {
	            throw new Error('vector tile sources must have a tileSize of 512');
	        }
	        this.setEventedParent(eventedParent);
	    }
	    if (Evented)
	        VectorTileSource.__proto__ = Evented;
	    VectorTileSource.prototype = Object.create(Evented && Evented.prototype);
	    VectorTileSource.prototype.constructor = VectorTileSource;
	    VectorTileSource.prototype.load = function load() {
	        var this$1 = this;
	        this._loaded = false;
	        this.fire(new performance.Event('dataloading', { dataType: 'source' }));
	        this._tileJSONRequest = loadTileJSON(this._options, this.map._requestManager, function (err, tileJSON) {
	            this$1._tileJSONRequest = null;
	            this$1._loaded = true;
	            if (err) {
	                this$1.fire(new performance.ErrorEvent(err));
	            } else if (tileJSON) {
	                performance.extend(this$1, tileJSON);
	                if (tileJSON.bounds) {
	                    this$1.tileBounds = new TileBounds(tileJSON.bounds, this$1.minzoom, this$1.maxzoom);
	                }
	                performance.postTurnstileEvent(tileJSON.tiles, this$1.map._requestManager._customAccessToken);
	                performance.postMapLoadEvent(tileJSON.tiles, this$1.map._getMapId(), this$1.map._requestManager._skuToken, this$1.map._requestManager._customAccessToken);
	                this$1.fire(new performance.Event('data', {
	                    dataType: 'source',
	                    sourceDataType: 'metadata'
	                }));
	                this$1.fire(new performance.Event('data', {
	                    dataType: 'source',
	                    sourceDataType: 'content'
	                }));
	            }
	        });
	    };
	    VectorTileSource.prototype.loaded = function loaded() {
	        return this._loaded;
	    };
	    VectorTileSource.prototype.hasTile = function hasTile(tileID) {
	        return !this.tileBounds || this.tileBounds.contains(tileID.canonical);
	    };
	    VectorTileSource.prototype.onAdd = function onAdd(map) {
	        this.map = map;
	        this.load();
	    };
	    VectorTileSource.prototype.setSourceProperty = function setSourceProperty(callback) {
	        if (this._tileJSONRequest) {
	            this._tileJSONRequest.cancel();
	        }
	        callback();
	        var sourceCache = this.map.style.sourceCaches[this.id];
	        sourceCache.clearTiles();
	        this.load();
	    };
	    VectorTileSource.prototype.setTiles = function setTiles(tiles) {
	        var this$1 = this;
	        this.setSourceProperty(function () {
	            this$1._options.tiles = tiles;
	        });
	        return this;
	    };
	    VectorTileSource.prototype.setUrl = function setUrl(url) {
	        var this$1 = this;
	        this.setSourceProperty(function () {
	            this$1.url = url;
	            this$1._options.url = url;
	        });
	        return this;
	    };
	    VectorTileSource.prototype.onRemove = function onRemove() {
	        if (this._tileJSONRequest) {
	            this._tileJSONRequest.cancel();
	            this._tileJSONRequest = null;
	        }
	    };
	    VectorTileSource.prototype.serialize = function serialize() {
	        return performance.extend({}, this._options);
	    };
	    VectorTileSource.prototype.loadTile = function loadTile(tile, callback) {
	        var url = this.map._requestManager.normalizeTileURL(tile.tileID.canonical.url(this.tiles, this.scheme));
	        var params = {
	            request: this.map._requestManager.transformRequest(url, performance.ResourceType.Tile),
	            uid: tile.uid,
	            tileID: tile.tileID,
	            zoom: tile.tileID.overscaledZ,
	            tileSize: this.tileSize * tile.tileID.overscaleFactor(),
	            type: this.type,
	            source: this.id,
	            pixelRatio: performance.browser.devicePixelRatio,
	            showCollisionBoxes: this.map.showCollisionBoxes,
	            promoteId: this.promoteId
	        };
	        params.request.collectResourceTiming = this._collectResourceTiming;
	        if (!tile.actor || tile.state === 'expired') {
	            tile.actor = this.dispatcher.getActor();
	            tile.request = tile.actor.send('loadTile', params, done.bind(this));
	        } else if (tile.state === 'loading') {
	            tile.reloadCallback = callback;
	        } else {
	            tile.request = tile.actor.send('reloadTile', params, done.bind(this));
	        }
	        function done(err, data) {
	            delete tile.request;
	            if (tile.aborted) {
	                return callback(null);
	            }
	            if (err && err.status !== 404) {
	                return callback(err);
	            }
	            if (data && data.resourceTiming) {
	                tile.resourceTiming = data.resourceTiming;
	            }
	            if (this.map._refreshExpiredTiles && data) {
	                tile.setExpiryData(data);
	            }
	            tile.loadVectorData(data, this.map.painter);
	            performance.cacheEntryPossiblyAdded(this.dispatcher);
	            callback(null);
	            if (tile.reloadCallback) {
	                this.loadTile(tile, tile.reloadCallback);
	                tile.reloadCallback = null;
	            }
	        }
	    };
	    VectorTileSource.prototype.abortTile = function abortTile(tile) {
	        if (tile.request) {
	            tile.request.cancel();
	            delete tile.request;
	        }
	        if (tile.actor) {
	            tile.actor.send('abortTile', {
	                uid: tile.uid,
	                type: this.type,
	                source: this.id
	            }, undefined);
	        }
	    };
	    VectorTileSource.prototype.unloadTile = function unloadTile(tile) {
	        tile.unloadVectorData();
	        if (tile.actor) {
	            tile.actor.send('removeTile', {
	                uid: tile.uid,
	                type: this.type,
	                source: this.id
	            }, undefined);
	        }
	    };
	    VectorTileSource.prototype.hasTransition = function hasTransition() {
	        return false;
	    };
	    return VectorTileSource;
	}(performance.Evented);

	var RasterTileSource = function (Evented) {
	    function RasterTileSource(id, options, dispatcher, eventedParent) {
	        Evented.call(this);
	        this.id = id;
	        this.dispatcher = dispatcher;
	        this.setEventedParent(eventedParent);
	        this.type = 'raster';
	        this.minzoom = 0;
	        this.maxzoom = 22;
	        this.roundZoom = true;
	        this.scheme = 'xyz';
	        this.tileSize = 512;
	        this._loaded = false;
	        this._options = performance.extend({ type: 'raster' }, options);
	        performance.extend(this, performance.pick(options, [
	            'url',
	            'scheme',
	            'tileSize'
	        ]));
	    }
	    if (Evented)
	        RasterTileSource.__proto__ = Evented;
	    RasterTileSource.prototype = Object.create(Evented && Evented.prototype);
	    RasterTileSource.prototype.constructor = RasterTileSource;
	    RasterTileSource.prototype.load = function load() {
	        var this$1 = this;
	        this._loaded = false;
	        this.fire(new performance.Event('dataloading', { dataType: 'source' }));
	        this._tileJSONRequest = loadTileJSON(this._options, this.map._requestManager, function (err, tileJSON) {
	            this$1._tileJSONRequest = null;
	            this$1._loaded = true;
	            if (err) {
	                this$1.fire(new performance.ErrorEvent(err));
	            } else if (tileJSON) {
	                performance.extend(this$1, tileJSON);
	                if (tileJSON.bounds) {
	                    this$1.tileBounds = new TileBounds(tileJSON.bounds, this$1.minzoom, this$1.maxzoom);
	                }
	                performance.postTurnstileEvent(tileJSON.tiles);
	                performance.postMapLoadEvent(tileJSON.tiles, this$1.map._getMapId(), this$1.map._requestManager._skuToken);
	                this$1.fire(new performance.Event('data', {
	                    dataType: 'source',
	                    sourceDataType: 'metadata'
	                }));
	                this$1.fire(new performance.Event('data', {
	                    dataType: 'source',
	                    sourceDataType: 'content'
	                }));
	            }
	        });
	    };
	    RasterTileSource.prototype.loaded = function loaded() {
	        return this._loaded;
	    };
	    RasterTileSource.prototype.onAdd = function onAdd(map) {
	        this.map = map;
	        this.load();
	    };
	    RasterTileSource.prototype.onRemove = function onRemove() {
	        if (this._tileJSONRequest) {
	            this._tileJSONRequest.cancel();
	            this._tileJSONRequest = null;
	        }
	    };
	    RasterTileSource.prototype.serialize = function serialize() {
	        return performance.extend({}, this._options);
	    };
	    RasterTileSource.prototype.hasTile = function hasTile(tileID) {
	        return !this.tileBounds || this.tileBounds.contains(tileID.canonical);
	    };
	    RasterTileSource.prototype.loadTile = function loadTile(tile, callback) {
	        var this$1 = this;
	        var url = this.map._requestManager.normalizeTileURL(tile.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
	        tile.request = performance.getImage(this.map._requestManager.transformRequest(url, performance.ResourceType.Tile), function (err, img) {
	            delete tile.request;
	            if (tile.aborted) {
	                tile.state = 'unloaded';
	                callback(null);
	            } else if (err) {
	                tile.state = 'errored';
	                callback(err);
	            } else if (img) {
	                if (this$1.map._refreshExpiredTiles) {
	                    tile.setExpiryData(img);
	                }
	                delete img.cacheControl;
	                delete img.expires;
	                var context = this$1.map.painter.context;
	                var gl = context.gl;
	                tile.texture = this$1.map.painter.getTileTexture(img.width);
	                if (tile.texture) {
	                    tile.texture.update(img, { useMipmap: true });
	                } else {
	                    tile.texture = new performance.Texture(context, img, gl.RGBA, { useMipmap: true });
	                    tile.texture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE, gl.LINEAR_MIPMAP_NEAREST);
	                    if (context.extTextureFilterAnisotropic) {
	                        gl.texParameterf(gl.TEXTURE_2D, context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, context.extTextureFilterAnisotropicMax);
	                    }
	                }
	                tile.state = 'loaded';
	                performance.cacheEntryPossiblyAdded(this$1.dispatcher);
	                callback(null);
	            }
	        });
	    };
	    RasterTileSource.prototype.abortTile = function abortTile(tile, callback) {
	        if (tile.request) {
	            tile.request.cancel();
	            delete tile.request;
	        }
	        callback();
	    };
	    RasterTileSource.prototype.unloadTile = function unloadTile(tile, callback) {
	        if (tile.texture) {
	            this.map.painter.saveTileTexture(tile.texture);
	        }
	        callback();
	    };
	    RasterTileSource.prototype.hasTransition = function hasTransition() {
	        return false;
	    };
	    return RasterTileSource;
	}(performance.Evented);

	var RasterDEMTileSource = function (RasterTileSource) {
	    function RasterDEMTileSource(id, options, dispatcher, eventedParent) {
	        RasterTileSource.call(this, id, options, dispatcher, eventedParent);
	        this.type = 'raster-dem';
	        this.maxzoom = 22;
	        this._options = performance.extend({ type: 'raster-dem' }, options);
	        this.encoding = options.encoding || 'mapbox';
	    }
	    if (RasterTileSource)
	        RasterDEMTileSource.__proto__ = RasterTileSource;
	    RasterDEMTileSource.prototype = Object.create(RasterTileSource && RasterTileSource.prototype);
	    RasterDEMTileSource.prototype.constructor = RasterDEMTileSource;
	    RasterDEMTileSource.prototype.serialize = function serialize() {
	        return {
	            type: 'raster-dem',
	            url: this.url,
	            tileSize: this.tileSize,
	            tiles: this.tiles,
	            bounds: this.bounds,
	            encoding: this.encoding
	        };
	    };
	    RasterDEMTileSource.prototype.loadTile = function loadTile(tile, callback) {
	        var url = this.map._requestManager.normalizeTileURL(tile.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
	        tile.request = performance.getImage(this.map._requestManager.transformRequest(url, performance.ResourceType.Tile), imageLoaded.bind(this));
	        tile.neighboringTiles = this._getNeighboringTiles(tile.tileID);
	        function imageLoaded(err, img) {
	            delete tile.request;
	            if (tile.aborted) {
	                tile.state = 'unloaded';
	                callback(null);
	            } else if (err) {
	                tile.state = 'errored';
	                callback(err);
	            } else if (img) {
	                if (this.map._refreshExpiredTiles) {
	                    tile.setExpiryData(img);
	                }
	                delete img.cacheControl;
	                delete img.expires;
	                var transfer = performance.window.ImageBitmap && img instanceof performance.window.ImageBitmap && performance.offscreenCanvasSupported();
	                var rawImageData = transfer ? img : performance.browser.getImageData(img, 1);
	                var params = {
	                    uid: tile.uid,
	                    coord: tile.tileID,
	                    source: this.id,
	                    rawImageData: rawImageData,
	                    encoding: this.encoding
	                };
	                if (!tile.actor || tile.state === 'expired') {
	                    tile.actor = this.dispatcher.getActor();
	                    tile.actor.send('loadDEMTile', params, done.bind(this));
	                }
	            }
	        }
	        function done(err, dem) {
	            if (err) {
	                tile.state = 'errored';
	                callback(err);
	            }
	            if (dem) {
	                tile.dem = dem;
	                tile.needsHillshadePrepare = true;
	                tile.state = 'loaded';
	                callback(null);
	            }
	        }
	    };
	    RasterDEMTileSource.prototype._getNeighboringTiles = function _getNeighboringTiles(tileID) {
	        var canonical = tileID.canonical;
	        var dim = Math.pow(2, canonical.z);
	        var px = (canonical.x - 1 + dim) % dim;
	        var pxw = canonical.x === 0 ? tileID.wrap - 1 : tileID.wrap;
	        var nx = (canonical.x + 1 + dim) % dim;
	        var nxw = canonical.x + 1 === dim ? tileID.wrap + 1 : tileID.wrap;
	        var neighboringTiles = {};
	        neighboringTiles[new performance.OverscaledTileID(tileID.overscaledZ, pxw, canonical.z, px, canonical.y).key] = { backfilled: false };
	        neighboringTiles[new performance.OverscaledTileID(tileID.overscaledZ, nxw, canonical.z, nx, canonical.y).key] = { backfilled: false };
	        if (canonical.y > 0) {
	            neighboringTiles[new performance.OverscaledTileID(tileID.overscaledZ, pxw, canonical.z, px, canonical.y - 1).key] = { backfilled: false };
	            neighboringTiles[new performance.OverscaledTileID(tileID.overscaledZ, tileID.wrap, canonical.z, canonical.x, canonical.y - 1).key] = { backfilled: false };
	            neighboringTiles[new performance.OverscaledTileID(tileID.overscaledZ, nxw, canonical.z, nx, canonical.y - 1).key] = { backfilled: false };
	        }
	        if (canonical.y + 1 < dim) {
	            neighboringTiles[new performance.OverscaledTileID(tileID.overscaledZ, pxw, canonical.z, px, canonical.y + 1).key] = { backfilled: false };
	            neighboringTiles[new performance.OverscaledTileID(tileID.overscaledZ, tileID.wrap, canonical.z, canonical.x, canonical.y + 1).key] = { backfilled: false };
	            neighboringTiles[new performance.OverscaledTileID(tileID.overscaledZ, nxw, canonical.z, nx, canonical.y + 1).key] = { backfilled: false };
	        }
	        return neighboringTiles;
	    };
	    RasterDEMTileSource.prototype.unloadTile = function unloadTile(tile) {
	        if (tile.demTexture) {
	            this.map.painter.saveTileTexture(tile.demTexture);
	        }
	        if (tile.fbo) {
	            tile.fbo.destroy();
	            delete tile.fbo;
	        }
	        if (tile.dem) {
	            delete tile.dem;
	        }
	        delete tile.neighboringTiles;
	        tile.state = 'unloaded';
	        if (tile.actor) {
	            tile.actor.send('removeDEMTile', {
	                uid: tile.uid,
	                source: this.id
	            });
	        }
	    };
	    return RasterDEMTileSource;
	}(RasterTileSource);

	var GeoJSONSource = function (Evented) {
	    function GeoJSONSource(id, options, dispatcher, eventedParent) {
	        Evented.call(this);
	        this.id = id;
	        this.type = 'geojson';
	        this.minzoom = 0;
	        this.maxzoom = 18;
	        this.tileSize = 512;
	        this.isTileClipped = true;
	        this.reparseOverscaled = true;
	        this._removed = false;
	        this._loaded = false;
	        this.actor = dispatcher.getActor();
	        this.setEventedParent(eventedParent);
	        this._data = options.data;
	        this._options = performance.extend({}, options);
	        this._collectResourceTiming = options.collectResourceTiming;
	        this._resourceTiming = [];
	        if (options.maxzoom !== undefined) {
	            this.maxzoom = options.maxzoom;
	        }
	        if (options.type) {
	            this.type = options.type;
	        }
	        if (options.attribution) {
	            this.attribution = options.attribution;
	        }
	        this.promoteId = options.promoteId;
	        var scale = performance.EXTENT / this.tileSize;
	        this.workerOptions = performance.extend({
	            source: this.id,
	            cluster: options.cluster || false,
	            geojsonVtOptions: {
	                buffer: (options.buffer !== undefined ? options.buffer : 128) * scale,
	                tolerance: (options.tolerance !== undefined ? options.tolerance : 0.375) * scale,
	                extent: performance.EXTENT,
	                maxZoom: this.maxzoom,
	                lineMetrics: options.lineMetrics || false,
	                generateId: options.generateId || false
	            },
	            superclusterOptions: {
	                maxZoom: options.clusterMaxZoom !== undefined ? Math.min(options.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1,
	                minPoints: Math.max(2, options.clusterMinPoints || 2),
	                extent: performance.EXTENT,
	                radius: (options.clusterRadius || 50) * scale,
	                log: false,
	                generateId: options.generateId || false
	            },
	            clusterProperties: options.clusterProperties,
	            filter: options.filter
	        }, options.workerOptions);
	    }
	    if (Evented)
	        GeoJSONSource.__proto__ = Evented;
	    GeoJSONSource.prototype = Object.create(Evented && Evented.prototype);
	    GeoJSONSource.prototype.constructor = GeoJSONSource;
	    GeoJSONSource.prototype.load = function load() {
	        var this$1 = this;
	        this.fire(new performance.Event('dataloading', { dataType: 'source' }));
	        this._updateWorkerData(function (err) {
	            if (err) {
	                this$1.fire(new performance.ErrorEvent(err));
	                return;
	            }
	            var data = {
	                dataType: 'source',
	                sourceDataType: 'metadata'
	            };
	            if (this$1._collectResourceTiming && this$1._resourceTiming && this$1._resourceTiming.length > 0) {
	                data.resourceTiming = this$1._resourceTiming;
	                this$1._resourceTiming = [];
	            }
	            this$1.fire(new performance.Event('data', data));
	        });
	    };
	    GeoJSONSource.prototype.onAdd = function onAdd(map) {
	        this.map = map;
	        this.load();
	    };
	    GeoJSONSource.prototype.setData = function setData(data) {
	        var this$1 = this;
	        this._data = data;
	        this.fire(new performance.Event('dataloading', { dataType: 'source' }));
	        this._updateWorkerData(function (err) {
	            if (err) {
	                this$1.fire(new performance.ErrorEvent(err));
	                return;
	            }
	            var data = {
	                dataType: 'source',
	                sourceDataType: 'content'
	            };
	            if (this$1._collectResourceTiming && this$1._resourceTiming && this$1._resourceTiming.length > 0) {
	                data.resourceTiming = this$1._resourceTiming;
	                this$1._resourceTiming = [];
	            }
	            this$1.fire(new performance.Event('data', data));
	        });
	        return this;
	    };
	    GeoJSONSource.prototype.getClusterExpansionZoom = function getClusterExpansionZoom(clusterId, callback) {
	        this.actor.send('geojson.getClusterExpansionZoom', {
	            clusterId: clusterId,
	            source: this.id
	        }, callback);
	        return this;
	    };
	    GeoJSONSource.prototype.getClusterChildren = function getClusterChildren(clusterId, callback) {
	        this.actor.send('geojson.getClusterChildren', {
	            clusterId: clusterId,
	            source: this.id
	        }, callback);
	        return this;
	    };
	    GeoJSONSource.prototype.getClusterLeaves = function getClusterLeaves(clusterId, limit, offset, callback) {
	        this.actor.send('geojson.getClusterLeaves', {
	            source: this.id,
	            clusterId: clusterId,
	            limit: limit,
	            offset: offset
	        }, callback);
	        return this;
	    };
	    GeoJSONSource.prototype._updateWorkerData = function _updateWorkerData(callback) {
	        var this$1 = this;
	        this._loaded = false;
	        var options = performance.extend({}, this.workerOptions);
	        var data = this._data;
	        if (typeof data === 'string') {
	            options.request = this.map._requestManager.transformRequest(performance.browser.resolveURL(data), performance.ResourceType.Source);
	            options.request.collectResourceTiming = this._collectResourceTiming;
	        } else {
	            options.data = JSON.stringify(data);
	        }
	        this.actor.send(this.type + '.loadData', options, function (err, result) {
	            if (this$1._removed || result && result.abandoned) {
	                return;
	            }
	            this$1._loaded = true;
	            if (result && result.resourceTiming && result.resourceTiming[this$1.id]) {
	                this$1._resourceTiming = result.resourceTiming[this$1.id].slice(0);
	            }
	            this$1.actor.send(this$1.type + '.coalesce', { source: options.source }, null);
	            callback(err);
	        });
	    };
	    GeoJSONSource.prototype.loaded = function loaded() {
	        return this._loaded;
	    };
	    GeoJSONSource.prototype.loadTile = function loadTile(tile, callback) {
	        var this$1 = this;
	        var message = !tile.actor ? 'loadTile' : 'reloadTile';
	        tile.actor = this.actor;
	        var params = {
	            type: this.type,
	            uid: tile.uid,
	            tileID: tile.tileID,
	            zoom: tile.tileID.overscaledZ,
	            maxZoom: this.maxzoom,
	            tileSize: this.tileSize,
	            source: this.id,
	            pixelRatio: performance.browser.devicePixelRatio,
	            showCollisionBoxes: this.map.showCollisionBoxes,
	            promoteId: this.promoteId
	        };
	        tile.request = this.actor.send(message, params, function (err, data) {
	            delete tile.request;
	            tile.unloadVectorData();
	            if (tile.aborted) {
	                return callback(null);
	            }
	            if (err) {
	                return callback(err);
	            }
	            tile.loadVectorData(data, this$1.map.painter, message === 'reloadTile');
	            return callback(null);
	        });
	    };
	    GeoJSONSource.prototype.abortTile = function abortTile(tile) {
	        if (tile.request) {
	            tile.request.cancel();
	            delete tile.request;
	        }
	        tile.aborted = true;
	    };
	    GeoJSONSource.prototype.unloadTile = function unloadTile(tile) {
	        tile.unloadVectorData();
	        this.actor.send('removeTile', {
	            uid: tile.uid,
	            type: this.type,
	            source: this.id
	        });
	    };
	    GeoJSONSource.prototype.onRemove = function onRemove() {
	        this._removed = true;
	        this.actor.send('removeSource', {
	            type: this.type,
	            source: this.id
	        });
	    };
	    GeoJSONSource.prototype.serialize = function serialize() {
	        return performance.extend({}, this._options, {
	            type: this.type,
	            data: this._data
	        });
	    };
	    GeoJSONSource.prototype.hasTransition = function hasTransition() {
	        return false;
	    };
	    return GeoJSONSource;
	}(performance.Evented);

	var rasterBoundsAttributes = performance.createLayout([
	    {
	        name: 'a_pos',
	        type: 'Int16',
	        components: 2
	    },
	    {
	        name: 'a_texture_pos',
	        type: 'Int16',
	        components: 2
	    }
	]);

	var ImageSource = function (Evented) {
	    function ImageSource(id, options, dispatcher, eventedParent) {
	        Evented.call(this);
	        this.id = id;
	        this.dispatcher = dispatcher;
	        this.coordinates = options.coordinates;
	        this.type = 'image';
	        this.minzoom = 0;
	        this.maxzoom = 22;
	        this.tileSize = 512;
	        this.tiles = {};
	        this._loaded = false;
	        this.setEventedParent(eventedParent);
	        this.options = options;
	    }
	    if (Evented)
	        ImageSource.__proto__ = Evented;
	    ImageSource.prototype = Object.create(Evented && Evented.prototype);
	    ImageSource.prototype.constructor = ImageSource;
	    ImageSource.prototype.load = function load(newCoordinates, successCallback) {
	        var this$1 = this;
	        this._loaded = false;
	        this.fire(new performance.Event('dataloading', { dataType: 'source' }));
	        this.url = this.options.url;
	        performance.getImage(this.map._requestManager.transformRequest(this.url, performance.ResourceType.Image), function (err, image) {
	            this$1._loaded = true;
	            if (err) {
	                this$1.fire(new performance.ErrorEvent(err));
	            } else if (image) {
	                this$1.image = image;
	                if (newCoordinates) {
	                    this$1.coordinates = newCoordinates;
	                }
	                if (successCallback) {
	                    successCallback();
	                }
	                this$1._finishLoading();
	            }
	        });
	    };
	    ImageSource.prototype.loaded = function loaded() {
	        return this._loaded;
	    };
	    ImageSource.prototype.updateImage = function updateImage(options) {
	        var this$1 = this;
	        if (!this.image || !options.url) {
	            return this;
	        }
	        this.options.url = options.url;
	        this.load(options.coordinates, function () {
	            this$1.texture = null;
	        });
	        return this;
	    };
	    ImageSource.prototype._finishLoading = function _finishLoading() {
	        if (this.map) {
	            this.setCoordinates(this.coordinates);
	            this.fire(new performance.Event('data', {
	                dataType: 'source',
	                sourceDataType: 'metadata'
	            }));
	        }
	    };
	    ImageSource.prototype.onAdd = function onAdd(map) {
	        this.map = map;
	        this.load();
	    };
	    ImageSource.prototype.setCoordinates = function setCoordinates(coordinates) {
	        var this$1 = this;
	        this.coordinates = coordinates;
	        var cornerCoords = coordinates.map(performance.MercatorCoordinate.fromLngLat);
	        this.tileID = getCoordinatesCenterTileID(cornerCoords);
	        this.minzoom = this.maxzoom = this.tileID.z;
	        var tileCoords = cornerCoords.map(function (coord) {
	            return this$1.tileID.getTilePoint(coord)._round();
	        });
	        this._boundsArray = new performance.StructArrayLayout4i8();
	        this._boundsArray.emplaceBack(tileCoords[0].x, tileCoords[0].y, 0, 0);
	        this._boundsArray.emplaceBack(tileCoords[1].x, tileCoords[1].y, performance.EXTENT, 0);
	        this._boundsArray.emplaceBack(tileCoords[3].x, tileCoords[3].y, 0, performance.EXTENT);
	        this._boundsArray.emplaceBack(tileCoords[2].x, tileCoords[2].y, performance.EXTENT, performance.EXTENT);
	        if (this.boundsBuffer) {
	            this.boundsBuffer.destroy();
	            delete this.boundsBuffer;
	        }
	        this.fire(new performance.Event('data', {
	            dataType: 'source',
	            sourceDataType: 'content'
	        }));
	        return this;
	    };
	    ImageSource.prototype.prepare = function prepare() {
	        if (Object.keys(this.tiles).length === 0 || !this.image) {
	            return;
	        }
	        var context = this.map.painter.context;
	        var gl = context.gl;
	        if (!this.boundsBuffer) {
	            this.boundsBuffer = context.createVertexBuffer(this._boundsArray, rasterBoundsAttributes.members);
	        }
	        if (!this.boundsSegments) {
	            this.boundsSegments = performance.SegmentVector.simpleSegment(0, 0, 4, 2);
	        }
	        if (!this.texture) {
	            this.texture = new performance.Texture(context, this.image, gl.RGBA);
	            this.texture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
	        }
	        for (var w in this.tiles) {
	            var tile = this.tiles[w];
	            if (tile.state !== 'loaded') {
	                tile.state = 'loaded';
	                tile.texture = this.texture;
	            }
	        }
	    };
	    ImageSource.prototype.loadTile = function loadTile(tile, callback) {
	        if (this.tileID && this.tileID.equals(tile.tileID.canonical)) {
	            this.tiles[String(tile.tileID.wrap)] = tile;
	            tile.buckets = {};
	            callback(null);
	        } else {
	            tile.state = 'errored';
	            callback(null);
	        }
	    };
	    ImageSource.prototype.serialize = function serialize() {
	        return {
	            type: 'image',
	            url: this.options.url,
	            coordinates: this.coordinates
	        };
	    };
	    ImageSource.prototype.hasTransition = function hasTransition() {
	        return false;
	    };
	    return ImageSource;
	}(performance.Evented);
	function getCoordinatesCenterTileID(coords) {
	    var minX = Infinity;
	    var minY = Infinity;
	    var maxX = -Infinity;
	    var maxY = -Infinity;
	    for (var i = 0, list = coords; i < list.length; i += 1) {
	        var coord = list[i];
	        minX = Math.min(minX, coord.x);
	        minY = Math.min(minY, coord.y);
	        maxX = Math.max(maxX, coord.x);
	        maxY = Math.max(maxY, coord.y);
	    }
	    var dx = maxX - minX;
	    var dy = maxY - minY;
	    var dMax = Math.max(dx, dy);
	    var zoom = Math.max(0, Math.floor(-Math.log(dMax) / Math.LN2));
	    var tilesAtZoom = Math.pow(2, zoom);
	    return new performance.CanonicalTileID(zoom, Math.floor((minX + maxX) / 2 * tilesAtZoom), Math.floor((minY + maxY) / 2 * tilesAtZoom));
	}

	var VideoSource = function (ImageSource) {
	    function VideoSource(id, options, dispatcher, eventedParent) {
	        ImageSource.call(this, id, options, dispatcher, eventedParent);
	        this.roundZoom = true;
	        this.type = 'video';
	        this.options = options;
	    }
	    if (ImageSource)
	        VideoSource.__proto__ = ImageSource;
	    VideoSource.prototype = Object.create(ImageSource && ImageSource.prototype);
	    VideoSource.prototype.constructor = VideoSource;
	    VideoSource.prototype.load = function load() {
	        var this$1 = this;
	        this._loaded = false;
	        var options = this.options;
	        this.urls = [];
	        for (var i = 0, list = options.urls; i < list.length; i += 1) {
	            var url = list[i];
	            this.urls.push(this.map._requestManager.transformRequest(url, performance.ResourceType.Source).url);
	        }
	        performance.getVideo(this.urls, function (err, video) {
	            this$1._loaded = true;
	            if (err) {
	                this$1.fire(new performance.ErrorEvent(err));
	            } else if (video) {
	                this$1.video = video;
	                this$1.video.loop = true;
	                this$1.video.addEventListener('playing', function () {
	                    this$1.map.triggerRepaint();
	                });
	                if (this$1.map) {
	                    this$1.video.play();
	                }
	                this$1._finishLoading();
	            }
	        });
	    };
	    VideoSource.prototype.pause = function pause() {
	        if (this.video) {
	            this.video.pause();
	        }
	    };
	    VideoSource.prototype.play = function play() {
	        if (this.video) {
	            this.video.play();
	        }
	    };
	    VideoSource.prototype.seek = function seek(seconds) {
	        if (this.video) {
	            var seekableRange = this.video.seekable;
	            if (seconds < seekableRange.start(0) || seconds > seekableRange.end(0)) {
	                this.fire(new performance.ErrorEvent(new performance.ValidationError('sources.' + this.id, null, 'Playback for this video can be set only between the ' + seekableRange.start(0) + ' and ' + seekableRange.end(0) + '-second mark.')));
	            } else {
	                this.video.currentTime = seconds;
	            }
	        }
	    };
	    VideoSource.prototype.getVideo = function getVideo() {
	        return this.video;
	    };
	    VideoSource.prototype.onAdd = function onAdd(map) {
	        if (this.map) {
	            return;
	        }
	        this.map = map;
	        this.load();
	        if (this.video) {
	            this.video.play();
	            this.setCoordinates(this.coordinates);
	        }
	    };
	    VideoSource.prototype.prepare = function prepare() {
	        if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) {
	            return;
	        }
	        var context = this.map.painter.context;
	        var gl = context.gl;
	        if (!this.boundsBuffer) {
	            this.boundsBuffer = context.createVertexBuffer(this._boundsArray, rasterBoundsAttributes.members);
	        }
	        if (!this.boundsSegments) {
	            this.boundsSegments = performance.SegmentVector.simpleSegment(0, 0, 4, 2);
	        }
	        if (!this.texture) {
	            this.texture = new performance.Texture(context, this.video, gl.RGBA);
	            this.texture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
	        } else if (!this.video.paused) {
	            this.texture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
	            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
	        }
	        for (var w in this.tiles) {
	            var tile = this.tiles[w];
	            if (tile.state !== 'loaded') {
	                tile.state = 'loaded';
	                tile.texture = this.texture;
	            }
	        }
	    };
	    VideoSource.prototype.serialize = function serialize() {
	        return {
	            type: 'video',
	            urls: this.urls,
	            coordinates: this.coordinates
	        };
	    };
	    VideoSource.prototype.hasTransition = function hasTransition() {
	        return this.video && !this.video.paused;
	    };
	    return VideoSource;
	}(ImageSource);

	var CanvasSource = function (ImageSource) {
	    function CanvasSource(id, options, dispatcher, eventedParent) {
	        ImageSource.call(this, id, options, dispatcher, eventedParent);
	        if (!options.coordinates) {
	            this.fire(new performance.ErrorEvent(new performance.ValidationError('sources.' + id, null, 'missing required property "coordinates"')));
	        } else if (!Array.isArray(options.coordinates) || options.coordinates.length !== 4 || options.coordinates.some(function (c) {
	                return !Array.isArray(c) || c.length !== 2 || c.some(function (l) {
	                    return typeof l !== 'number';
	                });
	            })) {
	            this.fire(new performance.ErrorEvent(new performance.ValidationError('sources.' + id, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs')));
	        }
	        if (options.animate && typeof options.animate !== 'boolean') {
	            this.fire(new performance.ErrorEvent(new performance.ValidationError('sources.' + id, null, 'optional "animate" property must be a boolean value')));
	        }
	        if (!options.canvas) {
	            this.fire(new performance.ErrorEvent(new performance.ValidationError('sources.' + id, null, 'missing required property "canvas"')));
	        } else if (typeof options.canvas !== 'string' && !(options.canvas instanceof performance.window.HTMLCanvasElement)) {
	            this.fire(new performance.ErrorEvent(new performance.ValidationError('sources.' + id, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance')));
	        }
	        this.options = options;
	        this.animate = options.animate !== undefined ? options.animate : true;
	    }
	    if (ImageSource)
	        CanvasSource.__proto__ = ImageSource;
	    CanvasSource.prototype = Object.create(ImageSource && ImageSource.prototype);
	    CanvasSource.prototype.constructor = CanvasSource;
	    CanvasSource.prototype.load = function load() {
	        this._loaded = true;
	        if (!this.canvas) {
	            this.canvas = this.options.canvas instanceof performance.window.HTMLCanvasElement ? this.options.canvas : performance.window.document.getElementById(this.options.canvas);
	        }
	        this.width = this.canvas.width;
	        this.height = this.canvas.height;
	        if (this._hasInvalidDimensions()) {
	            this.fire(new performance.ErrorEvent(new Error('Canvas dimensions cannot be less than or equal to zero.')));
	            return;
	        }
	        this.play = function () {
	            this._playing = true;
	            this.map.triggerRepaint();
	        };
	        this.pause = function () {
	            if (this._playing) {
	                this.prepare();
	                this._playing = false;
	            }
	        };
	        this._finishLoading();
	    };
	    CanvasSource.prototype.getCanvas = function getCanvas() {
	        return this.canvas;
	    };
	    CanvasSource.prototype.onAdd = function onAdd(map) {
	        this.map = map;
	        this.load();
	        if (this.canvas) {
	            if (this.animate) {
	                this.play();
	            }
	        }
	    };
	    CanvasSource.prototype.onRemove = function onRemove() {
	        this.pause();
	    };
	    CanvasSource.prototype.prepare = function prepare() {
	        var resize = false;
	        if (this.canvas.width !== this.width) {
	            this.width = this.canvas.width;
	            resize = true;
	        }
	        if (this.canvas.height !== this.height) {
	            this.height = this.canvas.height;
	            resize = true;
	        }
	        if (this._hasInvalidDimensions()) {
	            return;
	        }
	        if (Object.keys(this.tiles).length === 0) {
	            return;
	        }
	        var context = this.map.painter.context;
	        var gl = context.gl;
	        if (!this.boundsBuffer) {
	            this.boundsBuffer = context.createVertexBuffer(this._boundsArray, rasterBoundsAttributes.members);
	        }
	        if (!this.boundsSegments) {
	            this.boundsSegments = performance.SegmentVector.simpleSegment(0, 0, 4, 2);
	        }
	        if (!this.texture) {
	            this.texture = new performance.Texture(context, this.canvas, gl.RGBA, { premultiply: true });
	        } else if (resize || this._playing) {
	            this.texture.update(this.canvas, { premultiply: true });
	        }
	        for (var w in this.tiles) {
	            var tile = this.tiles[w];
	            if (tile.state !== 'loaded') {
	                tile.state = 'loaded';
	                tile.texture = this.texture;
	            }
	        }
	    };
	    CanvasSource.prototype.serialize = function serialize() {
	        return {
	            type: 'canvas',
	            coordinates: this.coordinates
	        };
	    };
	    CanvasSource.prototype.hasTransition = function hasTransition() {
	        return this._playing;
	    };
	    CanvasSource.prototype._hasInvalidDimensions = function _hasInvalidDimensions() {
	        for (var i = 0, list = [
	                    this.canvas.width,
	                    this.canvas.height
	                ]; i < list.length; i += 1) {
	            var x = list[i];
	            if (isNaN(x) || x <= 0) {
	                return true;
	            }
	        }
	        return false;
	    };
	    return CanvasSource;
	}(ImageSource);

	var sourceTypes = {
	    vector: VectorTileSource,
	    raster: RasterTileSource,
	    'raster-dem': RasterDEMTileSource,
	    geojson: GeoJSONSource,
	    video: VideoSource,
	    image: ImageSource,
	    canvas: CanvasSource
	};
	var create = function (id, specification, dispatcher, eventedParent) {
	    var source = new sourceTypes[specification.type](id, specification, dispatcher, eventedParent);
	    if (source.id !== id) {
	        throw new Error('Expected Source id to be ' + id + ' instead of ' + source.id);
	    }
	    performance.bindAll([
	        'load',
	        'abort',
	        'unload',
	        'serialize',
	        'prepare'
	    ], source);
	    return source;
	};
	var getType = function (name) {
	    return sourceTypes[name];
	};
	var setType = function (name, type) {
	    sourceTypes[name] = type;
	};

	function getPixelPosMatrix(transform, tileID) {
	    var t = performance.identity([]);
	    performance.translate(t, t, [
	        1,
	        1,
	        0
	    ]);
	    performance.scale(t, t, [
	        transform.width * 0.5,
	        transform.height * 0.5,
	        1
	    ]);
	    return performance.multiply(t, t, transform.calculatePosMatrix(tileID.toUnwrapped()));
	}
	function queryIncludes3DLayer(layers, styleLayers, sourceID) {
	    if (layers) {
	        for (var i = 0, list = layers; i < list.length; i += 1) {
	            var layerID = list[i];
	            var layer = styleLayers[layerID];
	            if (layer && layer.source === sourceID && layer.type === 'fill-extrusion') {
	                return true;
	            }
	        }
	    } else {
	        for (var key in styleLayers) {
	            var layer$1 = styleLayers[key];
	            if (layer$1.source === sourceID && layer$1.type === 'fill-extrusion') {
	                return true;
	            }
	        }
	    }
	    return false;
	}
	function queryRenderedFeatures(sourceCache, styleLayers, serializedLayers, queryGeometry, params, transform) {
	    var has3DLayer = queryIncludes3DLayer(params && params.layers, styleLayers, sourceCache.id);
	    var maxPitchScaleFactor = transform.maxPitchScaleFactor();
	    var tilesIn = sourceCache.tilesIn(queryGeometry, maxPitchScaleFactor, has3DLayer);
	    tilesIn.sort(sortTilesIn);
	    var renderedFeatureLayers = [];
	    for (var i = 0, list = tilesIn; i < list.length; i += 1) {
	        var tileIn = list[i];
	        renderedFeatureLayers.push({
	            wrappedTileID: tileIn.tileID.wrapped().key,
	            queryResults: tileIn.tile.queryRenderedFeatures(styleLayers, serializedLayers, sourceCache._state, tileIn.queryGeometry, tileIn.cameraQueryGeometry, tileIn.scale, params, transform, maxPitchScaleFactor, getPixelPosMatrix(sourceCache.transform, tileIn.tileID))
	        });
	    }
	    var result = mergeRenderedFeatureLayers(renderedFeatureLayers);
	    for (var layerID in result) {
	        result[layerID].forEach(function (featureWrapper) {
	            var feature = featureWrapper.feature;
	            var state = sourceCache.getFeatureState(feature.layer['source-layer'], feature.id);
	            feature.source = feature.layer.source;
	            if (feature.layer['source-layer']) {
	                feature.sourceLayer = feature.layer['source-layer'];
	            }
	            feature.state = state;
	        });
	    }
	    return result;
	}
	function queryRenderedSymbols(styleLayers, serializedLayers, sourceCaches, queryGeometry, params, collisionIndex, retainedQueryData) {
	    var result = {};
	    var renderedSymbols = collisionIndex.queryRenderedSymbols(queryGeometry);
	    var bucketQueryData = [];
	    for (var i = 0, list = Object.keys(renderedSymbols).map(Number); i < list.length; i += 1) {
	        var bucketInstanceId = list[i];
	        bucketQueryData.push(retainedQueryData[bucketInstanceId]);
	    }
	    bucketQueryData.sort(sortTilesIn);
	    var loop = function () {
	        var queryData = list$2[i$2];
	        var bucketSymbols = queryData.featureIndex.lookupSymbolFeatures(renderedSymbols[queryData.bucketInstanceId], serializedLayers, queryData.bucketIndex, queryData.sourceLayerIndex, params.filter, params.layers, params.availableImages, styleLayers);
	        for (var layerID in bucketSymbols) {
	            var resultFeatures = result[layerID] = result[layerID] || [];
	            var layerSymbols = bucketSymbols[layerID];
	            layerSymbols.sort(function (a, b) {
	                var featureSortOrder = queryData.featureSortOrder;
	                if (featureSortOrder) {
	                    var sortedA = featureSortOrder.indexOf(a.featureIndex);
	                    var sortedB = featureSortOrder.indexOf(b.featureIndex);
	                    return sortedB - sortedA;
	                } else {
	                    return b.featureIndex - a.featureIndex;
	                }
	            });
	            for (var i$1 = 0, list$1 = layerSymbols; i$1 < list$1.length; i$1 += 1) {
	                var symbolFeature = list$1[i$1];
	                resultFeatures.push(symbolFeature);
	            }
	        }
	    };
	    for (var i$2 = 0, list$2 = bucketQueryData; i$2 < list$2.length; i$2 += 1)
	        loop();
	    var loop$1 = function (layerName) {
	        result[layerName].forEach(function (featureWrapper) {
	            var feature = featureWrapper.feature;
	            var layer = styleLayers[layerName];
	            var sourceCache = sourceCaches[layer.source];
	            var state = sourceCache.getFeatureState(feature.layer['source-layer'], feature.id);
	            feature.source = feature.layer.source;
	            if (feature.layer['source-layer']) {
	                feature.sourceLayer = feature.layer['source-layer'];
	            }
	            feature.state = state;
	        });
	    };
	    for (var layerName in result)
	        loop$1(layerName);
	    return result;
	}
	function querySourceFeatures(sourceCache, params) {
	    var tiles = sourceCache.getRenderableIds().map(function (id) {
	        return sourceCache.getTileByID(id);
	    });
	    var result = [];
	    var dataTiles = {};
	    for (var i = 0; i < tiles.length; i++) {
	        var tile = tiles[i];
	        var dataID = tile.tileID.canonical.key;
	        if (!dataTiles[dataID]) {
	            dataTiles[dataID] = true;
	            tile.querySourceFeatures(result, params);
	        }
	    }
	    return result;
	}
	function sortTilesIn(a, b) {
	    var idA = a.tileID;
	    var idB = b.tileID;
	    return idA.overscaledZ - idB.overscaledZ || idA.canonical.y - idB.canonical.y || idA.wrap - idB.wrap || idA.canonical.x - idB.canonical.x;
	}
	function mergeRenderedFeatureLayers(tiles) {
	    var result = {};
	    var wrappedIDLayerMap = {};
	    for (var i$1 = 0, list$1 = tiles; i$1 < list$1.length; i$1 += 1) {
	        var tile = list$1[i$1];
	        var queryResults = tile.queryResults;
	        var wrappedID = tile.wrappedTileID;
	        var wrappedIDLayers = wrappedIDLayerMap[wrappedID] = wrappedIDLayerMap[wrappedID] || {};
	        for (var layerID in queryResults) {
	            var tileFeatures = queryResults[layerID];
	            var wrappedIDFeatures = wrappedIDLayers[layerID] = wrappedIDLayers[layerID] || {};
	            var resultFeatures = result[layerID] = result[layerID] || [];
	            for (var i = 0, list = tileFeatures; i < list.length; i += 1) {
	                var tileFeature = list[i];
	                if (!wrappedIDFeatures[tileFeature.featureIndex]) {
	                    wrappedIDFeatures[tileFeature.featureIndex] = true;
	                    resultFeatures.push(tileFeature);
	                }
	            }
	        }
	    }
	    return result;
	}

	var TileCache = function TileCache(max, onRemove) {
	    this.max = max;
	    this.onRemove = onRemove;
	    this.reset();
	};
	TileCache.prototype.reset = function reset() {
	    for (var key in this.data) {
	        for (var i = 0, list = this.data[key]; i < list.length; i += 1) {
	            var removedData = list[i];
	            if (removedData.timeout) {
	                clearTimeout(removedData.timeout);
	            }
	            this.onRemove(removedData.value);
	        }
	    }
	    this.data = {};
	    this.order = [];
	    return this;
	};
	TileCache.prototype.add = function add(tileID, data, expiryTimeout) {
	    var this$1 = this;
	    var key = tileID.wrapped().key;
	    if (this.data[key] === undefined) {
	        this.data[key] = [];
	    }
	    var dataWrapper = {
	        value: data,
	        timeout: undefined
	    };
	    if (expiryTimeout !== undefined) {
	        dataWrapper.timeout = setTimeout(function () {
	            this$1.remove(tileID, dataWrapper);
	        }, expiryTimeout);
	    }
	    this.data[key].push(dataWrapper);
	    this.order.push(key);
	    if (this.order.length > this.max) {
	        var removedData = this._getAndRemoveByKey(this.order[0]);
	        if (removedData) {
	            this.onRemove(removedData);
	        }
	    }
	    return this;
	};
	TileCache.prototype.has = function has(tileID) {
	    return tileID.wrapped().key in this.data;
	};
	TileCache.prototype.getAndRemove = function getAndRemove(tileID) {
	    if (!this.has(tileID)) {
	        return null;
	    }
	    return this._getAndRemoveByKey(tileID.wrapped().key);
	};
	TileCache.prototype._getAndRemoveByKey = function _getAndRemoveByKey(key) {
	    var data = this.data[key].shift();
	    if (data.timeout) {
	        clearTimeout(data.timeout);
	    }
	    if (this.data[key].length === 0) {
	        delete this.data[key];
	    }
	    this.order.splice(this.order.indexOf(key), 1);
	    return data.value;
	};
	TileCache.prototype.getByKey = function getByKey(key) {
	    var data = this.data[key];
	    return data ? data[0].value : null;
	};
	TileCache.prototype.get = function get(tileID) {
	    if (!this.has(tileID)) {
	        return null;
	    }
	    var data = this.data[tileID.wrapped().key][0];
	    return data.value;
	};
	TileCache.prototype.remove = function remove(tileID, value) {
	    if (!this.has(tileID)) {
	        return this;
	    }
	    var key = tileID.wrapped().key;
	    var dataIndex = value === undefined ? 0 : this.data[key].indexOf(value);
	    var data = this.data[key][dataIndex];
	    this.data[key].splice(dataIndex, 1);
	    if (data.timeout) {
	        clearTimeout(data.timeout);
	    }
	    if (this.data[key].length === 0) {
	        delete this.data[key];
	    }
	    this.onRemove(data.value);
	    this.order.splice(this.order.indexOf(key), 1);
	    return this;
	};
	TileCache.prototype.setMaxSize = function setMaxSize(max) {
	    this.max = max;
	    while (this.order.length > this.max) {
	        var removedData = this._getAndRemoveByKey(this.order[0]);
	        if (removedData) {
	            this.onRemove(removedData);
	        }
	    }
	    return this;
	};
	TileCache.prototype.filter = function filter(filterFn) {
	    var removed = [];
	    for (var key in this.data) {
	        for (var i = 0, list = this.data[key]; i < list.length; i += 1) {
	            var entry = list[i];
	            if (!filterFn(entry.value)) {
	                removed.push(entry);
	            }
	        }
	    }
	    for (var i$1 = 0, list$1 = removed; i$1 < list$1.length; i$1 += 1) {
	        var r = list$1[i$1];
	        this.remove(r.value.tileID, r);
	    }
	};

	var IndexBuffer = function IndexBuffer(context, array, dynamicDraw) {
	    this.context = context;
	    var gl = context.gl;
	    this.buffer = gl.createBuffer();
	    this.dynamicDraw = Boolean(dynamicDraw);
	    this.context.unbindVAO();
	    context.bindElementBuffer.set(this.buffer);
	    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array.arrayBuffer, this.dynamicDraw ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW);
	    if (!this.dynamicDraw) {
	        delete array.arrayBuffer;
	    }
	};
	IndexBuffer.prototype.bind = function bind() {
	    this.context.bindElementBuffer.set(this.buffer);
	};
	IndexBuffer.prototype.updateData = function updateData(array) {
	    var gl = this.context.gl;
	    this.context.unbindVAO();
	    this.bind();
	    gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, array.arrayBuffer);
	};
	IndexBuffer.prototype.destroy = function destroy() {
	    var gl = this.context.gl;
	    if (this.buffer) {
	        gl.deleteBuffer(this.buffer);
	        delete this.buffer;
	    }
	};

	var AttributeType = {
	    Int8: 'BYTE',
	    Uint8: 'UNSIGNED_BYTE',
	    Int16: 'SHORT',
	    Uint16: 'UNSIGNED_SHORT',
	    Int32: 'INT',
	    Uint32: 'UNSIGNED_INT',
	    Float32: 'FLOAT'
	};
	var VertexBuffer = function VertexBuffer(context, array, attributes, dynamicDraw) {
	    this.length = array.length;
	    this.attributes = attributes;
	    this.itemSize = array.bytesPerElement;
	    this.dynamicDraw = dynamicDraw;
	    this.context = context;
	    var gl = context.gl;
	    this.buffer = gl.createBuffer();
	    context.bindVertexBuffer.set(this.buffer);
	    gl.bufferData(gl.ARRAY_BUFFER, array.arrayBuffer, this.dynamicDraw ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW);
	    if (!this.dynamicDraw) {
	        delete array.arrayBuffer;
	    }
	};
	VertexBuffer.prototype.bind = function bind() {
	    this.context.bindVertexBuffer.set(this.buffer);
	};
	VertexBuffer.prototype.updateData = function updateData(array) {
	    var gl = this.context.gl;
	    this.bind();
	    gl.bufferSubData(gl.ARRAY_BUFFER, 0, array.arrayBuffer);
	};
	VertexBuffer.prototype.enableAttributes = function enableAttributes(gl, program) {
	    for (var j = 0; j < this.attributes.length; j++) {
	        var member = this.attributes[j];
	        var attribIndex = program.attributes[member.name];
	        if (attribIndex !== undefined) {
	            gl.enableVertexAttribArray(attribIndex);
	        }
	    }
	};
	VertexBuffer.prototype.setVertexAttribPointers = function setVertexAttribPointers(gl, program, vertexOffset) {
	    for (var j = 0; j < this.attributes.length; j++) {
	        var member = this.attributes[j];
	        var attribIndex = program.attributes[member.name];
	        if (attribIndex !== undefined) {
	            gl.vertexAttribPointer(attribIndex, member.components, gl[AttributeType[member.type]], false, this.itemSize, member.offset + this.itemSize * (vertexOffset || 0));
	        }
	    }
	};
	VertexBuffer.prototype.destroy = function destroy() {
	    var gl = this.context.gl;
	    if (this.buffer) {
	        gl.deleteBuffer(this.buffer);
	        delete this.buffer;
	    }
	};

	var BaseValue = function BaseValue(context) {
	    this.gl = context.gl;
	    this.default = this.getDefault();
	    this.current = this.default;
	    this.dirty = false;
	};
	BaseValue.prototype.get = function get() {
	    return this.current;
	};
	BaseValue.prototype.set = function set(value) {
	};
	BaseValue.prototype.getDefault = function getDefault() {
	    return this.default;
	};
	BaseValue.prototype.setDefault = function setDefault() {
	    this.set(this.default);
	};
	var ClearColor = function (BaseValue) {
	    function ClearColor() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        ClearColor.__proto__ = BaseValue;
	    ClearColor.prototype = Object.create(BaseValue && BaseValue.prototype);
	    ClearColor.prototype.constructor = ClearColor;
	    ClearColor.prototype.getDefault = function getDefault() {
	        return performance.Color.transparent;
	    };
	    ClearColor.prototype.set = function set(v) {
	        var c = this.current;
	        if (v.r === c.r && v.g === c.g && v.b === c.b && v.a === c.a && !this.dirty) {
	            return;
	        }
	        this.gl.clearColor(v.r, v.g, v.b, v.a);
	        this.current = v;
	        this.dirty = false;
	    };
	    return ClearColor;
	}(BaseValue);
	var ClearDepth = function (BaseValue) {
	    function ClearDepth() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        ClearDepth.__proto__ = BaseValue;
	    ClearDepth.prototype = Object.create(BaseValue && BaseValue.prototype);
	    ClearDepth.prototype.constructor = ClearDepth;
	    ClearDepth.prototype.getDefault = function getDefault() {
	        return 1;
	    };
	    ClearDepth.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        this.gl.clearDepth(v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return ClearDepth;
	}(BaseValue);
	var ClearStencil = function (BaseValue) {
	    function ClearStencil() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        ClearStencil.__proto__ = BaseValue;
	    ClearStencil.prototype = Object.create(BaseValue && BaseValue.prototype);
	    ClearStencil.prototype.constructor = ClearStencil;
	    ClearStencil.prototype.getDefault = function getDefault() {
	        return 0;
	    };
	    ClearStencil.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        this.gl.clearStencil(v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return ClearStencil;
	}(BaseValue);
	var ColorMask = function (BaseValue) {
	    function ColorMask() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        ColorMask.__proto__ = BaseValue;
	    ColorMask.prototype = Object.create(BaseValue && BaseValue.prototype);
	    ColorMask.prototype.constructor = ColorMask;
	    ColorMask.prototype.getDefault = function getDefault() {
	        return [
	            true,
	            true,
	            true,
	            true
	        ];
	    };
	    ColorMask.prototype.set = function set(v) {
	        var c = this.current;
	        if (v[0] === c[0] && v[1] === c[1] && v[2] === c[2] && v[3] === c[3] && !this.dirty) {
	            return;
	        }
	        this.gl.colorMask(v[0], v[1], v[2], v[3]);
	        this.current = v;
	        this.dirty = false;
	    };
	    return ColorMask;
	}(BaseValue);
	var DepthMask = function (BaseValue) {
	    function DepthMask() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        DepthMask.__proto__ = BaseValue;
	    DepthMask.prototype = Object.create(BaseValue && BaseValue.prototype);
	    DepthMask.prototype.constructor = DepthMask;
	    DepthMask.prototype.getDefault = function getDefault() {
	        return true;
	    };
	    DepthMask.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        this.gl.depthMask(v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return DepthMask;
	}(BaseValue);
	var StencilMask = function (BaseValue) {
	    function StencilMask() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        StencilMask.__proto__ = BaseValue;
	    StencilMask.prototype = Object.create(BaseValue && BaseValue.prototype);
	    StencilMask.prototype.constructor = StencilMask;
	    StencilMask.prototype.getDefault = function getDefault() {
	        return 255;
	    };
	    StencilMask.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        this.gl.stencilMask(v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return StencilMask;
	}(BaseValue);
	var StencilFunc = function (BaseValue) {
	    function StencilFunc() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        StencilFunc.__proto__ = BaseValue;
	    StencilFunc.prototype = Object.create(BaseValue && BaseValue.prototype);
	    StencilFunc.prototype.constructor = StencilFunc;
	    StencilFunc.prototype.getDefault = function getDefault() {
	        return {
	            func: this.gl.ALWAYS,
	            ref: 0,
	            mask: 255
	        };
	    };
	    StencilFunc.prototype.set = function set(v) {
	        var c = this.current;
	        if (v.func === c.func && v.ref === c.ref && v.mask === c.mask && !this.dirty) {
	            return;
	        }
	        this.gl.stencilFunc(v.func, v.ref, v.mask);
	        this.current = v;
	        this.dirty = false;
	    };
	    return StencilFunc;
	}(BaseValue);
	var StencilOp = function (BaseValue) {
	    function StencilOp() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        StencilOp.__proto__ = BaseValue;
	    StencilOp.prototype = Object.create(BaseValue && BaseValue.prototype);
	    StencilOp.prototype.constructor = StencilOp;
	    StencilOp.prototype.getDefault = function getDefault() {
	        var gl = this.gl;
	        return [
	            gl.KEEP,
	            gl.KEEP,
	            gl.KEEP
	        ];
	    };
	    StencilOp.prototype.set = function set(v) {
	        var c = this.current;
	        if (v[0] === c[0] && v[1] === c[1] && v[2] === c[2] && !this.dirty) {
	            return;
	        }
	        this.gl.stencilOp(v[0], v[1], v[2]);
	        this.current = v;
	        this.dirty = false;
	    };
	    return StencilOp;
	}(BaseValue);
	var StencilTest = function (BaseValue) {
	    function StencilTest() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        StencilTest.__proto__ = BaseValue;
	    StencilTest.prototype = Object.create(BaseValue && BaseValue.prototype);
	    StencilTest.prototype.constructor = StencilTest;
	    StencilTest.prototype.getDefault = function getDefault() {
	        return false;
	    };
	    StencilTest.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        var gl = this.gl;
	        if (v) {
	            gl.enable(gl.STENCIL_TEST);
	        } else {
	            gl.disable(gl.STENCIL_TEST);
	        }
	        this.current = v;
	        this.dirty = false;
	    };
	    return StencilTest;
	}(BaseValue);
	var DepthRange = function (BaseValue) {
	    function DepthRange() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        DepthRange.__proto__ = BaseValue;
	    DepthRange.prototype = Object.create(BaseValue && BaseValue.prototype);
	    DepthRange.prototype.constructor = DepthRange;
	    DepthRange.prototype.getDefault = function getDefault() {
	        return [
	            0,
	            1
	        ];
	    };
	    DepthRange.prototype.set = function set(v) {
	        var c = this.current;
	        if (v[0] === c[0] && v[1] === c[1] && !this.dirty) {
	            return;
	        }
	        this.gl.depthRange(v[0], v[1]);
	        this.current = v;
	        this.dirty = false;
	    };
	    return DepthRange;
	}(BaseValue);
	var DepthTest = function (BaseValue) {
	    function DepthTest() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        DepthTest.__proto__ = BaseValue;
	    DepthTest.prototype = Object.create(BaseValue && BaseValue.prototype);
	    DepthTest.prototype.constructor = DepthTest;
	    DepthTest.prototype.getDefault = function getDefault() {
	        return false;
	    };
	    DepthTest.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        var gl = this.gl;
	        if (v) {
	            gl.enable(gl.DEPTH_TEST);
	        } else {
	            gl.disable(gl.DEPTH_TEST);
	        }
	        this.current = v;
	        this.dirty = false;
	    };
	    return DepthTest;
	}(BaseValue);
	var DepthFunc = function (BaseValue) {
	    function DepthFunc() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        DepthFunc.__proto__ = BaseValue;
	    DepthFunc.prototype = Object.create(BaseValue && BaseValue.prototype);
	    DepthFunc.prototype.constructor = DepthFunc;
	    DepthFunc.prototype.getDefault = function getDefault() {
	        return this.gl.LESS;
	    };
	    DepthFunc.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        this.gl.depthFunc(v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return DepthFunc;
	}(BaseValue);
	var Blend = function (BaseValue) {
	    function Blend() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        Blend.__proto__ = BaseValue;
	    Blend.prototype = Object.create(BaseValue && BaseValue.prototype);
	    Blend.prototype.constructor = Blend;
	    Blend.prototype.getDefault = function getDefault() {
	        return false;
	    };
	    Blend.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        var gl = this.gl;
	        if (v) {
	            gl.enable(gl.BLEND);
	        } else {
	            gl.disable(gl.BLEND);
	        }
	        this.current = v;
	        this.dirty = false;
	    };
	    return Blend;
	}(BaseValue);
	var BlendFunc = function (BaseValue) {
	    function BlendFunc() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        BlendFunc.__proto__ = BaseValue;
	    BlendFunc.prototype = Object.create(BaseValue && BaseValue.prototype);
	    BlendFunc.prototype.constructor = BlendFunc;
	    BlendFunc.prototype.getDefault = function getDefault() {
	        var gl = this.gl;
	        return [
	            gl.ONE,
	            gl.ZERO
	        ];
	    };
	    BlendFunc.prototype.set = function set(v) {
	        var c = this.current;
	        if (v[0] === c[0] && v[1] === c[1] && !this.dirty) {
	            return;
	        }
	        this.gl.blendFunc(v[0], v[1]);
	        this.current = v;
	        this.dirty = false;
	    };
	    return BlendFunc;
	}(BaseValue);
	var BlendColor = function (BaseValue) {
	    function BlendColor() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        BlendColor.__proto__ = BaseValue;
	    BlendColor.prototype = Object.create(BaseValue && BaseValue.prototype);
	    BlendColor.prototype.constructor = BlendColor;
	    BlendColor.prototype.getDefault = function getDefault() {
	        return performance.Color.transparent;
	    };
	    BlendColor.prototype.set = function set(v) {
	        var c = this.current;
	        if (v.r === c.r && v.g === c.g && v.b === c.b && v.a === c.a && !this.dirty) {
	            return;
	        }
	        this.gl.blendColor(v.r, v.g, v.b, v.a);
	        this.current = v;
	        this.dirty = false;
	    };
	    return BlendColor;
	}(BaseValue);
	var BlendEquation = function (BaseValue) {
	    function BlendEquation() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        BlendEquation.__proto__ = BaseValue;
	    BlendEquation.prototype = Object.create(BaseValue && BaseValue.prototype);
	    BlendEquation.prototype.constructor = BlendEquation;
	    BlendEquation.prototype.getDefault = function getDefault() {
	        return this.gl.FUNC_ADD;
	    };
	    BlendEquation.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        this.gl.blendEquation(v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return BlendEquation;
	}(BaseValue);
	var CullFace = function (BaseValue) {
	    function CullFace() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        CullFace.__proto__ = BaseValue;
	    CullFace.prototype = Object.create(BaseValue && BaseValue.prototype);
	    CullFace.prototype.constructor = CullFace;
	    CullFace.prototype.getDefault = function getDefault() {
	        return false;
	    };
	    CullFace.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        var gl = this.gl;
	        if (v) {
	            gl.enable(gl.CULL_FACE);
	        } else {
	            gl.disable(gl.CULL_FACE);
	        }
	        this.current = v;
	        this.dirty = false;
	    };
	    return CullFace;
	}(BaseValue);
	var CullFaceSide = function (BaseValue) {
	    function CullFaceSide() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        CullFaceSide.__proto__ = BaseValue;
	    CullFaceSide.prototype = Object.create(BaseValue && BaseValue.prototype);
	    CullFaceSide.prototype.constructor = CullFaceSide;
	    CullFaceSide.prototype.getDefault = function getDefault() {
	        return this.gl.BACK;
	    };
	    CullFaceSide.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        this.gl.cullFace(v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return CullFaceSide;
	}(BaseValue);
	var FrontFace = function (BaseValue) {
	    function FrontFace() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        FrontFace.__proto__ = BaseValue;
	    FrontFace.prototype = Object.create(BaseValue && BaseValue.prototype);
	    FrontFace.prototype.constructor = FrontFace;
	    FrontFace.prototype.getDefault = function getDefault() {
	        return this.gl.CCW;
	    };
	    FrontFace.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        this.gl.frontFace(v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return FrontFace;
	}(BaseValue);
	var Program = function (BaseValue) {
	    function Program() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        Program.__proto__ = BaseValue;
	    Program.prototype = Object.create(BaseValue && BaseValue.prototype);
	    Program.prototype.constructor = Program;
	    Program.prototype.getDefault = function getDefault() {
	        return null;
	    };
	    Program.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        this.gl.useProgram(v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return Program;
	}(BaseValue);
	var ActiveTextureUnit = function (BaseValue) {
	    function ActiveTextureUnit() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        ActiveTextureUnit.__proto__ = BaseValue;
	    ActiveTextureUnit.prototype = Object.create(BaseValue && BaseValue.prototype);
	    ActiveTextureUnit.prototype.constructor = ActiveTextureUnit;
	    ActiveTextureUnit.prototype.getDefault = function getDefault() {
	        return this.gl.TEXTURE0;
	    };
	    ActiveTextureUnit.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        this.gl.activeTexture(v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return ActiveTextureUnit;
	}(BaseValue);
	var Viewport = function (BaseValue) {
	    function Viewport() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        Viewport.__proto__ = BaseValue;
	    Viewport.prototype = Object.create(BaseValue && BaseValue.prototype);
	    Viewport.prototype.constructor = Viewport;
	    Viewport.prototype.getDefault = function getDefault() {
	        var gl = this.gl;
	        return [
	            0,
	            0,
	            gl.drawingBufferWidth,
	            gl.drawingBufferHeight
	        ];
	    };
	    Viewport.prototype.set = function set(v) {
	        var c = this.current;
	        if (v[0] === c[0] && v[1] === c[1] && v[2] === c[2] && v[3] === c[3] && !this.dirty) {
	            return;
	        }
	        this.gl.viewport(v[0], v[1], v[2], v[3]);
	        this.current = v;
	        this.dirty = false;
	    };
	    return Viewport;
	}(BaseValue);
	var BindFramebuffer = function (BaseValue) {
	    function BindFramebuffer() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        BindFramebuffer.__proto__ = BaseValue;
	    BindFramebuffer.prototype = Object.create(BaseValue && BaseValue.prototype);
	    BindFramebuffer.prototype.constructor = BindFramebuffer;
	    BindFramebuffer.prototype.getDefault = function getDefault() {
	        return null;
	    };
	    BindFramebuffer.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        var gl = this.gl;
	        gl.bindFramebuffer(gl.FRAMEBUFFER, v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return BindFramebuffer;
	}(BaseValue);
	var BindRenderbuffer = function (BaseValue) {
	    function BindRenderbuffer() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        BindRenderbuffer.__proto__ = BaseValue;
	    BindRenderbuffer.prototype = Object.create(BaseValue && BaseValue.prototype);
	    BindRenderbuffer.prototype.constructor = BindRenderbuffer;
	    BindRenderbuffer.prototype.getDefault = function getDefault() {
	        return null;
	    };
	    BindRenderbuffer.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        var gl = this.gl;
	        gl.bindRenderbuffer(gl.RENDERBUFFER, v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return BindRenderbuffer;
	}(BaseValue);
	var BindTexture = function (BaseValue) {
	    function BindTexture() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        BindTexture.__proto__ = BaseValue;
	    BindTexture.prototype = Object.create(BaseValue && BaseValue.prototype);
	    BindTexture.prototype.constructor = BindTexture;
	    BindTexture.prototype.getDefault = function getDefault() {
	        return null;
	    };
	    BindTexture.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        var gl = this.gl;
	        gl.bindTexture(gl.TEXTURE_2D, v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return BindTexture;
	}(BaseValue);
	var BindVertexBuffer = function (BaseValue) {
	    function BindVertexBuffer() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        BindVertexBuffer.__proto__ = BaseValue;
	    BindVertexBuffer.prototype = Object.create(BaseValue && BaseValue.prototype);
	    BindVertexBuffer.prototype.constructor = BindVertexBuffer;
	    BindVertexBuffer.prototype.getDefault = function getDefault() {
	        return null;
	    };
	    BindVertexBuffer.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        var gl = this.gl;
	        gl.bindBuffer(gl.ARRAY_BUFFER, v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return BindVertexBuffer;
	}(BaseValue);
	var BindElementBuffer = function (BaseValue) {
	    function BindElementBuffer() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        BindElementBuffer.__proto__ = BaseValue;
	    BindElementBuffer.prototype = Object.create(BaseValue && BaseValue.prototype);
	    BindElementBuffer.prototype.constructor = BindElementBuffer;
	    BindElementBuffer.prototype.getDefault = function getDefault() {
	        return null;
	    };
	    BindElementBuffer.prototype.set = function set(v) {
	        var gl = this.gl;
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return BindElementBuffer;
	}(BaseValue);
	var BindVertexArrayOES = function (BaseValue) {
	    function BindVertexArrayOES(context) {
	        BaseValue.call(this, context);
	        this.vao = context.extVertexArrayObject;
	    }
	    if (BaseValue)
	        BindVertexArrayOES.__proto__ = BaseValue;
	    BindVertexArrayOES.prototype = Object.create(BaseValue && BaseValue.prototype);
	    BindVertexArrayOES.prototype.constructor = BindVertexArrayOES;
	    BindVertexArrayOES.prototype.getDefault = function getDefault() {
	        return null;
	    };
	    BindVertexArrayOES.prototype.set = function set(v) {
	        if (!this.vao || v === this.current && !this.dirty) {
	            return;
	        }
	        this.vao.bindVertexArrayOES(v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return BindVertexArrayOES;
	}(BaseValue);
	var PixelStoreUnpack = function (BaseValue) {
	    function PixelStoreUnpack() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        PixelStoreUnpack.__proto__ = BaseValue;
	    PixelStoreUnpack.prototype = Object.create(BaseValue && BaseValue.prototype);
	    PixelStoreUnpack.prototype.constructor = PixelStoreUnpack;
	    PixelStoreUnpack.prototype.getDefault = function getDefault() {
	        return 4;
	    };
	    PixelStoreUnpack.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        var gl = this.gl;
	        gl.pixelStorei(gl.UNPACK_ALIGNMENT, v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return PixelStoreUnpack;
	}(BaseValue);
	var PixelStoreUnpackPremultiplyAlpha = function (BaseValue) {
	    function PixelStoreUnpackPremultiplyAlpha() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        PixelStoreUnpackPremultiplyAlpha.__proto__ = BaseValue;
	    PixelStoreUnpackPremultiplyAlpha.prototype = Object.create(BaseValue && BaseValue.prototype);
	    PixelStoreUnpackPremultiplyAlpha.prototype.constructor = PixelStoreUnpackPremultiplyAlpha;
	    PixelStoreUnpackPremultiplyAlpha.prototype.getDefault = function getDefault() {
	        return false;
	    };
	    PixelStoreUnpackPremultiplyAlpha.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        var gl = this.gl;
	        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return PixelStoreUnpackPremultiplyAlpha;
	}(BaseValue);
	var PixelStoreUnpackFlipY = function (BaseValue) {
	    function PixelStoreUnpackFlipY() {
	        BaseValue.apply(this, arguments);
	    }
	    if (BaseValue)
	        PixelStoreUnpackFlipY.__proto__ = BaseValue;
	    PixelStoreUnpackFlipY.prototype = Object.create(BaseValue && BaseValue.prototype);
	    PixelStoreUnpackFlipY.prototype.constructor = PixelStoreUnpackFlipY;
	    PixelStoreUnpackFlipY.prototype.getDefault = function getDefault() {
	        return false;
	    };
	    PixelStoreUnpackFlipY.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        var gl = this.gl;
	        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return PixelStoreUnpackFlipY;
	}(BaseValue);
	var FramebufferAttachment = function (BaseValue) {
	    function FramebufferAttachment(context, parent) {
	        BaseValue.call(this, context);
	        this.context = context;
	        this.parent = parent;
	    }
	    if (BaseValue)
	        FramebufferAttachment.__proto__ = BaseValue;
	    FramebufferAttachment.prototype = Object.create(BaseValue && BaseValue.prototype);
	    FramebufferAttachment.prototype.constructor = FramebufferAttachment;
	    FramebufferAttachment.prototype.getDefault = function getDefault() {
	        return null;
	    };
	    return FramebufferAttachment;
	}(BaseValue);
	var ColorAttachment = function (FramebufferAttachment) {
	    function ColorAttachment() {
	        FramebufferAttachment.apply(this, arguments);
	    }
	    if (FramebufferAttachment)
	        ColorAttachment.__proto__ = FramebufferAttachment;
	    ColorAttachment.prototype = Object.create(FramebufferAttachment && FramebufferAttachment.prototype);
	    ColorAttachment.prototype.constructor = ColorAttachment;
	    ColorAttachment.prototype.setDirty = function setDirty() {
	        this.dirty = true;
	    };
	    ColorAttachment.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        this.context.bindFramebuffer.set(this.parent);
	        var gl = this.gl;
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, v, 0);
	        this.current = v;
	        this.dirty = false;
	    };
	    return ColorAttachment;
	}(FramebufferAttachment);
	var DepthAttachment = function (FramebufferAttachment) {
	    function DepthAttachment() {
	        FramebufferAttachment.apply(this, arguments);
	    }
	    if (FramebufferAttachment)
	        DepthAttachment.__proto__ = FramebufferAttachment;
	    DepthAttachment.prototype = Object.create(FramebufferAttachment && FramebufferAttachment.prototype);
	    DepthAttachment.prototype.constructor = DepthAttachment;
	    DepthAttachment.prototype.set = function set(v) {
	        if (v === this.current && !this.dirty) {
	            return;
	        }
	        this.context.bindFramebuffer.set(this.parent);
	        var gl = this.gl;
	        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, v);
	        this.current = v;
	        this.dirty = false;
	    };
	    return DepthAttachment;
	}(FramebufferAttachment);

	var Framebuffer = function Framebuffer(context, width, height, hasDepth) {
	    this.context = context;
	    this.width = width;
	    this.height = height;
	    var gl = context.gl;
	    var fbo = this.framebuffer = gl.createFramebuffer();
	    this.colorAttachment = new ColorAttachment(context, fbo);
	    if (hasDepth) {
	        this.depthAttachment = new DepthAttachment(context, fbo);
	    }
	};
	Framebuffer.prototype.destroy = function destroy() {
	    var gl = this.context.gl;
	    var texture = this.colorAttachment.get();
	    if (texture) {
	        gl.deleteTexture(texture);
	    }
	    if (this.depthAttachment) {
	        var renderbuffer = this.depthAttachment.get();
	        if (renderbuffer) {
	            gl.deleteRenderbuffer(renderbuffer);
	        }
	    }
	    gl.deleteFramebuffer(this.framebuffer);
	};

	var ALWAYS = 519;
	var DepthMode = function DepthMode(depthFunc, depthMask, depthRange) {
	    this.func = depthFunc;
	    this.mask = depthMask;
	    this.range = depthRange;
	};
	DepthMode.ReadOnly = false;
	DepthMode.ReadWrite = true;
	DepthMode.disabled = new DepthMode(ALWAYS, DepthMode.ReadOnly, [
	    0,
	    1
	]);

	var ALWAYS$1 = 519;
	var KEEP = 7680;
	var StencilMode = function StencilMode(test, ref, mask, fail, depthFail, pass) {
	    this.test = test;
	    this.ref = ref;
	    this.mask = mask;
	    this.fail = fail;
	    this.depthFail = depthFail;
	    this.pass = pass;
	};
	StencilMode.disabled = new StencilMode({
	    func: ALWAYS$1,
	    mask: 0
	}, 0, 0, KEEP, KEEP, KEEP);

	var ZERO = 0;
	var ONE = 1;
	var ONE_MINUS_SRC_ALPHA = 771;
	var ColorMode = function ColorMode(blendFunction, blendColor, mask) {
	    this.blendFunction = blendFunction;
	    this.blendColor = blendColor;
	    this.mask = mask;
	};
	ColorMode.Replace = [
	    ONE,
	    ZERO
	];
	ColorMode.disabled = new ColorMode(ColorMode.Replace, performance.Color.transparent, [
	    false,
	    false,
	    false,
	    false
	]);
	ColorMode.unblended = new ColorMode(ColorMode.Replace, performance.Color.transparent, [
	    true,
	    true,
	    true,
	    true
	]);
	ColorMode.alphaBlended = new ColorMode([
	    ONE,
	    ONE_MINUS_SRC_ALPHA
	], performance.Color.transparent, [
	    true,
	    true,
	    true,
	    true
	]);

	var BACK = 1029;
	var CCW = 2305;
	var CullFaceMode = function CullFaceMode(enable, mode, frontFace) {
	    this.enable = enable;
	    this.mode = mode;
	    this.frontFace = frontFace;
	};
	CullFaceMode.disabled = new CullFaceMode(false, BACK, CCW);
	CullFaceMode.backCCW = new CullFaceMode(true, BACK, CCW);

	var Context = function Context(gl) {
	    this.gl = gl;
	    this.extVertexArrayObject = this.gl.getExtension('OES_vertex_array_object');
	    this.clearColor = new ClearColor(this);
	    this.clearDepth = new ClearDepth(this);
	    this.clearStencil = new ClearStencil(this);
	    this.colorMask = new ColorMask(this);
	    this.depthMask = new DepthMask(this);
	    this.stencilMask = new StencilMask(this);
	    this.stencilFunc = new StencilFunc(this);
	    this.stencilOp = new StencilOp(this);
	    this.stencilTest = new StencilTest(this);
	    this.depthRange = new DepthRange(this);
	    this.depthTest = new DepthTest(this);
	    this.depthFunc = new DepthFunc(this);
	    this.blend = new Blend(this);
	    this.blendFunc = new BlendFunc(this);
	    this.blendColor = new BlendColor(this);
	    this.blendEquation = new BlendEquation(this);
	    this.cullFace = new CullFace(this);
	    this.cullFaceSide = new CullFaceSide(this);
	    this.frontFace = new FrontFace(this);
	    this.program = new Program(this);
	    this.activeTexture = new ActiveTextureUnit(this);
	    this.viewport = new Viewport(this);
	    this.bindFramebuffer = new BindFramebuffer(this);
	    this.bindRenderbuffer = new BindRenderbuffer(this);
	    this.bindTexture = new BindTexture(this);
	    this.bindVertexBuffer = new BindVertexBuffer(this);
	    this.bindElementBuffer = new BindElementBuffer(this);
	    this.bindVertexArrayOES = this.extVertexArrayObject && new BindVertexArrayOES(this);
	    this.pixelStoreUnpack = new PixelStoreUnpack(this);
	    this.pixelStoreUnpackPremultiplyAlpha = new PixelStoreUnpackPremultiplyAlpha(this);
	    this.pixelStoreUnpackFlipY = new PixelStoreUnpackFlipY(this);
	    this.extTextureFilterAnisotropic = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
	    if (this.extTextureFilterAnisotropic) {
	        this.extTextureFilterAnisotropicMax = gl.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
	    }
	    this.extTextureHalfFloat = gl.getExtension('OES_texture_half_float');
	    if (this.extTextureHalfFloat) {
	        gl.getExtension('OES_texture_half_float_linear');
	        this.extRenderToTextureHalfFloat = gl.getExtension('EXT_color_buffer_half_float');
	    }
	    this.extTimerQuery = gl.getExtension('EXT_disjoint_timer_query');
	    this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	};
	Context.prototype.setDefault = function setDefault() {
	    this.unbindVAO();
	    this.clearColor.setDefault();
	    this.clearDepth.setDefault();
	    this.clearStencil.setDefault();
	    this.colorMask.setDefault();
	    this.depthMask.setDefault();
	    this.stencilMask.setDefault();
	    this.stencilFunc.setDefault();
	    this.stencilOp.setDefault();
	    this.stencilTest.setDefault();
	    this.depthRange.setDefault();
	    this.depthTest.setDefault();
	    this.depthFunc.setDefault();
	    this.blend.setDefault();
	    this.blendFunc.setDefault();
	    this.blendColor.setDefault();
	    this.blendEquation.setDefault();
	    this.cullFace.setDefault();
	    this.cullFaceSide.setDefault();
	    this.frontFace.setDefault();
	    this.program.setDefault();
	    this.activeTexture.setDefault();
	    this.bindFramebuffer.setDefault();
	    this.pixelStoreUnpack.setDefault();
	    this.pixelStoreUnpackPremultiplyAlpha.setDefault();
	    this.pixelStoreUnpackFlipY.setDefault();
	};
	Context.prototype.setDirty = function setDirty() {
	    this.clearColor.dirty = true;
	    this.clearDepth.dirty = true;
	    this.clearStencil.dirty = true;
	    this.colorMask.dirty = true;
	    this.depthMask.dirty = true;
	    this.stencilMask.dirty = true;
	    this.stencilFunc.dirty = true;
	    this.stencilOp.dirty = true;
	    this.stencilTest.dirty = true;
	    this.depthRange.dirty = true;
	    this.depthTest.dirty = true;
	    this.depthFunc.dirty = true;
	    this.blend.dirty = true;
	    this.blendFunc.dirty = true;
	    this.blendColor.dirty = true;
	    this.blendEquation.dirty = true;
	    this.cullFace.dirty = true;
	    this.cullFaceSide.dirty = true;
	    this.frontFace.dirty = true;
	    this.program.dirty = true;
	    this.activeTexture.dirty = true;
	    this.viewport.dirty = true;
	    this.bindFramebuffer.dirty = true;
	    this.bindRenderbuffer.dirty = true;
	    this.bindTexture.dirty = true;
	    this.bindVertexBuffer.dirty = true;
	    this.bindElementBuffer.dirty = true;
	    if (this.extVertexArrayObject) {
	        this.bindVertexArrayOES.dirty = true;
	    }
	    this.pixelStoreUnpack.dirty = true;
	    this.pixelStoreUnpackPremultiplyAlpha.dirty = true;
	    this.pixelStoreUnpackFlipY.dirty = true;
	};
	Context.prototype.createIndexBuffer = function createIndexBuffer(array, dynamicDraw) {
	    return new IndexBuffer(this, array, dynamicDraw);
	};
	Context.prototype.createVertexBuffer = function createVertexBuffer(array, attributes, dynamicDraw) {
	    return new VertexBuffer(this, array, attributes, dynamicDraw);
	};
	Context.prototype.createRenderbuffer = function createRenderbuffer(storageFormat, width, height) {
	    var gl = this.gl;
	    var rbo = gl.createRenderbuffer();
	    this.bindRenderbuffer.set(rbo);
	    gl.renderbufferStorage(gl.RENDERBUFFER, storageFormat, width, height);
	    this.bindRenderbuffer.set(null);
	    return rbo;
	};
	Context.prototype.createFramebuffer = function createFramebuffer(width, height, hasDepth) {
	    return new Framebuffer(this, width, height, hasDepth);
	};
	Context.prototype.clear = function clear(ref) {
	    var color = ref.color;
	    var depth = ref.depth;
	    var gl = this.gl;
	    var mask = 0;
	    if (color) {
	        mask |= gl.COLOR_BUFFER_BIT;
	        this.clearColor.set(color);
	        this.colorMask.set([
	            true,
	            true,
	            true,
	            true
	        ]);
	    }
	    if (typeof depth !== 'undefined') {
	        mask |= gl.DEPTH_BUFFER_BIT;
	        this.depthRange.set([
	            0,
	            1
	        ]);
	        this.clearDepth.set(depth);
	        this.depthMask.set(true);
	    }
	    gl.clear(mask);
	};
	Context.prototype.setCullFace = function setCullFace(cullFaceMode) {
	    if (cullFaceMode.enable === false) {
	        this.cullFace.set(false);
	    } else {
	        this.cullFace.set(true);
	        this.cullFaceSide.set(cullFaceMode.mode);
	        this.frontFace.set(cullFaceMode.frontFace);
	    }
	};
	Context.prototype.setDepthMode = function setDepthMode(depthMode) {
	    if (depthMode.func === this.gl.ALWAYS && !depthMode.mask) {
	        this.depthTest.set(false);
	    } else {
	        this.depthTest.set(true);
	        this.depthFunc.set(depthMode.func);
	        this.depthMask.set(depthMode.mask);
	        this.depthRange.set(depthMode.range);
	    }
	};
	Context.prototype.setStencilMode = function setStencilMode(stencilMode) {
	    if (stencilMode.test.func === this.gl.ALWAYS && !stencilMode.mask) {
	        this.stencilTest.set(false);
	    } else {
	        this.stencilTest.set(true);
	        this.stencilMask.set(stencilMode.mask);
	        this.stencilOp.set([
	            stencilMode.fail,
	            stencilMode.depthFail,
	            stencilMode.pass
	        ]);
	        this.stencilFunc.set({
	            func: stencilMode.test.func,
	            ref: stencilMode.ref,
	            mask: stencilMode.test.mask
	        });
	    }
	};
	Context.prototype.setColorMode = function setColorMode(colorMode) {
	    if (performance.deepEqual(colorMode.blendFunction, ColorMode.Replace)) {
	        this.blend.set(false);
	    } else {
	        this.blend.set(true);
	        this.blendFunc.set(colorMode.blendFunction);
	        this.blendColor.set(colorMode.blendColor);
	    }
	    this.colorMask.set(colorMode.mask);
	};
	Context.prototype.unbindVAO = function unbindVAO() {
	    if (this.extVertexArrayObject) {
	        this.bindVertexArrayOES.set(null);
	    }
	};

	var SourceCache = function (Evented) {
	    function SourceCache(id, options, dispatcher) {
	        var this$1 = this;
	        Evented.call(this);
	        this.id = id;
	        this.dispatcher = dispatcher;
	        this.on('data', function (e) {
	            if (e.dataType === 'source' && e.sourceDataType === 'metadata') {
	                this$1._sourceLoaded = true;
	            }
	            if (this$1._sourceLoaded && !this$1._paused && e.dataType === 'source' && e.sourceDataType === 'content') {
	                this$1.reload();
	                if (this$1.transform) {
	                    this$1.update(this$1.transform);
	                }
	            }
	        });
	        this.on('error', function () {
	            this$1._sourceErrored = true;
	        });
	        this._source = create(id, options, dispatcher, this);
	        this._tiles = {};
	        this._cache = new TileCache(0, this._unloadTile.bind(this));
	        this._timers = {};
	        this._cacheTimers = {};
	        this._maxTileCacheSize = null;
	        this._loadedParentTiles = {};
	        this._coveredTiles = {};
	        this._state = new performance.SourceFeatureState();
	    }
	    if (Evented)
	        SourceCache.__proto__ = Evented;
	    SourceCache.prototype = Object.create(Evented && Evented.prototype);
	    SourceCache.prototype.constructor = SourceCache;
	    SourceCache.prototype.onAdd = function onAdd(map) {
	        this.map = map;
	        this._maxTileCacheSize = map ? map._maxTileCacheSize : null;
	        if (this._source && this._source.onAdd) {
	            this._source.onAdd(map);
	        }
	    };
	    SourceCache.prototype.onRemove = function onRemove(map) {
	        if (this._source && this._source.onRemove) {
	            this._source.onRemove(map);
	        }
	    };
	    SourceCache.prototype.loaded = function loaded() {
	        if (this._sourceErrored) {
	            return true;
	        }
	        if (!this._sourceLoaded) {
	            return false;
	        }
	        if (!this._source.loaded()) {
	            return false;
	        }
	        for (var t in this._tiles) {
	            var tile = this._tiles[t];
	            if (tile.state !== 'loaded' && tile.state !== 'errored') {
	                return false;
	            }
	        }
	        return true;
	    };
	    SourceCache.prototype.getSource = function getSource() {
	        return this._source;
	    };
	    SourceCache.prototype.pause = function pause() {
	        this._paused = true;
	    };
	    SourceCache.prototype.resume = function resume() {
	        if (!this._paused) {
	            return;
	        }
	        var shouldReload = this._shouldReloadOnResume;
	        this._paused = false;
	        this._shouldReloadOnResume = false;
	        if (shouldReload) {
	            this.reload();
	        }
	        if (this.transform) {
	            this.update(this.transform);
	        }
	    };
	    SourceCache.prototype._loadTile = function _loadTile(tile, callback) {
	        return this._source.loadTile(tile, callback);
	    };
	    SourceCache.prototype._unloadTile = function _unloadTile(tile) {
	        if (this._source.unloadTile) {
	            return this._source.unloadTile(tile, function () {
	            });
	        }
	    };
	    SourceCache.prototype._abortTile = function _abortTile(tile) {
	        if (this._source.abortTile) {
	            return this._source.abortTile(tile, function () {
	            });
	        }
	    };
	    SourceCache.prototype.serialize = function serialize() {
	        return this._source.serialize();
	    };
	    SourceCache.prototype.prepare = function prepare(context) {
	        if (this._source.prepare) {
	            this._source.prepare();
	        }
	        this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
	        for (var i in this._tiles) {
	            var tile = this._tiles[i];
	            tile.upload(context);
	            tile.prepare(this.map.style.imageManager);
	        }
	    };
	    SourceCache.prototype.getIds = function getIds() {
	        return performance.values(this._tiles).map(function (tile) {
	            return tile.tileID;
	        }).sort(compareTileId).map(function (id) {
	            return id.key;
	        });
	    };
	    SourceCache.prototype.getRenderableIds = function getRenderableIds(symbolLayer) {
	        var this$1 = this;
	        var renderables = [];
	        for (var id in this._tiles) {
	            if (this._isIdRenderable(id, symbolLayer)) {
	                renderables.push(this._tiles[id]);
	            }
	        }
	        if (symbolLayer) {
	            return renderables.sort(function (a_, b_) {
	                var a = a_.tileID;
	                var b = b_.tileID;
	                var rotatedA = new performance.Point(a.canonical.x, a.canonical.y)._rotate(this$1.transform.angle);
	                var rotatedB = new performance.Point(b.canonical.x, b.canonical.y)._rotate(this$1.transform.angle);
	                return a.overscaledZ - b.overscaledZ || rotatedB.y - rotatedA.y || rotatedB.x - rotatedA.x;
	            }).map(function (tile) {
	                return tile.tileID.key;
	            });
	        }
	        return renderables.map(function (tile) {
	            return tile.tileID;
	        }).sort(compareTileId).map(function (id) {
	            return id.key;
	        });
	    };
	    SourceCache.prototype.hasRenderableParent = function hasRenderableParent(tileID) {
	        var parentTile = this.findLoadedParent(tileID, 0);
	        if (parentTile) {
	            return this._isIdRenderable(parentTile.tileID.key);
	        }
	        return false;
	    };
	    SourceCache.prototype._isIdRenderable = function _isIdRenderable(id, symbolLayer) {
	        return this._tiles[id] && this._tiles[id].hasData() && !this._coveredTiles[id] && (symbolLayer || !this._tiles[id].holdingForFade());
	    };
	    SourceCache.prototype.reload = function reload() {
	        if (this._paused) {
	            this._shouldReloadOnResume = true;
	            return;
	        }
	        this._cache.reset();
	        for (var i in this._tiles) {
	            if (this._tiles[i].state !== 'errored') {
	                this._reloadTile(i, 'reloading');
	            }
	        }
	    };
	    SourceCache.prototype._reloadTile = function _reloadTile(id, state) {
	        var tile = this._tiles[id];
	        if (!tile) {
	            return;
	        }
	        if (tile.state !== 'loading') {
	            tile.state = state;
	        }
	        this._loadTile(tile, this._tileLoaded.bind(this, tile, id, state));
	    };
	    SourceCache.prototype._tileLoaded = function _tileLoaded(tile, id, previousState, err) {
	        if (err) {
	            tile.state = 'errored';
	            if (err.status !== 404) {
	                this._source.fire(new performance.ErrorEvent(err, { tile: tile }));
	            } else {
	                this.update(this.transform);
	            }
	            return;
	        }
	        tile.timeAdded = performance.browser.now();
	        if (previousState === 'expired') {
	            tile.refreshedUponExpiration = true;
	        }
	        this._setTileReloadTimer(id, tile);
	        if (this.getSource().type === 'raster-dem' && tile.dem) {
	            this._backfillDEM(tile);
	        }
	        this._state.initializeTileState(tile, this.map ? this.map.painter : null);
	        this._source.fire(new performance.Event('data', {
	            dataType: 'source',
	            tile: tile,
	            coord: tile.tileID
	        }));
	    };
	    SourceCache.prototype._backfillDEM = function _backfillDEM(tile) {
	        var renderables = this.getRenderableIds();
	        for (var i = 0; i < renderables.length; i++) {
	            var borderId = renderables[i];
	            if (tile.neighboringTiles && tile.neighboringTiles[borderId]) {
	                var borderTile = this.getTileByID(borderId);
	                fillBorder(tile, borderTile);
	                fillBorder(borderTile, tile);
	            }
	        }
	        function fillBorder(tile, borderTile) {
	            tile.needsHillshadePrepare = true;
	            var dx = borderTile.tileID.canonical.x - tile.tileID.canonical.x;
	            var dy = borderTile.tileID.canonical.y - tile.tileID.canonical.y;
	            var dim = Math.pow(2, tile.tileID.canonical.z);
	            var borderId = borderTile.tileID.key;
	            if (dx === 0 && dy === 0) {
	                return;
	            }
	            if (Math.abs(dy) > 1) {
	                return;
	            }
	            if (Math.abs(dx) > 1) {
	                if (Math.abs(dx + dim) === 1) {
	                    dx += dim;
	                } else if (Math.abs(dx - dim) === 1) {
	                    dx -= dim;
	                }
	            }
	            if (!borderTile.dem || !tile.dem) {
	                return;
	            }
	            tile.dem.backfillBorder(borderTile.dem, dx, dy);
	            if (tile.neighboringTiles && tile.neighboringTiles[borderId]) {
	                tile.neighboringTiles[borderId].backfilled = true;
	            }
	        }
	    };
	    SourceCache.prototype.getTile = function getTile(tileID) {
	        return this.getTileByID(tileID.key);
	    };
	    SourceCache.prototype.getTileByID = function getTileByID(id) {
	        return this._tiles[id];
	    };
	    SourceCache.prototype._retainLoadedChildren = function _retainLoadedChildren(idealTiles, zoom, maxCoveringZoom, retain) {
	        for (var id in this._tiles) {
	            var tile = this._tiles[id];
	            if (retain[id] || !tile.hasData() || tile.tileID.overscaledZ <= zoom || tile.tileID.overscaledZ > maxCoveringZoom) {
	                continue;
	            }
	            var topmostLoadedID = tile.tileID;
	            while (tile && tile.tileID.overscaledZ > zoom + 1) {
	                var parentID = tile.tileID.scaledTo(tile.tileID.overscaledZ - 1);
	                tile = this._tiles[parentID.key];
	                if (tile && tile.hasData()) {
	                    topmostLoadedID = parentID;
	                }
	            }
	            var tileID = topmostLoadedID;
	            while (tileID.overscaledZ > zoom) {
	                tileID = tileID.scaledTo(tileID.overscaledZ - 1);
	                if (idealTiles[tileID.key]) {
	                    retain[topmostLoadedID.key] = topmostLoadedID;
	                    break;
	                }
	            }
	        }
	    };
	    SourceCache.prototype.findLoadedParent = function findLoadedParent(tileID, minCoveringZoom) {
	        if (tileID.key in this._loadedParentTiles) {
	            var parent = this._loadedParentTiles[tileID.key];
	            if (parent && parent.tileID.overscaledZ >= minCoveringZoom) {
	                return parent;
	            } else {
	                return null;
	            }
	        }
	        for (var z = tileID.overscaledZ - 1; z >= minCoveringZoom; z--) {
	            var parentTileID = tileID.scaledTo(z);
	            var tile = this._getLoadedTile(parentTileID);
	            if (tile) {
	                return tile;
	            }
	        }
	    };
	    SourceCache.prototype._getLoadedTile = function _getLoadedTile(tileID) {
	        var tile = this._tiles[tileID.key];
	        if (tile && tile.hasData()) {
	            return tile;
	        }
	        var cachedTile = this._cache.getByKey(tileID.wrapped().key);
	        return cachedTile;
	    };
	    SourceCache.prototype.updateCacheSize = function updateCacheSize(transform) {
	        var widthInTiles = Math.ceil(transform.width / this._source.tileSize) + 1;
	        var heightInTiles = Math.ceil(transform.height / this._source.tileSize) + 1;
	        var approxTilesInView = widthInTiles * heightInTiles;
	        var commonZoomRange = 5;
	        var viewDependentMaxSize = Math.floor(approxTilesInView * commonZoomRange);
	        var maxSize = typeof this._maxTileCacheSize === 'number' ? Math.min(this._maxTileCacheSize, viewDependentMaxSize) : viewDependentMaxSize;
	        this._cache.setMaxSize(maxSize);
	    };
	    SourceCache.prototype.handleWrapJump = function handleWrapJump(lng) {
	        var prevLng = this._prevLng === undefined ? lng : this._prevLng;
	        var lngDifference = lng - prevLng;
	        var worldDifference = lngDifference / 360;
	        var wrapDelta = Math.round(worldDifference);
	        this._prevLng = lng;
	        if (wrapDelta) {
	            var tiles = {};
	            for (var key in this._tiles) {
	                var tile = this._tiles[key];
	                tile.tileID = tile.tileID.unwrapTo(tile.tileID.wrap + wrapDelta);
	                tiles[tile.tileID.key] = tile;
	            }
	            this._tiles = tiles;
	            for (var id in this._timers) {
	                clearTimeout(this._timers[id]);
	                delete this._timers[id];
	            }
	            for (var id$1 in this._tiles) {
	                var tile$1 = this._tiles[id$1];
	                this._setTileReloadTimer(id$1, tile$1);
	            }
	        }
	    };
	    SourceCache.prototype.update = function update(transform) {
	        var this$1 = this;
	        this.transform = transform;
	        if (!this._sourceLoaded || this._paused) {
	            return;
	        }
	        this.updateCacheSize(transform);
	        this.handleWrapJump(this.transform.center.lng);
	        this._coveredTiles = {};
	        var idealTileIDs;
	        if (!this.used) {
	            idealTileIDs = [];
	        } else if (this._source.tileID) {
	            idealTileIDs = transform.getVisibleUnwrappedCoordinates(this._source.tileID).map(function (unwrapped) {
	                return new performance.OverscaledTileID(unwrapped.canonical.z, unwrapped.wrap, unwrapped.canonical.z, unwrapped.canonical.x, unwrapped.canonical.y);
	            });
	        } else {
	            idealTileIDs = transform.coveringTiles({
	                tileSize: this._source.tileSize,
	                minzoom: this._source.minzoom,
	                maxzoom: this._source.maxzoom,
	                roundZoom: this._source.roundZoom,
	                reparseOverscaled: this._source.reparseOverscaled
	            });
	            if (this._source.hasTile) {
	                idealTileIDs = idealTileIDs.filter(function (coord) {
	                    return this$1._source.hasTile(coord);
	                });
	            }
	        }
	        var zoom = transform.coveringZoomLevel(this._source);
	        var minCoveringZoom = Math.max(zoom - SourceCache.maxOverzooming, this._source.minzoom);
	        var maxCoveringZoom = Math.max(zoom + SourceCache.maxUnderzooming, this._source.minzoom);
	        var retain = this._updateRetainedTiles(idealTileIDs, zoom);
	        if (isRasterType(this._source.type)) {
	            var parentsForFading = {};
	            var fadingTiles = {};
	            var ids = Object.keys(retain);
	            for (var i = 0, list = ids; i < list.length; i += 1) {
	                var id = list[i];
	                var tileID = retain[id];
	                var tile = this._tiles[id];
	                if (!tile || tile.fadeEndTime && tile.fadeEndTime <= performance.browser.now()) {
	                    continue;
	                }
	                var parentTile = this.findLoadedParent(tileID, minCoveringZoom);
	                if (parentTile) {
	                    this._addTile(parentTile.tileID);
	                    parentsForFading[parentTile.tileID.key] = parentTile.tileID;
	                }
	                fadingTiles[id] = tileID;
	            }
	            this._retainLoadedChildren(fadingTiles, zoom, maxCoveringZoom, retain);
	            for (var id$1 in parentsForFading) {
	                if (!retain[id$1]) {
	                    this._coveredTiles[id$1] = true;
	                    retain[id$1] = parentsForFading[id$1];
	                }
	            }
	        }
	        for (var retainedId in retain) {
	            this._tiles[retainedId].clearFadeHold();
	        }
	        var remove = performance.keysDifference(this._tiles, retain);
	        for (var i$1 = 0, list$1 = remove; i$1 < list$1.length; i$1 += 1) {
	            var tileID$1 = list$1[i$1];
	            var tile$1 = this._tiles[tileID$1];
	            if (tile$1.hasSymbolBuckets && !tile$1.holdingForFade()) {
	                tile$1.setHoldDuration(this.map._fadeDuration);
	            } else if (!tile$1.hasSymbolBuckets || tile$1.symbolFadeFinished()) {
	                this._removeTile(tileID$1);
	            }
	        }
	        this._updateLoadedParentTileCache();
	    };
	    SourceCache.prototype.releaseSymbolFadeTiles = function releaseSymbolFadeTiles() {
	        for (var id in this._tiles) {
	            if (this._tiles[id].holdingForFade()) {
	                this._removeTile(id);
	            }
	        }
	    };
	    SourceCache.prototype._updateRetainedTiles = function _updateRetainedTiles(idealTileIDs, zoom) {
	        var retain = {};
	        var checked = {};
	        var minCoveringZoom = Math.max(zoom - SourceCache.maxOverzooming, this._source.minzoom);
	        var maxCoveringZoom = Math.max(zoom + SourceCache.maxUnderzooming, this._source.minzoom);
	        var missingTiles = {};
	        for (var i = 0, list = idealTileIDs; i < list.length; i += 1) {
	            var tileID = list[i];
	            var tile = this._addTile(tileID);
	            retain[tileID.key] = tileID;
	            if (tile.hasData()) {
	                continue;
	            }
	            if (zoom < this._source.maxzoom) {
	                missingTiles[tileID.key] = tileID;
	            }
	        }
	        this._retainLoadedChildren(missingTiles, zoom, maxCoveringZoom, retain);
	        for (var i$1 = 0, list$1 = idealTileIDs; i$1 < list$1.length; i$1 += 1) {
	            var tileID$1 = list$1[i$1];
	            var tile$1 = this._tiles[tileID$1.key];
	            if (tile$1.hasData()) {
	                continue;
	            }
	            if (zoom + 1 > this._source.maxzoom) {
	                var childCoord = tileID$1.children(this._source.maxzoom)[0];
	                var childTile = this.getTile(childCoord);
	                if (!!childTile && childTile.hasData()) {
	                    retain[childCoord.key] = childCoord;
	                    continue;
	                }
	            } else {
	                var children = tileID$1.children(this._source.maxzoom);
	                if (retain[children[0].key] && retain[children[1].key] && retain[children[2].key] && retain[children[3].key]) {
	                    continue;
	                }
	            }
	            var parentWasRequested = tile$1.wasRequested();
	            for (var overscaledZ = tileID$1.overscaledZ - 1; overscaledZ >= minCoveringZoom; --overscaledZ) {
	                var parentId = tileID$1.scaledTo(overscaledZ);
	                if (checked[parentId.key]) {
	                    break;
	                }
	                checked[parentId.key] = true;
	                tile$1 = this.getTile(parentId);
	                if (!tile$1 && parentWasRequested) {
	                    tile$1 = this._addTile(parentId);
	                }
	                if (tile$1) {
	                    retain[parentId.key] = parentId;
	                    parentWasRequested = tile$1.wasRequested();
	                    if (tile$1.hasData()) {
	                        break;
	                    }
	                }
	            }
	        }
	        return retain;
	    };
	    SourceCache.prototype._updateLoadedParentTileCache = function _updateLoadedParentTileCache() {
	        this._loadedParentTiles = {};
	        for (var tileKey in this._tiles) {
	            var path = [];
	            var parentTile = void 0;
	            var currentId = this._tiles[tileKey].tileID;
	            while (currentId.overscaledZ > 0) {
	                if (currentId.key in this._loadedParentTiles) {
	                    parentTile = this._loadedParentTiles[currentId.key];
	                    break;
	                }
	                path.push(currentId.key);
	                var parentId = currentId.scaledTo(currentId.overscaledZ - 1);
	                parentTile = this._getLoadedTile(parentId);
	                if (parentTile) {
	                    break;
	                }
	                currentId = parentId;
	            }
	            for (var i = 0, list = path; i < list.length; i += 1) {
	                var key = list[i];
	                this._loadedParentTiles[key] = parentTile;
	            }
	        }
	    };
	    SourceCache.prototype._addTile = function _addTile(tileID) {
	        var tile = this._tiles[tileID.key];
	        if (tile) {
	            return tile;
	        }
	        tile = this._cache.getAndRemove(tileID);
	        if (tile) {
	            this._setTileReloadTimer(tileID.key, tile);
	            tile.tileID = tileID;
	            this._state.initializeTileState(tile, this.map ? this.map.painter : null);
	            if (this._cacheTimers[tileID.key]) {
	                clearTimeout(this._cacheTimers[tileID.key]);
	                delete this._cacheTimers[tileID.key];
	                this._setTileReloadTimer(tileID.key, tile);
	            }
	        }
	        var cached = Boolean(tile);
	        if (!cached) {
	            tile = new performance.Tile(tileID, this._source.tileSize * tileID.overscaleFactor());
	            this._loadTile(tile, this._tileLoaded.bind(this, tile, tileID.key, tile.state));
	        }
	        if (!tile) {
	            return null;
	        }
	        tile.uses++;
	        this._tiles[tileID.key] = tile;
	        if (!cached) {
	            this._source.fire(new performance.Event('dataloading', {
	                tile: tile,
	                coord: tile.tileID,
	                dataType: 'source'
	            }));
	        }
	        return tile;
	    };
	    SourceCache.prototype._setTileReloadTimer = function _setTileReloadTimer(id, tile) {
	        var this$1 = this;
	        if (id in this._timers) {
	            clearTimeout(this._timers[id]);
	            delete this._timers[id];
	        }
	        var expiryTimeout = tile.getExpiryTimeout();
	        if (expiryTimeout) {
	            this._timers[id] = setTimeout(function () {
	                this$1._reloadTile(id, 'expired');
	                delete this$1._timers[id];
	            }, expiryTimeout);
	        }
	    };
	    SourceCache.prototype._removeTile = function _removeTile(id) {
	        var tile = this._tiles[id];
	        if (!tile) {
	            return;
	        }
	        tile.uses--;
	        delete this._tiles[id];
	        if (this._timers[id]) {
	            clearTimeout(this._timers[id]);
	            delete this._timers[id];
	        }
	        if (tile.uses > 0) {
	            return;
	        }
	        if (tile.hasData() && tile.state !== 'reloading') {
	            this._cache.add(tile.tileID, tile, tile.getExpiryTimeout());
	        } else {
	            tile.aborted = true;
	            this._abortTile(tile);
	            this._unloadTile(tile);
	        }
	    };
	    SourceCache.prototype.clearTiles = function clearTiles() {
	        this._shouldReloadOnResume = false;
	        this._paused = false;
	        for (var id in this._tiles) {
	            this._removeTile(id);
	        }
	        this._cache.reset();
	    };
	    SourceCache.prototype.tilesIn = function tilesIn(pointQueryGeometry, maxPitchScaleFactor, has3DLayer) {
	        var this$1 = this;
	        var tileResults = [];
	        var transform = this.transform;
	        if (!transform) {
	            return tileResults;
	        }
	        var cameraPointQueryGeometry = has3DLayer ? transform.getCameraQueryGeometry(pointQueryGeometry) : pointQueryGeometry;
	        var queryGeometry = pointQueryGeometry.map(function (p) {
	            return transform.pointCoordinate(p);
	        });
	        var cameraQueryGeometry = cameraPointQueryGeometry.map(function (p) {
	            return transform.pointCoordinate(p);
	        });
	        var ids = this.getIds();
	        var minX = Infinity;
	        var minY = Infinity;
	        var maxX = -Infinity;
	        var maxY = -Infinity;
	        for (var i$1 = 0, list = cameraQueryGeometry; i$1 < list.length; i$1 += 1) {
	            var p = list[i$1];
	            minX = Math.min(minX, p.x);
	            minY = Math.min(minY, p.y);
	            maxX = Math.max(maxX, p.x);
	            maxY = Math.max(maxY, p.y);
	        }
	        var loop = function (i) {
	            var tile = this$1._tiles[ids[i]];
	            if (tile.holdingForFade()) {
	                return;
	            }
	            var tileID = tile.tileID;
	            var scale = Math.pow(2, transform.zoom - tile.tileID.overscaledZ);
	            var queryPadding = maxPitchScaleFactor * tile.queryPadding * performance.EXTENT / tile.tileSize / scale;
	            var tileSpaceBounds = [
	                tileID.getTilePoint(new performance.MercatorCoordinate(minX, minY)),
	                tileID.getTilePoint(new performance.MercatorCoordinate(maxX, maxY))
	            ];
	            if (tileSpaceBounds[0].x - queryPadding < performance.EXTENT && tileSpaceBounds[0].y - queryPadding < performance.EXTENT && tileSpaceBounds[1].x + queryPadding >= 0 && tileSpaceBounds[1].y + queryPadding >= 0) {
	                var tileSpaceQueryGeometry = queryGeometry.map(function (c) {
	                    return tileID.getTilePoint(c);
	                });
	                var tileSpaceCameraQueryGeometry = cameraQueryGeometry.map(function (c) {
	                    return tileID.getTilePoint(c);
	                });
	                tileResults.push({
	                    tile: tile,
	                    tileID: tileID,
	                    queryGeometry: tileSpaceQueryGeometry,
	                    cameraQueryGeometry: tileSpaceCameraQueryGeometry,
	                    scale: scale
	                });
	            }
	        };
	        for (var i = 0; i < ids.length; i++)
	            loop(i);
	        return tileResults;
	    };
	    SourceCache.prototype.getVisibleCoordinates = function getVisibleCoordinates(symbolLayer) {
	        var this$1 = this;
	        var coords = this.getRenderableIds(symbolLayer).map(function (id) {
	            return this$1._tiles[id].tileID;
	        });
	        for (var i = 0, list = coords; i < list.length; i += 1) {
	            var coord = list[i];
	            coord.posMatrix = this.transform.calculatePosMatrix(coord.toUnwrapped());
	        }
	        return coords;
	    };
	    SourceCache.prototype.hasTransition = function hasTransition() {
	        if (this._source.hasTransition()) {
	            return true;
	        }
	        if (isRasterType(this._source.type)) {
	            for (var id in this._tiles) {
	                var tile = this._tiles[id];
	                if (tile.fadeEndTime !== undefined && tile.fadeEndTime >= performance.browser.now()) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    };
	    SourceCache.prototype.setFeatureState = function setFeatureState(sourceLayer, featureId, state) {
	        sourceLayer = sourceLayer || '_geojsonTileLayer';
	        this._state.updateState(sourceLayer, featureId, state);
	    };
	    SourceCache.prototype.removeFeatureState = function removeFeatureState(sourceLayer, featureId, key) {
	        sourceLayer = sourceLayer || '_geojsonTileLayer';
	        this._state.removeFeatureState(sourceLayer, featureId, key);
	    };
	    SourceCache.prototype.getFeatureState = function getFeatureState(sourceLayer, featureId) {
	        sourceLayer = sourceLayer || '_geojsonTileLayer';
	        return this._state.getState(sourceLayer, featureId);
	    };
	    SourceCache.prototype.setDependencies = function setDependencies(tileKey, namespace, dependencies) {
	        var tile = this._tiles[tileKey];
	        if (tile) {
	            tile.setDependencies(namespace, dependencies);
	        }
	    };
	    SourceCache.prototype.reloadTilesForDependencies = function reloadTilesForDependencies(namespaces, keys) {
	        for (var id in this._tiles) {
	            var tile = this._tiles[id];
	            if (tile.hasDependency(namespaces, keys)) {
	                this._reloadTile(id, 'reloading');
	            }
	        }
	        this._cache.filter(function (tile) {
	            return !tile.hasDependency(namespaces, keys);
	        });
	    };
	    return SourceCache;
	}(performance.Evented);
	SourceCache.maxOverzooming = 10;
	SourceCache.maxUnderzooming = 3;
	function compareTileId(a, b) {
	    var aWrap = Math.abs(a.wrap * 2) - +(a.wrap < 0);
	    var bWrap = Math.abs(b.wrap * 2) - +(b.wrap < 0);
	    return a.overscaledZ - b.overscaledZ || bWrap - aWrap || b.canonical.y - a.canonical.y || b.canonical.x - a.canonical.x;
	}
	function isRasterType(type) {
	    return type === 'raster' || type === 'image' || type === 'video';
	}

	function WebWorker () {
	    return new performance.window.Worker(exported.workerUrl);
	}

	var PRELOAD_POOL_ID = 'mapboxgl_preloaded_worker_pool';
	var WorkerPool = function WorkerPool() {
	    this.active = {};
	};
	WorkerPool.prototype.acquire = function acquire(mapId) {
	    if (!this.workers) {
	        this.workers = [];
	        while (this.workers.length < WorkerPool.workerCount) {
	            this.workers.push(new WebWorker());
	        }
	    }
	    this.active[mapId] = true;
	    return this.workers.slice();
	};
	WorkerPool.prototype.release = function release(mapId) {
	    delete this.active[mapId];
	    if (this.numActive() === 0) {
	        this.workers.forEach(function (w) {
	            w.terminate();
	        });
	        this.workers = null;
	    }
	};
	WorkerPool.prototype.isPreloaded = function isPreloaded() {
	    return !!this.active[PRELOAD_POOL_ID];
	};
	WorkerPool.prototype.numActive = function numActive() {
	    return Object.keys(this.active).length;
	};
	var availableLogicalProcessors = Math.floor(performance.browser.hardwareConcurrency / 2);
	WorkerPool.workerCount = Math.max(Math.min(availableLogicalProcessors, 6), 1);

	var globalWorkerPool;
	function getGlobalWorkerPool() {
	    if (!globalWorkerPool) {
	        globalWorkerPool = new WorkerPool();
	    }
	    return globalWorkerPool;
	}
	function prewarm() {
	    var workerPool = getGlobalWorkerPool();
	    workerPool.acquire(PRELOAD_POOL_ID);
	}
	function clearPrewarmedResources() {
	    var pool = globalWorkerPool;
	    if (pool) {
	        if (pool.isPreloaded() && pool.numActive() === 1) {
	            pool.release(PRELOAD_POOL_ID);
	            globalWorkerPool = null;
	        } else {
	            console.warn('Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()');
	        }
	    }
	}

	function deref(layer, parent) {
	    var result = {};
	    for (var k in layer) {
	        if (k !== 'ref') {
	            result[k] = layer[k];
	        }
	    }
	    performance.refProperties.forEach(function (k) {
	        if (k in parent) {
	            result[k] = parent[k];
	        }
	    });
	    return result;
	}
	function derefLayers(layers) {
	    layers = layers.slice();
	    var map = Object.create(null);
	    for (var i = 0; i < layers.length; i++) {
	        map[layers[i].id] = layers[i];
	    }
	    for (var i$1 = 0; i$1 < layers.length; i$1++) {
	        if ('ref' in layers[i$1]) {
	            layers[i$1] = deref(layers[i$1], map[layers[i$1].ref]);
	        }
	    }
	    return layers;
	}

	function emptyStyle() {
	    var style = {};
	    var version = performance.styleSpec['$version'];
	    for (var styleKey in performance.styleSpec['$root']) {
	        var spec = performance.styleSpec['$root'][styleKey];
	        if (spec.required) {
	            var value = null;
	            if (styleKey === 'version') {
	                value = version;
	            } else {
	                if (spec.type === 'array') {
	                    value = [];
	                } else {
	                    value = {};
	                }
	            }
	            if (value != null) {
	                style[styleKey] = value;
	            }
	        }
	    }
	    return style;
	}

	var operations = {
	    setStyle: 'setStyle',
	    addLayer: 'addLayer',
	    moveLayer: 'moveLayer',
	    removeLayer: 'removeLayer',
	    setPaintProperty: 'setPaintProperty',
	    setLayoutProperty: 'setLayoutProperty',
	    setFilter: 'setFilter',
	    addSource: 'addSource',
	    removeSource: 'removeSource',
	    setGeoJSONSourceData: 'setGeoJSONSourceData',
	    setLayerZoomRange: 'setLayerZoomRange',
	    setLayerProperty: 'setLayerProperty',
	    setCenter: 'setCenter',
	    setZoom: 'setZoom',
	    setBearing: 'setBearing',
	    setPitch: 'setPitch',
	    setSprite: 'setSprite',
	    setGlyphs: 'setGlyphs',
	    setTransition: 'setTransition',
	    setLight: 'setLight'
	};
	function addSource(sourceId, after, commands) {
	    commands.push({
	        command: operations.addSource,
	        args: [
	            sourceId,
	            after[sourceId]
	        ]
	    });
	}
	function removeSource(sourceId, commands, sourcesRemoved) {
	    commands.push({
	        command: operations.removeSource,
	        args: [sourceId]
	    });
	    sourcesRemoved[sourceId] = true;
	}
	function updateSource(sourceId, after, commands, sourcesRemoved) {
	    removeSource(sourceId, commands, sourcesRemoved);
	    addSource(sourceId, after, commands);
	}
	function canUpdateGeoJSON(before, after, sourceId) {
	    var prop;
	    for (prop in before[sourceId]) {
	        if (!before[sourceId].hasOwnProperty(prop)) {
	            continue;
	        }
	        if (prop !== 'data' && !performance.deepEqual(before[sourceId][prop], after[sourceId][prop])) {
	            return false;
	        }
	    }
	    for (prop in after[sourceId]) {
	        if (!after[sourceId].hasOwnProperty(prop)) {
	            continue;
	        }
	        if (prop !== 'data' && !performance.deepEqual(before[sourceId][prop], after[sourceId][prop])) {
	            return false;
	        }
	    }
	    return true;
	}
	function diffSources(before, after, commands, sourcesRemoved) {
	    before = before || {};
	    after = after || {};
	    var sourceId;
	    for (sourceId in before) {
	        if (!before.hasOwnProperty(sourceId)) {
	            continue;
	        }
	        if (!after.hasOwnProperty(sourceId)) {
	            removeSource(sourceId, commands, sourcesRemoved);
	        }
	    }
	    for (sourceId in after) {
	        if (!after.hasOwnProperty(sourceId)) {
	            continue;
	        }
	        if (!before.hasOwnProperty(sourceId)) {
	            addSource(sourceId, after, commands);
	        } else if (!performance.deepEqual(before[sourceId], after[sourceId])) {
	            if (before[sourceId].type === 'geojson' && after[sourceId].type === 'geojson' && canUpdateGeoJSON(before, after, sourceId)) {
	                commands.push({
	                    command: operations.setGeoJSONSourceData,
	                    args: [
	                        sourceId,
	                        after[sourceId].data
	                    ]
	                });
	            } else {
	                updateSource(sourceId, after, commands, sourcesRemoved);
	            }
	        }
	    }
	}
	function diffLayerPropertyChanges(before, after, commands, layerId, klass, command) {
	    before = before || {};
	    after = after || {};
	    var prop;
	    for (prop in before) {
	        if (!before.hasOwnProperty(prop)) {
	            continue;
	        }
	        if (!performance.deepEqual(before[prop], after[prop])) {
	            commands.push({
	                command: command,
	                args: [
	                    layerId,
	                    prop,
	                    after[prop],
	                    klass
	                ]
	            });
	        }
	    }
	    for (prop in after) {
	        if (!after.hasOwnProperty(prop) || before.hasOwnProperty(prop)) {
	            continue;
	        }
	        if (!performance.deepEqual(before[prop], after[prop])) {
	            commands.push({
	                command: command,
	                args: [
	                    layerId,
	                    prop,
	                    after[prop],
	                    klass
	                ]
	            });
	        }
	    }
	}
	function pluckId(layer) {
	    return layer.id;
	}
	function indexById(group, layer) {
	    group[layer.id] = layer;
	    return group;
	}
	function diffLayers(before, after, commands, patch) {
	    before = before || [];
	    after = after || [];
	    var beforeOrder = before.map(pluckId);
	    var afterOrder = after.map(pluckId);
	    var beforeIndex = before.reduce(indexById, {});
	    var afterIndex = after.reduce(indexById, {});
	    var tracker = beforeOrder.slice();
	    var clean = Object.create(null);
	    var i, d, layerId, beforeLayer, afterLayer, insertBeforeLayerId, prop;
	    for (i = 0, d = 0; i < beforeOrder.length; i++) {
	        layerId = beforeOrder[i];
	        if (!afterIndex.hasOwnProperty(layerId)) {
	            commands.push({
	                command: operations.removeLayer,
	                args: [layerId]
	            });
	            tracker.splice(tracker.indexOf(layerId, d), 1);
	        } else {
	            d++;
	        }
	    }
	    for (i = 0, d = 0; i < afterOrder.length; i++) {
	        layerId = afterOrder[afterOrder.length - 1 - i];
	        if (tracker[tracker.length - 1 - i] === layerId) {
	            continue;
	        }
	        if (beforeIndex.hasOwnProperty(layerId)) {
	            commands.push({
	                command: operations.removeLayer,
	                args: [layerId]
	            });
	            tracker.splice(tracker.lastIndexOf(layerId, tracker.length - d), 1);
	        } else {
	            d++;
	        }
	        insertBeforeLayerId = tracker[tracker.length - i];
	        commands.push({
	            command: operations.addLayer,
	            args: [
	                afterIndex[layerId],
	                insertBeforeLayerId
	            ]
	        });
	        tracker.splice(tracker.length - i, 0, layerId);
	        clean[layerId] = true;
	    }
	    for (i = 0; i < afterOrder.length; i++) {
	        layerId = afterOrder[i];
	        beforeLayer = beforeIndex[layerId];
	        afterLayer = afterIndex[layerId];
	        if (clean[layerId] || performance.deepEqual(beforeLayer, afterLayer)) {
	            continue;
	        }
	        if (!performance.deepEqual(beforeLayer.source, afterLayer.source) || !performance.deepEqual(beforeLayer['source-layer'], afterLayer['source-layer']) || !performance.deepEqual(beforeLayer.type, afterLayer.type)) {
	            commands.push({
	                command: operations.removeLayer,
	                args: [layerId]
	            });
	            insertBeforeLayerId = tracker[tracker.lastIndexOf(layerId) + 1];
	            commands.push({
	                command: operations.addLayer,
	                args: [
	                    afterLayer,
	                    insertBeforeLayerId
	                ]
	            });
	            continue;
	        }
	        diffLayerPropertyChanges(beforeLayer.layout, afterLayer.layout, commands, layerId, null, operations.setLayoutProperty);
	        diffLayerPropertyChanges(beforeLayer.paint, afterLayer.paint, commands, layerId, null, operations.setPaintProperty);
	        if (!performance.deepEqual(beforeLayer.filter, afterLayer.filter)) {
	            commands.push({
	                command: operations.setFilter,
	                args: [
	                    layerId,
	                    afterLayer.filter
	                ]
	            });
	        }
	        if (!performance.deepEqual(beforeLayer.minzoom, afterLayer.minzoom) || !performance.deepEqual(beforeLayer.maxzoom, afterLayer.maxzoom)) {
	            commands.push({
	                command: operations.setLayerZoomRange,
	                args: [
	                    layerId,
	                    afterLayer.minzoom,
	                    afterLayer.maxzoom
	                ]
	            });
	        }
	        for (prop in beforeLayer) {
	            if (!beforeLayer.hasOwnProperty(prop)) {
	                continue;
	            }
	            if (prop === 'layout' || prop === 'paint' || prop === 'filter' || prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') {
	                continue;
	            }
	            if (prop.indexOf('paint.') === 0) {
	                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);
	            } else if (!performance.deepEqual(beforeLayer[prop], afterLayer[prop])) {
	                commands.push({
	                    command: operations.setLayerProperty,
	                    args: [
	                        layerId,
	                        prop,
	                        afterLayer[prop]
	                    ]
	                });
	            }
	        }
	        for (prop in afterLayer) {
	            if (!afterLayer.hasOwnProperty(prop) || beforeLayer.hasOwnProperty(prop)) {
	                continue;
	            }
	            if (prop === 'layout' || prop === 'paint' || prop === 'filter' || prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') {
	                continue;
	            }
	            if (prop.indexOf('paint.') === 0) {
	                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);
	            } else if (!performance.deepEqual(beforeLayer[prop], afterLayer[prop])) {
	                commands.push({
	                    command: operations.setLayerProperty,
	                    args: [
	                        layerId,
	                        prop,
	                        afterLayer[prop]
	                    ]
	                });
	            }
	        }
	    }
	}
	function diffStyles(before, after, patch) {
	    if (!before) {
	        return [{
	                command: operations.setStyle,
	                args: [after]
	            }];
	    }
	    var commands = [];
	    try {
	        if (!performance.deepEqual(before.version, after.version)) {
	            return [{
	                    command: operations.setStyle,
	                    args: [after]
	                }];
	        }
	        if (!performance.deepEqual(before.center, after.center)) {
	            commands.push({
	                command: operations.setCenter,
	                args: [after.center]
	            });
	        }
	        if (!performance.deepEqual(before.zoom, after.zoom)) {
	            commands.push({
	                command: operations.setZoom,
	                args: [after.zoom]
	            });
	        }
	        if (!performance.deepEqual(before.bearing, after.bearing)) {
	            commands.push({
	                command: operations.setBearing,
	                args: [after.bearing]
	            });
	        }
	        if (!performance.deepEqual(before.pitch, after.pitch)) {
	            commands.push({
	                command: operations.setPitch,
	                args: [after.pitch]
	            });
	        }
	        if (!performance.deepEqual(before.sprite, after.sprite)) {
	            commands.push({
	                command: operations.setSprite,
	                args: [after.sprite]
	            });
	        }
	        if (!performance.deepEqual(before.glyphs, after.glyphs)) {
	            commands.push({
	                command: operations.setGlyphs,
	                args: [after.glyphs]
	            });
	        }
	        if (!performance.deepEqual(before.transition, after.transition)) {
	            commands.push({
	                command: operations.setTransition,
	                args: [after.transition]
	            });
	        }
	        if (!performance.deepEqual(before.light, after.light)) {
	            commands.push({
	                command: operations.setLight,
	                args: [after.light]
	            });
	        }
	        var sourcesRemoved = {};
	        var removeOrAddSourceCommands = [];
	        diffSources(before.sources, after.sources, removeOrAddSourceCommands, sourcesRemoved);
	        var beforeLayers = [];
	        if (before.layers) {
	            before.layers.forEach(function (layer) {
	                if (sourcesRemoved[layer.source]) {
	                    commands.push({
	                        command: operations.removeLayer,
	                        args: [layer.id]
	                    });
	                } else {
	                    beforeLayers.push(layer);
	                }
	            });
	        }
	        commands = commands.concat(removeOrAddSourceCommands);
	        diffLayers(beforeLayers, after.layers, commands);
	    } catch (e) {
	        console.warn('Unable to compute style diff:', e);
	        commands = [{
	                command: operations.setStyle,
	                args: [after]
	            }];
	    }
	    return commands;
	}

	var PathInterpolator = function PathInterpolator(points_, padding_) {
	    this.reset(points_, padding_);
	};
	PathInterpolator.prototype.reset = function reset(points_, padding_) {
	    this.points = points_ || [];
	    this._distances = [0];
	    for (var i = 1; i < this.points.length; i++) {
	        this._distances[i] = this._distances[i - 1] + this.points[i].dist(this.points[i - 1]);
	    }
	    this.length = this._distances[this._distances.length - 1];
	    this.padding = Math.min(padding_ || 0, this.length * 0.5);
	    this.paddedLength = this.length - this.padding * 2;
	};
	PathInterpolator.prototype.lerp = function lerp(t) {
	    if (this.points.length === 1) {
	        return this.points[0];
	    }
	    t = performance.clamp(t, 0, 1);
	    var currentIndex = 1;
	    var distOfCurrentIdx = this._distances[currentIndex];
	    var distToTarget = t * this.paddedLength + this.padding;
	    while (distOfCurrentIdx < distToTarget && currentIndex < this._distances.length) {
	        distOfCurrentIdx = this._distances[++currentIndex];
	    }
	    var idxOfPrevPoint = currentIndex - 1;
	    var distOfPrevIdx = this._distances[idxOfPrevPoint];
	    var segmentLength = distOfCurrentIdx - distOfPrevIdx;
	    var segmentT = segmentLength > 0 ? (distToTarget - distOfPrevIdx) / segmentLength : 0;
	    return this.points[idxOfPrevPoint].mult(1 - segmentT).add(this.points[currentIndex].mult(segmentT));
	};

	var GridIndex = function GridIndex(width, height, cellSize) {
	    var boxCells = this.boxCells = [];
	    var circleCells = this.circleCells = [];
	    this.xCellCount = Math.ceil(width / cellSize);
	    this.yCellCount = Math.ceil(height / cellSize);
	    for (var i = 0; i < this.xCellCount * this.yCellCount; i++) {
	        boxCells.push([]);
	        circleCells.push([]);
	    }
	    this.circleKeys = [];
	    this.boxKeys = [];
	    this.bboxes = [];
	    this.circles = [];
	    this.width = width;
	    this.height = height;
	    this.xScale = this.xCellCount / width;
	    this.yScale = this.yCellCount / height;
	    this.boxUid = 0;
	    this.circleUid = 0;
	};
	GridIndex.prototype.keysLength = function keysLength() {
	    return this.boxKeys.length + this.circleKeys.length;
	};
	GridIndex.prototype.insert = function insert(key, x1, y1, x2, y2) {
	    this._forEachCell(x1, y1, x2, y2, this._insertBoxCell, this.boxUid++);
	    this.boxKeys.push(key);
	    this.bboxes.push(x1);
	    this.bboxes.push(y1);
	    this.bboxes.push(x2);
	    this.bboxes.push(y2);
	};
	GridIndex.prototype.insertCircle = function insertCircle(key, x, y, radius) {
	    this._forEachCell(x - radius, y - radius, x + radius, y + radius, this._insertCircleCell, this.circleUid++);
	    this.circleKeys.push(key);
	    this.circles.push(x);
	    this.circles.push(y);
	    this.circles.push(radius);
	};
	GridIndex.prototype._insertBoxCell = function _insertBoxCell(x1, y1, x2, y2, cellIndex, uid) {
	    this.boxCells[cellIndex].push(uid);
	};
	GridIndex.prototype._insertCircleCell = function _insertCircleCell(x1, y1, x2, y2, cellIndex, uid) {
	    this.circleCells[cellIndex].push(uid);
	};
	GridIndex.prototype._query = function _query(x1, y1, x2, y2, hitTest, predicate) {
	    if (x2 < 0 || x1 > this.width || y2 < 0 || y1 > this.height) {
	        return hitTest ? false : [];
	    }
	    var result = [];
	    if (x1 <= 0 && y1 <= 0 && this.width <= x2 && this.height <= y2) {
	        if (hitTest) {
	            return true;
	        }
	        for (var boxUid = 0; boxUid < this.boxKeys.length; boxUid++) {
	            result.push({
	                key: this.boxKeys[boxUid],
	                x1: this.bboxes[boxUid * 4],
	                y1: this.bboxes[boxUid * 4 + 1],
	                x2: this.bboxes[boxUid * 4 + 2],
	                y2: this.bboxes[boxUid * 4 + 3]
	            });
	        }
	        for (var circleUid = 0; circleUid < this.circleKeys.length; circleUid++) {
	            var x = this.circles[circleUid * 3];
	            var y = this.circles[circleUid * 3 + 1];
	            var radius = this.circles[circleUid * 3 + 2];
	            result.push({
	                key: this.circleKeys[circleUid],
	                x1: x - radius,
	                y1: y - radius,
	                x2: x + radius,
	                y2: y + radius
	            });
	        }
	        return predicate ? result.filter(predicate) : result;
	    } else {
	        var queryArgs = {
	            hitTest: hitTest,
	            seenUids: {
	                box: {},
	                circle: {}
	            }
	        };
	        this._forEachCell(x1, y1, x2, y2, this._queryCell, result, queryArgs, predicate);
	        return hitTest ? result.length > 0 : result;
	    }
	};
	GridIndex.prototype._queryCircle = function _queryCircle(x, y, radius, hitTest, predicate) {
	    var x1 = x - radius;
	    var x2 = x + radius;
	    var y1 = y - radius;
	    var y2 = y + radius;
	    if (x2 < 0 || x1 > this.width || y2 < 0 || y1 > this.height) {
	        return hitTest ? false : [];
	    }
	    var result = [];
	    var queryArgs = {
	        hitTest: hitTest,
	        circle: {
	            x: x,
	            y: y,
	            radius: radius
	        },
	        seenUids: {
	            box: {},
	            circle: {}
	        }
	    };
	    this._forEachCell(x1, y1, x2, y2, this._queryCellCircle, result, queryArgs, predicate);
	    return hitTest ? result.length > 0 : result;
	};
	GridIndex.prototype.query = function query(x1, y1, x2, y2, predicate) {
	    return this._query(x1, y1, x2, y2, false, predicate);
	};
	GridIndex.prototype.hitTest = function hitTest(x1, y1, x2, y2, predicate) {
	    return this._query(x1, y1, x2, y2, true, predicate);
	};
	GridIndex.prototype.hitTestCircle = function hitTestCircle(x, y, radius, predicate) {
	    return this._queryCircle(x, y, radius, true, predicate);
	};
	GridIndex.prototype._queryCell = function _queryCell(x1, y1, x2, y2, cellIndex, result, queryArgs, predicate) {
	    var seenUids = queryArgs.seenUids;
	    var boxCell = this.boxCells[cellIndex];
	    if (boxCell !== null) {
	        var bboxes = this.bboxes;
	        for (var i = 0, list = boxCell; i < list.length; i += 1) {
	            var boxUid = list[i];
	            if (!seenUids.box[boxUid]) {
	                seenUids.box[boxUid] = true;
	                var offset = boxUid * 4;
	                if (x1 <= bboxes[offset + 2] && y1 <= bboxes[offset + 3] && x2 >= bboxes[offset + 0] && y2 >= bboxes[offset + 1] && (!predicate || predicate(this.boxKeys[boxUid]))) {
	                    if (queryArgs.hitTest) {
	                        result.push(true);
	                        return true;
	                    } else {
	                        result.push({
	                            key: this.boxKeys[boxUid],
	                            x1: bboxes[offset],
	                            y1: bboxes[offset + 1],
	                            x2: bboxes[offset + 2],
	                            y2: bboxes[offset + 3]
	                        });
	                    }
	                }
	            }
	        }
	    }
	    var circleCell = this.circleCells[cellIndex];
	    if (circleCell !== null) {
	        var circles = this.circles;
	        for (var i$1 = 0, list$1 = circleCell; i$1 < list$1.length; i$1 += 1) {
	            var circleUid = list$1[i$1];
	            if (!seenUids.circle[circleUid]) {
	                seenUids.circle[circleUid] = true;
	                var offset$1 = circleUid * 3;
	                if (this._circleAndRectCollide(circles[offset$1], circles[offset$1 + 1], circles[offset$1 + 2], x1, y1, x2, y2) && (!predicate || predicate(this.circleKeys[circleUid]))) {
	                    if (queryArgs.hitTest) {
	                        result.push(true);
	                        return true;
	                    } else {
	                        var x = circles[offset$1];
	                        var y = circles[offset$1 + 1];
	                        var radius = circles[offset$1 + 2];
	                        result.push({
	                            key: this.circleKeys[circleUid],
	                            x1: x - radius,
	                            y1: y - radius,
	                            x2: x + radius,
	                            y2: y + radius
	                        });
	                    }
	                }
	            }
	        }
	    }
	};
	GridIndex.prototype._queryCellCircle = function _queryCellCircle(x1, y1, x2, y2, cellIndex, result, queryArgs, predicate) {
	    var circle = queryArgs.circle;
	    var seenUids = queryArgs.seenUids;
	    var boxCell = this.boxCells[cellIndex];
	    if (boxCell !== null) {
	        var bboxes = this.bboxes;
	        for (var i = 0, list = boxCell; i < list.length; i += 1) {
	            var boxUid = list[i];
	            if (!seenUids.box[boxUid]) {
	                seenUids.box[boxUid] = true;
	                var offset = boxUid * 4;
	                if (this._circleAndRectCollide(circle.x, circle.y, circle.radius, bboxes[offset + 0], bboxes[offset + 1], bboxes[offset + 2], bboxes[offset + 3]) && (!predicate || predicate(this.boxKeys[boxUid]))) {
	                    result.push(true);
	                    return true;
	                }
	            }
	        }
	    }
	    var circleCell = this.circleCells[cellIndex];
	    if (circleCell !== null) {
	        var circles = this.circles;
	        for (var i$1 = 0, list$1 = circleCell; i$1 < list$1.length; i$1 += 1) {
	            var circleUid = list$1[i$1];
	            if (!seenUids.circle[circleUid]) {
	                seenUids.circle[circleUid] = true;
	                var offset$1 = circleUid * 3;
	                if (this._circlesCollide(circles[offset$1], circles[offset$1 + 1], circles[offset$1 + 2], circle.x, circle.y, circle.radius) && (!predicate || predicate(this.circleKeys[circleUid]))) {
	                    result.push(true);
	                    return true;
	                }
	            }
	        }
	    }
	};
	GridIndex.prototype._forEachCell = function _forEachCell(x1, y1, x2, y2, fn, arg1, arg2, predicate) {
	    var cx1 = this._convertToXCellCoord(x1);
	    var cy1 = this._convertToYCellCoord(y1);
	    var cx2 = this._convertToXCellCoord(x2);
	    var cy2 = this._convertToYCellCoord(y2);
	    for (var x = cx1; x <= cx2; x++) {
	        for (var y = cy1; y <= cy2; y++) {
	            var cellIndex = this.xCellCount * y + x;
	            if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2, predicate)) {
	                return;
	            }
	        }
	    }
	};
	GridIndex.prototype._convertToXCellCoord = function _convertToXCellCoord(x) {
	    return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(x * this.xScale)));
	};
	GridIndex.prototype._convertToYCellCoord = function _convertToYCellCoord(y) {
	    return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(y * this.yScale)));
	};
	GridIndex.prototype._circlesCollide = function _circlesCollide(x1, y1, r1, x2, y2, r2) {
	    var dx = x2 - x1;
	    var dy = y2 - y1;
	    var bothRadii = r1 + r2;
	    return bothRadii * bothRadii > dx * dx + dy * dy;
	};
	GridIndex.prototype._circleAndRectCollide = function _circleAndRectCollide(circleX, circleY, radius, x1, y1, x2, y2) {
	    var halfRectWidth = (x2 - x1) / 2;
	    var distX = Math.abs(circleX - (x1 + halfRectWidth));
	    if (distX > halfRectWidth + radius) {
	        return false;
	    }
	    var halfRectHeight = (y2 - y1) / 2;
	    var distY = Math.abs(circleY - (y1 + halfRectHeight));
	    if (distY > halfRectHeight + radius) {
	        return false;
	    }
	    if (distX <= halfRectWidth || distY <= halfRectHeight) {
	        return true;
	    }
	    var dx = distX - halfRectWidth;
	    var dy = distY - halfRectHeight;
	    return dx * dx + dy * dy <= radius * radius;
	};

	function getLabelPlaneMatrix(posMatrix, pitchWithMap, rotateWithMap, transform, pixelsToTileUnits) {
	    var m = performance.create();
	    if (pitchWithMap) {
	        performance.scale(m, m, [
	            1 / pixelsToTileUnits,
	            1 / pixelsToTileUnits,
	            1
	        ]);
	        if (!rotateWithMap) {
	            performance.rotateZ(m, m, transform.angle);
	        }
	    } else {
	        performance.multiply(m, transform.labelPlaneMatrix, posMatrix);
	    }
	    return m;
	}
	function getGlCoordMatrix(posMatrix, pitchWithMap, rotateWithMap, transform, pixelsToTileUnits) {
	    if (pitchWithMap) {
	        var m = performance.clone(posMatrix);
	        performance.scale(m, m, [
	            pixelsToTileUnits,
	            pixelsToTileUnits,
	            1
	        ]);
	        if (!rotateWithMap) {
	            performance.rotateZ(m, m, -transform.angle);
	        }
	        return m;
	    } else {
	        return transform.glCoordMatrix;
	    }
	}
	function project(point, matrix) {
	    var pos = [
	        point.x,
	        point.y,
	        0,
	        1
	    ];
	    xyTransformMat4(pos, pos, matrix);
	    var w = pos[3];
	    return {
	        point: new performance.Point(pos[0] / w, pos[1] / w),
	        signedDistanceFromCamera: w
	    };
	}
	function getPerspectiveRatio(cameraToCenterDistance, signedDistanceFromCamera) {
	    return 0.5 + 0.5 * (cameraToCenterDistance / signedDistanceFromCamera);
	}
	function isVisible(anchorPos, clippingBuffer) {
	    var x = anchorPos[0] / anchorPos[3];
	    var y = anchorPos[1] / anchorPos[3];
	    var inPaddedViewport = x >= -clippingBuffer[0] && x <= clippingBuffer[0] && y >= -clippingBuffer[1] && y <= clippingBuffer[1];
	    return inPaddedViewport;
	}
	function updateLineLabels(bucket, posMatrix, painter, isText, labelPlaneMatrix, glCoordMatrix, pitchWithMap, keepUpright) {
	    var sizeData = isText ? bucket.textSizeData : bucket.iconSizeData;
	    var partiallyEvaluatedSize = performance.evaluateSizeForZoom(sizeData, painter.transform.zoom);
	    var clippingBuffer = [
	        256 / painter.width * 2 + 1,
	        256 / painter.height * 2 + 1
	    ];
	    var dynamicLayoutVertexArray = isText ? bucket.text.dynamicLayoutVertexArray : bucket.icon.dynamicLayoutVertexArray;
	    dynamicLayoutVertexArray.clear();
	    var lineVertexArray = bucket.lineVertexArray;
	    var placedSymbols = isText ? bucket.text.placedSymbolArray : bucket.icon.placedSymbolArray;
	    var aspectRatio = painter.transform.width / painter.transform.height;
	    var useVertical = false;
	    for (var s = 0; s < placedSymbols.length; s++) {
	        var symbol = placedSymbols.get(s);
	        if (symbol.hidden || symbol.writingMode === performance.WritingMode.vertical && !useVertical) {
	            hideGlyphs(symbol.numGlyphs, dynamicLayoutVertexArray);
	            continue;
	        }
	        useVertical = false;
	        var anchorPos = [
	            symbol.anchorX,
	            symbol.anchorY,
	            0,
	            1
	        ];
	        performance.transformMat4(anchorPos, anchorPos, posMatrix);
	        if (!isVisible(anchorPos, clippingBuffer)) {
	            hideGlyphs(symbol.numGlyphs, dynamicLayoutVertexArray);
	            continue;
	        }
	        var cameraToAnchorDistance = anchorPos[3];
	        var perspectiveRatio = getPerspectiveRatio(painter.transform.cameraToCenterDistance, cameraToAnchorDistance);
	        var fontSize = performance.evaluateSizeForFeature(sizeData, partiallyEvaluatedSize, symbol);
	        var pitchScaledFontSize = pitchWithMap ? fontSize / perspectiveRatio : fontSize * perspectiveRatio;
	        var tileAnchorPoint = new performance.Point(symbol.anchorX, symbol.anchorY);
	        var anchorPoint = project(tileAnchorPoint, labelPlaneMatrix).point;
	        var projectionCache = {};
	        var placeUnflipped = placeGlyphsAlongLine(symbol, pitchScaledFontSize, false, keepUpright, posMatrix, labelPlaneMatrix, glCoordMatrix, bucket.glyphOffsetArray, lineVertexArray, dynamicLayoutVertexArray, anchorPoint, tileAnchorPoint, projectionCache, aspectRatio);
	        useVertical = placeUnflipped.useVertical;
	        if (placeUnflipped.notEnoughRoom || useVertical || placeUnflipped.needsFlipping && placeGlyphsAlongLine(symbol, pitchScaledFontSize, true, keepUpright, posMatrix, labelPlaneMatrix, glCoordMatrix, bucket.glyphOffsetArray, lineVertexArray, dynamicLayoutVertexArray, anchorPoint, tileAnchorPoint, projectionCache, aspectRatio).notEnoughRoom) {
	            hideGlyphs(symbol.numGlyphs, dynamicLayoutVertexArray);
	        }
	    }
	    if (isText) {
	        bucket.text.dynamicLayoutVertexBuffer.updateData(dynamicLayoutVertexArray);
	    } else {
	        bucket.icon.dynamicLayoutVertexBuffer.updateData(dynamicLayoutVertexArray);
	    }
	}
	function placeFirstAndLastGlyph(fontScale, glyphOffsetArray, lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol, lineVertexArray, labelPlaneMatrix, projectionCache) {
	    var glyphEndIndex = symbol.glyphStartIndex + symbol.numGlyphs;
	    var lineStartIndex = symbol.lineStartIndex;
	    var lineEndIndex = symbol.lineStartIndex + symbol.lineLength;
	    var firstGlyphOffset = glyphOffsetArray.getoffsetX(symbol.glyphStartIndex);
	    var lastGlyphOffset = glyphOffsetArray.getoffsetX(glyphEndIndex - 1);
	    var firstPlacedGlyph = placeGlyphAlongLine(fontScale * firstGlyphOffset, lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol.segment, lineStartIndex, lineEndIndex, lineVertexArray, labelPlaneMatrix, projectionCache);
	    if (!firstPlacedGlyph) {
	        return null;
	    }
	    var lastPlacedGlyph = placeGlyphAlongLine(fontScale * lastGlyphOffset, lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol.segment, lineStartIndex, lineEndIndex, lineVertexArray, labelPlaneMatrix, projectionCache);
	    if (!lastPlacedGlyph) {
	        return null;
	    }
	    return {
	        first: firstPlacedGlyph,
	        last: lastPlacedGlyph
	    };
	}
	function requiresOrientationChange(writingMode, firstPoint, lastPoint, aspectRatio) {
	    if (writingMode === performance.WritingMode.horizontal) {
	        var rise = Math.abs(lastPoint.y - firstPoint.y);
	        var run = Math.abs(lastPoint.x - firstPoint.x) * aspectRatio;
	        if (rise > run) {
	            return { useVertical: true };
	        }
	    }
	    if (writingMode === performance.WritingMode.vertical ? firstPoint.y < lastPoint.y : firstPoint.x > lastPoint.x) {
	        return { needsFlipping: true };
	    }
	    return null;
	}
	function placeGlyphsAlongLine(symbol, fontSize, flip, keepUpright, posMatrix, labelPlaneMatrix, glCoordMatrix, glyphOffsetArray, lineVertexArray, dynamicLayoutVertexArray, anchorPoint, tileAnchorPoint, projectionCache, aspectRatio) {
	    var fontScale = fontSize / 24;
	    var lineOffsetX = symbol.lineOffsetX * fontScale;
	    var lineOffsetY = symbol.lineOffsetY * fontScale;
	    var placedGlyphs;
	    if (symbol.numGlyphs > 1) {
	        var glyphEndIndex = symbol.glyphStartIndex + symbol.numGlyphs;
	        var lineStartIndex = symbol.lineStartIndex;
	        var lineEndIndex = symbol.lineStartIndex + symbol.lineLength;
	        var firstAndLastGlyph = placeFirstAndLastGlyph(fontScale, glyphOffsetArray, lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol, lineVertexArray, labelPlaneMatrix, projectionCache);
	        if (!firstAndLastGlyph) {
	            return { notEnoughRoom: true };
	        }
	        var firstPoint = project(firstAndLastGlyph.first.point, glCoordMatrix).point;
	        var lastPoint = project(firstAndLastGlyph.last.point, glCoordMatrix).point;
	        if (keepUpright && !flip) {
	            var orientationChange = requiresOrientationChange(symbol.writingMode, firstPoint, lastPoint, aspectRatio);
	            if (orientationChange) {
	                return orientationChange;
	            }
	        }
	        placedGlyphs = [firstAndLastGlyph.first];
	        for (var glyphIndex = symbol.glyphStartIndex + 1; glyphIndex < glyphEndIndex - 1; glyphIndex++) {
	            placedGlyphs.push(placeGlyphAlongLine(fontScale * glyphOffsetArray.getoffsetX(glyphIndex), lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol.segment, lineStartIndex, lineEndIndex, lineVertexArray, labelPlaneMatrix, projectionCache));
	        }
	        placedGlyphs.push(firstAndLastGlyph.last);
	    } else {
	        if (keepUpright && !flip) {
	            var a = project(tileAnchorPoint, posMatrix).point;
	            var tileVertexIndex = symbol.lineStartIndex + symbol.segment + 1;
	            var tileSegmentEnd = new performance.Point(lineVertexArray.getx(tileVertexIndex), lineVertexArray.gety(tileVertexIndex));
	            var projectedVertex = project(tileSegmentEnd, posMatrix);
	            var b = projectedVertex.signedDistanceFromCamera > 0 ? projectedVertex.point : projectTruncatedLineSegment(tileAnchorPoint, tileSegmentEnd, a, 1, posMatrix);
	            var orientationChange$1 = requiresOrientationChange(symbol.writingMode, a, b, aspectRatio);
	            if (orientationChange$1) {
	                return orientationChange$1;
	            }
	        }
	        var singleGlyph = placeGlyphAlongLine(fontScale * glyphOffsetArray.getoffsetX(symbol.glyphStartIndex), lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol.segment, symbol.lineStartIndex, symbol.lineStartIndex + symbol.lineLength, lineVertexArray, labelPlaneMatrix, projectionCache);
	        if (!singleGlyph) {
	            return { notEnoughRoom: true };
	        }
	        placedGlyphs = [singleGlyph];
	    }
	    for (var i = 0, list = placedGlyphs; i < list.length; i += 1) {
	        var glyph = list[i];
	        performance.addDynamicAttributes(dynamicLayoutVertexArray, glyph.point, glyph.angle);
	    }
	    return {};
	}
	function projectTruncatedLineSegment(previousTilePoint, currentTilePoint, previousProjectedPoint, minimumLength, projectionMatrix) {
	    var projectedUnitVertex = project(previousTilePoint.add(previousTilePoint.sub(currentTilePoint)._unit()), projectionMatrix).point;
	    var projectedUnitSegment = previousProjectedPoint.sub(projectedUnitVertex);
	    return previousProjectedPoint.add(projectedUnitSegment._mult(minimumLength / projectedUnitSegment.mag()));
	}
	function placeGlyphAlongLine(offsetX, lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, anchorSegment, lineStartIndex, lineEndIndex, lineVertexArray, labelPlaneMatrix, projectionCache) {
	    var combinedOffsetX = flip ? offsetX - lineOffsetX : offsetX + lineOffsetX;
	    var dir = combinedOffsetX > 0 ? 1 : -1;
	    var angle = 0;
	    if (flip) {
	        dir *= -1;
	        angle = Math.PI;
	    }
	    if (dir < 0) {
	        angle += Math.PI;
	    }
	    var currentIndex = dir > 0 ? lineStartIndex + anchorSegment : lineStartIndex + anchorSegment + 1;
	    var current = anchorPoint;
	    var prev = anchorPoint;
	    var distanceToPrev = 0;
	    var currentSegmentDistance = 0;
	    var absOffsetX = Math.abs(combinedOffsetX);
	    var pathVertices = [];
	    while (distanceToPrev + currentSegmentDistance <= absOffsetX) {
	        currentIndex += dir;
	        if (currentIndex < lineStartIndex || currentIndex >= lineEndIndex) {
	            return null;
	        }
	        prev = current;
	        pathVertices.push(current);
	        current = projectionCache[currentIndex];
	        if (current === undefined) {
	            var currentVertex = new performance.Point(lineVertexArray.getx(currentIndex), lineVertexArray.gety(currentIndex));
	            var projection = project(currentVertex, labelPlaneMatrix);
	            if (projection.signedDistanceFromCamera > 0) {
	                current = projectionCache[currentIndex] = projection.point;
	            } else {
	                var previousLineVertexIndex = currentIndex - dir;
	                var previousTilePoint = distanceToPrev === 0 ? tileAnchorPoint : new performance.Point(lineVertexArray.getx(previousLineVertexIndex), lineVertexArray.gety(previousLineVertexIndex));
	                current = projectTruncatedLineSegment(previousTilePoint, currentVertex, prev, absOffsetX - distanceToPrev + 1, labelPlaneMatrix);
	            }
	        }
	        distanceToPrev += currentSegmentDistance;
	        currentSegmentDistance = prev.dist(current);
	    }
	    var segmentInterpolationT = (absOffsetX - distanceToPrev) / currentSegmentDistance;
	    var prevToCurrent = current.sub(prev);
	    var p = prevToCurrent.mult(segmentInterpolationT)._add(prev);
	    p._add(prevToCurrent._unit()._perp()._mult(lineOffsetY * dir));
	    var segmentAngle = angle + Math.atan2(current.y - prev.y, current.x - prev.x);
	    pathVertices.push(p);
	    return {
	        point: p,
	        angle: segmentAngle,
	        path: pathVertices
	    };
	}
	var hiddenGlyphAttributes = new Float32Array([
	    -Infinity,
	    -Infinity,
	    0,
	    -Infinity,
	    -Infinity,
	    0,
	    -Infinity,
	    -Infinity,
	    0,
	    -Infinity,
	    -Infinity,
	    0
	]);
	function hideGlyphs(num, dynamicLayoutVertexArray) {
	    for (var i = 0; i < num; i++) {
	        var offset = dynamicLayoutVertexArray.length;
	        dynamicLayoutVertexArray.resize(offset + 4);
	        dynamicLayoutVertexArray.float32.set(hiddenGlyphAttributes, offset * 3);
	    }
	}
	function xyTransformMat4(out, a, m) {
	    var x = a[0], y = a[1];
	    out[0] = m[0] * x + m[4] * y + m[12];
	    out[1] = m[1] * x + m[5] * y + m[13];
	    out[3] = m[3] * x + m[7] * y + m[15];
	    return out;
	}

	var viewportPadding = 100;
	var CollisionIndex = function CollisionIndex(transform, grid, ignoredGrid) {
	    if (grid === void 0)
	        grid = new GridIndex(transform.width + 2 * viewportPadding, transform.height + 2 * viewportPadding, 25);
	    if (ignoredGrid === void 0)
	        ignoredGrid = new GridIndex(transform.width + 2 * viewportPadding, transform.height + 2 * viewportPadding, 25);
	    this.transform = transform;
	    this.grid = grid;
	    this.ignoredGrid = ignoredGrid;
	    this.pitchfactor = Math.cos(transform._pitch) * transform.cameraToCenterDistance;
	    this.screenRightBoundary = transform.width + viewportPadding;
	    this.screenBottomBoundary = transform.height + viewportPadding;
	    this.gridRightBoundary = transform.width + 2 * viewportPadding;
	    this.gridBottomBoundary = transform.height + 2 * viewportPadding;
	};
	CollisionIndex.prototype.placeCollisionBox = function placeCollisionBox(collisionBox, allowOverlap, textPixelRatio, posMatrix, collisionGroupPredicate) {
	    var projectedPoint = this.projectAndGetPerspectiveRatio(posMatrix, collisionBox.anchorPointX, collisionBox.anchorPointY);
	    var tileToViewport = textPixelRatio * projectedPoint.perspectiveRatio;
	    var tlX = collisionBox.x1 * tileToViewport + projectedPoint.point.x;
	    var tlY = collisionBox.y1 * tileToViewport + projectedPoint.point.y;
	    var brX = collisionBox.x2 * tileToViewport + projectedPoint.point.x;
	    var brY = collisionBox.y2 * tileToViewport + projectedPoint.point.y;
	    if (!this.isInsideGrid(tlX, tlY, brX, brY) || !allowOverlap && this.grid.hitTest(tlX, tlY, brX, brY, collisionGroupPredicate)) {
	        return {
	            box: [],
	            offscreen: false
	        };
	    }
	    return {
	        box: [
	            tlX,
	            tlY,
	            brX,
	            brY
	        ],
	        offscreen: this.isOffscreen(tlX, tlY, brX, brY)
	    };
	};
	CollisionIndex.prototype.placeCollisionCircles = function placeCollisionCircles(allowOverlap, symbol, lineVertexArray, glyphOffsetArray, fontSize, posMatrix, labelPlaneMatrix, labelToScreenMatrix, showCollisionCircles, pitchWithMap, collisionGroupPredicate, circlePixelDiameter, textPixelPadding) {
	    var placedCollisionCircles = [];
	    var tileUnitAnchorPoint = new performance.Point(symbol.anchorX, symbol.anchorY);
	    var screenAnchorPoint = project(tileUnitAnchorPoint, posMatrix);
	    var perspectiveRatio = getPerspectiveRatio(this.transform.cameraToCenterDistance, screenAnchorPoint.signedDistanceFromCamera);
	    var labelPlaneFontSize = pitchWithMap ? fontSize / perspectiveRatio : fontSize * perspectiveRatio;
	    var labelPlaneFontScale = labelPlaneFontSize / performance.ONE_EM;
	    var labelPlaneAnchorPoint = project(tileUnitAnchorPoint, labelPlaneMatrix).point;
	    var projectionCache = {};
	    var lineOffsetX = symbol.lineOffsetX * labelPlaneFontScale;
	    var lineOffsetY = symbol.lineOffsetY * labelPlaneFontScale;
	    var firstAndLastGlyph = placeFirstAndLastGlyph(labelPlaneFontScale, glyphOffsetArray, lineOffsetX, lineOffsetY, false, labelPlaneAnchorPoint, tileUnitAnchorPoint, symbol, lineVertexArray, labelPlaneMatrix, projectionCache);
	    var collisionDetected = false;
	    var inGrid = false;
	    var entirelyOffscreen = true;
	    if (firstAndLastGlyph) {
	        var radius = circlePixelDiameter * 0.5 * perspectiveRatio + textPixelPadding;
	        var screenPlaneMin = new performance.Point(-viewportPadding, -viewportPadding);
	        var screenPlaneMax = new performance.Point(this.screenRightBoundary, this.screenBottomBoundary);
	        var interpolator = new PathInterpolator();
	        var first = firstAndLastGlyph.first;
	        var last = firstAndLastGlyph.last;
	        var projectedPath = [];
	        for (var i = first.path.length - 1; i >= 1; i--) {
	            projectedPath.push(first.path[i]);
	        }
	        for (var i$1 = 1; i$1 < last.path.length; i$1++) {
	            projectedPath.push(last.path[i$1]);
	        }
	        var circleDist = radius * 2.5;
	        if (labelToScreenMatrix) {
	            var screenSpacePath = projectedPath.map(function (p) {
	                return project(p, labelToScreenMatrix);
	            });
	            if (screenSpacePath.some(function (point) {
	                    return point.signedDistanceFromCamera <= 0;
	                })) {
	                projectedPath = [];
	            } else {
	                projectedPath = screenSpacePath.map(function (p) {
	                    return p.point;
	                });
	            }
	        }
	        var segments = [];
	        if (projectedPath.length > 0) {
	            var minPoint = projectedPath[0].clone();
	            var maxPoint = projectedPath[0].clone();
	            for (var i$2 = 1; i$2 < projectedPath.length; i$2++) {
	                minPoint.x = Math.min(minPoint.x, projectedPath[i$2].x);
	                minPoint.y = Math.min(minPoint.y, projectedPath[i$2].y);
	                maxPoint.x = Math.max(maxPoint.x, projectedPath[i$2].x);
	                maxPoint.y = Math.max(maxPoint.y, projectedPath[i$2].y);
	            }
	            if (minPoint.x >= screenPlaneMin.x && maxPoint.x <= screenPlaneMax.x && minPoint.y >= screenPlaneMin.y && maxPoint.y <= screenPlaneMax.y) {
	                segments = [projectedPath];
	            } else if (maxPoint.x < screenPlaneMin.x || minPoint.x > screenPlaneMax.x || maxPoint.y < screenPlaneMin.y || minPoint.y > screenPlaneMax.y) {
	                segments = [];
	            } else {
	                segments = performance.clipLine([projectedPath], screenPlaneMin.x, screenPlaneMin.y, screenPlaneMax.x, screenPlaneMax.y);
	            }
	        }
	        for (var i$4 = 0, list = segments; i$4 < list.length; i$4 += 1) {
	            var seg = list[i$4];
	            interpolator.reset(seg, radius * 0.25);
	            var numCircles = 0;
	            if (interpolator.length <= 0.5 * radius) {
	                numCircles = 1;
	            } else {
	                numCircles = Math.ceil(interpolator.paddedLength / circleDist) + 1;
	            }
	            for (var i$3 = 0; i$3 < numCircles; i$3++) {
	                var t = i$3 / Math.max(numCircles - 1, 1);
	                var circlePosition = interpolator.lerp(t);
	                var centerX = circlePosition.x + viewportPadding;
	                var centerY = circlePosition.y + viewportPadding;
	                placedCollisionCircles.push(centerX, centerY, radius, 0);
	                var x1 = centerX - radius;
	                var y1 = centerY - radius;
	                var x2 = centerX + radius;
	                var y2 = centerY + radius;
	                entirelyOffscreen = entirelyOffscreen && this.isOffscreen(x1, y1, x2, y2);
	                inGrid = inGrid || this.isInsideGrid(x1, y1, x2, y2);
	                if (!allowOverlap) {
	                    if (this.grid.hitTestCircle(centerX, centerY, radius, collisionGroupPredicate)) {
	                        collisionDetected = true;
	                        if (!showCollisionCircles) {
	                            return {
	                                circles: [],
	                                offscreen: false,
	                                collisionDetected: collisionDetected
	                            };
	                        }
	                    }
	                }
	            }
	        }
	    }
	    return {
	        circles: !showCollisionCircles && collisionDetected || !inGrid ? [] : placedCollisionCircles,
	        offscreen: entirelyOffscreen,
	        collisionDetected: collisionDetected
	    };
	};
	CollisionIndex.prototype.queryRenderedSymbols = function queryRenderedSymbols(viewportQueryGeometry) {
	    if (viewportQueryGeometry.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) {
	        return {};
	    }
	    var query = [];
	    var minX = Infinity;
	    var minY = Infinity;
	    var maxX = -Infinity;
	    var maxY = -Infinity;
	    for (var i = 0, list = viewportQueryGeometry; i < list.length; i += 1) {
	        var point = list[i];
	        var gridPoint = new performance.Point(point.x + viewportPadding, point.y + viewportPadding);
	        minX = Math.min(minX, gridPoint.x);
	        minY = Math.min(minY, gridPoint.y);
	        maxX = Math.max(maxX, gridPoint.x);
	        maxY = Math.max(maxY, gridPoint.y);
	        query.push(gridPoint);
	    }
	    var features = this.grid.query(minX, minY, maxX, maxY).concat(this.ignoredGrid.query(minX, minY, maxX, maxY));
	    var seenFeatures = {};
	    var result = {};
	    for (var i$1 = 0, list$1 = features; i$1 < list$1.length; i$1 += 1) {
	        var feature = list$1[i$1];
	        var featureKey = feature.key;
	        if (seenFeatures[featureKey.bucketInstanceId] === undefined) {
	            seenFeatures[featureKey.bucketInstanceId] = {};
	        }
	        if (seenFeatures[featureKey.bucketInstanceId][featureKey.featureIndex]) {
	            continue;
	        }
	        var bbox = [
	            new performance.Point(feature.x1, feature.y1),
	            new performance.Point(feature.x2, feature.y1),
	            new performance.Point(feature.x2, feature.y2),
	            new performance.Point(feature.x1, feature.y2)
	        ];
	        if (!performance.polygonIntersectsPolygon(query, bbox)) {
	            continue;
	        }
	        seenFeatures[featureKey.bucketInstanceId][featureKey.featureIndex] = true;
	        if (result[featureKey.bucketInstanceId] === undefined) {
	            result[featureKey.bucketInstanceId] = [];
	        }
	        result[featureKey.bucketInstanceId].push(featureKey.featureIndex);
	    }
	    return result;
	};
	CollisionIndex.prototype.insertCollisionBox = function insertCollisionBox(collisionBox, ignorePlacement, bucketInstanceId, featureIndex, collisionGroupID) {
	    var grid = ignorePlacement ? this.ignoredGrid : this.grid;
	    var key = {
	        bucketInstanceId: bucketInstanceId,
	        featureIndex: featureIndex,
	        collisionGroupID: collisionGroupID
	    };
	    grid.insert(key, collisionBox[0], collisionBox[1], collisionBox[2], collisionBox[3]);
	};
	CollisionIndex.prototype.insertCollisionCircles = function insertCollisionCircles(collisionCircles, ignorePlacement, bucketInstanceId, featureIndex, collisionGroupID) {
	    var grid = ignorePlacement ? this.ignoredGrid : this.grid;
	    var key = {
	        bucketInstanceId: bucketInstanceId,
	        featureIndex: featureIndex,
	        collisionGroupID: collisionGroupID
	    };
	    for (var k = 0; k < collisionCircles.length; k += 4) {
	        grid.insertCircle(key, collisionCircles[k], collisionCircles[k + 1], collisionCircles[k + 2]);
	    }
	};
	CollisionIndex.prototype.projectAndGetPerspectiveRatio = function projectAndGetPerspectiveRatio(posMatrix, x, y) {
	    var p = [
	        x,
	        y,
	        0,
	        1
	    ];
	    xyTransformMat4(p, p, posMatrix);
	    var a = new performance.Point((p[0] / p[3] + 1) / 2 * this.transform.width + viewportPadding, (-p[1] / p[3] + 1) / 2 * this.transform.height + viewportPadding);
	    return {
	        point: a,
	        perspectiveRatio: 0.5 + 0.5 * (this.transform.cameraToCenterDistance / p[3])
	    };
	};
	CollisionIndex.prototype.isOffscreen = function isOffscreen(x1, y1, x2, y2) {
	    return x2 < viewportPadding || x1 >= this.screenRightBoundary || y2 < viewportPadding || y1 > this.screenBottomBoundary;
	};
	CollisionIndex.prototype.isInsideGrid = function isInsideGrid(x1, y1, x2, y2) {
	    return x2 >= 0 && x1 < this.gridRightBoundary && y2 >= 0 && y1 < this.gridBottomBoundary;
	};
	CollisionIndex.prototype.getViewportMatrix = function getViewportMatrix() {
	    var m = performance.identity([]);
	    performance.translate(m, m, [
	        -viewportPadding,
	        -viewportPadding,
	        0
	    ]);
	    return m;
	};

	function pixelsToTileUnits (tile, pixelValue, z) {
	    return pixelValue * (performance.EXTENT / (tile.tileSize * Math.pow(2, z - tile.tileID.overscaledZ)));
	}

	var OpacityState = function OpacityState(prevState, increment, placed, skipFade) {
	    if (prevState) {
	        this.opacity = Math.max(0, Math.min(1, prevState.opacity + (prevState.placed ? increment : -increment)));
	    } else {
	        this.opacity = skipFade && placed ? 1 : 0;
	    }
	    this.placed = placed;
	};
	OpacityState.prototype.isHidden = function isHidden() {
	    return this.opacity === 0 && !this.placed;
	};
	var JointOpacityState = function JointOpacityState(prevState, increment, placedText, placedIcon, skipFade) {
	    this.text = new OpacityState(prevState ? prevState.text : null, increment, placedText, skipFade);
	    this.icon = new OpacityState(prevState ? prevState.icon : null, increment, placedIcon, skipFade);
	};
	JointOpacityState.prototype.isHidden = function isHidden() {
	    return this.text.isHidden() && this.icon.isHidden();
	};
	var JointPlacement = function JointPlacement(text, icon, skipFade) {
	    this.text = text;
	    this.icon = icon;
	    this.skipFade = skipFade;
	};
	var CollisionCircleArray = function CollisionCircleArray() {
	    this.invProjMatrix = performance.create();
	    this.viewportMatrix = performance.create();
	    this.circles = [];
	};
	var RetainedQueryData = function RetainedQueryData(bucketInstanceId, featureIndex, sourceLayerIndex, bucketIndex, tileID) {
	    this.bucketInstanceId = bucketInstanceId;
	    this.featureIndex = featureIndex;
	    this.sourceLayerIndex = sourceLayerIndex;
	    this.bucketIndex = bucketIndex;
	    this.tileID = tileID;
	};
	var CollisionGroups = function CollisionGroups(crossSourceCollisions) {
	    this.crossSourceCollisions = crossSourceCollisions;
	    this.maxGroupID = 0;
	    this.collisionGroups = {};
	};
	CollisionGroups.prototype.get = function get(sourceID) {
	    if (!this.crossSourceCollisions) {
	        if (!this.collisionGroups[sourceID]) {
	            var nextGroupID = ++this.maxGroupID;
	            this.collisionGroups[sourceID] = {
	                ID: nextGroupID,
	                predicate: function (key) {
	                    return key.collisionGroupID === nextGroupID;
	                }
	            };
	        }
	        return this.collisionGroups[sourceID];
	    } else {
	        return {
	            ID: 0,
	            predicate: null
	        };
	    }
	};
	function calculateVariableLayoutShift(anchor, width, height, textOffset, textBoxScale) {
	    var ref = performance.getAnchorAlignment(anchor);
	    var horizontalAlign = ref.horizontalAlign;
	    var verticalAlign = ref.verticalAlign;
	    var shiftX = -(horizontalAlign - 0.5) * width;
	    var shiftY = -(verticalAlign - 0.5) * height;
	    var offset = performance.evaluateVariableOffset(anchor, textOffset);
	    return new performance.Point(shiftX + offset[0] * textBoxScale, shiftY + offset[1] * textBoxScale);
	}
	function shiftVariableCollisionBox(collisionBox, shiftX, shiftY, rotateWithMap, pitchWithMap, angle) {
	    var x1 = collisionBox.x1;
	    var x2 = collisionBox.x2;
	    var y1 = collisionBox.y1;
	    var y2 = collisionBox.y2;
	    var anchorPointX = collisionBox.anchorPointX;
	    var anchorPointY = collisionBox.anchorPointY;
	    var rotatedOffset = new performance.Point(shiftX, shiftY);
	    if (rotateWithMap) {
	        rotatedOffset._rotate(pitchWithMap ? angle : -angle);
	    }
	    return {
	        x1: x1 + rotatedOffset.x,
	        y1: y1 + rotatedOffset.y,
	        x2: x2 + rotatedOffset.x,
	        y2: y2 + rotatedOffset.y,
	        anchorPointX: anchorPointX,
	        anchorPointY: anchorPointY
	    };
	}
	var Placement = function Placement(transform, fadeDuration, crossSourceCollisions, prevPlacement) {
	    this.transform = transform.clone();
	    this.collisionIndex = new CollisionIndex(this.transform);
	    this.placements = {};
	    this.opacities = {};
	    this.variableOffsets = {};
	    this.stale = false;
	    this.commitTime = 0;
	    this.fadeDuration = fadeDuration;
	    this.retainedQueryData = {};
	    this.collisionGroups = new CollisionGroups(crossSourceCollisions);
	    this.collisionCircleArrays = {};
	    this.prevPlacement = prevPlacement;
	    if (prevPlacement) {
	        prevPlacement.prevPlacement = undefined;
	    }
	    this.placedOrientations = {};
	};
	Placement.prototype.getBucketParts = function getBucketParts(results, styleLayer, tile, sortAcrossTiles) {
	    var symbolBucket = tile.getBucket(styleLayer);
	    var bucketFeatureIndex = tile.latestFeatureIndex;
	    if (!symbolBucket || !bucketFeatureIndex || styleLayer.id !== symbolBucket.layerIds[0]) {
	        return;
	    }
	    var collisionBoxArray = tile.collisionBoxArray;
	    var layout = symbolBucket.layers[0].layout;
	    var scale = Math.pow(2, this.transform.zoom - tile.tileID.overscaledZ);
	    var textPixelRatio = tile.tileSize / performance.EXTENT;
	    var posMatrix = this.transform.calculatePosMatrix(tile.tileID.toUnwrapped());
	    var pitchWithMap = layout.get('text-pitch-alignment') === 'map';
	    var rotateWithMap = layout.get('text-rotation-alignment') === 'map';
	    var pixelsToTiles = pixelsToTileUnits(tile, 1, this.transform.zoom);
	    var textLabelPlaneMatrix = getLabelPlaneMatrix(posMatrix, pitchWithMap, rotateWithMap, this.transform, pixelsToTiles);
	    var labelToScreenMatrix = null;
	    if (pitchWithMap) {
	        var glMatrix = getGlCoordMatrix(posMatrix, pitchWithMap, rotateWithMap, this.transform, pixelsToTiles);
	        labelToScreenMatrix = performance.multiply([], this.transform.labelPlaneMatrix, glMatrix);
	    }
	    this.retainedQueryData[symbolBucket.bucketInstanceId] = new RetainedQueryData(symbolBucket.bucketInstanceId, bucketFeatureIndex, symbolBucket.sourceLayerIndex, symbolBucket.index, tile.tileID);
	    var parameters = {
	        bucket: symbolBucket,
	        layout: layout,
	        posMatrix: posMatrix,
	        textLabelPlaneMatrix: textLabelPlaneMatrix,
	        labelToScreenMatrix: labelToScreenMatrix,
	        scale: scale,
	        textPixelRatio: textPixelRatio,
	        holdingForFade: tile.holdingForFade(),
	        collisionBoxArray: collisionBoxArray,
	        partiallyEvaluatedTextSize: performance.evaluateSizeForZoom(symbolBucket.textSizeData, this.transform.zoom),
	        collisionGroup: this.collisionGroups.get(symbolBucket.sourceID)
	    };
	    if (sortAcrossTiles) {
	        for (var i = 0, list = symbolBucket.sortKeyRanges; i < list.length; i += 1) {
	            var range = list[i];
	            var sortKey = range.sortKey;
	            var symbolInstanceStart = range.symbolInstanceStart;
	            var symbolInstanceEnd = range.symbolInstanceEnd;
	            results.push({
	                sortKey: sortKey,
	                symbolInstanceStart: symbolInstanceStart,
	                symbolInstanceEnd: symbolInstanceEnd,
	                parameters: parameters
	            });
	        }
	    } else {
	        results.push({
	            symbolInstanceStart: 0,
	            symbolInstanceEnd: symbolBucket.symbolInstances.length,
	            parameters: parameters
	        });
	    }
	};
	Placement.prototype.attemptAnchorPlacement = function attemptAnchorPlacement(anchor, textBox, width, height, textBoxScale, rotateWithMap, pitchWithMap, textPixelRatio, posMatrix, collisionGroup, textAllowOverlap, symbolInstance, bucket, orientation, iconBox) {
	    var textOffset = [
	        symbolInstance.textOffset0,
	        symbolInstance.textOffset1
	    ];
	    var shift = calculateVariableLayoutShift(anchor, width, height, textOffset, textBoxScale);
	    var placedGlyphBoxes = this.collisionIndex.placeCollisionBox(shiftVariableCollisionBox(textBox, shift.x, shift.y, rotateWithMap, pitchWithMap, this.transform.angle), textAllowOverlap, textPixelRatio, posMatrix, collisionGroup.predicate);
	    if (iconBox) {
	        var placedIconBoxes = this.collisionIndex.placeCollisionBox(shiftVariableCollisionBox(iconBox, shift.x, shift.y, rotateWithMap, pitchWithMap, this.transform.angle), textAllowOverlap, textPixelRatio, posMatrix, collisionGroup.predicate);
	        if (placedIconBoxes.box.length === 0) {
	            return;
	        }
	    }
	    if (placedGlyphBoxes.box.length > 0) {
	        var prevAnchor;
	        if (this.prevPlacement && this.prevPlacement.variableOffsets[symbolInstance.crossTileID] && this.prevPlacement.placements[symbolInstance.crossTileID] && this.prevPlacement.placements[symbolInstance.crossTileID].text) {
	            prevAnchor = this.prevPlacement.variableOffsets[symbolInstance.crossTileID].anchor;
	        }
	        this.variableOffsets[symbolInstance.crossTileID] = {
	            textOffset: textOffset,
	            width: width,
	            height: height,
	            anchor: anchor,
	            textBoxScale: textBoxScale,
	            prevAnchor: prevAnchor
	        };
	        this.markUsedJustification(bucket, anchor, symbolInstance, orientation);
	        if (bucket.allowVerticalPlacement) {
	            this.markUsedOrientation(bucket, orientation, symbolInstance);
	            this.placedOrientations[symbolInstance.crossTileID] = orientation;
	        }
	        return {
	            shift: shift,
	            placedGlyphBoxes: placedGlyphBoxes
	        };
	    }
	};
	Placement.prototype.placeLayerBucketPart = function placeLayerBucketPart(bucketPart, seenCrossTileIDs, showCollisionBoxes) {
	    var this$1 = this;
	    var ref = bucketPart.parameters;
	    var bucket = ref.bucket;
	    var layout = ref.layout;
	    var posMatrix = ref.posMatrix;
	    var textLabelPlaneMatrix = ref.textLabelPlaneMatrix;
	    var labelToScreenMatrix = ref.labelToScreenMatrix;
	    var textPixelRatio = ref.textPixelRatio;
	    var holdingForFade = ref.holdingForFade;
	    var collisionBoxArray = ref.collisionBoxArray;
	    var partiallyEvaluatedTextSize = ref.partiallyEvaluatedTextSize;
	    var collisionGroup = ref.collisionGroup;
	    var textOptional = layout.get('text-optional');
	    var iconOptional = layout.get('icon-optional');
	    var textAllowOverlap = layout.get('text-allow-overlap');
	    var iconAllowOverlap = layout.get('icon-allow-overlap');
	    var rotateWithMap = layout.get('text-rotation-alignment') === 'map';
	    var pitchWithMap = layout.get('text-pitch-alignment') === 'map';
	    var hasIconTextFit = layout.get('icon-text-fit') !== 'none';
	    var zOrderByViewportY = layout.get('symbol-z-order') === 'viewport-y';
	    var alwaysShowText = textAllowOverlap && (iconAllowOverlap || !bucket.hasIconData() || iconOptional);
	    var alwaysShowIcon = iconAllowOverlap && (textAllowOverlap || !bucket.hasTextData() || textOptional);
	    if (!bucket.collisionArrays && collisionBoxArray) {
	        bucket.deserializeCollisionBoxes(collisionBoxArray);
	    }
	    var placeSymbol = function (symbolInstance, collisionArrays) {
	        if (seenCrossTileIDs[symbolInstance.crossTileID]) {
	            return;
	        }
	        if (holdingForFade) {
	            this$1.placements[symbolInstance.crossTileID] = new JointPlacement(false, false, false);
	            return;
	        }
	        var placeText = false;
	        var placeIcon = false;
	        var offscreen = true;
	        var shift = null;
	        var placed = {
	            box: null,
	            offscreen: null
	        };
	        var placedVerticalText = {
	            box: null,
	            offscreen: null
	        };
	        var placedGlyphBoxes = null;
	        var placedGlyphCircles = null;
	        var placedIconBoxes = null;
	        var textFeatureIndex = 0;
	        var verticalTextFeatureIndex = 0;
	        var iconFeatureIndex = 0;
	        if (collisionArrays.textFeatureIndex) {
	            textFeatureIndex = collisionArrays.textFeatureIndex;
	        } else if (symbolInstance.useRuntimeCollisionCircles) {
	            textFeatureIndex = symbolInstance.featureIndex;
	        }
	        if (collisionArrays.verticalTextFeatureIndex) {
	            verticalTextFeatureIndex = collisionArrays.verticalTextFeatureIndex;
	        }
	        var textBox = collisionArrays.textBox;
	        if (textBox) {
	            var updatePreviousOrientationIfNotPlaced = function (isPlaced) {
	                var previousOrientation = performance.WritingMode.horizontal;
	                if (bucket.allowVerticalPlacement && !isPlaced && this$1.prevPlacement) {
	                    var prevPlacedOrientation = this$1.prevPlacement.placedOrientations[symbolInstance.crossTileID];
	                    if (prevPlacedOrientation) {
	                        this$1.placedOrientations[symbolInstance.crossTileID] = prevPlacedOrientation;
	                        previousOrientation = prevPlacedOrientation;
	                        this$1.markUsedOrientation(bucket, previousOrientation, symbolInstance);
	                    }
	                }
	                return previousOrientation;
	            };
	            var placeTextForPlacementModes = function (placeHorizontalFn, placeVerticalFn) {
	                if (bucket.allowVerticalPlacement && symbolInstance.numVerticalGlyphVertices > 0 && collisionArrays.verticalTextBox) {
	                    for (var i = 0, list = bucket.writingModes; i < list.length; i += 1) {
	                        var placementMode = list[i];
	                        if (placementMode === performance.WritingMode.vertical) {
	                            placed = placeVerticalFn();
	                            placedVerticalText = placed;
	                        } else {
	                            placed = placeHorizontalFn();
	                        }
	                        if (placed && placed.box && placed.box.length) {
	                            break;
	                        }
	                    }
	                } else {
	                    placed = placeHorizontalFn();
	                }
	            };
	            if (!layout.get('text-variable-anchor')) {
	                var placeBox = function (collisionTextBox, orientation) {
	                    var placedFeature = this$1.collisionIndex.placeCollisionBox(collisionTextBox, textAllowOverlap, textPixelRatio, posMatrix, collisionGroup.predicate);
	                    if (placedFeature && placedFeature.box && placedFeature.box.length) {
	                        this$1.markUsedOrientation(bucket, orientation, symbolInstance);
	                        this$1.placedOrientations[symbolInstance.crossTileID] = orientation;
	                    }
	                    return placedFeature;
	                };
	                var placeHorizontal = function () {
	                    return placeBox(textBox, performance.WritingMode.horizontal);
	                };
	                var placeVertical = function () {
	                    var verticalTextBox = collisionArrays.verticalTextBox;
	                    if (bucket.allowVerticalPlacement && symbolInstance.numVerticalGlyphVertices > 0 && verticalTextBox) {
	                        return placeBox(verticalTextBox, performance.WritingMode.vertical);
	                    }
	                    return {
	                        box: null,
	                        offscreen: null
	                    };
	                };
	                placeTextForPlacementModes(placeHorizontal, placeVertical);
	                updatePreviousOrientationIfNotPlaced(placed && placed.box && placed.box.length);
	            } else {
	                var anchors = layout.get('text-variable-anchor');
	                if (this$1.prevPlacement && this$1.prevPlacement.variableOffsets[symbolInstance.crossTileID]) {
	                    var prevOffsets = this$1.prevPlacement.variableOffsets[symbolInstance.crossTileID];
	                    if (anchors.indexOf(prevOffsets.anchor) > 0) {
	                        anchors = anchors.filter(function (anchor) {
	                            return anchor !== prevOffsets.anchor;
	                        });
	                        anchors.unshift(prevOffsets.anchor);
	                    }
	                }
	                var placeBoxForVariableAnchors = function (collisionTextBox, collisionIconBox, orientation) {
	                    var width = collisionTextBox.x2 - collisionTextBox.x1;
	                    var height = collisionTextBox.y2 - collisionTextBox.y1;
	                    var textBoxScale = symbolInstance.textBoxScale;
	                    var variableIconBox = hasIconTextFit && !iconAllowOverlap ? collisionIconBox : null;
	                    var placedBox = {
	                        box: [],
	                        offscreen: false
	                    };
	                    var placementAttempts = textAllowOverlap ? anchors.length * 2 : anchors.length;
	                    for (var i = 0; i < placementAttempts; ++i) {
	                        var anchor = anchors[i % anchors.length];
	                        var allowOverlap = i >= anchors.length;
	                        var result = this$1.attemptAnchorPlacement(anchor, collisionTextBox, width, height, textBoxScale, rotateWithMap, pitchWithMap, textPixelRatio, posMatrix, collisionGroup, allowOverlap, symbolInstance, bucket, orientation, variableIconBox);
	                        if (result) {
	                            placedBox = result.placedGlyphBoxes;
	                            if (placedBox && placedBox.box && placedBox.box.length) {
	                                placeText = true;
	                                shift = result.shift;
	                                break;
	                            }
	                        }
	                    }
	                    return placedBox;
	                };
	                var placeHorizontal$1 = function () {
	                    return placeBoxForVariableAnchors(textBox, collisionArrays.iconBox, performance.WritingMode.horizontal);
	                };
	                var placeVertical$1 = function () {
	                    var verticalTextBox = collisionArrays.verticalTextBox;
	                    var wasPlaced = placed && placed.box && placed.box.length;
	                    if (bucket.allowVerticalPlacement && !wasPlaced && symbolInstance.numVerticalGlyphVertices > 0 && verticalTextBox) {
	                        return placeBoxForVariableAnchors(verticalTextBox, collisionArrays.verticalIconBox, performance.WritingMode.vertical);
	                    }
	                    return {
	                        box: null,
	                        offscreen: null
	                    };
	                };
	                placeTextForPlacementModes(placeHorizontal$1, placeVertical$1);
	                if (placed) {
	                    placeText = placed.box;
	                    offscreen = placed.offscreen;
	                }
	                var prevOrientation = updatePreviousOrientationIfNotPlaced(placed && placed.box);
	                if (!placeText && this$1.prevPlacement) {
	                    var prevOffset = this$1.prevPlacement.variableOffsets[symbolInstance.crossTileID];
	                    if (prevOffset) {
	                        this$1.variableOffsets[symbolInstance.crossTileID] = prevOffset;
	                        this$1.markUsedJustification(bucket, prevOffset.anchor, symbolInstance, prevOrientation);
	                    }
	                }
	            }
	        }
	        placedGlyphBoxes = placed;
	        placeText = placedGlyphBoxes && placedGlyphBoxes.box && placedGlyphBoxes.box.length > 0;
	        offscreen = placedGlyphBoxes && placedGlyphBoxes.offscreen;
	        if (symbolInstance.useRuntimeCollisionCircles) {
	            var placedSymbol = bucket.text.placedSymbolArray.get(symbolInstance.centerJustifiedTextSymbolIndex);
	            var fontSize = performance.evaluateSizeForFeature(bucket.textSizeData, partiallyEvaluatedTextSize, placedSymbol);
	            var textPixelPadding = layout.get('text-padding');
	            var circlePixelDiameter = symbolInstance.collisionCircleDiameter;
	            placedGlyphCircles = this$1.collisionIndex.placeCollisionCircles(textAllowOverlap, placedSymbol, bucket.lineVertexArray, bucket.glyphOffsetArray, fontSize, posMatrix, textLabelPlaneMatrix, labelToScreenMatrix, showCollisionBoxes, pitchWithMap, collisionGroup.predicate, circlePixelDiameter, textPixelPadding);
	            placeText = textAllowOverlap || placedGlyphCircles.circles.length > 0 && !placedGlyphCircles.collisionDetected;
	            offscreen = offscreen && placedGlyphCircles.offscreen;
	        }
	        if (collisionArrays.iconFeatureIndex) {
	            iconFeatureIndex = collisionArrays.iconFeatureIndex;
	        }
	        if (collisionArrays.iconBox) {
	            var placeIconFeature = function (iconBox) {
	                var shiftedIconBox = hasIconTextFit && shift ? shiftVariableCollisionBox(iconBox, shift.x, shift.y, rotateWithMap, pitchWithMap, this$1.transform.angle) : iconBox;
	                return this$1.collisionIndex.placeCollisionBox(shiftedIconBox, iconAllowOverlap, textPixelRatio, posMatrix, collisionGroup.predicate);
	            };
	            if (placedVerticalText && placedVerticalText.box && placedVerticalText.box.length && collisionArrays.verticalIconBox) {
	                placedIconBoxes = placeIconFeature(collisionArrays.verticalIconBox);
	                placeIcon = placedIconBoxes.box.length > 0;
	            } else {
	                placedIconBoxes = placeIconFeature(collisionArrays.iconBox);
	                placeIcon = placedIconBoxes.box.length > 0;
	            }
	            offscreen = offscreen && placedIconBoxes.offscreen;
	        }
	        var iconWithoutText = textOptional || symbolInstance.numHorizontalGlyphVertices === 0 && symbolInstance.numVerticalGlyphVertices === 0;
	        var textWithoutIcon = iconOptional || symbolInstance.numIconVertices === 0;
	        if (!iconWithoutText && !textWithoutIcon) {
	            placeIcon = placeText = placeIcon && placeText;
	        } else if (!textWithoutIcon) {
	            placeText = placeIcon && placeText;
	        } else if (!iconWithoutText) {
	            placeIcon = placeIcon && placeText;
	        }
	        if (placeText && placedGlyphBoxes && placedGlyphBoxes.box) {
	            if (placedVerticalText && placedVerticalText.box && verticalTextFeatureIndex) {
	                this$1.collisionIndex.insertCollisionBox(placedGlyphBoxes.box, layout.get('text-ignore-placement'), bucket.bucketInstanceId, verticalTextFeatureIndex, collisionGroup.ID);
	            } else {
	                this$1.collisionIndex.insertCollisionBox(placedGlyphBoxes.box, layout.get('text-ignore-placement'), bucket.bucketInstanceId, textFeatureIndex, collisionGroup.ID);
	            }
	        }
	        if (placeIcon && placedIconBoxes) {
	            this$1.collisionIndex.insertCollisionBox(placedIconBoxes.box, layout.get('icon-ignore-placement'), bucket.bucketInstanceId, iconFeatureIndex, collisionGroup.ID);
	        }
	        if (placedGlyphCircles) {
	            if (placeText) {
	                this$1.collisionIndex.insertCollisionCircles(placedGlyphCircles.circles, layout.get('text-ignore-placement'), bucket.bucketInstanceId, textFeatureIndex, collisionGroup.ID);
	            }
	            if (showCollisionBoxes) {
	                var id = bucket.bucketInstanceId;
	                var circleArray = this$1.collisionCircleArrays[id];
	                if (circleArray === undefined) {
	                    circleArray = this$1.collisionCircleArrays[id] = new CollisionCircleArray();
	                }
	                for (var i = 0; i < placedGlyphCircles.circles.length; i += 4) {
	                    circleArray.circles.push(placedGlyphCircles.circles[i + 0]);
	                    circleArray.circles.push(placedGlyphCircles.circles[i + 1]);
	                    circleArray.circles.push(placedGlyphCircles.circles[i + 2]);
	                    circleArray.circles.push(placedGlyphCircles.collisionDetected ? 1 : 0);
	                }
	            }
	        }
	        this$1.placements[symbolInstance.crossTileID] = new JointPlacement(placeText || alwaysShowText, placeIcon || alwaysShowIcon, offscreen || bucket.justReloaded);
	        seenCrossTileIDs[symbolInstance.crossTileID] = true;
	    };
	    if (zOrderByViewportY) {
	        var symbolIndexes = bucket.getSortedSymbolIndexes(this.transform.angle);
	        for (var i = symbolIndexes.length - 1; i >= 0; --i) {
	            var symbolIndex = symbolIndexes[i];
	            placeSymbol(bucket.symbolInstances.get(symbolIndex), bucket.collisionArrays[symbolIndex]);
	        }
	    } else {
	        for (var i$1 = bucketPart.symbolInstanceStart; i$1 < bucketPart.symbolInstanceEnd; i$1++) {
	            placeSymbol(bucket.symbolInstances.get(i$1), bucket.collisionArrays[i$1]);
	        }
	    }
	    if (showCollisionBoxes && bucket.bucketInstanceId in this.collisionCircleArrays) {
	        var circleArray = this.collisionCircleArrays[bucket.bucketInstanceId];
	        performance.invert(circleArray.invProjMatrix, posMatrix);
	        circleArray.viewportMatrix = this.collisionIndex.getViewportMatrix();
	    }
	    bucket.justReloaded = false;
	};
	Placement.prototype.markUsedJustification = function markUsedJustification(bucket, placedAnchor, symbolInstance, orientation) {
	    var justifications = {
	        'left': symbolInstance.leftJustifiedTextSymbolIndex,
	        'center': symbolInstance.centerJustifiedTextSymbolIndex,
	        'right': symbolInstance.rightJustifiedTextSymbolIndex
	    };
	    var autoIndex;
	    if (orientation === performance.WritingMode.vertical) {
	        autoIndex = symbolInstance.verticalPlacedTextSymbolIndex;
	    } else {
	        autoIndex = justifications[performance.getAnchorJustification(placedAnchor)];
	    }
	    var indexes = [
	        symbolInstance.leftJustifiedTextSymbolIndex,
	        symbolInstance.centerJustifiedTextSymbolIndex,
	        symbolInstance.rightJustifiedTextSymbolIndex,
	        symbolInstance.verticalPlacedTextSymbolIndex
	    ];
	    for (var i = 0, list = indexes; i < list.length; i += 1) {
	        var index = list[i];
	        if (index >= 0) {
	            if (autoIndex >= 0 && index !== autoIndex) {
	                bucket.text.placedSymbolArray.get(index).crossTileID = 0;
	            } else {
	                bucket.text.placedSymbolArray.get(index).crossTileID = symbolInstance.crossTileID;
	            }
	        }
	    }
	};
	Placement.prototype.markUsedOrientation = function markUsedOrientation(bucket, orientation, symbolInstance) {
	    var horizontal = orientation === performance.WritingMode.horizontal || orientation === performance.WritingMode.horizontalOnly ? orientation : 0;
	    var vertical = orientation === performance.WritingMode.vertical ? orientation : 0;
	    var horizontalIndexes = [
	        symbolInstance.leftJustifiedTextSymbolIndex,
	        symbolInstance.centerJustifiedTextSymbolIndex,
	        symbolInstance.rightJustifiedTextSymbolIndex
	    ];
	    for (var i = 0, list = horizontalIndexes; i < list.length; i += 1) {
	        var index = list[i];
	        bucket.text.placedSymbolArray.get(index).placedOrientation = horizontal;
	    }
	    if (symbolInstance.verticalPlacedTextSymbolIndex) {
	        bucket.text.placedSymbolArray.get(symbolInstance.verticalPlacedTextSymbolIndex).placedOrientation = vertical;
	    }
	};
	Placement.prototype.commit = function commit(now) {
	    this.commitTime = now;
	    this.zoomAtLastRecencyCheck = this.transform.zoom;
	    var prevPlacement = this.prevPlacement;
	    var placementChanged = false;
	    this.prevZoomAdjustment = prevPlacement ? prevPlacement.zoomAdjustment(this.transform.zoom) : 0;
	    var increment = prevPlacement ? prevPlacement.symbolFadeChange(now) : 1;
	    var prevOpacities = prevPlacement ? prevPlacement.opacities : {};
	    var prevOffsets = prevPlacement ? prevPlacement.variableOffsets : {};
	    var prevOrientations = prevPlacement ? prevPlacement.placedOrientations : {};
	    for (var crossTileID in this.placements) {
	        var jointPlacement = this.placements[crossTileID];
	        var prevOpacity = prevOpacities[crossTileID];
	        if (prevOpacity) {
	            this.opacities[crossTileID] = new JointOpacityState(prevOpacity, increment, jointPlacement.text, jointPlacement.icon);
	            placementChanged = placementChanged || jointPlacement.text !== prevOpacity.text.placed || jointPlacement.icon !== prevOpacity.icon.placed;
	        } else {
	            this.opacities[crossTileID] = new JointOpacityState(null, increment, jointPlacement.text, jointPlacement.icon, jointPlacement.skipFade);
	            placementChanged = placementChanged || jointPlacement.text || jointPlacement.icon;
	        }
	    }
	    for (var crossTileID$1 in prevOpacities) {
	        var prevOpacity$1 = prevOpacities[crossTileID$1];
	        if (!this.opacities[crossTileID$1]) {
	            var jointOpacity = new JointOpacityState(prevOpacity$1, increment, false, false);
	            if (!jointOpacity.isHidden()) {
	                this.opacities[crossTileID$1] = jointOpacity;
	                placementChanged = placementChanged || prevOpacity$1.text.placed || prevOpacity$1.icon.placed;
	            }
	        }
	    }
	    for (var crossTileID$2 in prevOffsets) {
	        if (!this.variableOffsets[crossTileID$2] && this.opacities[crossTileID$2] && !this.opacities[crossTileID$2].isHidden()) {
	            this.variableOffsets[crossTileID$2] = prevOffsets[crossTileID$2];
	        }
	    }
	    for (var crossTileID$3 in prevOrientations) {
	        if (!this.placedOrientations[crossTileID$3] && this.opacities[crossTileID$3] && !this.opacities[crossTileID$3].isHidden()) {
	            this.placedOrientations[crossTileID$3] = prevOrientations[crossTileID$3];
	        }
	    }
	    if (placementChanged) {
	        this.lastPlacementChangeTime = now;
	    } else if (typeof this.lastPlacementChangeTime !== 'number') {
	        this.lastPlacementChangeTime = prevPlacement ? prevPlacement.lastPlacementChangeTime : now;
	    }
	};
	Placement.prototype.updateLayerOpacities = function updateLayerOpacities(styleLayer, tiles) {
	    var seenCrossTileIDs = {};
	    for (var i = 0, list = tiles; i < list.length; i += 1) {
	        var tile = list[i];
	        var symbolBucket = tile.getBucket(styleLayer);
	        if (symbolBucket && tile.latestFeatureIndex && styleLayer.id === symbolBucket.layerIds[0]) {
	            this.updateBucketOpacities(symbolBucket, seenCrossTileIDs, tile.collisionBoxArray);
	        }
	    }
	};
	Placement.prototype.updateBucketOpacities = function updateBucketOpacities(bucket, seenCrossTileIDs, collisionBoxArray) {
	    var this$1 = this;
	    if (bucket.hasTextData()) {
	        bucket.text.opacityVertexArray.clear();
	    }
	    if (bucket.hasIconData()) {
	        bucket.icon.opacityVertexArray.clear();
	    }
	    if (bucket.hasIconCollisionBoxData()) {
	        bucket.iconCollisionBox.collisionVertexArray.clear();
	    }
	    if (bucket.hasTextCollisionBoxData()) {
	        bucket.textCollisionBox.collisionVertexArray.clear();
	    }
	    var layout = bucket.layers[0].layout;
	    var duplicateOpacityState = new JointOpacityState(null, 0, false, false, true);
	    var textAllowOverlap = layout.get('text-allow-overlap');
	    var iconAllowOverlap = layout.get('icon-allow-overlap');
	    var variablePlacement = layout.get('text-variable-anchor');
	    var rotateWithMap = layout.get('text-rotation-alignment') === 'map';
	    var pitchWithMap = layout.get('text-pitch-alignment') === 'map';
	    var hasIconTextFit = layout.get('icon-text-fit') !== 'none';
	    var defaultOpacityState = new JointOpacityState(null, 0, textAllowOverlap && (iconAllowOverlap || !bucket.hasIconData() || layout.get('icon-optional')), iconAllowOverlap && (textAllowOverlap || !bucket.hasTextData() || layout.get('text-optional')), true);
	    if (!bucket.collisionArrays && collisionBoxArray && (bucket.hasIconCollisionBoxData() || bucket.hasTextCollisionBoxData())) {
	        bucket.deserializeCollisionBoxes(collisionBoxArray);
	    }
	    var addOpacities = function (iconOrText, numVertices, opacity) {
	        for (var i = 0; i < numVertices / 4; i++) {
	            iconOrText.opacityVertexArray.emplaceBack(opacity);
	        }
	    };
	    var loop = function (s) {
	        var symbolInstance = bucket.symbolInstances.get(s);
	        var numHorizontalGlyphVertices = symbolInstance.numHorizontalGlyphVertices;
	        var numVerticalGlyphVertices = symbolInstance.numVerticalGlyphVertices;
	        var crossTileID = symbolInstance.crossTileID;
	        var isDuplicate = seenCrossTileIDs[crossTileID];
	        var opacityState = this$1.opacities[crossTileID];
	        if (isDuplicate) {
	            opacityState = duplicateOpacityState;
	        } else if (!opacityState) {
	            opacityState = defaultOpacityState;
	            this$1.opacities[crossTileID] = opacityState;
	        }
	        seenCrossTileIDs[crossTileID] = true;
	        var hasText = numHorizontalGlyphVertices > 0 || numVerticalGlyphVertices > 0;
	        var hasIcon = symbolInstance.numIconVertices > 0;
	        var placedOrientation = this$1.placedOrientations[symbolInstance.crossTileID];
	        var horizontalHidden = placedOrientation === performance.WritingMode.vertical;
	        var verticalHidden = placedOrientation === performance.WritingMode.horizontal || placedOrientation === performance.WritingMode.horizontalOnly;
	        if (hasText) {
	            var packedOpacity = packOpacity(opacityState.text);
	            var horizontalOpacity = horizontalHidden ? PACKED_HIDDEN_OPACITY : packedOpacity;
	            addOpacities(bucket.text, numHorizontalGlyphVertices, horizontalOpacity);
	            var verticalOpacity = verticalHidden ? PACKED_HIDDEN_OPACITY : packedOpacity;
	            addOpacities(bucket.text, numVerticalGlyphVertices, verticalOpacity);
	            var symbolHidden = opacityState.text.isHidden();
	            [
	                symbolInstance.rightJustifiedTextSymbolIndex,
	                symbolInstance.centerJustifiedTextSymbolIndex,
	                symbolInstance.leftJustifiedTextSymbolIndex
	            ].forEach(function (index) {
	                if (index >= 0) {
	                    bucket.text.placedSymbolArray.get(index).hidden = symbolHidden || horizontalHidden ? 1 : 0;
	                }
	            });
	            if (symbolInstance.verticalPlacedTextSymbolIndex >= 0) {
	                bucket.text.placedSymbolArray.get(symbolInstance.verticalPlacedTextSymbolIndex).hidden = symbolHidden || verticalHidden ? 1 : 0;
	            }
	            var prevOffset = this$1.variableOffsets[symbolInstance.crossTileID];
	            if (prevOffset) {
	                this$1.markUsedJustification(bucket, prevOffset.anchor, symbolInstance, placedOrientation);
	            }
	            var prevOrientation = this$1.placedOrientations[symbolInstance.crossTileID];
	            if (prevOrientation) {
	                this$1.markUsedJustification(bucket, 'left', symbolInstance, prevOrientation);
	                this$1.markUsedOrientation(bucket, prevOrientation, symbolInstance);
	            }
	        }
	        if (hasIcon) {
	            var packedOpacity$1 = packOpacity(opacityState.icon);
	            var useHorizontal = !(hasIconTextFit && symbolInstance.verticalPlacedIconSymbolIndex && horizontalHidden);
	            if (symbolInstance.placedIconSymbolIndex >= 0) {
	                var horizontalOpacity$1 = useHorizontal ? packedOpacity$1 : PACKED_HIDDEN_OPACITY;
	                addOpacities(bucket.icon, symbolInstance.numIconVertices, horizontalOpacity$1);
	                bucket.icon.placedSymbolArray.get(symbolInstance.placedIconSymbolIndex).hidden = opacityState.icon.isHidden();
	            }
	            if (symbolInstance.verticalPlacedIconSymbolIndex >= 0) {
	                var verticalOpacity$1 = !useHorizontal ? packedOpacity$1 : PACKED_HIDDEN_OPACITY;
	                addOpacities(bucket.icon, symbolInstance.numVerticalIconVertices, verticalOpacity$1);
	                bucket.icon.placedSymbolArray.get(symbolInstance.verticalPlacedIconSymbolIndex).hidden = opacityState.icon.isHidden();
	            }
	        }
	        if (bucket.hasIconCollisionBoxData() || bucket.hasTextCollisionBoxData()) {
	            var collisionArrays = bucket.collisionArrays[s];
	            if (collisionArrays) {
	                var shift = new performance.Point(0, 0);
	                if (collisionArrays.textBox || collisionArrays.verticalTextBox) {
	                    var used = true;
	                    if (variablePlacement) {
	                        var variableOffset = this$1.variableOffsets[crossTileID];
	                        if (variableOffset) {
	                            shift = calculateVariableLayoutShift(variableOffset.anchor, variableOffset.width, variableOffset.height, variableOffset.textOffset, variableOffset.textBoxScale);
	                            if (rotateWithMap) {
	                                shift._rotate(pitchWithMap ? this$1.transform.angle : -this$1.transform.angle);
	                            }
	                        } else {
	                            used = false;
	                        }
	                    }
	                    if (collisionArrays.textBox) {
	                        updateCollisionVertices(bucket.textCollisionBox.collisionVertexArray, opacityState.text.placed, !used || horizontalHidden, shift.x, shift.y);
	                    }
	                    if (collisionArrays.verticalTextBox) {
	                        updateCollisionVertices(bucket.textCollisionBox.collisionVertexArray, opacityState.text.placed, !used || verticalHidden, shift.x, shift.y);
	                    }
	                }
	                var verticalIconUsed = Boolean(!verticalHidden && collisionArrays.verticalIconBox);
	                if (collisionArrays.iconBox) {
	                    updateCollisionVertices(bucket.iconCollisionBox.collisionVertexArray, opacityState.icon.placed, verticalIconUsed, hasIconTextFit ? shift.x : 0, hasIconTextFit ? shift.y : 0);
	                }
	                if (collisionArrays.verticalIconBox) {
	                    updateCollisionVertices(bucket.iconCollisionBox.collisionVertexArray, opacityState.icon.placed, !verticalIconUsed, hasIconTextFit ? shift.x : 0, hasIconTextFit ? shift.y : 0);
	                }
	            }
	        }
	    };
	    for (var s = 0; s < bucket.symbolInstances.length; s++)
	        loop(s);
	    bucket.sortFeatures(this.transform.angle);
	    if (this.retainedQueryData[bucket.bucketInstanceId]) {
	        this.retainedQueryData[bucket.bucketInstanceId].featureSortOrder = bucket.featureSortOrder;
	    }
	    if (bucket.hasTextData() && bucket.text.opacityVertexBuffer) {
	        bucket.text.opacityVertexBuffer.updateData(bucket.text.opacityVertexArray);
	    }
	    if (bucket.hasIconData() && bucket.icon.opacityVertexBuffer) {
	        bucket.icon.opacityVertexBuffer.updateData(bucket.icon.opacityVertexArray);
	    }
	    if (bucket.hasIconCollisionBoxData() && bucket.iconCollisionBox.collisionVertexBuffer) {
	        bucket.iconCollisionBox.collisionVertexBuffer.updateData(bucket.iconCollisionBox.collisionVertexArray);
	    }
	    if (bucket.hasTextCollisionBoxData() && bucket.textCollisionBox.collisionVertexBuffer) {
	        bucket.textCollisionBox.collisionVertexBuffer.updateData(bucket.textCollisionBox.collisionVertexArray);
	    }
	    if (bucket.bucketInstanceId in this.collisionCircleArrays) {
	        var instance = this.collisionCircleArrays[bucket.bucketInstanceId];
	        bucket.placementInvProjMatrix = instance.invProjMatrix;
	        bucket.placementViewportMatrix = instance.viewportMatrix;
	        bucket.collisionCircleArray = instance.circles;
	        delete this.collisionCircleArrays[bucket.bucketInstanceId];
	    }
	};
	Placement.prototype.symbolFadeChange = function symbolFadeChange(now) {
	    return this.fadeDuration === 0 ? 1 : (now - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
	};
	Placement.prototype.zoomAdjustment = function zoomAdjustment(zoom) {
	    return Math.max(0, (this.transform.zoom - zoom) / 1.5);
	};
	Placement.prototype.hasTransitions = function hasTransitions(now) {
	    return this.stale || now - this.lastPlacementChangeTime < this.fadeDuration;
	};
	Placement.prototype.stillRecent = function stillRecent(now, zoom) {
	    var durationAdjustment = this.zoomAtLastRecencyCheck === zoom ? 1 - this.zoomAdjustment(zoom) : 1;
	    this.zoomAtLastRecencyCheck = zoom;
	    return this.commitTime + this.fadeDuration * durationAdjustment > now;
	};
	Placement.prototype.setStale = function setStale() {
	    this.stale = true;
	};
	function updateCollisionVertices(collisionVertexArray, placed, notUsed, shiftX, shiftY) {
	    collisionVertexArray.emplaceBack(placed ? 1 : 0, notUsed ? 1 : 0, shiftX || 0, shiftY || 0);
	    collisionVertexArray.emplaceBack(placed ? 1 : 0, notUsed ? 1 : 0, shiftX || 0, shiftY || 0);
	    collisionVertexArray.emplaceBack(placed ? 1 : 0, notUsed ? 1 : 0, shiftX || 0, shiftY || 0);
	    collisionVertexArray.emplaceBack(placed ? 1 : 0, notUsed ? 1 : 0, shiftX || 0, shiftY || 0);
	}
	var shift25 = Math.pow(2, 25);
	var shift24 = Math.pow(2, 24);
	var shift17 = Math.pow(2, 17);
	var shift16 = Math.pow(2, 16);
	var shift9 = Math.pow(2, 9);
	var shift8 = Math.pow(2, 8);
	var shift1 = Math.pow(2, 1);
	function packOpacity(opacityState) {
	    if (opacityState.opacity === 0 && !opacityState.placed) {
	        return 0;
	    } else if (opacityState.opacity === 1 && opacityState.placed) {
	        return 4294967295;
	    }
	    var targetBit = opacityState.placed ? 1 : 0;
	    var opacityBits = Math.floor(opacityState.opacity * 127);
	    return opacityBits * shift25 + targetBit * shift24 + opacityBits * shift17 + targetBit * shift16 + opacityBits * shift9 + targetBit * shift8 + opacityBits * shift1 + targetBit;
	}
	var PACKED_HIDDEN_OPACITY = 0;

	var LayerPlacement = function LayerPlacement(styleLayer) {
	    this._sortAcrossTiles = styleLayer.layout.get('symbol-z-order') !== 'viewport-y' && styleLayer.layout.get('symbol-sort-key').constantOr(1) !== undefined;
	    this._currentTileIndex = 0;
	    this._currentPartIndex = 0;
	    this._seenCrossTileIDs = {};
	    this._bucketParts = [];
	};
	LayerPlacement.prototype.continuePlacement = function continuePlacement(tiles, placement, showCollisionBoxes, styleLayer, shouldPausePlacement) {
	    var bucketParts = this._bucketParts;
	    while (this._currentTileIndex < tiles.length) {
	        var tile = tiles[this._currentTileIndex];
	        placement.getBucketParts(bucketParts, styleLayer, tile, this._sortAcrossTiles);
	        this._currentTileIndex++;
	        if (shouldPausePlacement()) {
	            return true;
	        }
	    }
	    if (this._sortAcrossTiles) {
	        this._sortAcrossTiles = false;
	        bucketParts.sort(function (a, b) {
	            return a.sortKey - b.sortKey;
	        });
	    }
	    while (this._currentPartIndex < bucketParts.length) {
	        var bucketPart = bucketParts[this._currentPartIndex];
	        placement.placeLayerBucketPart(bucketPart, this._seenCrossTileIDs, showCollisionBoxes);
	        this._currentPartIndex++;
	        if (shouldPausePlacement()) {
	            return true;
	        }
	    }
	    return false;
	};
	var PauseablePlacement = function PauseablePlacement(transform, order, forceFullPlacement, showCollisionBoxes, fadeDuration, crossSourceCollisions, prevPlacement) {
	    this.placement = new Placement(transform, fadeDuration, crossSourceCollisions, prevPlacement);
	    this._currentPlacementIndex = order.length - 1;
	    this._forceFullPlacement = forceFullPlacement;
	    this._showCollisionBoxes = showCollisionBoxes;
	    this._done = false;
	};
	PauseablePlacement.prototype.isDone = function isDone() {
	    return this._done;
	};
	PauseablePlacement.prototype.continuePlacement = function continuePlacement(order, layers, layerTiles) {
	    var this$1 = this;
	    var startTime = performance.browser.now();
	    var shouldPausePlacement = function () {
	        var elapsedTime = performance.browser.now() - startTime;
	        return this$1._forceFullPlacement ? false : elapsedTime > 2;
	    };
	    while (this._currentPlacementIndex >= 0) {
	        var layerId = order[this._currentPlacementIndex];
	        var layer = layers[layerId];
	        var placementZoom = this.placement.collisionIndex.transform.zoom;
	        if (layer.type === 'symbol' && (!layer.minzoom || layer.minzoom <= placementZoom) && (!layer.maxzoom || layer.maxzoom > placementZoom)) {
	            if (!this._inProgressLayer) {
	                this._inProgressLayer = new LayerPlacement(layer);
	            }
	            var pausePlacement = this._inProgressLayer.continuePlacement(layerTiles[layer.source], this.placement, this._showCollisionBoxes, layer, shouldPausePlacement);
	            if (pausePlacement) {
	                return;
	            }
	            delete this._inProgressLayer;
	        }
	        this._currentPlacementIndex--;
	    }
	    this._done = true;
	};
	PauseablePlacement.prototype.commit = function commit(now) {
	    this.placement.commit(now);
	    return this.placement;
	};

	var roundingFactor = 512 / performance.EXTENT / 2;
	var TileLayerIndex = function TileLayerIndex(tileID, symbolInstances, bucketInstanceId) {
	    this.tileID = tileID;
	    this.indexedSymbolInstances = {};
	    this.bucketInstanceId = bucketInstanceId;
	    for (var i = 0; i < symbolInstances.length; i++) {
	        var symbolInstance = symbolInstances.get(i);
	        var key = symbolInstance.key;
	        if (!this.indexedSymbolInstances[key]) {
	            this.indexedSymbolInstances[key] = [];
	        }
	        this.indexedSymbolInstances[key].push({
	            crossTileID: symbolInstance.crossTileID,
	            coord: this.getScaledCoordinates(symbolInstance, tileID)
	        });
	    }
	};
	TileLayerIndex.prototype.getScaledCoordinates = function getScaledCoordinates(symbolInstance, childTileID) {
	    var zDifference = childTileID.canonical.z - this.tileID.canonical.z;
	    var scale = roundingFactor / Math.pow(2, zDifference);
	    return {
	        x: Math.floor((childTileID.canonical.x * performance.EXTENT + symbolInstance.anchorX) * scale),
	        y: Math.floor((childTileID.canonical.y * performance.EXTENT + symbolInstance.anchorY) * scale)
	    };
	};
	TileLayerIndex.prototype.findMatches = function findMatches(symbolInstances, newTileID, zoomCrossTileIDs) {
	    var tolerance = this.tileID.canonical.z < newTileID.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - newTileID.canonical.z);
	    for (var i = 0; i < symbolInstances.length; i++) {
	        var symbolInstance = symbolInstances.get(i);
	        if (symbolInstance.crossTileID) {
	            continue;
	        }
	        var indexedInstances = this.indexedSymbolInstances[symbolInstance.key];
	        if (!indexedInstances) {
	            continue;
	        }
	        var scaledSymbolCoord = this.getScaledCoordinates(symbolInstance, newTileID);
	        for (var i$1 = 0, list = indexedInstances; i$1 < list.length; i$1 += 1) {
	            var thisTileSymbol = list[i$1];
	            if (Math.abs(thisTileSymbol.coord.x - scaledSymbolCoord.x) <= tolerance && Math.abs(thisTileSymbol.coord.y - scaledSymbolCoord.y) <= tolerance && !zoomCrossTileIDs[thisTileSymbol.crossTileID]) {
	                zoomCrossTileIDs[thisTileSymbol.crossTileID] = true;
	                symbolInstance.crossTileID = thisTileSymbol.crossTileID;
	                break;
	            }
	        }
	    }
	};
	var CrossTileIDs = function CrossTileIDs() {
	    this.maxCrossTileID = 0;
	};
	CrossTileIDs.prototype.generate = function generate() {
	    return ++this.maxCrossTileID;
	};
	var CrossTileSymbolLayerIndex = function CrossTileSymbolLayerIndex() {
	    this.indexes = {};
	    this.usedCrossTileIDs = {};
	    this.lng = 0;
	};
	CrossTileSymbolLayerIndex.prototype.handleWrapJump = function handleWrapJump(lng) {
	    var wrapDelta = Math.round((lng - this.lng) / 360);
	    if (wrapDelta !== 0) {
	        for (var zoom in this.indexes) {
	            var zoomIndexes = this.indexes[zoom];
	            var newZoomIndex = {};
	            for (var key in zoomIndexes) {
	                var index = zoomIndexes[key];
	                index.tileID = index.tileID.unwrapTo(index.tileID.wrap + wrapDelta);
	                newZoomIndex[index.tileID.key] = index;
	            }
	            this.indexes[zoom] = newZoomIndex;
	        }
	    }
	    this.lng = lng;
	};
	CrossTileSymbolLayerIndex.prototype.addBucket = function addBucket(tileID, bucket, crossTileIDs) {
	    if (this.indexes[tileID.overscaledZ] && this.indexes[tileID.overscaledZ][tileID.key]) {
	        if (this.indexes[tileID.overscaledZ][tileID.key].bucketInstanceId === bucket.bucketInstanceId) {
	            return false;
	        } else {
	            this.removeBucketCrossTileIDs(tileID.overscaledZ, this.indexes[tileID.overscaledZ][tileID.key]);
	        }
	    }
	    for (var i = 0; i < bucket.symbolInstances.length; i++) {
	        var symbolInstance = bucket.symbolInstances.get(i);
	        symbolInstance.crossTileID = 0;
	    }
	    if (!this.usedCrossTileIDs[tileID.overscaledZ]) {
	        this.usedCrossTileIDs[tileID.overscaledZ] = {};
	    }
	    var zoomCrossTileIDs = this.usedCrossTileIDs[tileID.overscaledZ];
	    for (var zoom in this.indexes) {
	        var zoomIndexes = this.indexes[zoom];
	        if (Number(zoom) > tileID.overscaledZ) {
	            for (var id in zoomIndexes) {
	                var childIndex = zoomIndexes[id];
	                if (childIndex.tileID.isChildOf(tileID)) {
	                    childIndex.findMatches(bucket.symbolInstances, tileID, zoomCrossTileIDs);
	                }
	            }
	        } else {
	            var parentCoord = tileID.scaledTo(Number(zoom));
	            var parentIndex = zoomIndexes[parentCoord.key];
	            if (parentIndex) {
	                parentIndex.findMatches(bucket.symbolInstances, tileID, zoomCrossTileIDs);
	            }
	        }
	    }
	    for (var i$1 = 0; i$1 < bucket.symbolInstances.length; i$1++) {
	        var symbolInstance$1 = bucket.symbolInstances.get(i$1);
	        if (!symbolInstance$1.crossTileID) {
	            symbolInstance$1.crossTileID = crossTileIDs.generate();
	            zoomCrossTileIDs[symbolInstance$1.crossTileID] = true;
	        }
	    }
	    if (this.indexes[tileID.overscaledZ] === undefined) {
	        this.indexes[tileID.overscaledZ] = {};
	    }
	    this.indexes[tileID.overscaledZ][tileID.key] = new TileLayerIndex(tileID, bucket.symbolInstances, bucket.bucketInstanceId);
	    return true;
	};
	CrossTileSymbolLayerIndex.prototype.removeBucketCrossTileIDs = function removeBucketCrossTileIDs(zoom, removedBucket) {
	    for (var key in removedBucket.indexedSymbolInstances) {
	        for (var i = 0, list = removedBucket.indexedSymbolInstances[key]; i < list.length; i += 1) {
	            var symbolInstance = list[i];
	            delete this.usedCrossTileIDs[zoom][symbolInstance.crossTileID];
	        }
	    }
	};
	CrossTileSymbolLayerIndex.prototype.removeStaleBuckets = function removeStaleBuckets(currentIDs) {
	    var tilesChanged = false;
	    for (var z in this.indexes) {
	        var zoomIndexes = this.indexes[z];
	        for (var tileKey in zoomIndexes) {
	            if (!currentIDs[zoomIndexes[tileKey].bucketInstanceId]) {
	                this.removeBucketCrossTileIDs(z, zoomIndexes[tileKey]);
	                delete zoomIndexes[tileKey];
	                tilesChanged = true;
	            }
	        }
	    }
	    return tilesChanged;
	};
	var CrossTileSymbolIndex = function CrossTileSymbolIndex() {
	    this.layerIndexes = {};
	    this.crossTileIDs = new CrossTileIDs();
	    this.maxBucketInstanceId = 0;
	    this.bucketsInCurrentPlacement = {};
	};
	CrossTileSymbolIndex.prototype.addLayer = function addLayer(styleLayer, tiles, lng) {
	    var layerIndex = this.layerIndexes[styleLayer.id];
	    if (layerIndex === undefined) {
	        layerIndex = this.layerIndexes[styleLayer.id] = new CrossTileSymbolLayerIndex();
	    }
	    var symbolBucketsChanged = false;
	    var currentBucketIDs = {};
	    layerIndex.handleWrapJump(lng);
	    for (var i = 0, list = tiles; i < list.length; i += 1) {
	        var tile = list[i];
	        var symbolBucket = tile.getBucket(styleLayer);
	        if (!symbolBucket || styleLayer.id !== symbolBucket.layerIds[0]) {
	            continue;
	        }
	        if (!symbolBucket.bucketInstanceId) {
	            symbolBucket.bucketInstanceId = ++this.maxBucketInstanceId;
	        }
	        if (layerIndex.addBucket(tile.tileID, symbolBucket, this.crossTileIDs)) {
	            symbolBucketsChanged = true;
	        }
	        currentBucketIDs[symbolBucket.bucketInstanceId] = true;
	    }
	    if (layerIndex.removeStaleBuckets(currentBucketIDs)) {
	        symbolBucketsChanged = true;
	    }
	    return symbolBucketsChanged;
	};
	CrossTileSymbolIndex.prototype.pruneUnusedLayers = function pruneUnusedLayers(usedLayers) {
	    var usedLayerMap = {};
	    usedLayers.forEach(function (usedLayer) {
	        usedLayerMap[usedLayer] = true;
	    });
	    for (var layerId in this.layerIndexes) {
	        if (!usedLayerMap[layerId]) {
	            delete this.layerIndexes[layerId];
	        }
	    }
	};

	var emitValidationErrors = function (evented, errors) {
	    return performance.emitValidationErrors(evented, errors && errors.filter(function (error) {
	        return error.identifier !== 'source.canvas';
	    }));
	};
	var supportedDiffOperations = performance.pick(operations, [
	    'moveLayer',
	    'addLayer',
	    'removeLayer',
	    'setPaintProperty',
	    'setLayoutProperty',
	    'setFilter',
	    'addSource',
	    'removeSource',
	    'setLayerZoomRange',
	    'setLight',
	    'setTransition',
	    'setGeoJSONSourceData'
	]);
	var ignoredDiffOperations = performance.pick(operations, [
	    'setCenter',
	    'setZoom',
	    'setBearing',
	    'setPitch'
	]);
	var empty = emptyStyle();
	var Style = function (Evented) {
	    function Style(map, options) {
	        var this$1 = this;
	        if (options === void 0)
	            options = {};
	        Evented.call(this);
	        this.map = map;
	        this.dispatcher = new Dispatcher(getGlobalWorkerPool(), this);
	        this.imageManager = new ImageManager();
	        this.imageManager.setEventedParent(this);
	        this.glyphManager = new GlyphManager(map._requestManager, options.localIdeographFontFamily);
	        this.lineAtlas = new LineAtlas(256, 512);
	        this.crossTileSymbolIndex = new CrossTileSymbolIndex();
	        this._layers = {};
	        this._serializedLayers = {};
	        this._order = [];
	        this.sourceCaches = {};
	        this.zoomHistory = new performance.ZoomHistory();
	        this._loaded = false;
	        this._availableImages = [];
	        this._resetUpdates();
	        this.dispatcher.broadcast('setReferrer', performance.getReferrer());
	        var self = this;
	        this._rtlTextPluginCallback = Style.registerForPluginStateChange(function (event) {
	            var state = {
	                pluginStatus: event.pluginStatus,
	                pluginURL: event.pluginURL
	            };
	            self.dispatcher.broadcast('syncRTLPluginState', state, function (err, results) {
	                performance.triggerPluginCompletionEvent(err);
	                if (results) {
	                    var allComplete = results.every(function (elem) {
	                        return elem;
	                    });
	                    if (allComplete) {
	                        for (var id in self.sourceCaches) {
	                            self.sourceCaches[id].reload();
	                        }
	                    }
	                }
	            });
	        });
	        this.on('data', function (event) {
	            if (event.dataType !== 'source' || event.sourceDataType !== 'metadata') {
	                return;
	            }
	            var sourceCache = this$1.sourceCaches[event.sourceId];
	            if (!sourceCache) {
	                return;
	            }
	            var source = sourceCache.getSource();
	            if (!source || !source.vectorLayerIds) {
	                return;
	            }
	            for (var layerId in this$1._layers) {
	                var layer = this$1._layers[layerId];
	                if (layer.source === source.id) {
	                    this$1._validateLayer(layer);
	                }
	            }
	        });
	    }
	    if (Evented)
	        Style.__proto__ = Evented;
	    Style.prototype = Object.create(Evented && Evented.prototype);
	    Style.prototype.constructor = Style;
	    Style.prototype.loadURL = function loadURL(url, options) {
	        var this$1 = this;
	        if (options === void 0)
	            options = {};
	        this.fire(new performance.Event('dataloading', { dataType: 'style' }));
	        options.validate = typeof options.validate === 'boolean' ? options.validate : !performance.isMapboxURL(url);
	        url = this.map._requestManager.normalizeStyleURL(url, options.accessToken);
	        var request = this.map._requestManager.transformRequest(url, performance.ResourceType.Style);
	        this._request = performance.getJSON(request, function (error, json) {
	            this$1._request = null;
	            if (error) {
	                this$1.fire(new performance.ErrorEvent(error));
	            } else if (json) {
	                this$1._load(json, options);
	            }
	        });
	    };
	    Style.prototype.loadJSON = function loadJSON(json, options) {
	        var this$1 = this;
	        if (options === void 0)
	            options = {};
	        this.fire(new performance.Event('dataloading', { dataType: 'style' }));
	        this._request = performance.browser.frame(function () {
	            this$1._request = null;
	            options.validate = options.validate !== false;
	            this$1._load(json, options);
	        });
	    };
	    Style.prototype.loadEmpty = function loadEmpty() {
	        this.fire(new performance.Event('dataloading', { dataType: 'style' }));
	        this._load(empty, { validate: false });
	    };
	    Style.prototype._load = function _load(json, options) {
	        var this$1 = this;
	        if (options.validate && emitValidationErrors(this, performance.validateStyle(json))) {
	            return;
	        }
	        var patchOperations = [];
	        if (options.stylePatch) {
	            patchOperations = this._buildStylePatch(json, options);
	            this.sourceCaches = {};
	        }
	        this._loaded = true;
	        this.stylesheet = json;
	        for (var id in json.sources) {
	            this.addSource(id, json.sources[id], { validate: false });
	        }
	        if (json.sprite) {
	            this._loadSprite(json.sprite);
	        } else {
	            this.imageManager.setLoaded(true);
	        }
	        this.glyphManager.setURL(json.glyphs);
	        var layers = derefLayers(this.stylesheet.layers);
	        this._order = layers.map(function (layer) {
	            return layer.id;
	        });
	        this._layers = {};
	        this._serializedLayers = {};
	        for (var i = 0, list = layers; i < list.length; i += 1) {
	            var layer = list[i];
	            layer = performance.createStyleLayer(layer);
	            layer.setEventedParent(this, { layer: { id: layer.id } });
	            this._layers[layer.id] = layer;
	            this._serializedLayers[layer.id] = layer.serialize();
	        }
	        this.dispatcher.broadcast('setLayers', this._serializeLayers(this._order));
	        this.light = new Light(this.stylesheet.light);
	        patchOperations.filter(function (op) {
	            return op.command !== operations.moveLayer;
	        }).forEach(function (op) {
	            this$1[op.command].apply(this$1, op.args);
	        });
	        this.fire(new performance.Event('data', { dataType: 'style' }));
	        this.fire(new performance.Event('style.load'));
	    };
	    Style.prototype._loadSprite = function _loadSprite(url) {
	        var this$1 = this;
	        this._spriteRequest = loadSprite(url, this.map._requestManager, function (err, images) {
	            this$1._spriteRequest = null;
	            if (err) {
	                this$1.fire(new performance.ErrorEvent(err));
	            } else if (images) {
	                for (var id in images) {
	                    this$1.imageManager.addImage(id, images[id]);
	                }
	            }
	            this$1.imageManager.setLoaded(true);
	            this$1._availableImages = this$1.imageManager.listImages();
	            this$1.dispatcher.broadcast('setImages', this$1._availableImages);
	            this$1.fire(new performance.Event('data', { dataType: 'style' }));
	        });
	    };
	    Style.prototype._validateLayer = function _validateLayer(layer) {
	        var sourceCache = this.sourceCaches[layer.source];
	        if (!sourceCache) {
	            return;
	        }
	        var sourceLayer = layer.sourceLayer;
	        if (!sourceLayer) {
	            return;
	        }
	        var source = sourceCache.getSource();
	        if (source.type === 'geojson' || source.vectorLayerIds && source.vectorLayerIds.indexOf(sourceLayer) === -1) {
	            this.fire(new performance.ErrorEvent(new Error('Source layer "' + sourceLayer + '" ' + 'does not exist on source "' + source.id + '" ' + 'as specified by style layer "' + layer.id + '"')));
	        }
	    };
	    Style.prototype.loaded = function loaded() {
	        if (!this._loaded) {
	            return false;
	        }
	        if (Object.keys(this._updatedSources).length) {
	            return false;
	        }
	        for (var id in this.sourceCaches) {
	            if (!this.sourceCaches[id].loaded()) {
	                return false;
	            }
	        }
	        if (!this.imageManager.isLoaded()) {
	            return false;
	        }
	        return true;
	    };
	    Style.prototype._serializeLayers = function _serializeLayers(ids) {
	        var serializedLayers = [];
	        for (var i = 0, list = ids; i < list.length; i += 1) {
	            var id = list[i];
	            var layer = this._layers[id];
	            if (layer.type !== 'custom') {
	                serializedLayers.push(layer.serialize());
	            }
	        }
	        return serializedLayers;
	    };
	    Style.prototype.hasTransitions = function hasTransitions() {
	        if (this.light && this.light.hasTransition()) {
	            return true;
	        }
	        for (var id in this.sourceCaches) {
	            if (this.sourceCaches[id].hasTransition()) {
	                return true;
	            }
	        }
	        for (var id$1 in this._layers) {
	            if (this._layers[id$1].hasTransition()) {
	                return true;
	            }
	        }
	        return false;
	    };
	    Style.prototype._checkLoaded = function _checkLoaded() {
	        if (!this._loaded) {
	            throw new Error('Style is not done loading');
	        }
	    };
	    Style.prototype.update = function update(parameters) {
	        if (!this.loaded) {
	            return;
	        }
	        var changed = this._changed;
	        if (this._changed) {
	            var updatedIds = Object.keys(this._updatedLayers);
	            var removedIds = Object.keys(this._removedLayers);
	            if (updatedIds.length || removedIds.length) {
	                this._updateWorkerLayers(updatedIds, removedIds);
	            }
	            for (var id in this._updatedSources) {
	                var action = this._updatedSources[id];
	                if (action === 'reload') {
	                    this._reloadSource(id);
	                } else if (action === 'clear') {
	                    this._clearSource(id);
	                }
	            }
	            this._updateTilesForChangedImages();
	            for (var id$1 in this._updatedPaintProps) {
	                this._layers[id$1].updateTransitions(parameters);
	                this._serializedLayers[id$1] = this._layers[id$1].serialize();
	            }
	            this.light.updateTransitions(parameters);
	            this._resetUpdates();
	        }
	        var sourcesUsedBefore = {};
	        for (var sourceId in this.sourceCaches) {
	            var sourceCache = this.sourceCaches[sourceId];
	            sourcesUsedBefore[sourceId] = sourceCache.used;
	            sourceCache.used = false;
	        }
	        for (var i = 0, list = this._order; i < list.length; i += 1) {
	            var layerId = list[i];
	            var layer = this._layers[layerId];
	            layer.recalculate(parameters, this._availableImages);
	            if (!layer.isHidden(parameters.zoom) && layer.source) {
	                this.sourceCaches[layer.source].used = true;
	            }
	        }
	        for (var sourceId$1 in sourcesUsedBefore) {
	            var sourceCache$1 = this.sourceCaches[sourceId$1];
	            if (sourcesUsedBefore[sourceId$1] !== sourceCache$1.used) {
	                sourceCache$1.fire(new performance.Event('data', {
	                    sourceDataType: 'visibility',
	                    dataType: 'source',
	                    sourceId: sourceId$1
	                }));
	            }
	        }
	        this.light.recalculate(parameters);
	        this.z = parameters.zoom;
	        if (changed) {
	            this.fire(new performance.Event('data', { dataType: 'style' }));
	        }
	    };
	    Style.prototype._updateTilesForChangedImages = function _updateTilesForChangedImages() {
	        var changedImages = Object.keys(this._changedImages);
	        if (changedImages.length) {
	            for (var name in this.sourceCaches) {
	                this.sourceCaches[name].reloadTilesForDependencies([
	                    'icons',
	                    'patterns'
	                ], changedImages);
	            }
	            this._changedImages = {};
	        }
	    };
	    Style.prototype._updateWorkerLayers = function _updateWorkerLayers(updatedIds, removedIds) {
	        this.dispatcher.broadcast('updateLayers', {
	            layers: this._serializeLayers(updatedIds),
	            removedIds: removedIds
	        });
	    };
	    Style.prototype._resetUpdates = function _resetUpdates() {
	        this._changed = false;
	        this._updatedLayers = {};
	        this._removedLayers = {};
	        this._updatedSources = {};
	        this._updatedPaintProps = {};
	        this._changedImages = {};
	    };
	    Style.prototype.setState = function setState(nextState, options) {
	        var this$1 = this;
	        if (options === void 0)
	            options = {};
	        this._checkLoaded();
	        if (emitValidationErrors(this, performance.validateStyle(nextState))) {
	            return false;
	        }
	        nextState = performance.clone$1(nextState);
	        nextState.layers = derefLayers(nextState.layers);
	        var patchOperations = [];
	        var preservedLayers = {};
	        var preservedSources = {};
	        if (options.stylePatch) {
	            patchOperations = this._buildStylePatch(nextState, options);
	        }
	        patchOperations = patchOperations.filter(function (op) {
	            if (op.command === operations.addLayer && this$1._serializedLayers.hasOwnProperty(op.args[0].id)) {
	                preservedLayers[op.args[0].id] = true;
	                return false;
	            }
	            if (op.command === operations.moveLayer && this$1._serializedLayers.hasOwnProperty(op.args[0])) {
	                preservedLayers[op.args[0]] = true;
	                return true;
	            }
	            if (op.command === operations.addSource && this$1.sourceCaches.hasOwnProperty(op.args[0])) {
	                preservedSources[op.args[0]] = true;
	                return false;
	            }
	            return true;
	        });
	        var changes = diffStyles(this.serialize(), nextState).filter(function (op) {
	            return !(op.command in ignoredDiffOperations);
	        });
	        changes = changes.concat(patchOperations);
	        if (changes.length === 0) {
	            return false;
	        }
	        var unimplementedOps = changes.filter(function (op) {
	            return !(op.command in supportedDiffOperations);
	        });
	        if (unimplementedOps.length > 0) {
	            throw new Error('Unimplemented: ' + unimplementedOps.map(function (op) {
	                return op.command;
	            }).join(', ') + '.');
	        }
	        changes.forEach(function (op) {
	            if (op.command === 'setTransition') {
	                return;
	            }
	            if (op.command === operations.removeLayer && preservedLayers.hasOwnProperty(op.args[0])) {
	                return;
	            }
	            if ((op.command === operations.addSource || op.command === operations.removeSource) && preservedSources.hasOwnProperty(op.args[0])) {
	                return;
	            }
	            this$1[op.command].apply(this$1, op.args);
	        });
	        this.stylesheet = nextState;
	        return true;
	    };
	    Style.prototype.addImage = function addImage(id, image) {
	        if (this.getImage(id)) {
	            return this.fire(new performance.ErrorEvent(new Error('An image with this name already exists.')));
	        }
	        this.imageManager.addImage(id, image);
	        this._afterImageUpdated(id);
	    };
	    Style.prototype.updateImage = function updateImage(id, image) {
	        this.imageManager.updateImage(id, image);
	    };
	    Style.prototype.getImage = function getImage(id) {
	        return this.imageManager.getImage(id);
	    };
	    Style.prototype.removeImage = function removeImage(id) {
	        if (!this.getImage(id)) {
	            return this.fire(new performance.ErrorEvent(new Error('No image with this name exists.')));
	        }
	        this.imageManager.removeImage(id);
	        this._afterImageUpdated(id);
	    };
	    Style.prototype._afterImageUpdated = function _afterImageUpdated(id) {
	        this._availableImages = this.imageManager.listImages();
	        this._changedImages[id] = true;
	        this._changed = true;
	        this.dispatcher.broadcast('setImages', this._availableImages);
	        this.fire(new performance.Event('data', { dataType: 'style' }));
	    };
	    Style.prototype.listImages = function listImages() {
	        this._checkLoaded();
	        return this.imageManager.listImages();
	    };
	    Style.prototype.addSource = function addSource(id, source, options) {
	        var this$1 = this;
	        if (options === void 0)
	            options = {};
	        this._checkLoaded();
	        if (this.sourceCaches[id] !== undefined) {
	            throw new Error('There is already a source with this ID');
	        }
	        if (!source.type) {
	            throw new Error('The type property must be defined, but only the following properties were given: ' + Object.keys(source).join(', ') + '.');
	        }
	        var builtIns = [
	            'vector',
	            'raster',
	            'geojson',
	            'video',
	            'image'
	        ];
	        var shouldValidate = builtIns.indexOf(source.type) >= 0;
	        if (shouldValidate && this._validate(performance.validateStyle.source, 'sources.' + id, source, null, options)) {
	            return;
	        }
	        if (this.map && this.map._collectResourceTiming) {
	            source.collectResourceTiming = true;
	        }
	        var sourceCache = this.sourceCaches[id] = new SourceCache(id, source, this.dispatcher);
	        sourceCache.style = this;
	        sourceCache.setEventedParent(this, function () {
	            return {
	                isSourceLoaded: this$1.loaded(),
	                source: sourceCache.serialize(),
	                sourceId: id
	            };
	        });
	        sourceCache.onAdd(this.map);
	        this._changed = true;
	    };
	    Style.prototype.removeSource = function removeSource(id) {
	        this._checkLoaded();
	        if (this.sourceCaches[id] === undefined) {
	            throw new Error('There is no source with this ID');
	        }
	        for (var layerId in this._layers) {
	            if (this._layers[layerId].source === id) {
	                return this.fire(new performance.ErrorEvent(new Error('Source "' + id + '" cannot be removed while layer "' + layerId + '" is using it.')));
	            }
	        }
	        var sourceCache = this.sourceCaches[id];
	        delete this.sourceCaches[id];
	        delete this._updatedSources[id];
	        sourceCache.fire(new performance.Event('data', {
	            sourceDataType: 'metadata',
	            dataType: 'source',
	            sourceId: id
	        }));
	        sourceCache.setEventedParent(null);
	        sourceCache.clearTiles();
	        if (sourceCache.onRemove) {
	            sourceCache.onRemove(this.map);
	        }
	        this._changed = true;
	    };
	    Style.prototype.setGeoJSONSourceData = function setGeoJSONSourceData(id, data) {
	        this._checkLoaded();
	        var geojsonSource = this.sourceCaches[id].getSource();
	        geojsonSource.setData(data);
	        this._changed = true;
	    };
	    Style.prototype.getSource = function getSource(id) {
	        return this.sourceCaches[id] && this.sourceCaches[id].getSource();
	    };
	    Style.prototype.addLayer = function addLayer(layerObject, before, options) {
	        if (options === void 0)
	            options = {};
	        this._checkLoaded();
	        var id = layerObject.id;
	        if (this.getLayer(id)) {
	            this.fire(new performance.ErrorEvent(new Error('Layer with id "' + id + '" already exists on this map')));
	            return;
	        }
	        var layer;
	        if (layerObject.type === 'custom') {
	            if (emitValidationErrors(this, performance.validateCustomStyleLayer(layerObject))) {
	                return;
	            }
	            layer = performance.createStyleLayer(layerObject);
	        } else {
	            if (typeof layerObject.source === 'object') {
	                this.addSource(id, layerObject.source);
	                layerObject = performance.clone$1(layerObject);
	                layerObject = performance.extend(layerObject, { source: id });
	            }
	            if (this._validate(performance.validateStyle.layer, 'layers.' + id, layerObject, { arrayIndex: -1 }, options)) {
	                return;
	            }
	            layer = performance.createStyleLayer(layerObject);
	            this._validateLayer(layer);
	            layer.setEventedParent(this, { layer: { id: id } });
	            this._serializedLayers[layer.id] = layer.serialize();
	        }
	        var index = before ? this._order.indexOf(before) : this._order.length;
	        if (before && index === -1) {
	            this.fire(new performance.ErrorEvent(new Error('Layer with id "' + before + '" does not exist on this map.')));
	            return;
	        }
	        this._order.splice(index, 0, id);
	        this._layerOrderChanged = true;
	        this._layers[id] = layer;
	        if (this._removedLayers[id] && layer.source && layer.type !== 'custom') {
	            var removed = this._removedLayers[id];
	            delete this._removedLayers[id];
	            if (removed.type !== layer.type) {
	                this._updatedSources[layer.source] = 'clear';
	            } else {
	                this._updatedSources[layer.source] = 'reload';
	                this.sourceCaches[layer.source].pause();
	            }
	        }
	        this._updateLayer(layer);
	        if (layer.onAdd) {
	            layer.onAdd(this.map);
	        }
	    };
	    Style.prototype.moveLayer = function moveLayer(id, before) {
	        this._checkLoaded();
	        this._changed = true;
	        var layer = this._layers[id];
	        if (!layer) {
	            this.fire(new performance.ErrorEvent(new Error('The layer \'' + id + '\' does not exist in the map\'s style and cannot be moved.')));
	            return;
	        }
	        if (id === before) {
	            return;
	        }
	        var index = this._order.indexOf(id);
	        this._order.splice(index, 1);
	        var newIndex = before ? this._order.indexOf(before) : this._order.length;
	        if (before && newIndex === -1) {
	            this.fire(new performance.ErrorEvent(new Error('Layer with id "' + before + '" does not exist on this map.')));
	            return;
	        }
	        this._order.splice(newIndex, 0, id);
	        this._layerOrderChanged = true;
	    };
	    Style.prototype.removeLayer = function removeLayer(id) {
	        this._checkLoaded();
	        var layer = this._layers[id];
	        if (!layer) {
	            this.fire(new performance.ErrorEvent(new Error('The layer \'' + id + '\' does not exist in the map\'s style and cannot be removed.')));
	            return;
	        }
	        layer.setEventedParent(null);
	        var index = this._order.indexOf(id);
	        this._order.splice(index, 1);
	        this._layerOrderChanged = true;
	        this._changed = true;
	        this._removedLayers[id] = layer;
	        delete this._layers[id];
	        delete this._serializedLayers[id];
	        delete this._updatedLayers[id];
	        delete this._updatedPaintProps[id];
	        if (layer.onRemove) {
	            layer.onRemove(this.map);
	        }
	    };
	    Style.prototype.getLayer = function getLayer(id) {
	        return this._layers[id];
	    };
	    Style.prototype.hasLayer = function hasLayer(id) {
	        return id in this._layers;
	    };
	    Style.prototype.setLayerZoomRange = function setLayerZoomRange(layerId, minzoom, maxzoom) {
	        this._checkLoaded();
	        var layer = this.getLayer(layerId);
	        if (!layer) {
	            this.fire(new performance.ErrorEvent(new Error('The layer \'' + layerId + '\' does not exist in the map\'s style and cannot have zoom extent.')));
	            return;
	        }
	        if (layer.minzoom === minzoom && layer.maxzoom === maxzoom) {
	            return;
	        }
	        if (minzoom != null) {
	            layer.minzoom = minzoom;
	        }
	        if (maxzoom != null) {
	            layer.maxzoom = maxzoom;
	        }
	        this._updateLayer(layer);
	    };
	    Style.prototype.setFilter = function setFilter(layerId, filter, options) {
	        if (options === void 0)
	            options = {};
	        this._checkLoaded();
	        var layer = this.getLayer(layerId);
	        if (!layer) {
	            this.fire(new performance.ErrorEvent(new Error('The layer \'' + layerId + '\' does not exist in the map\'s style and cannot be filtered.')));
	            return;
	        }
	        if (performance.deepEqual(layer.filter, filter)) {
	            return;
	        }
	        if (filter === null || filter === undefined) {
	            layer.filter = undefined;
	            this._updateLayer(layer);
	            return;
	        }
	        if (this._validate(performance.validateStyle.filter, 'layers.' + layer.id + '.filter', filter, null, options)) {
	            return;
	        }
	        layer.filter = performance.clone$1(filter);
	        this._updateLayer(layer);
	    };
	    Style.prototype.getFilter = function getFilter(layer) {
	        return performance.clone$1(this.getLayer(layer).filter);
	    };
	    Style.prototype.setLayoutProperty = function setLayoutProperty(layerId, name, value, options) {
	        if (options === void 0)
	            options = {};
	        this._checkLoaded();
	        var layer = this.getLayer(layerId);
	        if (!layer) {
	            this.fire(new performance.ErrorEvent(new Error('The layer \'' + layerId + '\' does not exist in the map\'s style and cannot be styled.')));
	            return;
	        }
	        if (performance.deepEqual(layer.getLayoutProperty(name), value)) {
	            return;
	        }
	        layer.setLayoutProperty(name, value, options);
	        this._serializedLayers[layerId] = layer.serialize();
	        this._updateLayer(layer);
	    };
	    Style.prototype.getLayoutProperty = function getLayoutProperty(layerId, name) {
	        var layer = this.getLayer(layerId);
	        if (!layer) {
	            this.fire(new performance.ErrorEvent(new Error('The layer \'' + layerId + '\' does not exist in the map\'s style.')));
	            return;
	        }
	        return layer.getLayoutProperty(name);
	    };
	    Style.prototype.setPaintProperty = function setPaintProperty(layerId, name, value, options) {
	        if (options === void 0)
	            options = {};
	        this._checkLoaded();
	        var layer = this.getLayer(layerId);
	        if (!layer) {
	            this.fire(new performance.ErrorEvent(new Error('The layer \'' + layerId + '\' does not exist in the map\'s style and cannot be styled.')));
	            return;
	        }
	        if (performance.deepEqual(layer.getPaintProperty(name), value)) {
	            return;
	        }
	        var requiresRelayout = layer.setPaintProperty(name, value, options);
	        if (requiresRelayout) {
	            this._updateLayer(layer);
	        }
	        this._changed = true;
	        this._updatedPaintProps[layerId] = true;
	    };
	    Style.prototype.getPaintProperty = function getPaintProperty(layer, name) {
	        return this.getLayer(layer).getPaintProperty(name);
	    };
	    Style.prototype.setFeatureState = function setFeatureState(target, state) {
	        this._checkLoaded();
	        var sourceId = target.source;
	        var sourceLayer = target.sourceLayer;
	        var sourceCache = this.sourceCaches[sourceId];
	        if (sourceCache === undefined) {
	            this.fire(new performance.ErrorEvent(new Error('The source \'' + sourceId + '\' does not exist in the map\'s style.')));
	            return;
	        }
	        var sourceType = sourceCache.getSource().type;
	        if (sourceType === 'geojson' && sourceLayer) {
	            this.fire(new performance.ErrorEvent(new Error('GeoJSON sources cannot have a sourceLayer parameter.')));
	            return;
	        }
	        if (sourceType === 'vector' && !sourceLayer) {
	            this.fire(new performance.ErrorEvent(new Error('The sourceLayer parameter must be provided for vector source types.')));
	            return;
	        }
	        if (target.id === undefined) {
	            this.fire(new performance.ErrorEvent(new Error('The feature id parameter must be provided.')));
	        }
	        sourceCache.setFeatureState(sourceLayer, target.id, state);
	    };
	    Style.prototype.removeFeatureState = function removeFeatureState(target, key) {
	        this._checkLoaded();
	        var sourceId = target.source;
	        var sourceCache = this.sourceCaches[sourceId];
	        if (sourceCache === undefined) {
	            this.fire(new performance.ErrorEvent(new Error('The source \'' + sourceId + '\' does not exist in the map\'s style.')));
	            return;
	        }
	        var sourceType = sourceCache.getSource().type;
	        var sourceLayer = sourceType === 'vector' ? target.sourceLayer : undefined;
	        if (sourceType === 'vector' && !sourceLayer) {
	            this.fire(new performance.ErrorEvent(new Error('The sourceLayer parameter must be provided for vector source types.')));
	            return;
	        }
	        if (key && (typeof target.id !== 'string' && typeof target.id !== 'number')) {
	            this.fire(new performance.ErrorEvent(new Error('A feature id is required to remove its specific state property.')));
	            return;
	        }
	        sourceCache.removeFeatureState(sourceLayer, target.id, key);
	    };
	    Style.prototype.getFeatureState = function getFeatureState(target) {
	        this._checkLoaded();
	        var sourceId = target.source;
	        var sourceLayer = target.sourceLayer;
	        var sourceCache = this.sourceCaches[sourceId];
	        if (sourceCache === undefined) {
	            this.fire(new performance.ErrorEvent(new Error('The source \'' + sourceId + '\' does not exist in the map\'s style.')));
	            return;
	        }
	        var sourceType = sourceCache.getSource().type;
	        if (sourceType === 'vector' && !sourceLayer) {
	            this.fire(new performance.ErrorEvent(new Error('The sourceLayer parameter must be provided for vector source types.')));
	            return;
	        }
	        if (target.id === undefined) {
	            this.fire(new performance.ErrorEvent(new Error('The feature id parameter must be provided.')));
	        }
	        return sourceCache.getFeatureState(sourceLayer, target.id);
	    };
	    Style.prototype.getTransition = function getTransition() {
	        return performance.extend({
	            duration: 300,
	            delay: 0
	        }, this.stylesheet && this.stylesheet.transition);
	    };
	    Style.prototype.serialize = function serialize() {
	        if (this._loaded) {
	            return performance.filterObject({
	                version: this.stylesheet.version,
	                name: this.stylesheet.name,
	                metadata: this.stylesheet.metadata,
	                light: this.stylesheet.light,
	                center: this.stylesheet.center,
	                zoom: this.stylesheet.zoom,
	                bearing: this.stylesheet.bearing,
	                pitch: this.stylesheet.pitch,
	                sprite: this.stylesheet.sprite,
	                glyphs: this.stylesheet.glyphs,
	                transition: this.stylesheet.transition,
	                sources: performance.mapObject(this.sourceCaches, function (source) {
	                    return source.serialize();
	                }),
	                layers: this._serializeLayers(this._order)
	            }, function (value) {
	                return value !== undefined;
	            });
	        } else {
	            return empty;
	        }
	    };
	    Style.prototype._buildStylePatch = function _buildStylePatch(next, options) {
	        var this$1 = this;
	        var patchOperations = [];
	        var preservedSources = [];
	        var preservedLayers = [];
	        var nextLayerIndex = next.layers.reduce(function (p, c) {
	            p[c.id] = c;
	            return p;
	        }, {});
	        var preserveLayer = function (layerId, before) {
	            if (this$1.hasLayer(layerId)) {
	                var preservedLayer = this$1._serializedLayers[layerId];
	                if (!next.sources.hasOwnProperty(preservedLayer.source) && !preservedSources.includes(preservedLayer.source)) {
	                    patchOperations.push({
	                        command: 'addSource',
	                        args: [
	                            preservedLayer.source,
	                            this$1.sourceCaches[preservedLayer.source].serialize(),
	                            { validate: false }
	                        ]
	                    });
	                    preservedSources.push(preservedLayer.source);
	                }
	                if (nextLayerIndex.hasOwnProperty(layerId)) {
	                    patchOperations.push({
	                        command: 'removeLayer',
	                        args: [layerId]
	                    });
	                }
	                before = nextLayerIndex.hasOwnProperty(before) || preservedLayers.find(function (l) {
	                    return l.id === before;
	                }) ? before : undefined;
	                patchOperations.push({
	                    command: 'moveLayer',
	                    args: [
	                        preservedLayer.id,
	                        before,
	                        { validate: true }
	                    ]
	                });
	                patchOperations.push({
	                    command: 'addLayer',
	                    args: [
	                        preservedLayer,
	                        before,
	                        { validate: true }
	                    ]
	                });
	                preservedLayers.push(layerId);
	            } else {
	                performance.warnOnce('Cannot preserve layer ' + layerId + ' that is not in the previous style.');
	            }
	        };
	        var updatePaintProperty = function (layerId, name, value) {
	            if (nextLayerIndex.hasOwnProperty(layerId) || preservedLayers.includes(layerId)) {
	                patchOperations.push({
	                    command: 'setPaintProperty',
	                    args: [
	                        layerId,
	                        name,
	                        value,
	                        { validate: true }
	                    ]
	                });
	            } else {
	                performance.warnOnce('Cannot update paint property on layer ' + layerId + ' that is not in the next style.');
	            }
	        };
	        var updateLayoutProperty = function (layerId, name, value) {
	            if (nextLayerIndex.hasOwnProperty(layerId) || preservedLayers.includes(layerId)) {
	                patchOperations.push({
	                    command: 'setLayoutProperty',
	                    args: [
	                        layerId,
	                        name,
	                        value,
	                        { validate: true }
	                    ]
	                });
	            } else {
	                performance.warnOnce('Cannot update layout property on layer ' + layerId + ' that is not in the next style.');
	            }
	        };
	        var updateFilter = function (layerId, name, value) {
	            if (nextLayerIndex.hasOwnProperty(layerId) || preservedLayers.includes(layerId)) {
	                patchOperations.push({
	                    command: 'setFilter',
	                    args: [
	                        layerId,
	                        name,
	                        value,
	                        { validate: true }
	                    ]
	                });
	            } else {
	                performance.warnOnce('Cannot update filter on layer ' + layerId + ' that is not in the next style.');
	            }
	        };
	        if (options.stylePatch) {
	            options.stylePatch(this.serialize(), next, preserveLayer.bind(this), updatePaintProperty.bind(this), updateLayoutProperty.bind(this), updateFilter.bind(this));
	        }
	        return patchOperations;
	    };
	    Style.prototype._updateLayer = function _updateLayer(layer) {
	        this._updatedLayers[layer.id] = true;
	        if (layer.source && !this._updatedSources[layer.source] && this.sourceCaches[layer.source].getSource().type !== 'raster') {
	            this._updatedSources[layer.source] = 'reload';
	            this.sourceCaches[layer.source].pause();
	        }
	        this._changed = true;
	    };
	    Style.prototype._flattenAndSortRenderedFeatures = function _flattenAndSortRenderedFeatures(sourceResults) {
	        var this$1 = this;
	        var isLayer3D = function (layerId) {
	            return this$1._layers[layerId].type === 'fill-extrusion';
	        };
	        var layerIndex = {};
	        var features3D = [];
	        for (var l = this._order.length - 1; l >= 0; l--) {
	            var layerId = this._order[l];
	            if (isLayer3D(layerId)) {
	                layerIndex[layerId] = l;
	                for (var i$2 = 0, list$1 = sourceResults; i$2 < list$1.length; i$2 += 1) {
	                    var sourceResult = list$1[i$2];
	                    var layerFeatures = sourceResult[layerId];
	                    if (layerFeatures) {
	                        for (var i$1 = 0, list = layerFeatures; i$1 < list.length; i$1 += 1) {
	                            var featureWrapper = list[i$1];
	                            features3D.push(featureWrapper);
	                        }
	                    }
	                }
	            }
	        }
	        features3D.sort(function (a, b) {
	            return b.intersectionZ - a.intersectionZ;
	        });
	        var features = [];
	        for (var l$1 = this._order.length - 1; l$1 >= 0; l$1--) {
	            var layerId$1 = this._order[l$1];
	            if (isLayer3D(layerId$1)) {
	                for (var i = features3D.length - 1; i >= 0; i--) {
	                    var topmost3D = features3D[i].feature;
	                    if (layerIndex[topmost3D.layer.id] < l$1) {
	                        break;
	                    }
	                    features.push(topmost3D);
	                    features3D.pop();
	                }
	            } else {
	                for (var i$4 = 0, list$3 = sourceResults; i$4 < list$3.length; i$4 += 1) {
	                    var sourceResult$1 = list$3[i$4];
	                    var layerFeatures$1 = sourceResult$1[layerId$1];
	                    if (layerFeatures$1) {
	                        for (var i$3 = 0, list$2 = layerFeatures$1; i$3 < list$2.length; i$3 += 1) {
	                            var featureWrapper$1 = list$2[i$3];
	                            features.push(featureWrapper$1.feature);
	                        }
	                    }
	                }
	            }
	        }
	        return features;
	    };
	    Style.prototype.queryRenderedFeatures = function queryRenderedFeatures$1(queryGeometry, params, transform) {
	        if (params && params.filter) {
	            this._validate(performance.validateStyle.filter, 'queryRenderedFeatures.filter', params.filter, null, params);
	        }
	        var includedSources = {};
	        if (params && params.layers) {
	            if (!Array.isArray(params.layers)) {
	                this.fire(new performance.ErrorEvent(new Error('parameters.layers must be an Array.')));
	                return [];
	            }
	            for (var i = 0, list = params.layers; i < list.length; i += 1) {
	                var layerId = list[i];
	                var layer = this._layers[layerId];
	                if (!layer) {
	                    this.fire(new performance.ErrorEvent(new Error('The layer \'' + layerId + '\' does not exist in the map\'s style and cannot be queried for features.')));
	                    return [];
	                }
	                includedSources[layer.source] = true;
	            }
	        }
	        var sourceResults = [];
	        params.availableImages = this._availableImages;
	        for (var id in this.sourceCaches) {
	            if (params.layers && !includedSources[id]) {
	                continue;
	            }
	            sourceResults.push(queryRenderedFeatures(this.sourceCaches[id], this._layers, this._serializedLayers, queryGeometry, params, transform));
	        }
	        if (this.placement) {
	            sourceResults.push(queryRenderedSymbols(this._layers, this._serializedLayers, this.sourceCaches, queryGeometry, params, this.placement.collisionIndex, this.placement.retainedQueryData));
	        }
	        return this._flattenAndSortRenderedFeatures(sourceResults);
	    };
	    Style.prototype.querySourceFeatures = function querySourceFeatures$1(sourceID, params) {
	        if (params && params.filter) {
	            this._validate(performance.validateStyle.filter, 'querySourceFeatures.filter', params.filter, null, params);
	        }
	        var sourceCache = this.sourceCaches[sourceID];
	        return sourceCache ? querySourceFeatures(sourceCache, params) : [];
	    };
	    Style.prototype.addSourceType = function addSourceType(name, SourceType, callback) {
	        if (Style.getSourceType(name)) {
	            return callback(new Error('A source type called "' + name + '" already exists.'));
	        }
	        Style.setSourceType(name, SourceType);
	        if (!SourceType.workerSourceURL) {
	            return callback(null, null);
	        }
	        this.dispatcher.broadcast('loadWorkerSource', {
	            name: name,
	            url: SourceType.workerSourceURL
	        }, callback);
	    };
	    Style.prototype.getLight = function getLight() {
	        return this.light.getLight();
	    };
	    Style.prototype.setLight = function setLight(lightOptions, options) {
	        if (options === void 0)
	            options = {};
	        this._checkLoaded();
	        var light = this.light.getLight();
	        var _update = false;
	        for (var key in lightOptions) {
	            if (!performance.deepEqual(lightOptions[key], light[key])) {
	                _update = true;
	                break;
	            }
	        }
	        if (!_update) {
	            return;
	        }
	        var parameters = {
	            now: performance.browser.now(),
	            transition: performance.extend({
	                duration: 300,
	                delay: 0
	            }, this.stylesheet.transition)
	        };
	        this.light.setLight(lightOptions, options);
	        this.light.updateTransitions(parameters);
	    };
	    Style.prototype._validate = function _validate(validate, key, value, props, options) {
	        if (options === void 0)
	            options = {};
	        if (options && options.validate === false) {
	            return false;
	        }
	        return emitValidationErrors(this, validate.call(performance.validateStyle, performance.extend({
	            key: key,
	            style: this.serialize(),
	            value: value,
	            styleSpec: performance.styleSpec
	        }, props)));
	    };
	    Style.prototype._remove = function _remove() {
	        if (this._request) {
	            this._request.cancel();
	            this._request = null;
	        }
	        if (this._spriteRequest) {
	            this._spriteRequest.cancel();
	            this._spriteRequest = null;
	        }
	        performance.evented.off('pluginStateChange', this._rtlTextPluginCallback);
	        for (var layerId in this._layers) {
	            var layer = this._layers[layerId];
	            layer.setEventedParent(null);
	        }
	        for (var id in this.sourceCaches) {
	            this.sourceCaches[id].clearTiles();
	            this.sourceCaches[id].setEventedParent(null);
	        }
	        this.imageManager.setEventedParent(null);
	        this.setEventedParent(null);
	        this.dispatcher.remove();
	    };
	    Style.prototype._clearSource = function _clearSource(id) {
	        this.sourceCaches[id].clearTiles();
	    };
	    Style.prototype._reloadSource = function _reloadSource(id) {
	        this.sourceCaches[id].resume();
	        this.sourceCaches[id].reload();
	    };
	    Style.prototype._updateSources = function _updateSources(transform) {
	        for (var id in this.sourceCaches) {
	            this.sourceCaches[id].update(transform);
	        }
	    };
	    Style.prototype._generateCollisionBoxes = function _generateCollisionBoxes() {
	        for (var id in this.sourceCaches) {
	            this._reloadSource(id);
	        }
	    };
	    Style.prototype._updatePlacement = function _updatePlacement(transform, showCollisionBoxes, fadeDuration, crossSourceCollisions, forceFullPlacement) {
	        if (forceFullPlacement === void 0)
	            forceFullPlacement = false;
	        var symbolBucketsChanged = false;
	        var placementCommitted = false;
	        var layerTiles = {};
	        for (var i = 0, list = this._order; i < list.length; i += 1) {
	            var layerID = list[i];
	            var styleLayer = this._layers[layerID];
	            if (styleLayer.type !== 'symbol') {
	                continue;
	            }
	            if (!layerTiles[styleLayer.source]) {
	                var sourceCache = this.sourceCaches[styleLayer.source];
	                layerTiles[styleLayer.source] = sourceCache.getRenderableIds(true).map(function (id) {
	                    return sourceCache.getTileByID(id);
	                }).sort(function (a, b) {
	                    return b.tileID.overscaledZ - a.tileID.overscaledZ || (a.tileID.isLessThan(b.tileID) ? -1 : 1);
	                });
	            }
	            var layerBucketsChanged = this.crossTileSymbolIndex.addLayer(styleLayer, layerTiles[styleLayer.source], transform.center.lng);
	            symbolBucketsChanged = symbolBucketsChanged || layerBucketsChanged;
	        }
	        this.crossTileSymbolIndex.pruneUnusedLayers(this._order);
	        forceFullPlacement = forceFullPlacement || this._layerOrderChanged || fadeDuration === 0;
	        if (forceFullPlacement || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(performance.browser.now(), transform.zoom)) {
	            this.pauseablePlacement = new PauseablePlacement(transform, this._order, forceFullPlacement, showCollisionBoxes, fadeDuration, crossSourceCollisions, this.placement);
	            this._layerOrderChanged = false;
	        }
	        if (this.pauseablePlacement.isDone()) {
	            this.placement.setStale();
	        } else {
	            this.pauseablePlacement.continuePlacement(this._order, this._layers, layerTiles);
	            if (this.pauseablePlacement.isDone()) {
	                this.placement = this.pauseablePlacement.commit(performance.browser.now());
	                placementCommitted = true;
	            }
	            if (symbolBucketsChanged) {
	                this.pauseablePlacement.placement.setStale();
	            }
	        }
	        if (placementCommitted || symbolBucketsChanged) {
	            for (var i$1 = 0, list$1 = this._order; i$1 < list$1.length; i$1 += 1) {
	                var layerID$1 = list$1[i$1];
	                var styleLayer$1 = this._layers[layerID$1];
	                if (styleLayer$1.type !== 'symbol') {
	                    continue;
	                }
	                this.placement.updateLayerOpacities(styleLayer$1, layerTiles[styleLayer$1.source]);
	            }
	        }
	        var needsRerender = !this.pauseablePlacement.isDone() || this.placement.hasTransitions(performance.browser.now());
	        return needsRerender;
	    };
	    Style.prototype._releaseSymbolFadeTiles = function _releaseSymbolFadeTiles() {
	        for (var id in this.sourceCaches) {
	            this.sourceCaches[id].releaseSymbolFadeTiles();
	        }
	    };
	    Style.prototype.getImages = function getImages(mapId, params, callback) {
	        this.imageManager.getImages(params.icons, callback);
	        this._updateTilesForChangedImages();
	        var sourceCache = this.sourceCaches[params.source];
	        if (sourceCache) {
	            sourceCache.setDependencies(params.tileID.key, params.type, params.icons);
	        }
	    };
	    Style.prototype.getGlyphs = function getGlyphs(mapId, params, callback) {
	        this.glyphManager.getGlyphs(params.stacks, callback);
	    };
	    Style.prototype.getResource = function getResource(mapId, params, callback) {
	        return performance.makeRequest(params, callback);
	    };
	    return Style;
	}(performance.Evented);
	Style.getSourceType = getType;
	Style.setSourceType = setType;
	Style.registerForPluginStateChange = performance.registerForPluginStateChange;

	var posAttributes = performance.createLayout([{
	        name: 'a_pos',
	        type: 'Int16',
	        components: 2
	    }]);

	var preludeFrag = "#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif";

	var preludeVert = "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}";

	var backgroundFrag = "uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var backgroundVert = "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}";

	var backgroundPatternFrag = "uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var backgroundPatternVert = "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}";

	var circleFrag = "varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var circleVert = "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}";

	var clippingMaskFrag = "void main() {gl_FragColor=vec4(1.0);}";

	var clippingMaskVert = "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}";

	var heatmapFrag = "uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var heatmapVert = "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}";

	var heatmapTextureFrag = "uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}";

	var heatmapTextureVert = "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}";

	var collisionBoxFrag = "varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}";

	var collisionBoxVert = "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}";

	var collisionCircleFrag = "varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}";

	var collisionCircleVert = "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}";

	var debugFrag = "uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}";

	var debugVert = "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}";

	var fillFrag = "#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var fillVert = "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}";

	var fillOutlineFrag = "varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var fillOutlineVert = "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}";

	var fillOutlinePatternFrag = "uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var fillOutlinePatternVert = "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}";

	var fillPatternFrag = "uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var fillPatternVert = "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}";

	var fillExtrusionFrag = "varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var fillExtrusionVert = "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}";

	var fillExtrusionPatternFrag = "uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var fillExtrusionPatternVert = "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}";

	var hillshadePrepareFrag = "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var hillshadePrepareVert = "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}";

	var hillshadeFrag = "uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var hillshadeVert = "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}";

	var lineFrag = "uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var lineVert = "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}";

	var lineGradientFrag = "uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var lineGradientVert = "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}";

	var linePatternFrag = "uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var linePatternVert = "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}";

	var lineSDFFrag = "uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var lineSDFVert = "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}";

	var rasterFrag = "uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var rasterVert = "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}";

	var symbolIconFrag = "uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var symbolIconVert = "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}";

	var symbolSDFFrag = "#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var symbolSDFVert = "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}";

	var symbolTextAndIconFrag = "#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";

	var symbolTextAndIconVert = "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}";

	var prelude = compile(preludeFrag, preludeVert);
	var background = compile(backgroundFrag, backgroundVert);
	var backgroundPattern = compile(backgroundPatternFrag, backgroundPatternVert);
	var circle = compile(circleFrag, circleVert);
	var clippingMask = compile(clippingMaskFrag, clippingMaskVert);
	var heatmap = compile(heatmapFrag, heatmapVert);
	var heatmapTexture = compile(heatmapTextureFrag, heatmapTextureVert);
	var collisionBox = compile(collisionBoxFrag, collisionBoxVert);
	var collisionCircle = compile(collisionCircleFrag, collisionCircleVert);
	var debug = compile(debugFrag, debugVert);
	var fill = compile(fillFrag, fillVert);
	var fillOutline = compile(fillOutlineFrag, fillOutlineVert);
	var fillOutlinePattern = compile(fillOutlinePatternFrag, fillOutlinePatternVert);
	var fillPattern = compile(fillPatternFrag, fillPatternVert);
	var fillExtrusion = compile(fillExtrusionFrag, fillExtrusionVert);
	var fillExtrusionPattern = compile(fillExtrusionPatternFrag, fillExtrusionPatternVert);
	var hillshadePrepare = compile(hillshadePrepareFrag, hillshadePrepareVert);
	var hillshade = compile(hillshadeFrag, hillshadeVert);
	var line = compile(lineFrag, lineVert);
	var lineGradient = compile(lineGradientFrag, lineGradientVert);
	var linePattern = compile(linePatternFrag, linePatternVert);
	var lineSDF = compile(lineSDFFrag, lineSDFVert);
	var raster = compile(rasterFrag, rasterVert);
	var symbolIcon = compile(symbolIconFrag, symbolIconVert);
	var symbolSDF = compile(symbolSDFFrag, symbolSDFVert);
	var symbolTextAndIcon = compile(symbolTextAndIconFrag, symbolTextAndIconVert);
	function compile(fragmentSource, vertexSource) {
	    var re = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g;
	    var staticAttributes = vertexSource.match(/attribute ([\w]+) ([\w]+)/g);
	    var fragmentUniforms = fragmentSource.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g);
	    var vertexUniforms = vertexSource.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g);
	    var staticUniforms = vertexUniforms ? vertexUniforms.concat(fragmentUniforms) : fragmentUniforms;
	    var fragmentPragmas = {};
	    fragmentSource = fragmentSource.replace(re, function (match, operation, precision, type, name) {
	        fragmentPragmas[name] = true;
	        if (operation === 'define') {
	            return '\n#ifndef HAS_UNIFORM_u_' + name + '\nvarying ' + precision + ' ' + type + ' ' + name + ';\n#else\nuniform ' + precision + ' ' + type + ' u_' + name + ';\n#endif\n';
	        } else {
	            return '\n#ifdef HAS_UNIFORM_u_' + name + '\n    ' + precision + ' ' + type + ' ' + name + ' = u_' + name + ';\n#endif\n';
	        }
	    });
	    vertexSource = vertexSource.replace(re, function (match, operation, precision, type, name) {
	        var attrType = type === 'float' ? 'vec2' : 'vec4';
	        var unpackType = name.match(/color/) ? 'color' : attrType;
	        if (fragmentPragmas[name]) {
	            if (operation === 'define') {
	                return '\n#ifndef HAS_UNIFORM_u_' + name + '\nuniform lowp float u_' + name + '_t;\nattribute ' + precision + ' ' + attrType + ' a_' + name + ';\nvarying ' + precision + ' ' + type + ' ' + name + ';\n#else\nuniform ' + precision + ' ' + type + ' u_' + name + ';\n#endif\n';
	            } else {
	                if (unpackType === 'vec4') {
	                    return '\n#ifndef HAS_UNIFORM_u_' + name + '\n    ' + name + ' = a_' + name + ';\n#else\n    ' + precision + ' ' + type + ' ' + name + ' = u_' + name + ';\n#endif\n';
	                } else {
	                    return '\n#ifndef HAS_UNIFORM_u_' + name + '\n    ' + name + ' = unpack_mix_' + unpackType + '(a_' + name + ', u_' + name + '_t);\n#else\n    ' + precision + ' ' + type + ' ' + name + ' = u_' + name + ';\n#endif\n';
	                }
	            }
	        } else {
	            if (operation === 'define') {
	                return '\n#ifndef HAS_UNIFORM_u_' + name + '\nuniform lowp float u_' + name + '_t;\nattribute ' + precision + ' ' + attrType + ' a_' + name + ';\n#else\nuniform ' + precision + ' ' + type + ' u_' + name + ';\n#endif\n';
	            } else {
	                if (unpackType === 'vec4') {
	                    return '\n#ifndef HAS_UNIFORM_u_' + name + '\n    ' + precision + ' ' + type + ' ' + name + ' = a_' + name + ';\n#else\n    ' + precision + ' ' + type + ' ' + name + ' = u_' + name + ';\n#endif\n';
	                } else {
	                    return '\n#ifndef HAS_UNIFORM_u_' + name + '\n    ' + precision + ' ' + type + ' ' + name + ' = unpack_mix_' + unpackType + '(a_' + name + ', u_' + name + '_t);\n#else\n    ' + precision + ' ' + type + ' ' + name + ' = u_' + name + ';\n#endif\n';
	                }
	            }
	        }
	    });
	    return {
	        fragmentSource: fragmentSource,
	        vertexSource: vertexSource,
	        staticAttributes: staticAttributes,
	        staticUniforms: staticUniforms
	    };
	}

	var shaders = /*#__PURE__*/Object.freeze({
	__proto__: null,
	prelude: prelude,
	background: background,
	backgroundPattern: backgroundPattern,
	circle: circle,
	clippingMask: clippingMask,
	heatmap: heatmap,
	heatmapTexture: heatmapTexture,
	collisionBox: collisionBox,
	collisionCircle: collisionCircle,
	debug: debug,
	fill: fill,
	fillOutline: fillOutline,
	fillOutlinePattern: fillOutlinePattern,
	fillPattern: fillPattern,
	fillExtrusion: fillExtrusion,
	fillExtrusionPattern: fillExtrusionPattern,
	hillshadePrepare: hillshadePrepare,
	hillshade: hillshade,
	line: line,
	lineGradient: lineGradient,
	linePattern: linePattern,
	lineSDF: lineSDF,
	raster: raster,
	symbolIcon: symbolIcon,
	symbolSDF: symbolSDF,
	symbolTextAndIcon: symbolTextAndIcon
	});

	var VertexArrayObject = function VertexArrayObject() {
	    this.boundProgram = null;
	    this.boundLayoutVertexBuffer = null;
	    this.boundPaintVertexBuffers = [];
	    this.boundIndexBuffer = null;
	    this.boundVertexOffset = null;
	    this.boundDynamicVertexBuffer = null;
	    this.vao = null;
	};
	VertexArrayObject.prototype.bind = function bind(context, program, layoutVertexBuffer, paintVertexBuffers, indexBuffer, vertexOffset, dynamicVertexBuffer, dynamicVertexBuffer2) {
	    this.context = context;
	    var paintBuffersDiffer = this.boundPaintVertexBuffers.length !== paintVertexBuffers.length;
	    for (var i = 0; !paintBuffersDiffer && i < paintVertexBuffers.length; i++) {
	        if (this.boundPaintVertexBuffers[i] !== paintVertexBuffers[i]) {
	            paintBuffersDiffer = true;
	        }
	    }
	    var isFreshBindRequired = !this.vao || this.boundProgram !== program || this.boundLayoutVertexBuffer !== layoutVertexBuffer || paintBuffersDiffer || this.boundIndexBuffer !== indexBuffer || this.boundVertexOffset !== vertexOffset || this.boundDynamicVertexBuffer !== dynamicVertexBuffer || this.boundDynamicVertexBuffer2 !== dynamicVertexBuffer2;
	    if (!context.extVertexArrayObject || isFreshBindRequired) {
	        this.freshBind(program, layoutVertexBuffer, paintVertexBuffers, indexBuffer, vertexOffset, dynamicVertexBuffer, dynamicVertexBuffer2);
	    } else {
	        context.bindVertexArrayOES.set(this.vao);
	        if (dynamicVertexBuffer) {
	            dynamicVertexBuffer.bind();
	        }
	        if (indexBuffer && indexBuffer.dynamicDraw) {
	            indexBuffer.bind();
	        }
	        if (dynamicVertexBuffer2) {
	            dynamicVertexBuffer2.bind();
	        }
	    }
	};
	VertexArrayObject.prototype.freshBind = function freshBind(program, layoutVertexBuffer, paintVertexBuffers, indexBuffer, vertexOffset, dynamicVertexBuffer, dynamicVertexBuffer2) {
	    var numPrevAttributes;
	    var numNextAttributes = program.numAttributes;
	    var context = this.context;
	    var gl = context.gl;
	    if (context.extVertexArrayObject) {
	        if (this.vao) {
	            this.destroy();
	        }
	        this.vao = context.extVertexArrayObject.createVertexArrayOES();
	        context.bindVertexArrayOES.set(this.vao);
	        numPrevAttributes = 0;
	        this.boundProgram = program;
	        this.boundLayoutVertexBuffer = layoutVertexBuffer;
	        this.boundPaintVertexBuffers = paintVertexBuffers;
	        this.boundIndexBuffer = indexBuffer;
	        this.boundVertexOffset = vertexOffset;
	        this.boundDynamicVertexBuffer = dynamicVertexBuffer;
	        this.boundDynamicVertexBuffer2 = dynamicVertexBuffer2;
	    } else {
	        numPrevAttributes = context.currentNumAttributes || 0;
	        for (var i = numNextAttributes; i < numPrevAttributes; i++) {
	            gl.disableVertexAttribArray(i);
	        }
	    }
	    layoutVertexBuffer.enableAttributes(gl, program);
	    for (var i$1 = 0, list = paintVertexBuffers; i$1 < list.length; i$1 += 1) {
	        var vertexBuffer = list[i$1];
	        vertexBuffer.enableAttributes(gl, program);
	    }
	    if (dynamicVertexBuffer) {
	        dynamicVertexBuffer.enableAttributes(gl, program);
	    }
	    if (dynamicVertexBuffer2) {
	        dynamicVertexBuffer2.enableAttributes(gl, program);
	    }
	    layoutVertexBuffer.bind();
	    layoutVertexBuffer.setVertexAttribPointers(gl, program, vertexOffset);
	    for (var i$2 = 0, list$1 = paintVertexBuffers; i$2 < list$1.length; i$2 += 1) {
	        var vertexBuffer$1 = list$1[i$2];
	        vertexBuffer$1.bind();
	        vertexBuffer$1.setVertexAttribPointers(gl, program, vertexOffset);
	    }
	    if (dynamicVertexBuffer) {
	        dynamicVertexBuffer.bind();
	        dynamicVertexBuffer.setVertexAttribPointers(gl, program, vertexOffset);
	    }
	    if (indexBuffer) {
	        indexBuffer.bind();
	    }
	    if (dynamicVertexBuffer2) {
	        dynamicVertexBuffer2.bind();
	        dynamicVertexBuffer2.setVertexAttribPointers(gl, program, vertexOffset);
	    }
	    context.currentNumAttributes = numNextAttributes;
	};
	VertexArrayObject.prototype.destroy = function destroy() {
	    if (this.vao) {
	        this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao);
	        this.vao = null;
	    }
	};

	function getTokenizedAttributesAndUniforms(array) {
	    var result = [];
	    for (var i = 0; i < array.length; i++) {
	        if (array[i] === null) {
	            continue;
	        }
	        var token = array[i].split(' ');
	        result.push(token.pop());
	    }
	    return result;
	}
	var Program$1 = function Program(context, name, source, configuration, fixedUniforms, showOverdrawInspector) {
	    var gl = context.gl;
	    this.program = gl.createProgram();
	    var staticAttrInfo = getTokenizedAttributesAndUniforms(source.staticAttributes);
	    var dynamicAttrInfo = configuration ? configuration.getBinderAttributes() : [];
	    var allAttrInfo = staticAttrInfo.concat(dynamicAttrInfo);
	    var staticUniformsInfo = source.staticUniforms ? getTokenizedAttributesAndUniforms(source.staticUniforms) : [];
	    var dynamicUniformsInfo = configuration ? configuration.getBinderUniforms() : [];
	    var uniformList = staticUniformsInfo.concat(dynamicUniformsInfo);
	    var allUniformsInfo = [];
	    for (var i$1 = 0, list = uniformList; i$1 < list.length; i$1 += 1) {
	        var uniform = list[i$1];
	        if (allUniformsInfo.indexOf(uniform) < 0) {
	            allUniformsInfo.push(uniform);
	        }
	    }
	    var defines = configuration ? configuration.defines() : [];
	    if (showOverdrawInspector) {
	        defines.push('#define OVERDRAW_INSPECTOR;');
	    }
	    var fragmentSource = defines.concat(prelude.fragmentSource, source.fragmentSource).join('\n');
	    var vertexSource = defines.concat(prelude.vertexSource, source.vertexSource).join('\n');
	    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	    if (gl.isContextLost()) {
	        this.failedToCreate = true;
	        return;
	    }
	    gl.shaderSource(fragmentShader, fragmentSource);
	    gl.compileShader(fragmentShader);
	    gl.attachShader(this.program, fragmentShader);
	    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	    if (gl.isContextLost()) {
	        this.failedToCreate = true;
	        return;
	    }
	    gl.shaderSource(vertexShader, vertexSource);
	    gl.compileShader(vertexShader);
	    gl.attachShader(this.program, vertexShader);
	    this.attributes = {};
	    var uniformLocations = {};
	    this.numAttributes = allAttrInfo.length;
	    for (var i = 0; i < this.numAttributes; i++) {
	        if (allAttrInfo[i]) {
	            gl.bindAttribLocation(this.program, i, allAttrInfo[i]);
	            this.attributes[allAttrInfo[i]] = i;
	        }
	    }
	    gl.linkProgram(this.program);
	    gl.deleteShader(vertexShader);
	    gl.deleteShader(fragmentShader);
	    for (var it = 0; it < allUniformsInfo.length; it++) {
	        var uniform$1 = allUniformsInfo[it];
	        if (uniform$1 && !uniformLocations[uniform$1]) {
	            var uniformLocation = gl.getUniformLocation(this.program, uniform$1);
	            if (uniformLocation) {
	                uniformLocations[uniform$1] = uniformLocation;
	            }
	        }
	    }
	    this.fixedUniforms = fixedUniforms(context, uniformLocations);
	    this.binderUniforms = configuration ? configuration.getUniforms(context, uniformLocations) : [];
	};
	Program$1.prototype.draw = function draw(context, drawMode, depthMode, stencilMode, colorMode, cullFaceMode, uniformValues, layerID, layoutVertexBuffer, indexBuffer, segments, currentProperties, zoom, configuration, dynamicLayoutBuffer, dynamicLayoutBuffer2) {
	    var obj;
	    var gl = context.gl;
	    if (this.failedToCreate) {
	        return;
	    }
	    context.program.set(this.program);
	    context.setDepthMode(depthMode);
	    context.setStencilMode(stencilMode);
	    context.setColorMode(colorMode);
	    context.setCullFace(cullFaceMode);
	    for (var name in this.fixedUniforms) {
	        this.fixedUniforms[name].set(uniformValues[name]);
	    }
	    if (configuration) {
	        configuration.setUniforms(context, this.binderUniforms, currentProperties, { zoom: zoom });
	    }
	    var primitiveSize = (obj = {}, obj[gl.LINES] = 2, obj[gl.TRIANGLES] = 3, obj[gl.LINE_STRIP] = 1, obj)[drawMode];
	    for (var i = 0, list = segments.get(); i < list.length; i += 1) {
	        var segment = list[i];
	        var vaos = segment.vaos || (segment.vaos = {});
	        var vao = vaos[layerID] || (vaos[layerID] = new VertexArrayObject());
	        vao.bind(context, this, layoutVertexBuffer, configuration ? configuration.getPaintVertexBuffers() : [], indexBuffer, segment.vertexOffset, dynamicLayoutBuffer, dynamicLayoutBuffer2);
	        gl.drawElements(drawMode, segment.primitiveLength * primitiveSize, gl.UNSIGNED_SHORT, segment.primitiveOffset * primitiveSize * 2);
	    }
	};

	function patternUniformValues(crossfade, painter, tile) {
	    var tileRatio = 1 / pixelsToTileUnits(tile, 1, painter.transform.tileZoom);
	    var numTiles = Math.pow(2, tile.tileID.overscaledZ);
	    var tileSizeAtNearestZoom = tile.tileSize * Math.pow(2, painter.transform.tileZoom) / numTiles;
	    var pixelX = tileSizeAtNearestZoom * (tile.tileID.canonical.x + tile.tileID.wrap * numTiles);
	    var pixelY = tileSizeAtNearestZoom * tile.tileID.canonical.y;
	    return {
	        'u_image': 0,
	        'u_texsize': tile.imageAtlasTexture.size,
	        'u_scale': [
	            tileRatio,
	            crossfade.fromScale,
	            crossfade.toScale
	        ],
	        'u_fade': crossfade.t,
	        'u_pixel_coord_upper': [
	            pixelX >> 16,
	            pixelY >> 16
	        ],
	        'u_pixel_coord_lower': [
	            pixelX & 65535,
	            pixelY & 65535
	        ]
	    };
	}
	function bgPatternUniformValues(image, crossfade, painter, tile) {
	    var imagePosA = painter.imageManager.getPattern(image.from.toString());
	    var imagePosB = painter.imageManager.getPattern(image.to.toString());
	    var ref = painter.imageManager.getPixelSize();
	    var width = ref.width;
	    var height = ref.height;
	    var numTiles = Math.pow(2, tile.tileID.overscaledZ);
	    var tileSizeAtNearestZoom = tile.tileSize * Math.pow(2, painter.transform.tileZoom) / numTiles;
	    var pixelX = tileSizeAtNearestZoom * (tile.tileID.canonical.x + tile.tileID.wrap * numTiles);
	    var pixelY = tileSizeAtNearestZoom * tile.tileID.canonical.y;
	    return {
	        'u_image': 0,
	        'u_pattern_tl_a': imagePosA.tl,
	        'u_pattern_br_a': imagePosA.br,
	        'u_pattern_tl_b': imagePosB.tl,
	        'u_pattern_br_b': imagePosB.br,
	        'u_texsize': [
	            width,
	            height
	        ],
	        'u_mix': crossfade.t,
	        'u_pattern_size_a': imagePosA.displaySize,
	        'u_pattern_size_b': imagePosB.displaySize,
	        'u_scale_a': crossfade.fromScale,
	        'u_scale_b': crossfade.toScale,
	        'u_tile_units_to_pixels': 1 / pixelsToTileUnits(tile, 1, painter.transform.tileZoom),
	        'u_pixel_coord_upper': [
	            pixelX >> 16,
	            pixelY >> 16
	        ],
	        'u_pixel_coord_lower': [
	            pixelX & 65535,
	            pixelY & 65535
	        ]
	    };
	}

	var fillExtrusionUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_lightpos': new performance.Uniform3f(context, locations.u_lightpos),
	        'u_lightintensity': new performance.Uniform1f(context, locations.u_lightintensity),
	        'u_lightcolor': new performance.Uniform3f(context, locations.u_lightcolor),
	        'u_vertical_gradient': new performance.Uniform1f(context, locations.u_vertical_gradient),
	        'u_opacity': new performance.Uniform1f(context, locations.u_opacity)
	    };
	};
	var fillExtrusionPatternUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_lightpos': new performance.Uniform3f(context, locations.u_lightpos),
	        'u_lightintensity': new performance.Uniform1f(context, locations.u_lightintensity),
	        'u_lightcolor': new performance.Uniform3f(context, locations.u_lightcolor),
	        'u_vertical_gradient': new performance.Uniform1f(context, locations.u_vertical_gradient),
	        'u_height_factor': new performance.Uniform1f(context, locations.u_height_factor),
	        'u_image': new performance.Uniform1i(context, locations.u_image),
	        'u_texsize': new performance.Uniform2f(context, locations.u_texsize),
	        'u_pixel_coord_upper': new performance.Uniform2f(context, locations.u_pixel_coord_upper),
	        'u_pixel_coord_lower': new performance.Uniform2f(context, locations.u_pixel_coord_lower),
	        'u_scale': new performance.Uniform3f(context, locations.u_scale),
	        'u_fade': new performance.Uniform1f(context, locations.u_fade),
	        'u_opacity': new performance.Uniform1f(context, locations.u_opacity)
	    };
	};
	var fillExtrusionUniformValues = function (matrix, painter, shouldUseVerticalGradient, opacity) {
	    var light = painter.style.light;
	    var _lp = light.properties.get('position');
	    var lightPos = [
	        _lp.x,
	        _lp.y,
	        _lp.z
	    ];
	    var lightMat = performance.create$1();
	    if (light.properties.get('anchor') === 'viewport') {
	        performance.fromRotation(lightMat, -painter.transform.angle);
	    }
	    performance.transformMat3(lightPos, lightPos, lightMat);
	    var lightColor = light.properties.get('color');
	    return {
	        'u_matrix': matrix,
	        'u_lightpos': lightPos,
	        'u_lightintensity': light.properties.get('intensity'),
	        'u_lightcolor': [
	            lightColor.r,
	            lightColor.g,
	            lightColor.b
	        ],
	        'u_vertical_gradient': +shouldUseVerticalGradient,
	        'u_opacity': opacity
	    };
	};
	var fillExtrusionPatternUniformValues = function (matrix, painter, shouldUseVerticalGradient, opacity, coord, crossfade, tile) {
	    return performance.extend(fillExtrusionUniformValues(matrix, painter, shouldUseVerticalGradient, opacity), patternUniformValues(crossfade, painter, tile), { 'u_height_factor': -Math.pow(2, coord.overscaledZ) / tile.tileSize / 8 });
	};

	var fillUniforms = function (context, locations) {
	    return { 'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix) };
	};
	var fillPatternUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_image': new performance.Uniform1i(context, locations.u_image),
	        'u_texsize': new performance.Uniform2f(context, locations.u_texsize),
	        'u_pixel_coord_upper': new performance.Uniform2f(context, locations.u_pixel_coord_upper),
	        'u_pixel_coord_lower': new performance.Uniform2f(context, locations.u_pixel_coord_lower),
	        'u_scale': new performance.Uniform3f(context, locations.u_scale),
	        'u_fade': new performance.Uniform1f(context, locations.u_fade)
	    };
	};
	var fillOutlineUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_world': new performance.Uniform2f(context, locations.u_world)
	    };
	};
	var fillOutlinePatternUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_world': new performance.Uniform2f(context, locations.u_world),
	        'u_image': new performance.Uniform1i(context, locations.u_image),
	        'u_texsize': new performance.Uniform2f(context, locations.u_texsize),
	        'u_pixel_coord_upper': new performance.Uniform2f(context, locations.u_pixel_coord_upper),
	        'u_pixel_coord_lower': new performance.Uniform2f(context, locations.u_pixel_coord_lower),
	        'u_scale': new performance.Uniform3f(context, locations.u_scale),
	        'u_fade': new performance.Uniform1f(context, locations.u_fade)
	    };
	};
	var fillUniformValues = function (matrix) {
	    return { 'u_matrix': matrix };
	};
	var fillPatternUniformValues = function (matrix, painter, crossfade, tile) {
	    return performance.extend(fillUniformValues(matrix), patternUniformValues(crossfade, painter, tile));
	};
	var fillOutlineUniformValues = function (matrix, drawingBufferSize) {
	    return {
	        'u_matrix': matrix,
	        'u_world': drawingBufferSize
	    };
	};
	var fillOutlinePatternUniformValues = function (matrix, painter, crossfade, tile, drawingBufferSize) {
	    return performance.extend(fillPatternUniformValues(matrix, painter, crossfade, tile), { 'u_world': drawingBufferSize });
	};

	var circleUniforms = function (context, locations) {
	    return {
	        'u_camera_to_center_distance': new performance.Uniform1f(context, locations.u_camera_to_center_distance),
	        'u_scale_with_map': new performance.Uniform1i(context, locations.u_scale_with_map),
	        'u_pitch_with_map': new performance.Uniform1i(context, locations.u_pitch_with_map),
	        'u_extrude_scale': new performance.Uniform2f(context, locations.u_extrude_scale),
	        'u_device_pixel_ratio': new performance.Uniform1f(context, locations.u_device_pixel_ratio),
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix)
	    };
	};
	var circleUniformValues = function (painter, coord, tile, layer) {
	    var transform = painter.transform;
	    var pitchWithMap, extrudeScale;
	    if (layer.paint.get('circle-pitch-alignment') === 'map') {
	        var pixelRatio = pixelsToTileUnits(tile, 1, transform.zoom);
	        pitchWithMap = true;
	        extrudeScale = [
	            pixelRatio,
	            pixelRatio
	        ];
	    } else {
	        pitchWithMap = false;
	        extrudeScale = transform.pixelsToGLUnits;
	    }
	    return {
	        'u_camera_to_center_distance': transform.cameraToCenterDistance,
	        'u_scale_with_map': +(layer.paint.get('circle-pitch-scale') === 'map'),
	        'u_matrix': painter.translatePosMatrix(coord.posMatrix, tile, layer.paint.get('circle-translate'), layer.paint.get('circle-translate-anchor')),
	        'u_pitch_with_map': +pitchWithMap,
	        'u_device_pixel_ratio': performance.browser.devicePixelRatio,
	        'u_extrude_scale': extrudeScale
	    };
	};

	var collisionUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_camera_to_center_distance': new performance.Uniform1f(context, locations.u_camera_to_center_distance),
	        'u_pixels_to_tile_units': new performance.Uniform1f(context, locations.u_pixels_to_tile_units),
	        'u_extrude_scale': new performance.Uniform2f(context, locations.u_extrude_scale),
	        'u_overscale_factor': new performance.Uniform1f(context, locations.u_overscale_factor)
	    };
	};
	var collisionCircleUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_inv_matrix': new performance.UniformMatrix4f(context, locations.u_inv_matrix),
	        'u_camera_to_center_distance': new performance.Uniform1f(context, locations.u_camera_to_center_distance),
	        'u_viewport_size': new performance.Uniform2f(context, locations.u_viewport_size)
	    };
	};
	var collisionUniformValues = function (matrix, transform, tile) {
	    var pixelRatio = pixelsToTileUnits(tile, 1, transform.zoom);
	    var scale = Math.pow(2, transform.zoom - tile.tileID.overscaledZ);
	    var overscaleFactor = tile.tileID.overscaleFactor();
	    return {
	        'u_matrix': matrix,
	        'u_camera_to_center_distance': transform.cameraToCenterDistance,
	        'u_pixels_to_tile_units': pixelRatio,
	        'u_extrude_scale': [
	            transform.pixelsToGLUnits[0] / (pixelRatio * scale),
	            transform.pixelsToGLUnits[1] / (pixelRatio * scale)
	        ],
	        'u_overscale_factor': overscaleFactor
	    };
	};
	var collisionCircleUniformValues = function (matrix, invMatrix, transform) {
	    return {
	        'u_matrix': matrix,
	        'u_inv_matrix': invMatrix,
	        'u_camera_to_center_distance': transform.cameraToCenterDistance,
	        'u_viewport_size': [
	            transform.width,
	            transform.height
	        ]
	    };
	};

	var debugUniforms = function (context, locations) {
	    return {
	        'u_color': new performance.UniformColor(context, locations.u_color),
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_overlay': new performance.Uniform1i(context, locations.u_overlay),
	        'u_overlay_scale': new performance.Uniform1f(context, locations.u_overlay_scale)
	    };
	};
	var debugUniformValues = function (matrix, color, scaleRatio) {
	    if (scaleRatio === void 0)
	        scaleRatio = 1;
	    return {
	        'u_matrix': matrix,
	        'u_color': color,
	        'u_overlay': 0,
	        'u_overlay_scale': scaleRatio
	    };
	};

	var clippingMaskUniforms = function (context, locations) {
	    return { 'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix) };
	};
	var clippingMaskUniformValues = function (matrix) {
	    return { 'u_matrix': matrix };
	};

	var heatmapUniforms = function (context, locations) {
	    return {
	        'u_extrude_scale': new performance.Uniform1f(context, locations.u_extrude_scale),
	        'u_intensity': new performance.Uniform1f(context, locations.u_intensity),
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix)
	    };
	};
	var heatmapTextureUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_world': new performance.Uniform2f(context, locations.u_world),
	        'u_image': new performance.Uniform1i(context, locations.u_image),
	        'u_color_ramp': new performance.Uniform1i(context, locations.u_color_ramp),
	        'u_opacity': new performance.Uniform1f(context, locations.u_opacity)
	    };
	};
	var heatmapUniformValues = function (matrix, tile, zoom, intensity) {
	    return {
	        'u_matrix': matrix,
	        'u_extrude_scale': pixelsToTileUnits(tile, 1, zoom),
	        'u_intensity': intensity
	    };
	};
	var heatmapTextureUniformValues = function (painter, layer, textureUnit, colorRampUnit) {
	    var matrix = performance.create();
	    performance.ortho(matrix, 0, painter.width, painter.height, 0, 0, 1);
	    var gl = painter.context.gl;
	    return {
	        'u_matrix': matrix,
	        'u_world': [
	            gl.drawingBufferWidth,
	            gl.drawingBufferHeight
	        ],
	        'u_image': textureUnit,
	        'u_color_ramp': colorRampUnit,
	        'u_opacity': layer.paint.get('heatmap-opacity')
	    };
	};

	var hillshadeUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_image': new performance.Uniform1i(context, locations.u_image),
	        'u_latrange': new performance.Uniform2f(context, locations.u_latrange),
	        'u_light': new performance.Uniform2f(context, locations.u_light),
	        'u_shadow': new performance.UniformColor(context, locations.u_shadow),
	        'u_highlight': new performance.UniformColor(context, locations.u_highlight),
	        'u_accent': new performance.UniformColor(context, locations.u_accent)
	    };
	};
	var hillshadePrepareUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_image': new performance.Uniform1i(context, locations.u_image),
	        'u_dimension': new performance.Uniform2f(context, locations.u_dimension),
	        'u_zoom': new performance.Uniform1f(context, locations.u_zoom),
	        'u_unpack': new performance.Uniform4f(context, locations.u_unpack)
	    };
	};
	var hillshadeUniformValues = function (painter, tile, layer) {
	    var shadow = layer.paint.get('hillshade-shadow-color');
	    var highlight = layer.paint.get('hillshade-highlight-color');
	    var accent = layer.paint.get('hillshade-accent-color');
	    var azimuthal = layer.paint.get('hillshade-illumination-direction') * (Math.PI / 180);
	    if (layer.paint.get('hillshade-illumination-anchor') === 'viewport') {
	        azimuthal -= painter.transform.angle;
	    }
	    var align = !painter.options.moving;
	    return {
	        'u_matrix': painter.transform.calculatePosMatrix(tile.tileID.toUnwrapped(), align),
	        'u_image': 0,
	        'u_latrange': getTileLatRange(painter, tile.tileID),
	        'u_light': [
	            layer.paint.get('hillshade-exaggeration'),
	            azimuthal
	        ],
	        'u_shadow': shadow,
	        'u_highlight': highlight,
	        'u_accent': accent
	    };
	};
	var hillshadeUniformPrepareValues = function (tileID, dem) {
	    var stride = dem.stride;
	    var matrix = performance.create();
	    performance.ortho(matrix, 0, performance.EXTENT, -performance.EXTENT, 0, 0, 1);
	    performance.translate(matrix, matrix, [
	        0,
	        -performance.EXTENT,
	        0
	    ]);
	    return {
	        'u_matrix': matrix,
	        'u_image': 1,
	        'u_dimension': [
	            stride,
	            stride
	        ],
	        'u_zoom': tileID.overscaledZ,
	        'u_unpack': dem.getUnpackVector()
	    };
	};
	function getTileLatRange(painter, tileID) {
	    var tilesAtZoom = Math.pow(2, tileID.canonical.z);
	    var y = tileID.canonical.y;
	    return [
	        new performance.MercatorCoordinate(0, y / tilesAtZoom).toLngLat().lat,
	        new performance.MercatorCoordinate(0, (y + 1) / tilesAtZoom).toLngLat().lat
	    ];
	}

	var lineUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_ratio': new performance.Uniform1f(context, locations.u_ratio),
	        'u_device_pixel_ratio': new performance.Uniform1f(context, locations.u_device_pixel_ratio),
	        'u_units_to_pixels': new performance.Uniform2f(context, locations.u_units_to_pixels)
	    };
	};
	var lineGradientUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_ratio': new performance.Uniform1f(context, locations.u_ratio),
	        'u_device_pixel_ratio': new performance.Uniform1f(context, locations.u_device_pixel_ratio),
	        'u_units_to_pixels': new performance.Uniform2f(context, locations.u_units_to_pixels),
	        'u_image': new performance.Uniform1i(context, locations.u_image),
	        'u_image_height': new performance.Uniform1f(context, locations.u_image_height)
	    };
	};
	var linePatternUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_texsize': new performance.Uniform2f(context, locations.u_texsize),
	        'u_ratio': new performance.Uniform1f(context, locations.u_ratio),
	        'u_device_pixel_ratio': new performance.Uniform1f(context, locations.u_device_pixel_ratio),
	        'u_image': new performance.Uniform1i(context, locations.u_image),
	        'u_units_to_pixels': new performance.Uniform2f(context, locations.u_units_to_pixels),
	        'u_scale': new performance.Uniform3f(context, locations.u_scale),
	        'u_fade': new performance.Uniform1f(context, locations.u_fade)
	    };
	};
	var lineSDFUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_ratio': new performance.Uniform1f(context, locations.u_ratio),
	        'u_device_pixel_ratio': new performance.Uniform1f(context, locations.u_device_pixel_ratio),
	        'u_units_to_pixels': new performance.Uniform2f(context, locations.u_units_to_pixels),
	        'u_patternscale_a': new performance.Uniform2f(context, locations.u_patternscale_a),
	        'u_patternscale_b': new performance.Uniform2f(context, locations.u_patternscale_b),
	        'u_sdfgamma': new performance.Uniform1f(context, locations.u_sdfgamma),
	        'u_image': new performance.Uniform1i(context, locations.u_image),
	        'u_tex_y_a': new performance.Uniform1f(context, locations.u_tex_y_a),
	        'u_tex_y_b': new performance.Uniform1f(context, locations.u_tex_y_b),
	        'u_mix': new performance.Uniform1f(context, locations.u_mix)
	    };
	};
	var lineUniformValues = function (painter, tile, layer) {
	    var transform = painter.transform;
	    return {
	        'u_matrix': calculateMatrix(painter, tile, layer),
	        'u_ratio': 1 / pixelsToTileUnits(tile, 1, transform.zoom),
	        'u_device_pixel_ratio': performance.browser.devicePixelRatio,
	        'u_units_to_pixels': [
	            1 / transform.pixelsToGLUnits[0],
	            1 / transform.pixelsToGLUnits[1]
	        ]
	    };
	};
	var lineGradientUniformValues = function (painter, tile, layer, imageHeight) {
	    return performance.extend(lineUniformValues(painter, tile, layer), {
	        'u_image': 0,
	        'u_image_height': imageHeight
	    });
	};
	var linePatternUniformValues = function (painter, tile, layer, crossfade) {
	    var transform = painter.transform;
	    var tileZoomRatio = calculateTileRatio(tile, transform);
	    return {
	        'u_matrix': calculateMatrix(painter, tile, layer),
	        'u_texsize': tile.imageAtlasTexture.size,
	        'u_ratio': 1 / pixelsToTileUnits(tile, 1, transform.zoom),
	        'u_device_pixel_ratio': performance.browser.devicePixelRatio,
	        'u_image': 0,
	        'u_scale': [
	            tileZoomRatio,
	            crossfade.fromScale,
	            crossfade.toScale
	        ],
	        'u_fade': crossfade.t,
	        'u_units_to_pixels': [
	            1 / transform.pixelsToGLUnits[0],
	            1 / transform.pixelsToGLUnits[1]
	        ]
	    };
	};
	var lineSDFUniformValues = function (painter, tile, layer, dasharray, crossfade) {
	    var transform = painter.transform;
	    var lineAtlas = painter.lineAtlas;
	    var tileRatio = calculateTileRatio(tile, transform);
	    var round = layer.layout.get('line-cap') === 'round';
	    var posA = lineAtlas.getDash(dasharray.from, round);
	    var posB = lineAtlas.getDash(dasharray.to, round);
	    var widthA = posA.width * crossfade.fromScale;
	    var widthB = posB.width * crossfade.toScale;
	    return performance.extend(lineUniformValues(painter, tile, layer), {
	        'u_patternscale_a': [
	            tileRatio / widthA,
	            -posA.height / 2
	        ],
	        'u_patternscale_b': [
	            tileRatio / widthB,
	            -posB.height / 2
	        ],
	        'u_sdfgamma': lineAtlas.width / (Math.min(widthA, widthB) * 256 * performance.browser.devicePixelRatio) / 2,
	        'u_image': 0,
	        'u_tex_y_a': posA.y,
	        'u_tex_y_b': posB.y,
	        'u_mix': crossfade.t
	    });
	};
	function calculateTileRatio(tile, transform) {
	    return 1 / pixelsToTileUnits(tile, 1, transform.tileZoom);
	}
	function calculateMatrix(painter, tile, layer) {
	    return painter.translatePosMatrix(tile.tileID.posMatrix, tile, layer.paint.get('line-translate'), layer.paint.get('line-translate-anchor'));
	}

	var rasterUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_tl_parent': new performance.Uniform2f(context, locations.u_tl_parent),
	        'u_scale_parent': new performance.Uniform1f(context, locations.u_scale_parent),
	        'u_buffer_scale': new performance.Uniform1f(context, locations.u_buffer_scale),
	        'u_fade_t': new performance.Uniform1f(context, locations.u_fade_t),
	        'u_opacity': new performance.Uniform1f(context, locations.u_opacity),
	        'u_image0': new performance.Uniform1i(context, locations.u_image0),
	        'u_image1': new performance.Uniform1i(context, locations.u_image1),
	        'u_brightness_low': new performance.Uniform1f(context, locations.u_brightness_low),
	        'u_brightness_high': new performance.Uniform1f(context, locations.u_brightness_high),
	        'u_saturation_factor': new performance.Uniform1f(context, locations.u_saturation_factor),
	        'u_contrast_factor': new performance.Uniform1f(context, locations.u_contrast_factor),
	        'u_spin_weights': new performance.Uniform3f(context, locations.u_spin_weights)
	    };
	};
	var rasterUniformValues = function (matrix, parentTL, parentScaleBy, fade, layer) {
	    return {
	        'u_matrix': matrix,
	        'u_tl_parent': parentTL,
	        'u_scale_parent': parentScaleBy,
	        'u_buffer_scale': 1,
	        'u_fade_t': fade.mix,
	        'u_opacity': fade.opacity * layer.paint.get('raster-opacity'),
	        'u_image0': 0,
	        'u_image1': 1,
	        'u_brightness_low': layer.paint.get('raster-brightness-min'),
	        'u_brightness_high': layer.paint.get('raster-brightness-max'),
	        'u_saturation_factor': saturationFactor(layer.paint.get('raster-saturation')),
	        'u_contrast_factor': contrastFactor(layer.paint.get('raster-contrast')),
	        'u_spin_weights': spinWeights(layer.paint.get('raster-hue-rotate'))
	    };
	};
	function spinWeights(angle) {
	    angle *= Math.PI / 180;
	    var s = Math.sin(angle);
	    var c = Math.cos(angle);
	    return [
	        (2 * c + 1) / 3,
	        (-Math.sqrt(3) * s - c + 1) / 3,
	        (Math.sqrt(3) * s - c + 1) / 3
	    ];
	}
	function contrastFactor(contrast) {
	    return contrast > 0 ? 1 / (1 - contrast) : 1 + contrast;
	}
	function saturationFactor(saturation) {
	    return saturation > 0 ? 1 - 1 / (1.001 - saturation) : -saturation;
	}

	var symbolIconUniforms = function (context, locations) {
	    return {
	        'u_is_size_zoom_constant': new performance.Uniform1i(context, locations.u_is_size_zoom_constant),
	        'u_is_size_feature_constant': new performance.Uniform1i(context, locations.u_is_size_feature_constant),
	        'u_size_t': new performance.Uniform1f(context, locations.u_size_t),
	        'u_size': new performance.Uniform1f(context, locations.u_size),
	        'u_camera_to_center_distance': new performance.Uniform1f(context, locations.u_camera_to_center_distance),
	        'u_pitch': new performance.Uniform1f(context, locations.u_pitch),
	        'u_rotate_symbol': new performance.Uniform1i(context, locations.u_rotate_symbol),
	        'u_aspect_ratio': new performance.Uniform1f(context, locations.u_aspect_ratio),
	        'u_fade_change': new performance.Uniform1f(context, locations.u_fade_change),
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_label_plane_matrix': new performance.UniformMatrix4f(context, locations.u_label_plane_matrix),
	        'u_coord_matrix': new performance.UniformMatrix4f(context, locations.u_coord_matrix),
	        'u_is_text': new performance.Uniform1i(context, locations.u_is_text),
	        'u_pitch_with_map': new performance.Uniform1i(context, locations.u_pitch_with_map),
	        'u_texsize': new performance.Uniform2f(context, locations.u_texsize),
	        'u_texture': new performance.Uniform1i(context, locations.u_texture)
	    };
	};
	var symbolSDFUniforms = function (context, locations) {
	    return {
	        'u_is_size_zoom_constant': new performance.Uniform1i(context, locations.u_is_size_zoom_constant),
	        'u_is_size_feature_constant': new performance.Uniform1i(context, locations.u_is_size_feature_constant),
	        'u_size_t': new performance.Uniform1f(context, locations.u_size_t),
	        'u_size': new performance.Uniform1f(context, locations.u_size),
	        'u_camera_to_center_distance': new performance.Uniform1f(context, locations.u_camera_to_center_distance),
	        'u_pitch': new performance.Uniform1f(context, locations.u_pitch),
	        'u_rotate_symbol': new performance.Uniform1i(context, locations.u_rotate_symbol),
	        'u_aspect_ratio': new performance.Uniform1f(context, locations.u_aspect_ratio),
	        'u_fade_change': new performance.Uniform1f(context, locations.u_fade_change),
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_label_plane_matrix': new performance.UniformMatrix4f(context, locations.u_label_plane_matrix),
	        'u_coord_matrix': new performance.UniformMatrix4f(context, locations.u_coord_matrix),
	        'u_is_text': new performance.Uniform1i(context, locations.u_is_text),
	        'u_pitch_with_map': new performance.Uniform1i(context, locations.u_pitch_with_map),
	        'u_texsize': new performance.Uniform2f(context, locations.u_texsize),
	        'u_texture': new performance.Uniform1i(context, locations.u_texture),
	        'u_gamma_scale': new performance.Uniform1f(context, locations.u_gamma_scale),
	        'u_device_pixel_ratio': new performance.Uniform1f(context, locations.u_device_pixel_ratio),
	        'u_is_halo': new performance.Uniform1i(context, locations.u_is_halo)
	    };
	};
	var symbolTextAndIconUniforms = function (context, locations) {
	    return {
	        'u_is_size_zoom_constant': new performance.Uniform1i(context, locations.u_is_size_zoom_constant),
	        'u_is_size_feature_constant': new performance.Uniform1i(context, locations.u_is_size_feature_constant),
	        'u_size_t': new performance.Uniform1f(context, locations.u_size_t),
	        'u_size': new performance.Uniform1f(context, locations.u_size),
	        'u_camera_to_center_distance': new performance.Uniform1f(context, locations.u_camera_to_center_distance),
	        'u_pitch': new performance.Uniform1f(context, locations.u_pitch),
	        'u_rotate_symbol': new performance.Uniform1i(context, locations.u_rotate_symbol),
	        'u_aspect_ratio': new performance.Uniform1f(context, locations.u_aspect_ratio),
	        'u_fade_change': new performance.Uniform1f(context, locations.u_fade_change),
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_label_plane_matrix': new performance.UniformMatrix4f(context, locations.u_label_plane_matrix),
	        'u_coord_matrix': new performance.UniformMatrix4f(context, locations.u_coord_matrix),
	        'u_is_text': new performance.Uniform1i(context, locations.u_is_text),
	        'u_pitch_with_map': new performance.Uniform1i(context, locations.u_pitch_with_map),
	        'u_texsize': new performance.Uniform2f(context, locations.u_texsize),
	        'u_texsize_icon': new performance.Uniform2f(context, locations.u_texsize_icon),
	        'u_texture': new performance.Uniform1i(context, locations.u_texture),
	        'u_texture_icon': new performance.Uniform1i(context, locations.u_texture_icon),
	        'u_gamma_scale': new performance.Uniform1f(context, locations.u_gamma_scale),
	        'u_device_pixel_ratio': new performance.Uniform1f(context, locations.u_device_pixel_ratio),
	        'u_is_halo': new performance.Uniform1i(context, locations.u_is_halo)
	    };
	};
	var symbolIconUniformValues = function (functionType, size, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, isText, texSize) {
	    var transform = painter.transform;
	    return {
	        'u_is_size_zoom_constant': +(functionType === 'constant' || functionType === 'source'),
	        'u_is_size_feature_constant': +(functionType === 'constant' || functionType === 'camera'),
	        'u_size_t': size ? size.uSizeT : 0,
	        'u_size': size ? size.uSize : 0,
	        'u_camera_to_center_distance': transform.cameraToCenterDistance,
	        'u_pitch': transform.pitch / 360 * 2 * Math.PI,
	        'u_rotate_symbol': +rotateInShader,
	        'u_aspect_ratio': transform.width / transform.height,
	        'u_fade_change': painter.options.fadeDuration ? painter.symbolFadeChange : 1,
	        'u_matrix': matrix,
	        'u_label_plane_matrix': labelPlaneMatrix,
	        'u_coord_matrix': glCoordMatrix,
	        'u_is_text': +isText,
	        'u_pitch_with_map': +pitchWithMap,
	        'u_texsize': texSize,
	        'u_texture': 0
	    };
	};
	var symbolSDFUniformValues = function (functionType, size, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, isText, texSize, isHalo) {
	    var transform = painter.transform;
	    return performance.extend(symbolIconUniformValues(functionType, size, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, isText, texSize), {
	        'u_gamma_scale': pitchWithMap ? Math.cos(transform._pitch) * transform.cameraToCenterDistance : 1,
	        'u_device_pixel_ratio': performance.browser.devicePixelRatio,
	        'u_is_halo': +isHalo
	    });
	};
	var symbolTextAndIconUniformValues = function (functionType, size, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, texSizeSDF, texSizeIcon) {
	    return performance.extend(symbolSDFUniformValues(functionType, size, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, true, texSizeSDF, true), {
	        'u_texsize_icon': texSizeIcon,
	        'u_texture_icon': 1
	    });
	};

	var backgroundUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_opacity': new performance.Uniform1f(context, locations.u_opacity),
	        'u_color': new performance.UniformColor(context, locations.u_color)
	    };
	};
	var backgroundPatternUniforms = function (context, locations) {
	    return {
	        'u_matrix': new performance.UniformMatrix4f(context, locations.u_matrix),
	        'u_opacity': new performance.Uniform1f(context, locations.u_opacity),
	        'u_image': new performance.Uniform1i(context, locations.u_image),
	        'u_pattern_tl_a': new performance.Uniform2f(context, locations.u_pattern_tl_a),
	        'u_pattern_br_a': new performance.Uniform2f(context, locations.u_pattern_br_a),
	        'u_pattern_tl_b': new performance.Uniform2f(context, locations.u_pattern_tl_b),
	        'u_pattern_br_b': new performance.Uniform2f(context, locations.u_pattern_br_b),
	        'u_texsize': new performance.Uniform2f(context, locations.u_texsize),
	        'u_mix': new performance.Uniform1f(context, locations.u_mix),
	        'u_pattern_size_a': new performance.Uniform2f(context, locations.u_pattern_size_a),
	        'u_pattern_size_b': new performance.Uniform2f(context, locations.u_pattern_size_b),
	        'u_scale_a': new performance.Uniform1f(context, locations.u_scale_a),
	        'u_scale_b': new performance.Uniform1f(context, locations.u_scale_b),
	        'u_pixel_coord_upper': new performance.Uniform2f(context, locations.u_pixel_coord_upper),
	        'u_pixel_coord_lower': new performance.Uniform2f(context, locations.u_pixel_coord_lower),
	        'u_tile_units_to_pixels': new performance.Uniform1f(context, locations.u_tile_units_to_pixels)
	    };
	};
	var backgroundUniformValues = function (matrix, opacity, color) {
	    return {
	        'u_matrix': matrix,
	        'u_opacity': opacity,
	        'u_color': color
	    };
	};
	var backgroundPatternUniformValues = function (matrix, opacity, painter, image, tile, crossfade) {
	    return performance.extend(bgPatternUniformValues(image, crossfade, painter, tile), {
	        'u_matrix': matrix,
	        'u_opacity': opacity
	    });
	};

	var programUniforms = {
	    fillExtrusion: fillExtrusionUniforms,
	    fillExtrusionPattern: fillExtrusionPatternUniforms,
	    fill: fillUniforms,
	    fillPattern: fillPatternUniforms,
	    fillOutline: fillOutlineUniforms,
	    fillOutlinePattern: fillOutlinePatternUniforms,
	    circle: circleUniforms,
	    collisionBox: collisionUniforms,
	    collisionCircle: collisionCircleUniforms,
	    debug: debugUniforms,
	    clippingMask: clippingMaskUniforms,
	    heatmap: heatmapUniforms,
	    heatmapTexture: heatmapTextureUniforms,
	    hillshade: hillshadeUniforms,
	    hillshadePrepare: hillshadePrepareUniforms,
	    line: lineUniforms,
	    lineGradient: lineGradientUniforms,
	    linePattern: linePatternUniforms,
	    lineSDF: lineSDFUniforms,
	    raster: rasterUniforms,
	    symbolIcon: symbolIconUniforms,
	    symbolSDF: symbolSDFUniforms,
	    symbolTextAndIcon: symbolTextAndIconUniforms,
	    background: backgroundUniforms,
	    backgroundPattern: backgroundPatternUniforms
	};

	var quadTriangles;
	function drawCollisionDebug(painter, sourceCache, layer, coords, translate, translateAnchor, isText) {
	    var context = painter.context;
	    var gl = context.gl;
	    var program = painter.useProgram('collisionBox');
	    var tileBatches = [];
	    var circleCount = 0;
	    var circleOffset = 0;
	    for (var i = 0; i < coords.length; i++) {
	        var coord = coords[i];
	        var tile = sourceCache.getTile(coord);
	        var bucket = tile.getBucket(layer);
	        if (!bucket) {
	            continue;
	        }
	        var posMatrix = coord.posMatrix;
	        if (translate[0] !== 0 || translate[1] !== 0) {
	            posMatrix = painter.translatePosMatrix(coord.posMatrix, tile, translate, translateAnchor);
	        }
	        var buffers = isText ? bucket.textCollisionBox : bucket.iconCollisionBox;
	        var circleArray = bucket.collisionCircleArray;
	        if (circleArray.length > 0) {
	            var invTransform = performance.create();
	            var transform = posMatrix;
	            performance.mul(invTransform, bucket.placementInvProjMatrix, painter.transform.glCoordMatrix);
	            performance.mul(invTransform, invTransform, bucket.placementViewportMatrix);
	            tileBatches.push({
	                circleArray: circleArray,
	                circleOffset: circleOffset,
	                transform: transform,
	                invTransform: invTransform
	            });
	            circleCount += circleArray.length / 4;
	            circleOffset = circleCount;
	        }
	        if (!buffers) {
	            continue;
	        }
	        program.draw(context, gl.LINES, DepthMode.disabled, StencilMode.disabled, painter.colorModeForRenderPass(), CullFaceMode.disabled, collisionUniformValues(posMatrix, painter.transform, tile), layer.id, buffers.layoutVertexBuffer, buffers.indexBuffer, buffers.segments, null, painter.transform.zoom, null, null, buffers.collisionVertexBuffer);
	    }
	    if (!isText || !tileBatches.length) {
	        return;
	    }
	    var circleProgram = painter.useProgram('collisionCircle');
	    var vertexData = new performance.StructArrayLayout2f1f2i16();
	    vertexData.resize(circleCount * 4);
	    vertexData._trim();
	    var vertexOffset = 0;
	    for (var i$2 = 0, list = tileBatches; i$2 < list.length; i$2 += 1) {
	        var batch = list[i$2];
	        for (var i$1 = 0; i$1 < batch.circleArray.length / 4; i$1++) {
	            var circleIdx = i$1 * 4;
	            var x = batch.circleArray[circleIdx + 0];
	            var y = batch.circleArray[circleIdx + 1];
	            var radius = batch.circleArray[circleIdx + 2];
	            var collision = batch.circleArray[circleIdx + 3];
	            vertexData.emplace(vertexOffset++, x, y, radius, collision, 0);
	            vertexData.emplace(vertexOffset++, x, y, radius, collision, 1);
	            vertexData.emplace(vertexOffset++, x, y, radius, collision, 2);
	            vertexData.emplace(vertexOffset++, x, y, radius, collision, 3);
	        }
	    }
	    if (!quadTriangles || quadTriangles.length < circleCount * 2) {
	        quadTriangles = createQuadTriangles(circleCount);
	    }
	    var indexBuffer = context.createIndexBuffer(quadTriangles, true);
	    var vertexBuffer = context.createVertexBuffer(vertexData, performance.collisionCircleLayout.members, true);
	    for (var i$3 = 0, list$1 = tileBatches; i$3 < list$1.length; i$3 += 1) {
	        var batch$1 = list$1[i$3];
	        var uniforms = collisionCircleUniformValues(batch$1.transform, batch$1.invTransform, painter.transform);
	        circleProgram.draw(context, gl.TRIANGLES, DepthMode.disabled, StencilMode.disabled, painter.colorModeForRenderPass(), CullFaceMode.disabled, uniforms, layer.id, vertexBuffer, indexBuffer, performance.SegmentVector.simpleSegment(0, batch$1.circleOffset * 2, batch$1.circleArray.length, batch$1.circleArray.length / 2), null, painter.transform.zoom, null, null, null);
	    }
	    vertexBuffer.destroy();
	    indexBuffer.destroy();
	}
	function createQuadTriangles(quadCount) {
	    var triCount = quadCount * 2;
	    var array = new performance.StructArrayLayout3ui6();
	    array.resize(triCount);
	    array._trim();
	    for (var i = 0; i < triCount; i++) {
	        var idx = i * 6;
	        array.uint16[idx + 0] = i * 4 + 0;
	        array.uint16[idx + 1] = i * 4 + 1;
	        array.uint16[idx + 2] = i * 4 + 2;
	        array.uint16[idx + 3] = i * 4 + 2;
	        array.uint16[idx + 4] = i * 4 + 3;
	        array.uint16[idx + 5] = i * 4 + 0;
	    }
	    return array;
	}

	var identityMat4 = performance.identity(new Float32Array(16));
	function drawSymbols(painter, sourceCache, layer, coords, variableOffsets) {
	    if (painter.renderPass !== 'translucent') {
	        return;
	    }
	    var stencilMode = StencilMode.disabled;
	    var colorMode = painter.colorModeForRenderPass();
	    var variablePlacement = layer.layout.get('text-variable-anchor');
	    if (variablePlacement) {
	        updateVariableAnchors(coords, painter, layer, sourceCache, layer.layout.get('text-rotation-alignment'), layer.layout.get('text-pitch-alignment'), variableOffsets);
	    }
	    if (layer.paint.get('icon-opacity').constantOr(1) !== 0) {
	        drawLayerSymbols(painter, sourceCache, layer, coords, false, layer.paint.get('icon-translate'), layer.paint.get('icon-translate-anchor'), layer.layout.get('icon-rotation-alignment'), layer.layout.get('icon-pitch-alignment'), layer.layout.get('icon-keep-upright'), stencilMode, colorMode);
	    }
	    if (layer.paint.get('text-opacity').constantOr(1) !== 0) {
	        drawLayerSymbols(painter, sourceCache, layer, coords, true, layer.paint.get('text-translate'), layer.paint.get('text-translate-anchor'), layer.layout.get('text-rotation-alignment'), layer.layout.get('text-pitch-alignment'), layer.layout.get('text-keep-upright'), stencilMode, colorMode);
	    }
	    if (sourceCache.map.showCollisionBoxes) {
	        drawCollisionDebug(painter, sourceCache, layer, coords, layer.paint.get('text-translate'), layer.paint.get('text-translate-anchor'), true);
	        drawCollisionDebug(painter, sourceCache, layer, coords, layer.paint.get('icon-translate'), layer.paint.get('icon-translate-anchor'), false);
	    }
	}
	function calculateVariableRenderShift(anchor, width, height, textOffset, textBoxScale, renderTextSize) {
	    var ref = performance.getAnchorAlignment(anchor);
	    var horizontalAlign = ref.horizontalAlign;
	    var verticalAlign = ref.verticalAlign;
	    var shiftX = -(horizontalAlign - 0.5) * width;
	    var shiftY = -(verticalAlign - 0.5) * height;
	    var variableOffset = performance.evaluateVariableOffset(anchor, textOffset);
	    return new performance.Point((shiftX / textBoxScale + variableOffset[0]) * renderTextSize, (shiftY / textBoxScale + variableOffset[1]) * renderTextSize);
	}
	function updateVariableAnchors(coords, painter, layer, sourceCache, rotationAlignment, pitchAlignment, variableOffsets) {
	    var tr = painter.transform;
	    var rotateWithMap = rotationAlignment === 'map';
	    var pitchWithMap = pitchAlignment === 'map';
	    for (var i = 0, list = coords; i < list.length; i += 1) {
	        var coord = list[i];
	        var tile = sourceCache.getTile(coord);
	        var bucket = tile.getBucket(layer);
	        if (!bucket || !bucket.text || !bucket.text.segments.get().length) {
	            continue;
	        }
	        var sizeData = bucket.textSizeData;
	        var size = performance.evaluateSizeForZoom(sizeData, tr.zoom);
	        var pixelToTileScale = pixelsToTileUnits(tile, 1, painter.transform.zoom);
	        var labelPlaneMatrix = getLabelPlaneMatrix(coord.posMatrix, pitchWithMap, rotateWithMap, painter.transform, pixelToTileScale);
	        var updateTextFitIcon = layer.layout.get('icon-text-fit') !== 'none' && bucket.hasIconData();
	        if (size) {
	            var tileScale = Math.pow(2, tr.zoom - tile.tileID.overscaledZ);
	            updateVariableAnchorsForBucket(bucket, rotateWithMap, pitchWithMap, variableOffsets, performance.symbolSize, tr, labelPlaneMatrix, coord.posMatrix, tileScale, size, updateTextFitIcon);
	        }
	    }
	}
	function updateVariableAnchorsForBucket(bucket, rotateWithMap, pitchWithMap, variableOffsets, symbolSize, transform, labelPlaneMatrix, posMatrix, tileScale, size, updateTextFitIcon) {
	    var placedSymbols = bucket.text.placedSymbolArray;
	    var dynamicTextLayoutVertexArray = bucket.text.dynamicLayoutVertexArray;
	    var dynamicIconLayoutVertexArray = bucket.icon.dynamicLayoutVertexArray;
	    var placedTextShifts = {};
	    dynamicTextLayoutVertexArray.clear();
	    for (var s = 0; s < placedSymbols.length; s++) {
	        var symbol = placedSymbols.get(s);
	        var skipOrientation = bucket.allowVerticalPlacement && !symbol.placedOrientation;
	        var variableOffset = !symbol.hidden && symbol.crossTileID && !skipOrientation ? variableOffsets[symbol.crossTileID] : null;
	        if (!variableOffset) {
	            hideGlyphs(symbol.numGlyphs, dynamicTextLayoutVertexArray);
	        } else {
	            var tileAnchor = new performance.Point(symbol.anchorX, symbol.anchorY);
	            var projectedAnchor = project(tileAnchor, pitchWithMap ? posMatrix : labelPlaneMatrix);
	            var perspectiveRatio = getPerspectiveRatio(transform.cameraToCenterDistance, projectedAnchor.signedDistanceFromCamera);
	            var renderTextSize = symbolSize.evaluateSizeForFeature(bucket.textSizeData, size, symbol) * perspectiveRatio / performance.ONE_EM;
	            if (pitchWithMap) {
	                renderTextSize *= bucket.tilePixelRatio / tileScale;
	            }
	            var width = variableOffset.width;
	            var height = variableOffset.height;
	            var anchor = variableOffset.anchor;
	            var textOffset = variableOffset.textOffset;
	            var textBoxScale = variableOffset.textBoxScale;
	            var shift = calculateVariableRenderShift(anchor, width, height, textOffset, textBoxScale, renderTextSize);
	            var shiftedAnchor = pitchWithMap ? project(tileAnchor.add(shift), labelPlaneMatrix).point : projectedAnchor.point.add(rotateWithMap ? shift.rotate(-transform.angle) : shift);
	            var angle = bucket.allowVerticalPlacement && symbol.placedOrientation === performance.WritingMode.vertical ? Math.PI / 2 : 0;
	            for (var g = 0; g < symbol.numGlyphs; g++) {
	                performance.addDynamicAttributes(dynamicTextLayoutVertexArray, shiftedAnchor, angle);
	            }
	            if (updateTextFitIcon && symbol.associatedIconIndex >= 0) {
	                placedTextShifts[symbol.associatedIconIndex] = {
	                    shiftedAnchor: shiftedAnchor,
	                    angle: angle
	                };
	            }
	        }
	    }
	    if (updateTextFitIcon) {
	        dynamicIconLayoutVertexArray.clear();
	        var placedIcons = bucket.icon.placedSymbolArray;
	        for (var i = 0; i < placedIcons.length; i++) {
	            var placedIcon = placedIcons.get(i);
	            if (placedIcon.hidden) {
	                hideGlyphs(placedIcon.numGlyphs, dynamicIconLayoutVertexArray);
	            } else {
	                var shift$1 = placedTextShifts[i];
	                if (!shift$1) {
	                    hideGlyphs(placedIcon.numGlyphs, dynamicIconLayoutVertexArray);
	                } else {
	                    for (var g$1 = 0; g$1 < placedIcon.numGlyphs; g$1++) {
	                        performance.addDynamicAttributes(dynamicIconLayoutVertexArray, shift$1.shiftedAnchor, shift$1.angle);
	                    }
	                }
	            }
	        }
	        bucket.icon.dynamicLayoutVertexBuffer.updateData(dynamicIconLayoutVertexArray);
	    }
	    bucket.text.dynamicLayoutVertexBuffer.updateData(dynamicTextLayoutVertexArray);
	}
	function getSymbolProgramName(isSDF, isText, bucket) {
	    if (bucket.iconsInText && isText) {
	        return 'symbolTextAndIcon';
	    } else if (isSDF) {
	        return 'symbolSDF';
	    } else {
	        return 'symbolIcon';
	    }
	}
	function drawLayerSymbols(painter, sourceCache, layer, coords, isText, translate, translateAnchor, rotationAlignment, pitchAlignment, keepUpright, stencilMode, colorMode) {
	    var context = painter.context;
	    var gl = context.gl;
	    var tr = painter.transform;
	    var rotateWithMap = rotationAlignment === 'map';
	    var pitchWithMap = pitchAlignment === 'map';
	    var alongLine = rotateWithMap && layer.layout.get('symbol-placement') !== 'point';
	    var rotateInShader = rotateWithMap && !pitchWithMap && !alongLine;
	    var hasSortKey = layer.layout.get('symbol-sort-key').constantOr(1) !== undefined;
	    var sortFeaturesByKey = false;
	    var depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);
	    var variablePlacement = layer.layout.get('text-variable-anchor');
	    var tileRenderState = [];
	    for (var i$1 = 0, list$1 = coords; i$1 < list$1.length; i$1 += 1) {
	        var coord = list$1[i$1];
	        var tile = sourceCache.getTile(coord);
	        var bucket = tile.getBucket(layer);
	        if (!bucket) {
	            continue;
	        }
	        var buffers = isText ? bucket.text : bucket.icon;
	        if (!buffers || !buffers.segments.get().length) {
	            continue;
	        }
	        var programConfiguration = buffers.programConfigurations.get(layer.id);
	        var isSDF = isText || bucket.sdfIcons;
	        var sizeData = isText ? bucket.textSizeData : bucket.iconSizeData;
	        var transformed = pitchWithMap || tr.pitch !== 0;
	        var program = painter.useProgram(getSymbolProgramName(isSDF, isText, bucket), programConfiguration);
	        var size = performance.evaluateSizeForZoom(sizeData, tr.zoom);
	        var texSize = void 0;
	        var texSizeIcon = [
	            0,
	            0
	        ];
	        var atlasTexture = void 0;
	        var atlasInterpolation = void 0;
	        var atlasTextureIcon = null;
	        var atlasInterpolationIcon = void 0;
	        if (isText) {
	            atlasTexture = tile.glyphAtlasTexture;
	            atlasInterpolation = gl.LINEAR;
	            texSize = tile.glyphAtlasTexture.size;
	            if (bucket.iconsInText) {
	                texSizeIcon = tile.imageAtlasTexture.size;
	                atlasTextureIcon = tile.imageAtlasTexture;
	                var zoomDependentSize = sizeData.kind === 'composite' || sizeData.kind === 'camera';
	                atlasInterpolationIcon = transformed || painter.options.rotating || painter.options.zooming || zoomDependentSize ? gl.LINEAR : gl.NEAREST;
	            }
	        } else {
	            var iconScaled = layer.layout.get('icon-size').constantOr(0) !== 1 || bucket.iconsNeedLinear;
	            atlasTexture = tile.imageAtlasTexture;
	            atlasInterpolation = isSDF || painter.options.rotating || painter.options.zooming || iconScaled || transformed ? gl.LINEAR : gl.NEAREST;
	            texSize = tile.imageAtlasTexture.size;
	        }
	        var s = pixelsToTileUnits(tile, 1, painter.transform.zoom);
	        var labelPlaneMatrix = getLabelPlaneMatrix(coord.posMatrix, pitchWithMap, rotateWithMap, painter.transform, s);
	        var glCoordMatrix = getGlCoordMatrix(coord.posMatrix, pitchWithMap, rotateWithMap, painter.transform, s);
	        var hasVariableAnchors = variablePlacement && bucket.hasTextData();
	        var updateTextFitIcon = layer.layout.get('icon-text-fit') !== 'none' && hasVariableAnchors && bucket.hasIconData();
	        if (alongLine) {
	            updateLineLabels(bucket, coord.posMatrix, painter, isText, labelPlaneMatrix, glCoordMatrix, pitchWithMap, keepUpright);
	        }
	        var matrix = painter.translatePosMatrix(coord.posMatrix, tile, translate, translateAnchor), uLabelPlaneMatrix = alongLine || isText && variablePlacement || updateTextFitIcon ? identityMat4 : labelPlaneMatrix, uglCoordMatrix = painter.translatePosMatrix(glCoordMatrix, tile, translate, translateAnchor, true);
	        var hasHalo = isSDF && layer.paint.get(isText ? 'text-halo-width' : 'icon-halo-width').constantOr(1) !== 0;
	        var uniformValues = void 0;
	        if (isSDF) {
	            if (!bucket.iconsInText) {
	                uniformValues = symbolSDFUniformValues(sizeData.kind, size, rotateInShader, pitchWithMap, painter, matrix, uLabelPlaneMatrix, uglCoordMatrix, isText, texSize, true);
	            } else {
	                uniformValues = symbolTextAndIconUniformValues(sizeData.kind, size, rotateInShader, pitchWithMap, painter, matrix, uLabelPlaneMatrix, uglCoordMatrix, texSize, texSizeIcon);
	            }
	        } else {
	            uniformValues = symbolIconUniformValues(sizeData.kind, size, rotateInShader, pitchWithMap, painter, matrix, uLabelPlaneMatrix, uglCoordMatrix, isText, texSize);
	        }
	        var state = {
	            program: program,
	            buffers: buffers,
	            uniformValues: uniformValues,
	            atlasTexture: atlasTexture,
	            atlasTextureIcon: atlasTextureIcon,
	            atlasInterpolation: atlasInterpolation,
	            atlasInterpolationIcon: atlasInterpolationIcon,
	            isSDF: isSDF,
	            hasHalo: hasHalo
	        };
	        if (hasSortKey && bucket.canOverlap) {
	            sortFeaturesByKey = true;
	            var oldSegments = buffers.segments.get();
	            for (var i = 0, list = oldSegments; i < list.length; i += 1) {
	                var segment = list[i];
	                tileRenderState.push({
	                    segments: new performance.SegmentVector([segment]),
	                    sortKey: segment.sortKey,
	                    state: state
	                });
	            }
	        } else {
	            tileRenderState.push({
	                segments: buffers.segments,
	                sortKey: 0,
	                state: state
	            });
	        }
	    }
	    if (sortFeaturesByKey) {
	        tileRenderState.sort(function (a, b) {
	            return a.sortKey - b.sortKey;
	        });
	    }
	    for (var i$2 = 0, list$2 = tileRenderState; i$2 < list$2.length; i$2 += 1) {
	        var segmentState = list$2[i$2];
	        var state$1 = segmentState.state;
	        context.activeTexture.set(gl.TEXTURE0);
	        state$1.atlasTexture.bind(state$1.atlasInterpolation, gl.CLAMP_TO_EDGE);
	        if (state$1.atlasTextureIcon) {
	            context.activeTexture.set(gl.TEXTURE1);
	            if (state$1.atlasTextureIcon) {
	                state$1.atlasTextureIcon.bind(state$1.atlasInterpolationIcon, gl.CLAMP_TO_EDGE);
	            }
	        }
	        if (state$1.isSDF) {
	            var uniformValues$1 = state$1.uniformValues;
	            if (state$1.hasHalo) {
	                uniformValues$1['u_is_halo'] = 1;
	                drawSymbolElements(state$1.buffers, segmentState.segments, layer, painter, state$1.program, depthMode, stencilMode, colorMode, uniformValues$1);
	            }
	            uniformValues$1['u_is_halo'] = 0;
	        }
	        drawSymbolElements(state$1.buffers, segmentState.segments, layer, painter, state$1.program, depthMode, stencilMode, colorMode, state$1.uniformValues);
	    }
	}
	function drawSymbolElements(buffers, segments, layer, painter, program, depthMode, stencilMode, colorMode, uniformValues) {
	    var context = painter.context;
	    var gl = context.gl;
	    program.draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, CullFaceMode.disabled, uniformValues, layer.id, buffers.layoutVertexBuffer, buffers.indexBuffer, segments, layer.paint, painter.transform.zoom, buffers.programConfigurations.get(layer.id), buffers.dynamicLayoutVertexBuffer, buffers.opacityVertexBuffer);
	}

	function drawCircles(painter, sourceCache, layer, coords) {
	    if (painter.renderPass !== 'translucent') {
	        return;
	    }
	    var opacity = layer.paint.get('circle-opacity');
	    var strokeWidth = layer.paint.get('circle-stroke-width');
	    var strokeOpacity = layer.paint.get('circle-stroke-opacity');
	    var sortFeaturesByKey = layer.layout.get('circle-sort-key').constantOr(1) !== undefined;
	    if (opacity.constantOr(1) === 0 && (strokeWidth.constantOr(1) === 0 || strokeOpacity.constantOr(1) === 0)) {
	        return;
	    }
	    var context = painter.context;
	    var gl = context.gl;
	    var depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);
	    var stencilMode = StencilMode.disabled;
	    var colorMode = painter.colorModeForRenderPass();
	    var segmentsRenderStates = [];
	    for (var i = 0; i < coords.length; i++) {
	        var coord = coords[i];
	        var tile = sourceCache.getTile(coord);
	        var bucket = tile.getBucket(layer);
	        if (!bucket) {
	            continue;
	        }
	        var programConfiguration = bucket.programConfigurations.get(layer.id);
	        var program = painter.useProgram('circle', programConfiguration);
	        var layoutVertexBuffer = bucket.layoutVertexBuffer;
	        var indexBuffer = bucket.indexBuffer;
	        var uniformValues = circleUniformValues(painter, coord, tile, layer);
	        var state = {
	            programConfiguration: programConfiguration,
	            program: program,
	            layoutVertexBuffer: layoutVertexBuffer,
	            indexBuffer: indexBuffer,
	            uniformValues: uniformValues
	        };
	        if (sortFeaturesByKey) {
	            var oldSegments = bucket.segments.get();
	            for (var i$1 = 0, list = oldSegments; i$1 < list.length; i$1 += 1) {
	                var segment = list[i$1];
	                segmentsRenderStates.push({
	                    segments: new performance.SegmentVector([segment]),
	                    sortKey: segment.sortKey,
	                    state: state
	                });
	            }
	        } else {
	            segmentsRenderStates.push({
	                segments: bucket.segments,
	                sortKey: 0,
	                state: state
	            });
	        }
	    }
	    if (sortFeaturesByKey) {
	        segmentsRenderStates.sort(function (a, b) {
	            return a.sortKey - b.sortKey;
	        });
	    }
	    for (var i$2 = 0, list$1 = segmentsRenderStates; i$2 < list$1.length; i$2 += 1) {
	        var segmentsState = list$1[i$2];
	        var ref = segmentsState.state;
	        var programConfiguration$1 = ref.programConfiguration;
	        var program$1 = ref.program;
	        var layoutVertexBuffer$1 = ref.layoutVertexBuffer;
	        var indexBuffer$1 = ref.indexBuffer;
	        var uniformValues$1 = ref.uniformValues;
	        var segments = segmentsState.segments;
	        program$1.draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, CullFaceMode.disabled, uniformValues$1, layer.id, layoutVertexBuffer$1, indexBuffer$1, segments, layer.paint, painter.transform.zoom, programConfiguration$1);
	    }
	}

	function drawHeatmap(painter, sourceCache, layer, coords) {
	    if (layer.paint.get('heatmap-opacity') === 0) {
	        return;
	    }
	    if (painter.renderPass === 'offscreen') {
	        var context = painter.context;
	        var gl = context.gl;
	        var stencilMode = StencilMode.disabled;
	        var colorMode = new ColorMode([
	            gl.ONE,
	            gl.ONE
	        ], performance.Color.transparent, [
	            true,
	            true,
	            true,
	            true
	        ]);
	        bindFramebuffer(context, painter, layer);
	        context.clear({ color: performance.Color.transparent });
	        for (var i = 0; i < coords.length; i++) {
	            var coord = coords[i];
	            if (sourceCache.hasRenderableParent(coord)) {
	                continue;
	            }
	            var tile = sourceCache.getTile(coord);
	            var bucket = tile.getBucket(layer);
	            if (!bucket) {
	                continue;
	            }
	            var programConfiguration = bucket.programConfigurations.get(layer.id);
	            var program = painter.useProgram('heatmap', programConfiguration);
	            var ref = painter.transform;
	            var zoom = ref.zoom;
	            program.draw(context, gl.TRIANGLES, DepthMode.disabled, stencilMode, colorMode, CullFaceMode.disabled, heatmapUniformValues(coord.posMatrix, tile, zoom, layer.paint.get('heatmap-intensity')), layer.id, bucket.layoutVertexBuffer, bucket.indexBuffer, bucket.segments, layer.paint, painter.transform.zoom, programConfiguration);
	        }
	        context.viewport.set([
	            0,
	            0,
	            painter.width,
	            painter.height
	        ]);
	    } else if (painter.renderPass === 'translucent') {
	        painter.context.setColorMode(painter.colorModeForRenderPass());
	        renderTextureToMap(painter, layer);
	    }
	}
	function bindFramebuffer(context, painter, layer) {
	    var gl = context.gl;
	    context.activeTexture.set(gl.TEXTURE1);
	    context.viewport.set([
	        0,
	        0,
	        painter.width / 4,
	        painter.height / 4
	    ]);
	    var fbo = layer.heatmapFbo;
	    if (!fbo) {
	        var texture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_2D, texture);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	        fbo = layer.heatmapFbo = context.createFramebuffer(painter.width / 4, painter.height / 4, false);
	        bindTextureToFramebuffer(context, painter, texture, fbo);
	    } else {
	        gl.bindTexture(gl.TEXTURE_2D, fbo.colorAttachment.get());
	        context.bindFramebuffer.set(fbo.framebuffer);
	    }
	}
	function bindTextureToFramebuffer(context, painter, texture, fbo) {
	    var gl = context.gl;
	    var internalFormat = context.extRenderToTextureHalfFloat ? context.extTextureHalfFloat.HALF_FLOAT_OES : gl.UNSIGNED_BYTE;
	    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, painter.width / 4, painter.height / 4, 0, gl.RGBA, internalFormat, null);
	    fbo.colorAttachment.set(texture);
	}
	function renderTextureToMap(painter, layer) {
	    var context = painter.context;
	    var gl = context.gl;
	    var fbo = layer.heatmapFbo;
	    if (!fbo) {
	        return;
	    }
	    context.activeTexture.set(gl.TEXTURE0);
	    gl.bindTexture(gl.TEXTURE_2D, fbo.colorAttachment.get());
	    context.activeTexture.set(gl.TEXTURE1);
	    var colorRampTexture = layer.colorRampTexture;
	    if (!colorRampTexture) {
	        colorRampTexture = layer.colorRampTexture = new performance.Texture(context, layer.colorRamp, gl.RGBA);
	    }
	    colorRampTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
	    painter.useProgram('heatmapTexture').draw(context, gl.TRIANGLES, DepthMode.disabled, StencilMode.disabled, painter.colorModeForRenderPass(), CullFaceMode.disabled, heatmapTextureUniformValues(painter, layer, 0, 1), layer.id, painter.viewportBuffer, painter.quadTriangleIndexBuffer, painter.viewportSegments, layer.paint, painter.transform.zoom);
	}

	function drawLine(painter, sourceCache, layer, coords) {
	    if (painter.renderPass !== 'translucent') {
	        return;
	    }
	    var opacity = layer.paint.get('line-opacity');
	    var width = layer.paint.get('line-width');
	    if (opacity.constantOr(1) === 0 || width.constantOr(1) === 0) {
	        return;
	    }
	    var depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);
	    var colorMode = painter.colorModeForRenderPass();
	    var dasharray = layer.paint.get('line-dasharray');
	    var patternProperty = layer.paint.get('line-pattern');
	    var image = patternProperty.constantOr(1);
	    var gradient = layer.paint.get('line-gradient');
	    var crossfade = layer.getCrossfadeParameters();
	    var programId = image ? 'linePattern' : dasharray ? 'lineSDF' : gradient ? 'lineGradient' : 'line';
	    var context = painter.context;
	    var gl = context.gl;
	    var firstTile = true;
	    for (var i = 0, list = coords; i < list.length; i += 1) {
	        var coord = list[i];
	        var tile = sourceCache.getTile(coord);
	        if (image && !tile.patternsLoaded()) {
	            continue;
	        }
	        var bucket = tile.getBucket(layer);
	        if (!bucket) {
	            continue;
	        }
	        var programConfiguration = bucket.programConfigurations.get(layer.id);
	        var prevProgram = painter.context.program.get();
	        var program = painter.useProgram(programId, programConfiguration);
	        var programChanged = firstTile || program.program !== prevProgram;
	        var constantPattern = patternProperty.constantOr(null);
	        if (constantPattern && tile.imageAtlas) {
	            var atlas = tile.imageAtlas;
	            var posTo = atlas.patternPositions[constantPattern.to.toString()];
	            var posFrom = atlas.patternPositions[constantPattern.from.toString()];
	            if (posTo && posFrom) {
	                programConfiguration.setConstantPatternPositions(posTo, posFrom);
	            }
	        }
	        var uniformValues = image ? linePatternUniformValues(painter, tile, layer, crossfade) : dasharray ? lineSDFUniformValues(painter, tile, layer, dasharray, crossfade) : gradient ? lineGradientUniformValues(painter, tile, layer, bucket.lineClipsArray.length) : lineUniformValues(painter, tile, layer);
	        if (image) {
	            context.activeTexture.set(gl.TEXTURE0);
	            tile.imageAtlasTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
	            programConfiguration.updatePaintBuffers(crossfade);
	        } else if (dasharray && (programChanged || painter.lineAtlas.dirty)) {
	            context.activeTexture.set(gl.TEXTURE0);
	            painter.lineAtlas.bind(context);
	        } else if (gradient) {
	            var layerGradient = bucket.gradients[layer.id];
	            var gradientTexture = layerGradient.texture;
	            if (layer.gradientVersion !== layerGradient.version) {
	                var textureResolution = 256;
	                if (layer.stepInterpolant) {
	                    var sourceMaxZoom = sourceCache.getSource().maxzoom;
	                    var potentialOverzoom = coord.canonical.z === sourceMaxZoom ? Math.ceil(1 << painter.transform.maxZoom - coord.canonical.z) : 1;
	                    var lineLength = bucket.maxLineLength / performance.EXTENT;
	                    var maxTilePixelSize = 1024;
	                    var maxTextureCoverage = lineLength * maxTilePixelSize * potentialOverzoom;
	                    textureResolution = performance.clamp(performance.nextPowerOfTwo(maxTextureCoverage), 256, context.maxTextureSize);
	                }
	                layerGradient.gradient = performance.renderColorRamp({
	                    expression: layer.gradientExpression(),
	                    evaluationKey: 'lineProgress',
	                    resolution: textureResolution,
	                    image: layerGradient.gradient || undefined,
	                    clips: bucket.lineClipsArray
	                });
	                if (layerGradient.texture) {
	                    layerGradient.texture.update(layerGradient.gradient);
	                } else {
	                    layerGradient.texture = new performance.Texture(context, layerGradient.gradient, gl.RGBA);
	                }
	                layerGradient.version = layer.gradientVersion;
	                gradientTexture = layerGradient.texture;
	            }
	            context.activeTexture.set(gl.TEXTURE0);
	            gradientTexture.bind(layer.stepInterpolant ? gl.NEAREST : gl.LINEAR, gl.CLAMP_TO_EDGE);
	        }
	        program.draw(context, gl.TRIANGLES, depthMode, painter.stencilModeForClipping(coord), colorMode, CullFaceMode.disabled, uniformValues, layer.id, bucket.layoutVertexBuffer, bucket.indexBuffer, bucket.segments, layer.paint, painter.transform.zoom, programConfiguration, bucket.layoutVertexBuffer2);
	        firstTile = false;
	    }
	}

	function drawFill(painter, sourceCache, layer, coords) {
	    var color = layer.paint.get('fill-color');
	    var opacity = layer.paint.get('fill-opacity');
	    if (opacity.constantOr(1) === 0) {
	        return;
	    }
	    var colorMode = painter.colorModeForRenderPass();
	    var pattern = layer.paint.get('fill-pattern');
	    var pass = painter.opaquePassEnabledForLayer() && (!pattern.constantOr(1) && color.constantOr(performance.Color.transparent).a === 1 && opacity.constantOr(0) === 1) ? 'opaque' : 'translucent';
	    if (painter.renderPass === pass) {
	        var depthMode = painter.depthModeForSublayer(1, painter.renderPass === 'opaque' ? DepthMode.ReadWrite : DepthMode.ReadOnly);
	        drawFillTiles(painter, sourceCache, layer, coords, depthMode, colorMode, false);
	    }
	    if (painter.renderPass === 'translucent' && layer.paint.get('fill-antialias')) {
	        var depthMode$1 = painter.depthModeForSublayer(layer.getPaintProperty('fill-outline-color') ? 2 : 0, DepthMode.ReadOnly);
	        drawFillTiles(painter, sourceCache, layer, coords, depthMode$1, colorMode, true);
	    }
	}
	function drawFillTiles(painter, sourceCache, layer, coords, depthMode, colorMode, isOutline) {
	    var gl = painter.context.gl;
	    var patternProperty = layer.paint.get('fill-pattern');
	    var image = patternProperty && patternProperty.constantOr(1);
	    var crossfade = layer.getCrossfadeParameters();
	    var drawMode, programName, uniformValues, indexBuffer, segments;
	    if (!isOutline) {
	        programName = image ? 'fillPattern' : 'fill';
	        drawMode = gl.TRIANGLES;
	    } else {
	        programName = image && !layer.getPaintProperty('fill-outline-color') ? 'fillOutlinePattern' : 'fillOutline';
	        drawMode = gl.LINES;
	    }
	    for (var i = 0, list = coords; i < list.length; i += 1) {
	        var coord = list[i];
	        var tile = sourceCache.getTile(coord);
	        if (image && !tile.patternsLoaded()) {
	            continue;
	        }
	        var bucket = tile.getBucket(layer);
	        if (!bucket) {
	            continue;
	        }
	        var programConfiguration = bucket.programConfigurations.get(layer.id);
	        var program = painter.useProgram(programName, programConfiguration);
	        if (image) {
	            painter.context.activeTexture.set(gl.TEXTURE0);
	            tile.imageAtlasTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
	            programConfiguration.updatePaintBuffers(crossfade);
	        }
	        var constantPattern = patternProperty.constantOr(null);
	        if (constantPattern && tile.imageAtlas) {
	            var atlas = tile.imageAtlas;
	            var posTo = atlas.patternPositions[constantPattern.to.toString()];
	            var posFrom = atlas.patternPositions[constantPattern.from.toString()];
	            if (posTo && posFrom) {
	                programConfiguration.setConstantPatternPositions(posTo, posFrom);
	            }
	        }
	        var tileMatrix = painter.translatePosMatrix(coord.posMatrix, tile, layer.paint.get('fill-translate'), layer.paint.get('fill-translate-anchor'));
	        if (!isOutline) {
	            indexBuffer = bucket.indexBuffer;
	            segments = bucket.segments;
	            uniformValues = image ? fillPatternUniformValues(tileMatrix, painter, crossfade, tile) : fillUniformValues(tileMatrix);
	        } else {
	            indexBuffer = bucket.indexBuffer2;
	            segments = bucket.segments2;
	            var drawingBufferSize = [
	                gl.drawingBufferWidth,
	                gl.drawingBufferHeight
	            ];
	            uniformValues = programName === 'fillOutlinePattern' && image ? fillOutlinePatternUniformValues(tileMatrix, painter, crossfade, tile, drawingBufferSize) : fillOutlineUniformValues(tileMatrix, drawingBufferSize);
	        }
	        program.draw(painter.context, drawMode, depthMode, painter.stencilModeForClipping(coord), colorMode, CullFaceMode.disabled, uniformValues, layer.id, bucket.layoutVertexBuffer, indexBuffer, segments, layer.paint, painter.transform.zoom, programConfiguration);
	    }
	}

	function draw(painter, source, layer, coords) {
	    var opacity = layer.paint.get('fill-extrusion-opacity');
	    if (opacity === 0) {
	        return;
	    }
	    if (painter.renderPass === 'translucent') {
	        var depthMode = new DepthMode(painter.context.gl.LEQUAL, DepthMode.ReadWrite, painter.depthRangeFor3D);
	        if (opacity === 1 && !layer.paint.get('fill-extrusion-pattern').constantOr(1)) {
	            var colorMode = painter.colorModeForRenderPass();
	            drawExtrusionTiles(painter, source, layer, coords, depthMode, StencilMode.disabled, colorMode);
	        } else {
	            drawExtrusionTiles(painter, source, layer, coords, depthMode, StencilMode.disabled, ColorMode.disabled);
	            drawExtrusionTiles(painter, source, layer, coords, depthMode, painter.stencilModeFor3D(), painter.colorModeForRenderPass());
	        }
	    }
	}
	function drawExtrusionTiles(painter, source, layer, coords, depthMode, stencilMode, colorMode) {
	    var context = painter.context;
	    var gl = context.gl;
	    var patternProperty = layer.paint.get('fill-extrusion-pattern');
	    var image = patternProperty.constantOr(1);
	    var crossfade = layer.getCrossfadeParameters();
	    var opacity = layer.paint.get('fill-extrusion-opacity');
	    for (var i = 0, list = coords; i < list.length; i += 1) {
	        var coord = list[i];
	        var tile = source.getTile(coord);
	        var bucket = tile.getBucket(layer);
	        if (!bucket) {
	            continue;
	        }
	        var programConfiguration = bucket.programConfigurations.get(layer.id);
	        var program = painter.useProgram(image ? 'fillExtrusionPattern' : 'fillExtrusion', programConfiguration);
	        if (image) {
	            painter.context.activeTexture.set(gl.TEXTURE0);
	            tile.imageAtlasTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
	            programConfiguration.updatePaintBuffers(crossfade);
	        }
	        var constantPattern = patternProperty.constantOr(null);
	        if (constantPattern && tile.imageAtlas) {
	            var atlas = tile.imageAtlas;
	            var posTo = atlas.patternPositions[constantPattern.to.toString()];
	            var posFrom = atlas.patternPositions[constantPattern.from.toString()];
	            if (posTo && posFrom) {
	                programConfiguration.setConstantPatternPositions(posTo, posFrom);
	            }
	        }
	        var matrix = painter.translatePosMatrix(coord.posMatrix, tile, layer.paint.get('fill-extrusion-translate'), layer.paint.get('fill-extrusion-translate-anchor'));
	        var shouldUseVerticalGradient = layer.paint.get('fill-extrusion-vertical-gradient');
	        var uniformValues = image ? fillExtrusionPatternUniformValues(matrix, painter, shouldUseVerticalGradient, opacity, coord, crossfade, tile) : fillExtrusionUniformValues(matrix, painter, shouldUseVerticalGradient, opacity);
	        program.draw(context, context.gl.TRIANGLES, depthMode, stencilMode, colorMode, CullFaceMode.backCCW, uniformValues, layer.id, bucket.layoutVertexBuffer, bucket.indexBuffer, bucket.segments, layer.paint, painter.transform.zoom, programConfiguration);
	    }
	}

	function drawHillshade(painter, sourceCache, layer, tileIDs) {
	    if (painter.renderPass !== 'offscreen' && painter.renderPass !== 'translucent') {
	        return;
	    }
	    var context = painter.context;
	    var depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);
	    var colorMode = painter.colorModeForRenderPass();
	    var ref = painter.renderPass === 'translucent' ? painter.stencilConfigForOverlap(tileIDs) : [
	        {},
	        tileIDs
	    ];
	    var stencilModes = ref[0];
	    var coords = ref[1];
	    for (var i = 0, list = coords; i < list.length; i += 1) {
	        var coord = list[i];
	        var tile = sourceCache.getTile(coord);
	        if (tile.needsHillshadePrepare && painter.renderPass === 'offscreen') {
	            prepareHillshade(painter, tile, layer, depthMode, StencilMode.disabled, colorMode);
	        } else if (painter.renderPass === 'translucent') {
	            renderHillshade(painter, tile, layer, depthMode, stencilModes[coord.overscaledZ], colorMode);
	        }
	    }
	    context.viewport.set([
	        0,
	        0,
	        painter.width,
	        painter.height
	    ]);
	}
	function renderHillshade(painter, tile, layer, depthMode, stencilMode, colorMode) {
	    var context = painter.context;
	    var gl = context.gl;
	    var fbo = tile.fbo;
	    if (!fbo) {
	        return;
	    }
	    var program = painter.useProgram('hillshade');
	    context.activeTexture.set(gl.TEXTURE0);
	    gl.bindTexture(gl.TEXTURE_2D, fbo.colorAttachment.get());
	    var uniformValues = hillshadeUniformValues(painter, tile, layer);
	    program.draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, CullFaceMode.disabled, uniformValues, layer.id, painter.rasterBoundsBuffer, painter.quadTriangleIndexBuffer, painter.rasterBoundsSegments);
	}
	function prepareHillshade(painter, tile, layer, depthMode, stencilMode, colorMode) {
	    var context = painter.context;
	    var gl = context.gl;
	    var dem = tile.dem;
	    if (dem && dem.data) {
	        var tileSize = dem.dim;
	        var textureStride = dem.stride;
	        var pixelData = dem.getPixels();
	        context.activeTexture.set(gl.TEXTURE1);
	        context.pixelStoreUnpackPremultiplyAlpha.set(false);
	        tile.demTexture = tile.demTexture || painter.getTileTexture(textureStride);
	        if (tile.demTexture) {
	            var demTexture = tile.demTexture;
	            demTexture.update(pixelData, { premultiply: false });
	            demTexture.bind(gl.NEAREST, gl.CLAMP_TO_EDGE);
	        } else {
	            tile.demTexture = new performance.Texture(context, pixelData, gl.RGBA, { premultiply: false });
	            tile.demTexture.bind(gl.NEAREST, gl.CLAMP_TO_EDGE);
	        }
	        context.activeTexture.set(gl.TEXTURE0);
	        var fbo = tile.fbo;
	        if (!fbo) {
	            var renderTexture = new performance.Texture(context, {
	                width: tileSize,
	                height: tileSize,
	                data: null
	            }, gl.RGBA);
	            renderTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
	            fbo = tile.fbo = context.createFramebuffer(tileSize, tileSize, true);
	            fbo.colorAttachment.set(renderTexture.texture);
	        }
	        context.bindFramebuffer.set(fbo.framebuffer);
	        context.viewport.set([
	            0,
	            0,
	            tileSize,
	            tileSize
	        ]);
	        painter.useProgram('hillshadePrepare').draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, CullFaceMode.disabled, hillshadeUniformPrepareValues(tile.tileID, dem), layer.id, painter.rasterBoundsBuffer, painter.quadTriangleIndexBuffer, painter.rasterBoundsSegments);
	        tile.needsHillshadePrepare = false;
	    }
	}

	function drawRaster(painter, sourceCache, layer, tileIDs) {
	    if (painter.renderPass !== 'translucent') {
	        return;
	    }
	    if (layer.paint.get('raster-opacity') === 0) {
	        return;
	    }
	    if (!tileIDs.length) {
	        return;
	    }
	    var context = painter.context;
	    var gl = context.gl;
	    var source = sourceCache.getSource();
	    var program = painter.useProgram('raster');
	    var colorMode = painter.colorModeForRenderPass();
	    var ref = source instanceof ImageSource ? [
	        {},
	        tileIDs
	    ] : painter.stencilConfigForOverlap(tileIDs);
	    var stencilModes = ref[0];
	    var coords = ref[1];
	    var minTileZ = coords[coords.length - 1].overscaledZ;
	    var align = !painter.options.moving;
	    for (var i = 0, list = coords; i < list.length; i += 1) {
	        var coord = list[i];
	        var depthMode = painter.depthModeForSublayer(coord.overscaledZ - minTileZ, layer.paint.get('raster-opacity') === 1 ? DepthMode.ReadWrite : DepthMode.ReadOnly, gl.LESS);
	        var tile = sourceCache.getTile(coord);
	        var posMatrix = painter.transform.calculatePosMatrix(coord.toUnwrapped(), align);
	        tile.registerFadeDuration(layer.paint.get('raster-fade-duration'));
	        var parentTile = sourceCache.findLoadedParent(coord, 0), fade = getFadeValues(tile, parentTile, sourceCache, layer, painter.transform);
	        var parentScaleBy = void 0, parentTL = void 0;
	        var textureFilter = layer.paint.get('raster-resampling') === 'nearest' ? gl.NEAREST : gl.LINEAR;
	        context.activeTexture.set(gl.TEXTURE0);
	        tile.texture.bind(textureFilter, gl.CLAMP_TO_EDGE, gl.LINEAR_MIPMAP_NEAREST);
	        context.activeTexture.set(gl.TEXTURE1);
	        if (parentTile) {
	            parentTile.texture.bind(textureFilter, gl.CLAMP_TO_EDGE, gl.LINEAR_MIPMAP_NEAREST);
	            parentScaleBy = Math.pow(2, parentTile.tileID.overscaledZ - tile.tileID.overscaledZ);
	            parentTL = [
	                tile.tileID.canonical.x * parentScaleBy % 1,
	                tile.tileID.canonical.y * parentScaleBy % 1
	            ];
	        } else {
	            tile.texture.bind(textureFilter, gl.CLAMP_TO_EDGE, gl.LINEAR_MIPMAP_NEAREST);
	        }
	        var uniformValues = rasterUniformValues(posMatrix, parentTL || [
	            0,
	            0
	        ], parentScaleBy || 1, fade, layer);
	        if (source instanceof ImageSource) {
	            program.draw(context, gl.TRIANGLES, depthMode, StencilMode.disabled, colorMode, CullFaceMode.disabled, uniformValues, layer.id, source.boundsBuffer, painter.quadTriangleIndexBuffer, source.boundsSegments);
	        } else {
	            program.draw(context, gl.TRIANGLES, depthMode, stencilModes[coord.overscaledZ], colorMode, CullFaceMode.disabled, uniformValues, layer.id, painter.rasterBoundsBuffer, painter.quadTriangleIndexBuffer, painter.rasterBoundsSegments);
	        }
	    }
	}
	function getFadeValues(tile, parentTile, sourceCache, layer, transform) {
	    var fadeDuration = layer.paint.get('raster-fade-duration');
	    if (fadeDuration > 0) {
	        var now = performance.browser.now();
	        var sinceTile = (now - tile.timeAdded) / fadeDuration;
	        var sinceParent = parentTile ? (now - parentTile.timeAdded) / fadeDuration : -1;
	        var source = sourceCache.getSource();
	        var idealZ = transform.coveringZoomLevel({
	            tileSize: source.tileSize,
	            roundZoom: source.roundZoom
	        });
	        var fadeIn = !parentTile || Math.abs(parentTile.tileID.overscaledZ - idealZ) > Math.abs(tile.tileID.overscaledZ - idealZ);
	        var childOpacity = fadeIn && tile.refreshedUponExpiration ? 1 : performance.clamp(fadeIn ? sinceTile : 1 - sinceParent, 0, 1);
	        if (tile.refreshedUponExpiration && sinceTile >= 1) {
	            tile.refreshedUponExpiration = false;
	        }
	        if (parentTile) {
	            return {
	                opacity: 1,
	                mix: 1 - childOpacity
	            };
	        } else {
	            return {
	                opacity: childOpacity,
	                mix: 0
	            };
	        }
	    } else {
	        return {
	            opacity: 1,
	            mix: 0
	        };
	    }
	}

	function drawBackground(painter, sourceCache, layer) {
	    var color = layer.paint.get('background-color');
	    var opacity = layer.paint.get('background-opacity');
	    if (opacity === 0) {
	        return;
	    }
	    var context = painter.context;
	    var gl = context.gl;
	    var transform = painter.transform;
	    var tileSize = transform.tileSize;
	    var image = layer.paint.get('background-pattern');
	    if (painter.isPatternMissing(image)) {
	        return;
	    }
	    var pass = !image && color.a === 1 && opacity === 1 && painter.opaquePassEnabledForLayer() ? 'opaque' : 'translucent';
	    if (painter.renderPass !== pass) {
	        return;
	    }
	    var stencilMode = StencilMode.disabled;
	    var depthMode = painter.depthModeForSublayer(0, pass === 'opaque' ? DepthMode.ReadWrite : DepthMode.ReadOnly);
	    var colorMode = painter.colorModeForRenderPass();
	    var program = painter.useProgram(image ? 'backgroundPattern' : 'background');
	    var tileIDs = transform.coveringTiles({ tileSize: tileSize });
	    if (image) {
	        context.activeTexture.set(gl.TEXTURE0);
	        painter.imageManager.bind(painter.context);
	    }
	    var crossfade = layer.getCrossfadeParameters();
	    for (var i = 0, list = tileIDs; i < list.length; i += 1) {
	        var tileID = list[i];
	        var matrix = painter.transform.calculatePosMatrix(tileID.toUnwrapped());
	        var uniformValues = image ? backgroundPatternUniformValues(matrix, opacity, painter, image, {
	            tileID: tileID,
	            tileSize: tileSize
	        }, crossfade) : backgroundUniformValues(matrix, opacity, color);
	        program.draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, CullFaceMode.disabled, uniformValues, layer.id, painter.tileExtentBuffer, painter.quadTriangleIndexBuffer, painter.tileExtentSegments);
	    }
	}

	var topColor = new performance.Color(1, 0, 0, 1);
	var btmColor = new performance.Color(0, 1, 0, 1);
	var leftColor = new performance.Color(0, 0, 1, 1);
	var rightColor = new performance.Color(1, 0, 1, 1);
	var centerColor = new performance.Color(0, 1, 1, 1);
	function drawDebugPadding(painter) {
	    var padding = painter.transform.padding;
	    var lineWidth = 3;
	    drawHorizontalLine(painter, painter.transform.height - (padding.top || 0), lineWidth, topColor);
	    drawHorizontalLine(painter, padding.bottom || 0, lineWidth, btmColor);
	    drawVerticalLine(painter, padding.left || 0, lineWidth, leftColor);
	    drawVerticalLine(painter, painter.transform.width - (padding.right || 0), lineWidth, rightColor);
	    var center = painter.transform.centerPoint;
	    drawCrosshair(painter, center.x, painter.transform.height - center.y, centerColor);
	}
	function drawCrosshair(painter, x, y, color) {
	    var size = 20;
	    var lineWidth = 2;
	    drawDebugSSRect(painter, x - lineWidth / 2, y - size / 2, lineWidth, size, color);
	    drawDebugSSRect(painter, x - size / 2, y - lineWidth / 2, size, lineWidth, color);
	}
	function drawHorizontalLine(painter, y, lineWidth, color) {
	    drawDebugSSRect(painter, 0, y + lineWidth / 2, painter.transform.width, lineWidth, color);
	}
	function drawVerticalLine(painter, x, lineWidth, color) {
	    drawDebugSSRect(painter, x - lineWidth / 2, 0, lineWidth, painter.transform.height, color);
	}
	function drawDebugSSRect(painter, x, y, width, height, color) {
	    var context = painter.context;
	    var gl = context.gl;
	    gl.enable(gl.SCISSOR_TEST);
	    gl.scissor(x * performance.browser.devicePixelRatio, y * performance.browser.devicePixelRatio, width * performance.browser.devicePixelRatio, height * performance.browser.devicePixelRatio);
	    context.clear({ color: color });
	    gl.disable(gl.SCISSOR_TEST);
	}
	function drawDebug(painter, sourceCache, coords) {
	    for (var i = 0; i < coords.length; i++) {
	        drawDebugTile(painter, sourceCache, coords[i]);
	    }
	}
	function drawDebugTile(painter, sourceCache, coord) {
	    var context = painter.context;
	    var gl = context.gl;
	    var posMatrix = coord.posMatrix;
	    var program = painter.useProgram('debug');
	    var depthMode = DepthMode.disabled;
	    var stencilMode = StencilMode.disabled;
	    var colorMode = painter.colorModeForRenderPass();
	    var id = '$debug';
	    context.activeTexture.set(gl.TEXTURE0);
	    painter.emptyTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
	    program.draw(context, gl.LINE_STRIP, depthMode, stencilMode, colorMode, CullFaceMode.disabled, debugUniformValues(posMatrix, performance.Color.red), id, painter.debugBuffer, painter.tileBorderIndexBuffer, painter.debugSegments);
	    var tileRawData = sourceCache.getTileByID(coord.key).latestRawTileData;
	    var tileByteLength = tileRawData && tileRawData.byteLength || 0;
	    var tileSizeKb = Math.floor(tileByteLength / 1024);
	    var tileSize = sourceCache.getTile(coord).tileSize;
	    var scaleRatio = 512 / Math.min(tileSize, 512) * (coord.overscaledZ / painter.transform.zoom) * 0.5;
	    var tileIdText = coord.canonical.toString();
	    if (coord.overscaledZ !== coord.canonical.z) {
	        tileIdText += ' => ' + coord.overscaledZ;
	    }
	    var tileLabel = tileIdText + ' ' + tileSizeKb + 'kb';
	    drawTextToOverlay(painter, tileLabel);
	    program.draw(context, gl.TRIANGLES, depthMode, stencilMode, ColorMode.alphaBlended, CullFaceMode.disabled, debugUniformValues(posMatrix, performance.Color.transparent, scaleRatio), id, painter.debugBuffer, painter.quadTriangleIndexBuffer, painter.debugSegments);
	}
	function drawTextToOverlay(painter, text) {
	    painter.initDebugOverlayCanvas();
	    var canvas = painter.debugOverlayCanvas;
	    var gl = painter.context.gl;
	    var ctx2d = painter.debugOverlayCanvas.getContext('2d');
	    ctx2d.clearRect(0, 0, canvas.width, canvas.height);
	    ctx2d.shadowColor = 'white';
	    ctx2d.shadowBlur = 2;
	    ctx2d.lineWidth = 1.5;
	    ctx2d.strokeStyle = 'white';
	    ctx2d.textBaseline = 'top';
	    ctx2d.font = 'bold ' + 36 + 'px Open Sans, sans-serif';
	    ctx2d.fillText(text, 5, 5);
	    ctx2d.strokeText(text, 5, 5);
	    painter.debugOverlayTexture.update(canvas);
	    painter.debugOverlayTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
	}

	function drawCustom(painter, sourceCache, layer) {
	    var context = painter.context;
	    var implementation = layer.implementation;
	    if (painter.renderPass === 'offscreen') {
	        var prerender = implementation.prerender;
	        if (prerender) {
	            painter.setCustomLayerDefaults();
	            context.setColorMode(painter.colorModeForRenderPass());
	            prerender.call(implementation, context.gl, painter.transform.customLayerMatrix());
	            context.setDirty();
	            painter.setBaseState();
	        }
	    } else if (painter.renderPass === 'translucent') {
	        painter.setCustomLayerDefaults();
	        context.setColorMode(painter.colorModeForRenderPass());
	        context.setStencilMode(StencilMode.disabled);
	        var depthMode = implementation.renderingMode === '3d' ? new DepthMode(painter.context.gl.LEQUAL, DepthMode.ReadWrite, painter.depthRangeFor3D) : painter.depthModeForSublayer(0, DepthMode.ReadOnly);
	        context.setDepthMode(depthMode);
	        implementation.render(context.gl, painter.transform.customLayerMatrix());
	        context.setDirty();
	        painter.setBaseState();
	        context.bindFramebuffer.set(null);
	    }
	}

	var draw$1 = {
	    symbol: drawSymbols,
	    circle: drawCircles,
	    heatmap: drawHeatmap,
	    line: drawLine,
	    fill: drawFill,
	    'fill-extrusion': draw,
	    hillshade: drawHillshade,
	    raster: drawRaster,
	    background: drawBackground,
	    debug: drawDebug,
	    custom: drawCustom
	};
	var Painter = function Painter(gl, transform) {
	    this.context = new Context(gl);
	    this.transform = transform;
	    this._tileTextures = {};
	    this.setup();
	    this.numSublayers = SourceCache.maxUnderzooming + SourceCache.maxOverzooming + 1;
	    this.depthEpsilon = 1 / Math.pow(2, 16);
	    this.crossTileSymbolIndex = new CrossTileSymbolIndex();
	    this.gpuTimers = {};
	};
	Painter.prototype.resize = function resize(width, height) {
	    this.width = width * performance.browser.devicePixelRatio;
	    this.height = height * performance.browser.devicePixelRatio;
	    this.context.viewport.set([
	        0,
	        0,
	        this.width,
	        this.height
	    ]);
	    if (this.style) {
	        for (var i = 0, list = this.style._order; i < list.length; i += 1) {
	            var layerId = list[i];
	            this.style._layers[layerId].resize();
	        }
	    }
	};
	Painter.prototype.setup = function setup() {
	    var context = this.context;
	    var tileExtentArray = new performance.StructArrayLayout2i4();
	    tileExtentArray.emplaceBack(0, 0);
	    tileExtentArray.emplaceBack(performance.EXTENT, 0);
	    tileExtentArray.emplaceBack(0, performance.EXTENT);
	    tileExtentArray.emplaceBack(performance.EXTENT, performance.EXTENT);
	    this.tileExtentBuffer = context.createVertexBuffer(tileExtentArray, posAttributes.members);
	    this.tileExtentSegments = performance.SegmentVector.simpleSegment(0, 0, 4, 2);
	    var debugArray = new performance.StructArrayLayout2i4();
	    debugArray.emplaceBack(0, 0);
	    debugArray.emplaceBack(performance.EXTENT, 0);
	    debugArray.emplaceBack(0, performance.EXTENT);
	    debugArray.emplaceBack(performance.EXTENT, performance.EXTENT);
	    this.debugBuffer = context.createVertexBuffer(debugArray, posAttributes.members);
	    this.debugSegments = performance.SegmentVector.simpleSegment(0, 0, 4, 5);
	    var rasterBoundsArray = new performance.StructArrayLayout4i8();
	    rasterBoundsArray.emplaceBack(0, 0, 0, 0);
	    rasterBoundsArray.emplaceBack(performance.EXTENT, 0, performance.EXTENT, 0);
	    rasterBoundsArray.emplaceBack(0, performance.EXTENT, 0, performance.EXTENT);
	    rasterBoundsArray.emplaceBack(performance.EXTENT, performance.EXTENT, performance.EXTENT, performance.EXTENT);
	    this.rasterBoundsBuffer = context.createVertexBuffer(rasterBoundsArray, rasterBoundsAttributes.members);
	    this.rasterBoundsSegments = performance.SegmentVector.simpleSegment(0, 0, 4, 2);
	    var viewportArray = new performance.StructArrayLayout2i4();
	    viewportArray.emplaceBack(0, 0);
	    viewportArray.emplaceBack(1, 0);
	    viewportArray.emplaceBack(0, 1);
	    viewportArray.emplaceBack(1, 1);
	    this.viewportBuffer = context.createVertexBuffer(viewportArray, posAttributes.members);
	    this.viewportSegments = performance.SegmentVector.simpleSegment(0, 0, 4, 2);
	    var tileLineStripIndices = new performance.StructArrayLayout1ui2();
	    tileLineStripIndices.emplaceBack(0);
	    tileLineStripIndices.emplaceBack(1);
	    tileLineStripIndices.emplaceBack(3);
	    tileLineStripIndices.emplaceBack(2);
	    tileLineStripIndices.emplaceBack(0);
	    this.tileBorderIndexBuffer = context.createIndexBuffer(tileLineStripIndices);
	    var quadTriangleIndices = new performance.StructArrayLayout3ui6();
	    quadTriangleIndices.emplaceBack(0, 1, 2);
	    quadTriangleIndices.emplaceBack(2, 1, 3);
	    this.quadTriangleIndexBuffer = context.createIndexBuffer(quadTriangleIndices);
	    this.emptyTexture = new performance.Texture(context, {
	        width: 1,
	        height: 1,
	        data: new Uint8Array([
	            0,
	            0,
	            0,
	            0
	        ])
	    }, context.gl.RGBA);
	    var gl = this.context.gl;
	    this.stencilClearMode = new StencilMode({
	        func: gl.ALWAYS,
	        mask: 0
	    }, 0, 255, gl.ZERO, gl.ZERO, gl.ZERO);
	};
	Painter.prototype.clearStencil = function clearStencil() {
	    var context = this.context;
	    var gl = context.gl;
	    this.nextStencilID = 1;
	    this.currentStencilSource = undefined;
	    var matrix = performance.create();
	    performance.ortho(matrix, 0, this.width, this.height, 0, 0, 1);
	    performance.scale(matrix, matrix, [
	        gl.drawingBufferWidth,
	        gl.drawingBufferHeight,
	        0
	    ]);
	    this.useProgram('clippingMask').draw(context, gl.TRIANGLES, DepthMode.disabled, this.stencilClearMode, ColorMode.disabled, CullFaceMode.disabled, clippingMaskUniformValues(matrix), '$clipping', this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
	};
	Painter.prototype._renderTileClippingMasks = function _renderTileClippingMasks(layer, tileIDs) {
	    if (this.currentStencilSource === layer.source || !layer.isTileClipped() || !tileIDs || !tileIDs.length) {
	        return;
	    }
	    this.currentStencilSource = layer.source;
	    var context = this.context;
	    var gl = context.gl;
	    if (this.nextStencilID + tileIDs.length > 256) {
	        this.clearStencil();
	    }
	    context.setColorMode(ColorMode.disabled);
	    context.setDepthMode(DepthMode.disabled);
	    var program = this.useProgram('clippingMask');
	    this._tileClippingMaskIDs = {};
	    for (var i = 0, list = tileIDs; i < list.length; i += 1) {
	        var tileID = list[i];
	        var id = this._tileClippingMaskIDs[tileID.key] = this.nextStencilID++;
	        program.draw(context, gl.TRIANGLES, DepthMode.disabled, new StencilMode({
	            func: gl.ALWAYS,
	            mask: 0
	        }, id, 255, gl.KEEP, gl.KEEP, gl.REPLACE), ColorMode.disabled, CullFaceMode.disabled, clippingMaskUniformValues(tileID.posMatrix), '$clipping', this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
	    }
	};
	Painter.prototype.stencilModeFor3D = function stencilModeFor3D() {
	    this.currentStencilSource = undefined;
	    if (this.nextStencilID + 1 > 256) {
	        this.clearStencil();
	    }
	    var id = this.nextStencilID++;
	    var gl = this.context.gl;
	    return new StencilMode({
	        func: gl.NOTEQUAL,
	        mask: 255
	    }, id, 255, gl.KEEP, gl.KEEP, gl.REPLACE);
	};
	Painter.prototype.stencilModeForClipping = function stencilModeForClipping(tileID) {
	    var gl = this.context.gl;
	    return new StencilMode({
	        func: gl.EQUAL,
	        mask: 255
	    }, this._tileClippingMaskIDs[tileID.key], 0, gl.KEEP, gl.KEEP, gl.REPLACE);
	};
	Painter.prototype.stencilConfigForOverlap = function stencilConfigForOverlap(tileIDs) {
	    var obj;
	    var gl = this.context.gl;
	    var coords = tileIDs.sort(function (a, b) {
	        return b.overscaledZ - a.overscaledZ;
	    });
	    var minTileZ = coords[coords.length - 1].overscaledZ;
	    var stencilValues = coords[0].overscaledZ - minTileZ + 1;
	    if (stencilValues > 1) {
	        this.currentStencilSource = undefined;
	        if (this.nextStencilID + stencilValues > 256) {
	            this.clearStencil();
	        }
	        var zToStencilMode = {};
	        for (var i = 0; i < stencilValues; i++) {
	            zToStencilMode[i + minTileZ] = new StencilMode({
	                func: gl.GEQUAL,
	                mask: 255
	            }, i + this.nextStencilID, 255, gl.KEEP, gl.KEEP, gl.REPLACE);
	        }
	        this.nextStencilID += stencilValues;
	        return [
	            zToStencilMode,
	            coords
	        ];
	    }
	    return [
	        (obj = {}, obj[minTileZ] = StencilMode.disabled, obj),
	        coords
	    ];
	};
	Painter.prototype.colorModeForRenderPass = function colorModeForRenderPass() {
	    var gl = this.context.gl;
	    if (this._showOverdrawInspector) {
	        var numOverdrawSteps = 8;
	        var a = 1 / numOverdrawSteps;
	        return new ColorMode([
	            gl.CONSTANT_COLOR,
	            gl.ONE
	        ], new performance.Color(a, a, a, 0), [
	            true,
	            true,
	            true,
	            true
	        ]);
	    } else if (this.renderPass === 'opaque') {
	        return ColorMode.unblended;
	    } else {
	        return ColorMode.alphaBlended;
	    }
	};
	Painter.prototype.depthModeForSublayer = function depthModeForSublayer(n, mask, func) {
	    if (!this.opaquePassEnabledForLayer()) {
	        return DepthMode.disabled;
	    }
	    var depth = 1 - ((1 + this.currentLayer) * this.numSublayers + n) * this.depthEpsilon;
	    return new DepthMode(func || this.context.gl.LEQUAL, mask, [
	        depth,
	        depth
	    ]);
	};
	Painter.prototype.opaquePassEnabledForLayer = function opaquePassEnabledForLayer() {
	    return this.currentLayer < this.opaquePassCutoff;
	};
	Painter.prototype.render = function render(style, options) {
	    var this$1 = this;
	    this.style = style;
	    this.options = options;
	    this.lineAtlas = style.lineAtlas;
	    this.imageManager = style.imageManager;
	    this.glyphManager = style.glyphManager;
	    this.symbolFadeChange = style.placement.symbolFadeChange(performance.browser.now());
	    this.imageManager.beginFrame();
	    var layerIds = this.style._order;
	    var sourceCaches = this.style.sourceCaches;
	    for (var id in sourceCaches) {
	        var sourceCache = sourceCaches[id];
	        if (sourceCache.used) {
	            sourceCache.prepare(this.context);
	        }
	    }
	    var coordsAscending = {};
	    var coordsDescending = {};
	    var coordsDescendingSymbol = {};
	    for (var id$1 in sourceCaches) {
	        var sourceCache$1 = sourceCaches[id$1];
	        coordsAscending[id$1] = sourceCache$1.getVisibleCoordinates();
	        coordsDescending[id$1] = coordsAscending[id$1].slice().reverse();
	        coordsDescendingSymbol[id$1] = sourceCache$1.getVisibleCoordinates(true).reverse();
	    }
	    this.opaquePassCutoff = Infinity;
	    for (var i = 0; i < layerIds.length; i++) {
	        var layerId = layerIds[i];
	        if (this.style._layers[layerId].is3D()) {
	            this.opaquePassCutoff = i;
	            break;
	        }
	    }
	    this.renderPass = 'offscreen';
	    for (var i$1 = 0, list = layerIds; i$1 < list.length; i$1 += 1) {
	        var layerId$1 = list[i$1];
	        var layer = this.style._layers[layerId$1];
	        if (!layer.hasOffscreenPass() || layer.isHidden(this.transform.zoom)) {
	            continue;
	        }
	        var coords = coordsDescending[layer.source];
	        if (layer.type !== 'custom' && !coords.length) {
	            continue;
	        }
	        this.renderLayer(this, sourceCaches[layer.source], layer, coords);
	    }
	    this.context.bindFramebuffer.set(null);
	    this.context.clear({
	        color: options.showOverdrawInspector ? performance.Color.black : performance.Color.transparent,
	        depth: 1
	    });
	    this.clearStencil();
	    this._showOverdrawInspector = options.showOverdrawInspector;
	    this.depthRangeFor3D = [
	        0,
	        1 - (style._order.length + 2) * this.numSublayers * this.depthEpsilon
	    ];
	    this.renderPass = 'opaque';
	    for (this.currentLayer = layerIds.length - 1; this.currentLayer >= 0; this.currentLayer--) {
	        var layer$1 = this.style._layers[layerIds[this.currentLayer]];
	        var sourceCache$2 = sourceCaches[layer$1.source];
	        var coords$1 = coordsAscending[layer$1.source];
	        this._renderTileClippingMasks(layer$1, coords$1);
	        this.renderLayer(this, sourceCache$2, layer$1, coords$1);
	    }
	    this.renderPass = 'translucent';
	    for (this.currentLayer = 0; this.currentLayer < layerIds.length; this.currentLayer++) {
	        var layer$2 = this.style._layers[layerIds[this.currentLayer]];
	        var sourceCache$3 = sourceCaches[layer$2.source];
	        var coords$2 = (layer$2.type === 'symbol' ? coordsDescendingSymbol : coordsDescending)[layer$2.source];
	        this._renderTileClippingMasks(layer$2, coordsAscending[layer$2.source]);
	        this.renderLayer(this, sourceCache$3, layer$2, coords$2);
	    }
	    if (this.options.showTileBoundaries) {
	        var selectedSource;
	        var sourceCache$4;
	        var layers = performance.values(this.style._layers);
	        layers.forEach(function (layer) {
	            if (layer.source && !layer.isHidden(this$1.transform.zoom)) {
	                if (layer.source !== (sourceCache$4 && sourceCache$4.id)) {
	                    sourceCache$4 = this$1.style.sourceCaches[layer.source];
	                }
	                if (!selectedSource || selectedSource.getSource().maxzoom < sourceCache$4.getSource().maxzoom) {
	                    selectedSource = sourceCache$4;
	                }
	            }
	        });
	        if (selectedSource) {
	            draw$1.debug(this, selectedSource, selectedSource.getVisibleCoordinates());
	        }
	    }
	    if (this.options.showPadding) {
	        drawDebugPadding(this);
	    }
	    this.context.setDefault();
	};
	Painter.prototype.renderLayer = function renderLayer(painter, sourceCache, layer, coords) {
	    if (layer.isHidden(this.transform.zoom)) {
	        return;
	    }
	    if (layer.type !== 'background' && layer.type !== 'custom' && !coords.length) {
	        return;
	    }
	    this.id = layer.id;
	    this.gpuTimingStart(layer);
	    draw$1[layer.type](painter, sourceCache, layer, coords, this.style.placement.variableOffsets);
	    this.gpuTimingEnd();
	};
	Painter.prototype.gpuTimingStart = function gpuTimingStart(layer) {
	    if (!this.options.gpuTiming) {
	        return;
	    }
	    var ext = this.context.extTimerQuery;
	    var layerTimer = this.gpuTimers[layer.id];
	    if (!layerTimer) {
	        layerTimer = this.gpuTimers[layer.id] = {
	            calls: 0,
	            cpuTime: 0,
	            query: ext.createQueryEXT()
	        };
	    }
	    layerTimer.calls++;
	    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, layerTimer.query);
	};
	Painter.prototype.gpuTimingEnd = function gpuTimingEnd() {
	    if (!this.options.gpuTiming) {
	        return;
	    }
	    var ext = this.context.extTimerQuery;
	    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
	};
	Painter.prototype.collectGpuTimers = function collectGpuTimers() {
	    var currentLayerTimers = this.gpuTimers;
	    this.gpuTimers = {};
	    return currentLayerTimers;
	};
	Painter.prototype.queryGpuTimers = function queryGpuTimers(gpuTimers) {
	    var layers = {};
	    for (var layerId in gpuTimers) {
	        var gpuTimer = gpuTimers[layerId];
	        var ext = this.context.extTimerQuery;
	        var gpuTime = ext.getQueryObjectEXT(gpuTimer.query, ext.QUERY_RESULT_EXT) / (1000 * 1000);
	        ext.deleteQueryEXT(gpuTimer.query);
	        layers[layerId] = gpuTime;
	    }
	    return layers;
	};
	Painter.prototype.translatePosMatrix = function translatePosMatrix(matrix, tile, translate, translateAnchor, inViewportPixelUnitsUnits) {
	    if (!translate[0] && !translate[1]) {
	        return matrix;
	    }
	    var angle = inViewportPixelUnitsUnits ? translateAnchor === 'map' ? this.transform.angle : 0 : translateAnchor === 'viewport' ? -this.transform.angle : 0;
	    if (angle) {
	        var sinA = Math.sin(angle);
	        var cosA = Math.cos(angle);
	        translate = [
	            translate[0] * cosA - translate[1] * sinA,
	            translate[0] * sinA + translate[1] * cosA
	        ];
	    }
	    var translation = [
	        inViewportPixelUnitsUnits ? translate[0] : pixelsToTileUnits(tile, translate[0], this.transform.zoom),
	        inViewportPixelUnitsUnits ? translate[1] : pixelsToTileUnits(tile, translate[1], this.transform.zoom),
	        0
	    ];
	    var translatedMatrix = new Float32Array(16);
	    performance.translate(translatedMatrix, matrix, translation);
	    return translatedMatrix;
	};
	Painter.prototype.saveTileTexture = function saveTileTexture(texture) {
	    var textures = this._tileTextures[texture.size[0]];
	    if (!textures) {
	        this._tileTextures[texture.size[0]] = [texture];
	    } else {
	        textures.push(texture);
	    }
	};
	Painter.prototype.getTileTexture = function getTileTexture(size) {
	    var textures = this._tileTextures[size];
	    return textures && textures.length > 0 ? textures.pop() : null;
	};
	Painter.prototype.isPatternMissing = function isPatternMissing(image) {
	    if (!image) {
	        return false;
	    }
	    if (!image.from || !image.to) {
	        return true;
	    }
	    var imagePosA = this.imageManager.getPattern(image.from.toString());
	    var imagePosB = this.imageManager.getPattern(image.to.toString());
	    return !imagePosA || !imagePosB;
	};
	Painter.prototype.useProgram = function useProgram(name, programConfiguration) {
	    this.cache = this.cache || {};
	    var key = '' + name + (programConfiguration ? programConfiguration.cacheKey : '') + (this._showOverdrawInspector ? '/overdraw' : '');
	    if (!this.cache[key]) {
	        this.cache[key] = new Program$1(this.context, name, shaders[name], programConfiguration, programUniforms[name], this._showOverdrawInspector);
	    }
	    return this.cache[key];
	};
	Painter.prototype.setCustomLayerDefaults = function setCustomLayerDefaults() {
	    this.context.unbindVAO();
	    this.context.cullFace.setDefault();
	    this.context.activeTexture.setDefault();
	    this.context.pixelStoreUnpack.setDefault();
	    this.context.pixelStoreUnpackPremultiplyAlpha.setDefault();
	    this.context.pixelStoreUnpackFlipY.setDefault();
	};
	Painter.prototype.setBaseState = function setBaseState() {
	    var gl = this.context.gl;
	    this.context.cullFace.set(false);
	    this.context.viewport.set([
	        0,
	        0,
	        this.width,
	        this.height
	    ]);
	    this.context.blendEquation.set(gl.FUNC_ADD);
	};
	Painter.prototype.initDebugOverlayCanvas = function initDebugOverlayCanvas() {
	    if (this.debugOverlayCanvas == null) {
	        this.debugOverlayCanvas = performance.window.document.createElement('canvas');
	        this.debugOverlayCanvas.width = 512;
	        this.debugOverlayCanvas.height = 512;
	        var gl = this.context.gl;
	        this.debugOverlayTexture = new performance.Texture(this.context, this.debugOverlayCanvas, gl.RGBA);
	    }
	};
	Painter.prototype.destroy = function destroy() {
	    this.emptyTexture.destroy();
	    if (this.debugOverlayTexture) {
	        this.debugOverlayTexture.destroy();
	    }
	};

	var Frustum = function Frustum(points_, planes_) {
	    this.points = points_;
	    this.planes = planes_;
	};
	Frustum.fromInvProjectionMatrix = function fromInvProjectionMatrix(invProj, worldSize, zoom) {
	    var clipSpaceCorners = [
	        [
	            -1,
	            1,
	            -1,
	            1
	        ],
	        [
	            1,
	            1,
	            -1,
	            1
	        ],
	        [
	            1,
	            -1,
	            -1,
	            1
	        ],
	        [
	            -1,
	            -1,
	            -1,
	            1
	        ],
	        [
	            -1,
	            1,
	            1,
	            1
	        ],
	        [
	            1,
	            1,
	            1,
	            1
	        ],
	        [
	            1,
	            -1,
	            1,
	            1
	        ],
	        [
	            -1,
	            -1,
	            1,
	            1
	        ]
	    ];
	    var scale = Math.pow(2, zoom);
	    var frustumCoords = clipSpaceCorners.map(function (v) {
	        return performance.transformMat4([], v, invProj);
	    }).map(function (v) {
	        return performance.scale$1([], v, 1 / v[3] / worldSize * scale);
	    });
	    var frustumPlanePointIndices = [
	        [
	            0,
	            1,
	            2
	        ],
	        [
	            6,
	            5,
	            4
	        ],
	        [
	            0,
	            3,
	            7
	        ],
	        [
	            2,
	            1,
	            5
	        ],
	        [
	            3,
	            2,
	            6
	        ],
	        [
	            0,
	            4,
	            5
	        ]
	    ];
	    var frustumPlanes = frustumPlanePointIndices.map(function (p) {
	        var a = performance.sub([], frustumCoords[p[0]], frustumCoords[p[1]]);
	        var b = performance.sub([], frustumCoords[p[2]], frustumCoords[p[1]]);
	        var n = performance.normalize([], performance.cross([], a, b));
	        var d = -performance.dot(n, frustumCoords[p[1]]);
	        return n.concat(d);
	    });
	    return new Frustum(frustumCoords, frustumPlanes);
	};
	var Aabb = function Aabb(min_, max_) {
	    this.min = min_;
	    this.max = max_;
	    this.center = performance.scale$2([], performance.add([], this.min, this.max), 0.5);
	};
	Aabb.prototype.quadrant = function quadrant(index) {
	    var split = [
	        index % 2 === 0,
	        index < 2
	    ];
	    var qMin = performance.clone$2(this.min);
	    var qMax = performance.clone$2(this.max);
	    for (var axis = 0; axis < split.length; axis++) {
	        qMin[axis] = split[axis] ? this.min[axis] : this.center[axis];
	        qMax[axis] = split[axis] ? this.center[axis] : this.max[axis];
	    }
	    qMax[2] = this.max[2];
	    return new Aabb(qMin, qMax);
	};
	Aabb.prototype.distanceX = function distanceX(point) {
	    var pointOnAabb = Math.max(Math.min(this.max[0], point[0]), this.min[0]);
	    return pointOnAabb - point[0];
	};
	Aabb.prototype.distanceY = function distanceY(point) {
	    var pointOnAabb = Math.max(Math.min(this.max[1], point[1]), this.min[1]);
	    return pointOnAabb - point[1];
	};
	Aabb.prototype.intersects = function intersects(frustum) {
	    var aabbPoints = [
	        [
	            this.min[0],
	            this.min[1],
	            0,
	            1
	        ],
	        [
	            this.max[0],
	            this.min[1],
	            0,
	            1
	        ],
	        [
	            this.max[0],
	            this.max[1],
	            0,
	            1
	        ],
	        [
	            this.min[0],
	            this.max[1],
	            0,
	            1
	        ]
	    ];
	    var fullyInside = true;
	    for (var p = 0; p < frustum.planes.length; p++) {
	        var plane = frustum.planes[p];
	        var pointsInside = 0;
	        for (var i = 0; i < aabbPoints.length; i++) {
	            pointsInside += performance.dot$1(plane, aabbPoints[i]) >= 0;
	        }
	        if (pointsInside === 0) {
	            return 0;
	        }
	        if (pointsInside !== aabbPoints.length) {
	            fullyInside = false;
	        }
	    }
	    if (fullyInside) {
	        return 2;
	    }
	    for (var axis = 0; axis < 3; axis++) {
	        var projMin = Number.MAX_VALUE;
	        var projMax = -Number.MAX_VALUE;
	        for (var p$1 = 0; p$1 < frustum.points.length; p$1++) {
	            var projectedPoint = frustum.points[p$1][axis] - this.min[axis];
	            projMin = Math.min(projMin, projectedPoint);
	            projMax = Math.max(projMax, projectedPoint);
	        }
	        if (projMax < 0 || projMin > this.max[axis] - this.min[axis]) {
	            return 0;
	        }
	    }
	    return 1;
	};

	var EdgeInsets = function EdgeInsets(top, bottom, left, right) {
	    if (top === void 0)
	        top = 0;
	    if (bottom === void 0)
	        bottom = 0;
	    if (left === void 0)
	        left = 0;
	    if (right === void 0)
	        right = 0;
	    if (isNaN(top) || top < 0 || isNaN(bottom) || bottom < 0 || isNaN(left) || left < 0 || isNaN(right) || right < 0) {
	        throw new Error('Invalid value for edge-insets, top, bottom, left and right must all be numbers');
	    }
	    this.top = top;
	    this.bottom = bottom;
	    this.left = left;
	    this.right = right;
	};
	EdgeInsets.prototype.interpolate = function interpolate(start, target, t) {
	    if (target.top != null && start.top != null) {
	        this.top = performance.number(start.top, target.top, t);
	    }
	    if (target.bottom != null && start.bottom != null) {
	        this.bottom = performance.number(start.bottom, target.bottom, t);
	    }
	    if (target.left != null && start.left != null) {
	        this.left = performance.number(start.left, target.left, t);
	    }
	    if (target.right != null && start.right != null) {
	        this.right = performance.number(start.right, target.right, t);
	    }
	    return this;
	};
	EdgeInsets.prototype.getCenter = function getCenter(width, height) {
	    var x = performance.clamp((this.left + width - this.right) / 2, 0, width);
	    var y = performance.clamp((this.top + height - this.bottom) / 2, 0, height);
	    return new performance.Point(x, y);
	};
	EdgeInsets.prototype.equals = function equals(other) {
	    return this.top === other.top && this.bottom === other.bottom && this.left === other.left && this.right === other.right;
	};
	EdgeInsets.prototype.clone = function clone() {
	    return new EdgeInsets(this.top, this.bottom, this.left, this.right);
	};
	EdgeInsets.prototype.toJSON = function toJSON() {
	    return {
	        top: this.top,
	        bottom: this.bottom,
	        left: this.left,
	        right: this.right
	    };
	};

	var Transform = function Transform(minZoom, maxZoom, minPitch, maxPitch, renderWorldCopies) {
	    this.tileSize = 512;
	    this.maxValidLatitude = 85.051129;
	    this._renderWorldCopies = renderWorldCopies === undefined ? true : renderWorldCopies;
	    this._minZoom = minZoom || 0;
	    this._maxZoom = maxZoom || 22;
	    this._minPitch = minPitch === undefined || minPitch === null ? 0 : minPitch;
	    this._maxPitch = maxPitch === undefined || maxPitch === null ? 60 : maxPitch;
	    this.setMaxBounds();
	    this.width = 0;
	    this.height = 0;
	    this._center = new performance.LngLat(0, 0);
	    this.zoom = 0;
	    this.angle = 0;
	    this._fov = 0.6435011087932844;
	    this._pitch = 0;
	    this._unmodified = true;
	    this._edgeInsets = new EdgeInsets();
	    this._posMatrixCache = {};
	    this._alignedPosMatrixCache = {};
	};
	var prototypeAccessors = {
	    minZoom: { configurable: true },
	    maxZoom: { configurable: true },
	    minPitch: { configurable: true },
	    maxPitch: { configurable: true },
	    renderWorldCopies: { configurable: true },
	    worldSize: { configurable: true },
	    centerOffset: { configurable: true },
	    size: { configurable: true },
	    bearing: { configurable: true },
	    pitch: { configurable: true },
	    fov: { configurable: true },
	    zoom: { configurable: true },
	    center: { configurable: true },
	    padding: { configurable: true },
	    centerPoint: { configurable: true },
	    unmodified: { configurable: true },
	    point: { configurable: true }
	};
	Transform.prototype.clone = function clone() {
	    var clone = new Transform(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
	    clone.tileSize = this.tileSize;
	    clone.latRange = this.latRange;
	    clone.width = this.width;
	    clone.height = this.height;
	    clone._center = this._center;
	    clone.zoom = this.zoom;
	    clone.angle = this.angle;
	    clone._fov = this._fov;
	    clone._pitch = this._pitch;
	    clone._unmodified = this._unmodified;
	    clone._edgeInsets = this._edgeInsets.clone();
	    clone._calcMatrices();
	    return clone;
	};
	prototypeAccessors.minZoom.get = function () {
	    return this._minZoom;
	};
	prototypeAccessors.minZoom.set = function (zoom) {
	    if (this._minZoom === zoom) {
	        return;
	    }
	    this._minZoom = zoom;
	    this.zoom = Math.max(this.zoom, zoom);
	};
	prototypeAccessors.maxZoom.get = function () {
	    return this._maxZoom;
	};
	prototypeAccessors.maxZoom.set = function (zoom) {
	    if (this._maxZoom === zoom) {
	        return;
	    }
	    this._maxZoom = zoom;
	    this.zoom = Math.min(this.zoom, zoom);
	};
	prototypeAccessors.minPitch.get = function () {
	    return this._minPitch;
	};
	prototypeAccessors.minPitch.set = function (pitch) {
	    if (this._minPitch === pitch) {
	        return;
	    }
	    this._minPitch = pitch;
	    this.pitch = Math.max(this.pitch, pitch);
	};
	prototypeAccessors.maxPitch.get = function () {
	    return this._maxPitch;
	};
	prototypeAccessors.maxPitch.set = function (pitch) {
	    if (this._maxPitch === pitch) {
	        return;
	    }
	    this._maxPitch = pitch;
	    this.pitch = Math.min(this.pitch, pitch);
	};
	prototypeAccessors.renderWorldCopies.get = function () {
	    return this._renderWorldCopies;
	};
	prototypeAccessors.renderWorldCopies.set = function (renderWorldCopies) {
	    if (renderWorldCopies === undefined) {
	        renderWorldCopies = true;
	    } else if (renderWorldCopies === null) {
	        renderWorldCopies = false;
	    }
	    this._renderWorldCopies = renderWorldCopies;
	};
	prototypeAccessors.worldSize.get = function () {
	    return this.tileSize * this.scale;
	};
	prototypeAccessors.centerOffset.get = function () {
	    return this.centerPoint._sub(this.size._div(2));
	};
	prototypeAccessors.size.get = function () {
	    return new performance.Point(this.width, this.height);
	};
	prototypeAccessors.bearing.get = function () {
	    return -this.angle / Math.PI * 180;
	};
	prototypeAccessors.bearing.set = function (bearing) {
	    var b = -performance.wrap(bearing, -180, 180) * Math.PI / 180;
	    if (this.angle === b) {
	        return;
	    }
	    this._unmodified = false;
	    this.angle = b;
	    this._calcMatrices();
	    this.rotationMatrix = performance.create$2();
	    performance.rotate(this.rotationMatrix, this.rotationMatrix, this.angle);
	};
	prototypeAccessors.pitch.get = function () {
	    return this._pitch / Math.PI * 180;
	};
	prototypeAccessors.pitch.set = function (pitch) {
	    var p = performance.clamp(pitch, this.minPitch, this.maxPitch) / 180 * Math.PI;
	    if (this._pitch === p) {
	        return;
	    }
	    this._unmodified = false;
	    this._pitch = p;
	    this._calcMatrices();
	};
	prototypeAccessors.fov.get = function () {
	    return this._fov / Math.PI * 180;
	};
	prototypeAccessors.fov.set = function (fov) {
	    fov = Math.max(0.01, Math.min(60, fov));
	    if (this._fov === fov) {
	        return;
	    }
	    this._unmodified = false;
	    this._fov = fov / 180 * Math.PI;
	    this._calcMatrices();
	};
	prototypeAccessors.zoom.get = function () {
	    return this._zoom;
	};
	prototypeAccessors.zoom.set = function (zoom) {
	    var z = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);
	    if (this._zoom === z) {
	        return;
	    }
	    this._unmodified = false;
	    this._zoom = z;
	    this.scale = this.zoomScale(z);
	    this.tileZoom = Math.floor(z);
	    this.zoomFraction = z - this.tileZoom;
	    this._constrain();
	    this._calcMatrices();
	};
	prototypeAccessors.center.get = function () {
	    return this._center;
	};
	prototypeAccessors.center.set = function (center) {
	    if (center.lat === this._center.lat && center.lng === this._center.lng) {
	        return;
	    }
	    this._unmodified = false;
	    this._center = center;
	    this._constrain();
	    this._calcMatrices();
	};
	prototypeAccessors.padding.get = function () {
	    return this._edgeInsets.toJSON();
	};
	prototypeAccessors.padding.set = function (padding) {
	    if (this._edgeInsets.equals(padding)) {
	        return;
	    }
	    this._unmodified = false;
	    this._edgeInsets.interpolate(this._edgeInsets, padding, 1);
	    this._calcMatrices();
	};
	prototypeAccessors.centerPoint.get = function () {
	    return this._edgeInsets.getCenter(this.width, this.height);
	};
	Transform.prototype.isPaddingEqual = function isPaddingEqual(padding) {
	    return this._edgeInsets.equals(padding);
	};
	Transform.prototype.interpolatePadding = function interpolatePadding(start, target, t) {
	    this._unmodified = false;
	    this._edgeInsets.interpolate(start, target, t);
	    this._constrain();
	    this._calcMatrices();
	};
	Transform.prototype.coveringZoomLevel = function coveringZoomLevel(options) {
	    var z = (options.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / options.tileSize));
	    return Math.max(0, z);
	};
	Transform.prototype.getVisibleUnwrappedCoordinates = function getVisibleUnwrappedCoordinates(tileID) {
	    var result = [new performance.UnwrappedTileID(0, tileID)];
	    if (this._renderWorldCopies) {
	        var utl = this.pointCoordinate(new performance.Point(0, 0));
	        var utr = this.pointCoordinate(new performance.Point(this.width, 0));
	        var ubl = this.pointCoordinate(new performance.Point(this.width, this.height));
	        var ubr = this.pointCoordinate(new performance.Point(0, this.height));
	        var w0 = Math.floor(Math.min(utl.x, utr.x, ubl.x, ubr.x));
	        var w1 = Math.floor(Math.max(utl.x, utr.x, ubl.x, ubr.x));
	        var extraWorldCopy = 1;
	        for (var w = w0 - extraWorldCopy; w <= w1 + extraWorldCopy; w++) {
	            if (w === 0) {
	                continue;
	            }
	            result.push(new performance.UnwrappedTileID(w, tileID));
	        }
	    }
	    return result;
	};
	Transform.prototype.coveringTiles = function coveringTiles(options) {
	    var z = this.coveringZoomLevel(options);
	    var actualZ = z;
	    if (options.minzoom !== undefined && z < options.minzoom) {
	        return [];
	    }
	    if (options.maxzoom !== undefined && z > options.maxzoom) {
	        z = options.maxzoom;
	    }
	    var centerCoord = performance.MercatorCoordinate.fromLngLat(this.center);
	    var numTiles = Math.pow(2, z);
	    var centerPoint = [
	        numTiles * centerCoord.x,
	        numTiles * centerCoord.y,
	        0
	    ];
	    var cameraFrustum = Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, z);
	    var minZoom = options.minzoom || 0;
	    if (this.pitch <= 60 && this._edgeInsets.top < 0.1) {
	        minZoom = z;
	    }
	    var radiusOfMaxLvlLodInTiles = 3;
	    var newRootTile = function (wrap) {
	        return {
	            aabb: new Aabb([
	                wrap * numTiles,
	                0,
	                0
	            ], [
	                (wrap + 1) * numTiles,
	                numTiles,
	                0
	            ]),
	            zoom: 0,
	            x: 0,
	            y: 0,
	            wrap: wrap,
	            fullyVisible: false
	        };
	    };
	    var stack = [];
	    var result = [];
	    var maxZoom = z;
	    var overscaledZ = options.reparseOverscaled ? actualZ : z;
	    if (this._renderWorldCopies) {
	        for (var i = 1; i <= 3; i++) {
	            stack.push(newRootTile(-i));
	            stack.push(newRootTile(i));
	        }
	    }
	    stack.push(newRootTile(0));
	    while (stack.length > 0) {
	        var it = stack.pop();
	        var x = it.x;
	        var y = it.y;
	        var fullyVisible = it.fullyVisible;
	        if (!fullyVisible) {
	            var intersectResult = it.aabb.intersects(cameraFrustum);
	            if (intersectResult === 0) {
	                continue;
	            }
	            fullyVisible = intersectResult === 2;
	        }
	        var distanceX = it.aabb.distanceX(centerPoint);
	        var distanceY = it.aabb.distanceY(centerPoint);
	        var longestDim = Math.max(Math.abs(distanceX), Math.abs(distanceY));
	        var distToSplit = radiusOfMaxLvlLodInTiles + (1 << maxZoom - it.zoom) - 2;
	        if (it.zoom === maxZoom || longestDim > distToSplit && it.zoom >= minZoom) {
	            result.push({
	                tileID: new performance.OverscaledTileID(it.zoom === maxZoom ? overscaledZ : it.zoom, it.wrap, it.zoom, x, y),
	                distanceSq: performance.sqrLen([
	                    centerPoint[0] - 0.5 - x,
	                    centerPoint[1] - 0.5 - y
	                ])
	            });
	            continue;
	        }
	        for (var i$1 = 0; i$1 < 4; i$1++) {
	            var childX = (x << 1) + i$1 % 2;
	            var childY = (y << 1) + (i$1 >> 1);
	            stack.push({
	                aabb: it.aabb.quadrant(i$1),
	                zoom: it.zoom + 1,
	                x: childX,
	                y: childY,
	                wrap: it.wrap,
	                fullyVisible: fullyVisible
	            });
	        }
	    }
	    return result.sort(function (a, b) {
	        return a.distanceSq - b.distanceSq;
	    }).map(function (a) {
	        return a.tileID;
	    });
	};
	Transform.prototype.resize = function resize(width, height) {
	    this.width = width;
	    this.height = height;
	    this.pixelsToGLUnits = [
	        2 / width,
	        -2 / height
	    ];
	    this._constrain();
	    this._calcMatrices();
	};
	prototypeAccessors.unmodified.get = function () {
	    return this._unmodified;
	};
	Transform.prototype.zoomScale = function zoomScale(zoom) {
	    return Math.pow(2, zoom);
	};
	Transform.prototype.scaleZoom = function scaleZoom(scale) {
	    return Math.log(scale) / Math.LN2;
	};
	Transform.prototype.project = function project(lnglat) {
	    var lat = performance.clamp(lnglat.lat, -this.maxValidLatitude, this.maxValidLatitude);
	    return new performance.Point(performance.mercatorXfromLng(lnglat.lng) * this.worldSize, performance.mercatorYfromLat(lat) * this.worldSize);
	};
	Transform.prototype.unproject = function unproject(point) {
	    return new performance.MercatorCoordinate(point.x / this.worldSize, point.y / this.worldSize).toLngLat();
	};
	prototypeAccessors.point.get = function () {
	    return this.project(this.center);
	};
	Transform.prototype.setLocationAtPoint = function setLocationAtPoint(lnglat, point) {
	    var a = this.pointCoordinate(point);
	    var b = this.pointCoordinate(this.centerPoint);
	    var loc = this.locationCoordinate(lnglat);
	    var newCenter = new performance.MercatorCoordinate(loc.x - (a.x - b.x), loc.y - (a.y - b.y));
	    this.center = this.coordinateLocation(newCenter);
	    if (this._renderWorldCopies) {
	        this.center = this.center.wrap();
	    }
	};
	Transform.prototype.locationPoint = function locationPoint(lnglat) {
	    return this.coordinatePoint(this.locationCoordinate(lnglat));
	};
	Transform.prototype.pointLocation = function pointLocation(p) {
	    return this.coordinateLocation(this.pointCoordinate(p));
	};
	Transform.prototype.locationCoordinate = function locationCoordinate(lnglat) {
	    return performance.MercatorCoordinate.fromLngLat(lnglat);
	};
	Transform.prototype.coordinateLocation = function coordinateLocation(coord) {
	    return coord.toLngLat();
	};
	Transform.prototype.pointCoordinate = function pointCoordinate(p) {
	    var targetZ = 0;
	    var coord0 = [
	        p.x,
	        p.y,
	        0,
	        1
	    ];
	    var coord1 = [
	        p.x,
	        p.y,
	        1,
	        1
	    ];
	    performance.transformMat4(coord0, coord0, this.pixelMatrixInverse);
	    performance.transformMat4(coord1, coord1, this.pixelMatrixInverse);
	    var w0 = coord0[3];
	    var w1 = coord1[3];
	    var x0 = coord0[0] / w0;
	    var x1 = coord1[0] / w1;
	    var y0 = coord0[1] / w0;
	    var y1 = coord1[1] / w1;
	    var z0 = coord0[2] / w0;
	    var z1 = coord1[2] / w1;
	    var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);
	    return new performance.MercatorCoordinate(performance.number(x0, x1, t) / this.worldSize, performance.number(y0, y1, t) / this.worldSize);
	};
	Transform.prototype.coordinatePoint = function coordinatePoint(coord) {
	    var p = [
	        coord.x * this.worldSize,
	        coord.y * this.worldSize,
	        0,
	        1
	    ];
	    performance.transformMat4(p, p, this.pixelMatrix);
	    return new performance.Point(p[0] / p[3], p[1] / p[3]);
	};
	Transform.prototype.getBounds = function getBounds() {
	    return new performance.LngLatBounds().extend(this.pointLocation(new performance.Point(0, 0))).extend(this.pointLocation(new performance.Point(this.width, 0))).extend(this.pointLocation(new performance.Point(this.width, this.height))).extend(this.pointLocation(new performance.Point(0, this.height)));
	};
	Transform.prototype.getMaxBounds = function getMaxBounds() {
	    if (!this.latRange || this.latRange.length !== 2 || !this.lngRange || this.lngRange.length !== 2) {
	        return null;
	    }
	    return new performance.LngLatBounds([
	        this.lngRange[0],
	        this.latRange[0]
	    ], [
	        this.lngRange[1],
	        this.latRange[1]
	    ]);
	};
	Transform.prototype.setMaxBounds = function setMaxBounds(bounds) {
	    if (bounds) {
	        this.lngRange = [
	            bounds.getWest(),
	            bounds.getEast()
	        ];
	        this.latRange = [
	            bounds.getSouth(),
	            bounds.getNorth()
	        ];
	        this._constrain();
	    } else {
	        this.lngRange = null;
	        this.latRange = [
	            -this.maxValidLatitude,
	            this.maxValidLatitude
	        ];
	    }
	};
	Transform.prototype.calculatePosMatrix = function calculatePosMatrix(unwrappedTileID, aligned) {
	    if (aligned === void 0)
	        aligned = false;
	    var posMatrixKey = unwrappedTileID.key;
	    var cache = aligned ? this._alignedPosMatrixCache : this._posMatrixCache;
	    if (cache[posMatrixKey]) {
	        return cache[posMatrixKey];
	    }
	    var canonical = unwrappedTileID.canonical;
	    var scale = this.worldSize / this.zoomScale(canonical.z);
	    var unwrappedX = canonical.x + Math.pow(2, canonical.z) * unwrappedTileID.wrap;
	    var posMatrix = performance.identity(new Float64Array(16));
	    performance.translate(posMatrix, posMatrix, [
	        unwrappedX * scale,
	        canonical.y * scale,
	        0
	    ]);
	    performance.scale(posMatrix, posMatrix, [
	        scale / performance.EXTENT,
	        scale / performance.EXTENT,
	        1
	    ]);
	    performance.multiply(posMatrix, aligned ? this.alignedProjMatrix : this.projMatrix, posMatrix);
	    cache[posMatrixKey] = new Float32Array(posMatrix);
	    return cache[posMatrixKey];
	};
	Transform.prototype.customLayerMatrix = function customLayerMatrix() {
	    return this.mercatorMatrix.slice();
	};
	Transform.prototype._constrain = function _constrain() {
	    if (!this.center || !this.width || !this.height || this._constraining) {
	        return;
	    }
	    this._constraining = true;
	    var minY = -90;
	    var maxY = 90;
	    var minX = -180;
	    var maxX = 180;
	    var sy, sx, x2, y2;
	    var size = this.size, unmodified = this._unmodified;
	    if (this.latRange) {
	        var latRange = this.latRange;
	        minY = performance.mercatorYfromLat(latRange[1]) * this.worldSize;
	        maxY = performance.mercatorYfromLat(latRange[0]) * this.worldSize;
	        sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;
	    }
	    if (this.lngRange) {
	        var lngRange = this.lngRange;
	        minX = performance.mercatorXfromLng(lngRange[0]) * this.worldSize;
	        maxX = performance.mercatorXfromLng(lngRange[1]) * this.worldSize;
	        sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;
	    }
	    var point = this.point;
	    var s = Math.max(sx || 0, sy || 0);
	    if (s) {
	        this.center = this.unproject(new performance.Point(sx ? (maxX + minX) / 2 : point.x, sy ? (maxY + minY) / 2 : point.y));
	        this.zoom += this.scaleZoom(s);
	        this._unmodified = unmodified;
	        this._constraining = false;
	        return;
	    }
	    if (this.latRange) {
	        var y = point.y, h2 = size.y / 2;
	        if (y - h2 < minY) {
	            y2 = minY + h2;
	        }
	        if (y + h2 > maxY) {
	            y2 = maxY - h2;
	        }
	    }
	    if (this.lngRange) {
	        var x = point.x, w2 = size.x / 2;
	        if (x - w2 < minX) {
	            x2 = minX + w2;
	        }
	        if (x + w2 > maxX) {
	            x2 = maxX - w2;
	        }
	    }
	    if (x2 !== undefined || y2 !== undefined) {
	        this.center = this.unproject(new performance.Point(x2 !== undefined ? x2 : point.x, y2 !== undefined ? y2 : point.y));
	    }
	    this._unmodified = unmodified;
	    this._constraining = false;
	};
	Transform.prototype._calcMatrices = function _calcMatrices() {
	    if (!this.height) {
	        return;
	    }
	    var halfFov = this._fov / 2;
	    var offset = this.centerOffset;
	    this.cameraToCenterDistance = 0.5 / Math.tan(halfFov) * this.height;
	    var groundAngle = Math.PI / 2 + this._pitch;
	    var fovAboveCenter = this._fov * (0.5 + offset.y / this.height);
	    var topHalfSurfaceDistance = Math.sin(fovAboveCenter) * this.cameraToCenterDistance / Math.sin(performance.clamp(Math.PI - groundAngle - fovAboveCenter, 0.01, Math.PI - 0.01));
	    var point = this.point;
	    var x = point.x, y = point.y;
	    var furthestDistance = Math.cos(Math.PI / 2 - this._pitch) * topHalfSurfaceDistance + this.cameraToCenterDistance;
	    var farZ = furthestDistance * 1.01;
	    var nearZ = this.height / 50;
	    var m = new Float64Array(16);
	    performance.perspective(m, this._fov, this.width / this.height, nearZ, farZ);
	    m[8] = -offset.x * 2 / this.width;
	    m[9] = offset.y * 2 / this.height;
	    performance.scale(m, m, [
	        1,
	        -1,
	        1
	    ]);
	    performance.translate(m, m, [
	        0,
	        0,
	        -this.cameraToCenterDistance
	    ]);
	    performance.rotateX(m, m, this._pitch);
	    performance.rotateZ(m, m, this.angle);
	    performance.translate(m, m, [
	        -x,
	        -y,
	        0
	    ]);
	    this.mercatorMatrix = performance.scale([], m, [
	        this.worldSize,
	        this.worldSize,
	        this.worldSize
	    ]);
	    performance.scale(m, m, [
	        1,
	        1,
	        performance.mercatorZfromAltitude(1, this.center.lat) * this.worldSize,
	        1
	    ]);
	    this.projMatrix = m;
	    this.invProjMatrix = performance.invert([], this.projMatrix);
	    var xShift = this.width % 2 / 2, yShift = this.height % 2 / 2, angleCos = Math.cos(this.angle), angleSin = Math.sin(this.angle), dx = x - Math.round(x) + angleCos * xShift + angleSin * yShift, dy = y - Math.round(y) + angleCos * yShift + angleSin * xShift;
	    var alignedM = new Float64Array(m);
	    performance.translate(alignedM, alignedM, [
	        dx > 0.5 ? dx - 1 : dx,
	        dy > 0.5 ? dy - 1 : dy,
	        0
	    ]);
	    this.alignedProjMatrix = alignedM;
	    m = performance.create();
	    performance.scale(m, m, [
	        this.width / 2,
	        -this.height / 2,
	        1
	    ]);
	    performance.translate(m, m, [
	        1,
	        -1,
	        0
	    ]);
	    this.labelPlaneMatrix = m;
	    m = performance.create();
	    performance.scale(m, m, [
	        1,
	        -1,
	        1
	    ]);
	    performance.translate(m, m, [
	        -1,
	        -1,
	        0
	    ]);
	    performance.scale(m, m, [
	        2 / this.width,
	        2 / this.height,
	        1
	    ]);
	    this.glCoordMatrix = m;
	    this.pixelMatrix = performance.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix);
	    m = performance.invert(new Float64Array(16), this.pixelMatrix);
	    if (!m) {
	        throw new Error('failed to invert matrix');
	    }
	    this.pixelMatrixInverse = m;
	    this._posMatrixCache = {};
	    this._alignedPosMatrixCache = {};
	};
	Transform.prototype.maxPitchScaleFactor = function maxPitchScaleFactor() {
	    if (!this.pixelMatrixInverse) {
	        return 1;
	    }
	    var coord = this.pointCoordinate(new performance.Point(0, 0));
	    var p = [
	        coord.x * this.worldSize,
	        coord.y * this.worldSize,
	        0,
	        1
	    ];
	    var topPoint = performance.transformMat4(p, p, this.pixelMatrix);
	    return topPoint[3] / this.cameraToCenterDistance;
	};
	Transform.prototype.getCameraPoint = function getCameraPoint() {
	    var pitch = this._pitch;
	    var yOffset = Math.tan(pitch) * (this.cameraToCenterDistance || 1);
	    return this.centerPoint.add(new performance.Point(0, yOffset));
	};
	Transform.prototype.getCameraQueryGeometry = function getCameraQueryGeometry(queryGeometry) {
	    var c = this.getCameraPoint();
	    if (queryGeometry.length === 1) {
	        return [
	            queryGeometry[0],
	            c
	        ];
	    } else {
	        var minX = c.x;
	        var minY = c.y;
	        var maxX = c.x;
	        var maxY = c.y;
	        for (var i = 0, list = queryGeometry; i < list.length; i += 1) {
	            var p = list[i];
	            minX = Math.min(minX, p.x);
	            minY = Math.min(minY, p.y);
	            maxX = Math.max(maxX, p.x);
	            maxY = Math.max(maxY, p.y);
	        }
	        return [
	            new performance.Point(minX, minY),
	            new performance.Point(maxX, minY),
	            new performance.Point(maxX, maxY),
	            new performance.Point(minX, maxY),
	            new performance.Point(minX, minY)
	        ];
	    }
	};
	Object.defineProperties(Transform.prototype, prototypeAccessors);

	function throttle(fn, time) {
	    var pending = false;
	    var timerId = null;
	    var later = function () {
	        timerId = null;
	        if (pending) {
	            fn();
	            timerId = setTimeout(later, time);
	            pending = false;
	        }
	    };
	    return function () {
	        pending = true;
	        if (!timerId) {
	            later();
	        }
	        return timerId;
	    };
	}

	var Hash = function Hash(hashName) {
	    this._hashName = hashName && encodeURIComponent(hashName);
	    performance.bindAll([
	        '_getCurrentHash',
	        '_onHashChange',
	        '_updateHash'
	    ], this);
	    this._updateHash = throttle(this._updateHashUnthrottled.bind(this), 30 * 1000 / 100);
	};
	Hash.prototype.addTo = function addTo(map) {
	    this._map = map;
	    performance.window.addEventListener('hashchange', this._onHashChange, false);
	    this._map.on('moveend', this._updateHash);
	    return this;
	};
	Hash.prototype.remove = function remove() {
	    performance.window.removeEventListener('hashchange', this._onHashChange, false);
	    this._map.off('moveend', this._updateHash);
	    clearTimeout(this._updateHash());
	    delete this._map;
	    return this;
	};
	Hash.prototype.getHashString = function getHashString(mapFeedback) {
	    var center = this._map.getCenter(), zoom = Math.round(this._map.getZoom() * 100) / 100, precision = Math.ceil((zoom * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), m = Math.pow(10, precision), lng = Math.round(center.lng * m) / m, lat = Math.round(center.lat * m) / m, bearing = this._map.getBearing(), pitch = this._map.getPitch();
	    var hash = '';
	    if (mapFeedback) {
	        hash += '/' + lng + '/' + lat + '/' + zoom;
	    } else {
	        hash += zoom + '/' + lat + '/' + lng;
	    }
	    if (bearing || pitch) {
	        hash += '/' + Math.round(bearing * 10) / 10;
	    }
	    if (pitch) {
	        hash += '/' + Math.round(pitch);
	    }
	    if (this._hashName) {
	        var hashName = this._hashName;
	        var found = false;
	        var parts = performance.window.location.hash.slice(1).split('&').map(function (part) {
	            var key = part.split('=')[0];
	            if (key === hashName) {
	                found = true;
	                return key + '=' + hash;
	            }
	            return part;
	        }).filter(function (a) {
	            return a;
	        });
	        if (!found) {
	            parts.push(hashName + '=' + hash);
	        }
	        return '#' + parts.join('&');
	    }
	    return '#' + hash;
	};
	Hash.prototype._getCurrentHash = function _getCurrentHash() {
	    var this$1 = this;
	    var hash = performance.window.location.hash.replace('#', '');
	    if (this._hashName) {
	        var keyval;
	        hash.split('&').map(function (part) {
	            return part.split('=');
	        }).forEach(function (part) {
	            if (part[0] === this$1._hashName) {
	                keyval = part;
	            }
	        });
	        return (keyval ? keyval[1] || '' : '').split('/');
	    }
	    return hash.split('/');
	};
	Hash.prototype._onHashChange = function _onHashChange() {
	    var loc = this._getCurrentHash();
	    if (loc.length >= 3 && !loc.some(function (v) {
	            return isNaN(v);
	        })) {
	        var bearing = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(loc[3] || 0) : this._map.getBearing();
	        this._map.jumpTo({
	            center: [
	                +loc[2],
	                +loc[1]
	            ],
	            zoom: +loc[0],
	            bearing: bearing,
	            pitch: +(loc[4] || 0)
	        });
	        return true;
	    }
	    return false;
	};
	Hash.prototype._updateHashUnthrottled = function _updateHashUnthrottled() {
	    var location = performance.window.location.href.replace(/(#.+)?$/, this.getHashString());
	    try {
	        performance.window.history.replaceState(performance.window.history.state, null, location);
	    } catch (SecurityError) {
	    }
	};

	var defaultInertiaOptions = {
	    linearity: 0.3,
	    easing: performance.bezier(0, 0, 0.3, 1)
	};
	var defaultPanInertiaOptions = performance.extend({
	    deceleration: 2500,
	    maxSpeed: 1400
	}, defaultInertiaOptions);
	var defaultZoomInertiaOptions = performance.extend({
	    deceleration: 20,
	    maxSpeed: 1400
	}, defaultInertiaOptions);
	var defaultBearingInertiaOptions = performance.extend({
	    deceleration: 1000,
	    maxSpeed: 360
	}, defaultInertiaOptions);
	var defaultPitchInertiaOptions = performance.extend({
	    deceleration: 1000,
	    maxSpeed: 90
	}, defaultInertiaOptions);
	var HandlerInertia = function HandlerInertia(map) {
	    this._map = map;
	    this.clear();
	};
	HandlerInertia.prototype.clear = function clear() {
	    this._inertiaBuffer = [];
	};
	HandlerInertia.prototype.record = function record(settings) {
	    this._drainInertiaBuffer();
	    this._inertiaBuffer.push({
	        time: performance.browser.now(),
	        settings: settings
	    });
	};
	HandlerInertia.prototype._drainInertiaBuffer = function _drainInertiaBuffer() {
	    var inertia = this._inertiaBuffer, now = performance.browser.now(), cutoff = 160;
	    while (inertia.length > 0 && now - inertia[0].time > cutoff) {
	        inertia.shift();
	    }
	};
	HandlerInertia.prototype._onMoveEnd = function _onMoveEnd(panInertiaOptions) {
	    this._drainInertiaBuffer();
	    if (this._inertiaBuffer.length < 2) {
	        return;
	    }
	    var deltas = {
	        zoom: 0,
	        bearing: 0,
	        pitch: 0,
	        pan: new performance.Point(0, 0),
	        pinchAround: undefined,
	        around: undefined
	    };
	    for (var i = 0, list = this._inertiaBuffer; i < list.length; i += 1) {
	        var ref = list[i];
	        var settings = ref.settings;
	        deltas.zoom += settings.zoomDelta || 0;
	        deltas.bearing += settings.bearingDelta || 0;
	        deltas.pitch += settings.pitchDelta || 0;
	        if (settings.panDelta) {
	            deltas.pan._add(settings.panDelta);
	        }
	        if (settings.around) {
	            deltas.around = settings.around;
	        }
	        if (settings.pinchAround) {
	            deltas.pinchAround = settings.pinchAround;
	        }
	    }
	    var lastEntry = this._inertiaBuffer[this._inertiaBuffer.length - 1];
	    var duration = lastEntry.time - this._inertiaBuffer[0].time;
	    var easeOptions = {};
	    if (deltas.pan.mag()) {
	        var result = calculateEasing(deltas.pan.mag(), duration, performance.extend({}, defaultPanInertiaOptions, panInertiaOptions || {}));
	        easeOptions.offset = deltas.pan.mult(result.amount / deltas.pan.mag());
	        easeOptions.center = this._map.transform.center;
	        extendDuration(easeOptions, result);
	    }
	    if (deltas.zoom) {
	        var result$1 = calculateEasing(deltas.zoom, duration, defaultZoomInertiaOptions);
	        easeOptions.zoom = this._map.transform.zoom + result$1.amount;
	        extendDuration(easeOptions, result$1);
	    }
	    if (deltas.bearing) {
	        var result$2 = calculateEasing(deltas.bearing, duration, defaultBearingInertiaOptions);
	        easeOptions.bearing = this._map.transform.bearing + performance.clamp(result$2.amount, -179, 179);
	        extendDuration(easeOptions, result$2);
	    }
	    if (deltas.pitch) {
	        var result$3 = calculateEasing(deltas.pitch, duration, defaultPitchInertiaOptions);
	        easeOptions.pitch = this._map.transform.pitch + result$3.amount;
	        extendDuration(easeOptions, result$3);
	    }
	    if (easeOptions.zoom || easeOptions.bearing) {
	        var last = deltas.pinchAround === undefined ? deltas.around : deltas.pinchAround;
	        easeOptions.around = last ? this._map.unproject(last) : this._map.getCenter();
	    }
	    this.clear();
	    return performance.extend(easeOptions, { noMoveStart: true });
	};
	function extendDuration(easeOptions, result) {
	    if (!easeOptions.duration || easeOptions.duration < result.duration) {
	        easeOptions.duration = result.duration;
	        easeOptions.easing = result.easing;
	    }
	}
	function calculateEasing(amount, inertiaDuration, inertiaOptions) {
	    var maxSpeed = inertiaOptions.maxSpeed;
	    var linearity = inertiaOptions.linearity;
	    var deceleration = inertiaOptions.deceleration;
	    var speed = performance.clamp(amount * linearity / (inertiaDuration / 1000), -maxSpeed, maxSpeed);
	    var duration = Math.abs(speed) / (deceleration * linearity);
	    return {
	        easing: inertiaOptions.easing,
	        duration: duration * 1000,
	        amount: speed * (duration / 2)
	    };
	}

	var MapMouseEvent = function (Event) {
	    function MapMouseEvent(type, map, originalEvent, data) {
	        if (data === void 0)
	            data = {};
	        var point = DOM.mousePos(map.getCanvasContainer(), originalEvent);
	        var lngLat = map.unproject(point);
	        Event.call(this, type, performance.extend({
	            point: point,
	            lngLat: lngLat,
	            originalEvent: originalEvent
	        }, data));
	        this._defaultPrevented = false;
	        this.target = map;
	    }
	    if (Event)
	        MapMouseEvent.__proto__ = Event;
	    MapMouseEvent.prototype = Object.create(Event && Event.prototype);
	    MapMouseEvent.prototype.constructor = MapMouseEvent;
	    var prototypeAccessors = { defaultPrevented: { configurable: true } };
	    MapMouseEvent.prototype.preventDefault = function preventDefault() {
	        this._defaultPrevented = true;
	    };
	    prototypeAccessors.defaultPrevented.get = function () {
	        return this._defaultPrevented;
	    };
	    Object.defineProperties(MapMouseEvent.prototype, prototypeAccessors);
	    return MapMouseEvent;
	}(performance.Event);
	var MapTouchEvent = function (Event) {
	    function MapTouchEvent(type, map, originalEvent) {
	        var touches = type === 'touchend' ? originalEvent.changedTouches : originalEvent.touches;
	        var points = DOM.touchPos(map.getCanvasContainer(), touches);
	        var lngLats = points.map(function (t) {
	            return map.unproject(t);
	        });
	        var point = points.reduce(function (prev, curr, i, arr) {
	            return prev.add(curr.div(arr.length));
	        }, new performance.Point(0, 0));
	        var lngLat = map.unproject(point);
	        Event.call(this, type, {
	            points: points,
	            point: point,
	            lngLats: lngLats,
	            lngLat: lngLat,
	            originalEvent: originalEvent
	        });
	        this._defaultPrevented = false;
	    }
	    if (Event)
	        MapTouchEvent.__proto__ = Event;
	    MapTouchEvent.prototype = Object.create(Event && Event.prototype);
	    MapTouchEvent.prototype.constructor = MapTouchEvent;
	    var prototypeAccessors$1 = { defaultPrevented: { configurable: true } };
	    MapTouchEvent.prototype.preventDefault = function preventDefault() {
	        this._defaultPrevented = true;
	    };
	    prototypeAccessors$1.defaultPrevented.get = function () {
	        return this._defaultPrevented;
	    };
	    Object.defineProperties(MapTouchEvent.prototype, prototypeAccessors$1);
	    return MapTouchEvent;
	}(performance.Event);
	var MapWheelEvent = function (Event) {
	    function MapWheelEvent(type, map, originalEvent) {
	        Event.call(this, type, { originalEvent: originalEvent });
	        this._defaultPrevented = false;
	    }
	    if (Event)
	        MapWheelEvent.__proto__ = Event;
	    MapWheelEvent.prototype = Object.create(Event && Event.prototype);
	    MapWheelEvent.prototype.constructor = MapWheelEvent;
	    var prototypeAccessors$2 = { defaultPrevented: { configurable: true } };
	    MapWheelEvent.prototype.preventDefault = function preventDefault() {
	        this._defaultPrevented = true;
	    };
	    prototypeAccessors$2.defaultPrevented.get = function () {
	        return this._defaultPrevented;
	    };
	    Object.defineProperties(MapWheelEvent.prototype, prototypeAccessors$2);
	    return MapWheelEvent;
	}(performance.Event);

	var MapEventHandler = function MapEventHandler(map, options) {
	    this._map = map;
	    this._clickTolerance = options.clickTolerance;
	};
	MapEventHandler.prototype.reset = function reset() {
	    delete this._mousedownPos;
	};
	MapEventHandler.prototype.wheel = function wheel(e) {
	    return this._firePreventable(new MapWheelEvent(e.type, this._map, e));
	};
	MapEventHandler.prototype.mousedown = function mousedown(e, point) {
	    this._mousedownPos = point;
	    return this._firePreventable(new MapMouseEvent(e.type, this._map, e));
	};
	MapEventHandler.prototype.mouseup = function mouseup(e) {
	    this._map.fire(new MapMouseEvent(e.type, this._map, e));
	};
	MapEventHandler.prototype.click = function click(e, point) {
	    if (this._mousedownPos && this._mousedownPos.dist(point) >= this._clickTolerance) {
	        return;
	    }
	    this._map.fire(new MapMouseEvent(e.type, this._map, e));
	};
	MapEventHandler.prototype.dblclick = function dblclick(e) {
	    return this._firePreventable(new MapMouseEvent(e.type, this._map, e));
	};
	MapEventHandler.prototype.mouseover = function mouseover(e) {
	    this._map.fire(new MapMouseEvent(e.type, this._map, e));
	};
	MapEventHandler.prototype.mouseout = function mouseout(e) {
	    this._map.fire(new MapMouseEvent(e.type, this._map, e));
	};
	MapEventHandler.prototype.touchstart = function touchstart(e) {
	    return this._firePreventable(new MapTouchEvent(e.type, this._map, e));
	};
	MapEventHandler.prototype.touchmove = function touchmove(e) {
	    this._map.fire(new MapTouchEvent(e.type, this._map, e));
	};
	MapEventHandler.prototype.touchend = function touchend(e) {
	    this._map.fire(new MapTouchEvent(e.type, this._map, e));
	};
	MapEventHandler.prototype.touchcancel = function touchcancel(e) {
	    this._map.fire(new MapTouchEvent(e.type, this._map, e));
	};
	MapEventHandler.prototype._firePreventable = function _firePreventable(mapEvent) {
	    this._map.fire(mapEvent);
	    if (mapEvent.defaultPrevented) {
	        return {};
	    }
	};
	MapEventHandler.prototype.isEnabled = function isEnabled() {
	    return true;
	};
	MapEventHandler.prototype.isActive = function isActive() {
	    return false;
	};
	MapEventHandler.prototype.enable = function enable() {
	};
	MapEventHandler.prototype.disable = function disable() {
	};
	var BlockableMapEventHandler = function BlockableMapEventHandler(map) {
	    this._map = map;
	};
	BlockableMapEventHandler.prototype.reset = function reset() {
	    this._delayContextMenu = false;
	    delete this._contextMenuEvent;
	};
	BlockableMapEventHandler.prototype.mousemove = function mousemove(e) {
	    this._map.fire(new MapMouseEvent(e.type, this._map, e));
	};
	BlockableMapEventHandler.prototype.mousedown = function mousedown() {
	    this._delayContextMenu = true;
	};
	BlockableMapEventHandler.prototype.mouseup = function mouseup() {
	    this._delayContextMenu = false;
	    if (this._contextMenuEvent) {
	        this._map.fire(new MapMouseEvent('contextmenu', this._map, this._contextMenuEvent));
	        delete this._contextMenuEvent;
	    }
	};
	BlockableMapEventHandler.prototype.contextmenu = function contextmenu(e) {
	    if (this._delayContextMenu) {
	        this._contextMenuEvent = e;
	    } else {
	        this._map.fire(new MapMouseEvent(e.type, this._map, e));
	    }
	    if (this._map.listens('contextmenu')) {
	        e.preventDefault();
	    }
	};
	BlockableMapEventHandler.prototype.isEnabled = function isEnabled() {
	    return true;
	};
	BlockableMapEventHandler.prototype.isActive = function isActive() {
	    return false;
	};
	BlockableMapEventHandler.prototype.enable = function enable() {
	};
	BlockableMapEventHandler.prototype.disable = function disable() {
	};

	var BoxZoomHandler = function BoxZoomHandler(map, options) {
	    this._map = map;
	    this._el = map.getCanvasContainer();
	    this._container = map.getContainer();
	    this._clickTolerance = options.clickTolerance || 1;
	};
	BoxZoomHandler.prototype.isEnabled = function isEnabled() {
	    return !!this._enabled;
	};
	BoxZoomHandler.prototype.isActive = function isActive() {
	    return !!this._active;
	};
	BoxZoomHandler.prototype.enable = function enable() {
	    if (this.isEnabled()) {
	        return;
	    }
	    this._enabled = true;
	};
	BoxZoomHandler.prototype.disable = function disable() {
	    if (!this.isEnabled()) {
	        return;
	    }
	    this._enabled = false;
	};
	BoxZoomHandler.prototype.mousedown = function mousedown(e, point) {
	    if (!this.isEnabled()) {
	        return;
	    }
	    if (!(e.shiftKey && e.button === 0)) {
	        return;
	    }
	    DOM.disableDrag();
	    this._startPos = this._lastPos = point;
	    this._active = true;
	};
	BoxZoomHandler.prototype.mousemoveWindow = function mousemoveWindow(e, point) {
	    if (!this._active) {
	        return;
	    }
	    var pos = point;
	    if (this._lastPos.equals(pos) || !this._box && pos.dist(this._startPos) < this._clickTolerance) {
	        return;
	    }
	    var p0 = this._startPos;
	    this._lastPos = pos;
	    if (!this._box) {
	        this._box = DOM.create('div', 'mapboxgl-boxzoom', this._container);
	        this._container.classList.add('mapboxgl-crosshair');
	        this._fireEvent('boxzoomstart', e);
	    }
	    var minX = Math.min(p0.x, pos.x), maxX = Math.max(p0.x, pos.x), minY = Math.min(p0.y, pos.y), maxY = Math.max(p0.y, pos.y);
	    DOM.setTransform(this._box, 'translate(' + minX + 'px,' + minY + 'px)');
	    this._box.style.width = maxX - minX + 'px';
	    this._box.style.height = maxY - minY + 'px';
	};
	BoxZoomHandler.prototype.mouseupWindow = function mouseupWindow(e, point) {
	    var this$1 = this;
	    if (!this._active) {
	        return;
	    }
	    if (e.button !== 0) {
	        return;
	    }
	    var p0 = this._startPos, p1 = point;
	    this.reset();
	    DOM.suppressClick();
	    if (p0.x === p1.x && p0.y === p1.y) {
	        this._fireEvent('boxzoomcancel', e);
	    } else {
	        this._map.fire(new performance.Event('boxzoomend', { originalEvent: e }));
	        return {
	            cameraAnimation: function (map) {
	                return map.fitScreenCoordinates(p0, p1, this$1._map.getBearing(), { linear: true });
	            }
	        };
	    }
	};
	BoxZoomHandler.prototype.keydown = function keydown(e) {
	    if (!this._active) {
	        return;
	    }
	    if (e.keyCode === 27) {
	        this.reset();
	        this._fireEvent('boxzoomcancel', e);
	    }
	};
	BoxZoomHandler.prototype.reset = function reset() {
	    this._active = false;
	    this._container.classList.remove('mapboxgl-crosshair');
	    if (this._box) {
	        DOM.remove(this._box);
	        this._box = null;
	    }
	    DOM.enableDrag();
	    delete this._startPos;
	    delete this._lastPos;
	};
	BoxZoomHandler.prototype._fireEvent = function _fireEvent(type, e) {
	    return this._map.fire(new performance.Event(type, { originalEvent: e }));
	};

	function indexTouches(touches, points) {
	    var obj = {};
	    for (var i = 0; i < touches.length; i++) {
	        obj[touches[i].identifier] = points[i];
	    }
	    return obj;
	}

	function getCentroid(points) {
	    var sum = new performance.Point(0, 0);
	    for (var i = 0, list = points; i < list.length; i += 1) {
	        var point = list[i];
	        sum._add(point);
	    }
	    return sum.div(points.length);
	}
	var MAX_TAP_INTERVAL = 500;
	var MAX_TOUCH_TIME = 500;
	var MAX_DIST = 30;
	var SingleTapRecognizer = function SingleTapRecognizer(options) {
	    this.reset();
	    this.numTouches = options.numTouches;
	};
	SingleTapRecognizer.prototype.reset = function reset() {
	    delete this.centroid;
	    delete this.startTime;
	    delete this.touches;
	    this.aborted = false;
	};
	SingleTapRecognizer.prototype.touchstart = function touchstart(e, points, mapTouches) {
	    if (this.centroid || mapTouches.length > this.numTouches) {
	        this.aborted = true;
	    }
	    if (this.aborted) {
	        return;
	    }
	    if (this.startTime === undefined) {
	        this.startTime = e.timeStamp;
	    }
	    if (mapTouches.length === this.numTouches) {
	        this.centroid = getCentroid(points);
	        this.touches = indexTouches(mapTouches, points);
	    }
	};
	SingleTapRecognizer.prototype.touchmove = function touchmove(e, points, mapTouches) {
	    if (this.aborted || !this.centroid) {
	        return;
	    }
	    var newTouches = indexTouches(mapTouches, points);
	    for (var id in this.touches) {
	        var prevPos = this.touches[id];
	        var pos = newTouches[id];
	        if (!pos || pos.dist(prevPos) > MAX_DIST) {
	            this.aborted = true;
	        }
	    }
	};
	SingleTapRecognizer.prototype.touchend = function touchend(e, points, mapTouches) {
	    if (!this.centroid || e.timeStamp - this.startTime > MAX_TOUCH_TIME) {
	        this.aborted = true;
	    }
	    if (mapTouches.length === 0) {
	        var centroid = !this.aborted && this.centroid;
	        this.reset();
	        if (centroid) {
	            return centroid;
	        }
	    }
	};
	var TapRecognizer = function TapRecognizer(options) {
	    this.singleTap = new SingleTapRecognizer(options);
	    this.numTaps = options.numTaps;
	    this.reset();
	};
	TapRecognizer.prototype.reset = function reset() {
	    this.lastTime = Infinity;
	    delete this.lastTap;
	    this.count = 0;
	    this.singleTap.reset();
	};
	TapRecognizer.prototype.touchstart = function touchstart(e, points, mapTouches) {
	    this.singleTap.touchstart(e, points, mapTouches);
	};
	TapRecognizer.prototype.touchmove = function touchmove(e, points, mapTouches) {
	    this.singleTap.touchmove(e, points, mapTouches);
	};
	TapRecognizer.prototype.touchend = function touchend(e, points, mapTouches) {
	    var tap = this.singleTap.touchend(e, points, mapTouches);
	    if (tap) {
	        var soonEnough = e.timeStamp - this.lastTime < MAX_TAP_INTERVAL;
	        var closeEnough = !this.lastTap || this.lastTap.dist(tap) < MAX_DIST;
	        if (!soonEnough || !closeEnough) {
	            this.reset();
	        }
	        this.count++;
	        this.lastTime = e.timeStamp;
	        this.lastTap = tap;
	        if (this.count === this.numTaps) {
	            this.reset();
	            return tap;
	        }
	    }
	};

	var TapZoomHandler = function TapZoomHandler() {
	    this._zoomIn = new TapRecognizer({
	        numTouches: 1,
	        numTaps: 2
	    });
	    this._zoomOut = new TapRecognizer({
	        numTouches: 2,
	        numTaps: 1
	    });
	    this.reset();
	};
	TapZoomHandler.prototype.reset = function reset() {
	    this._active = false;
	    this._zoomIn.reset();
	    this._zoomOut.reset();
	};
	TapZoomHandler.prototype.touchstart = function touchstart(e, points, mapTouches) {
	    this._zoomIn.touchstart(e, points, mapTouches);
	    this._zoomOut.touchstart(e, points, mapTouches);
	};
	TapZoomHandler.prototype.touchmove = function touchmove(e, points, mapTouches) {
	    this._zoomIn.touchmove(e, points, mapTouches);
	    this._zoomOut.touchmove(e, points, mapTouches);
	};
	TapZoomHandler.prototype.touchend = function touchend(e, points, mapTouches) {
	    var this$1 = this;
	    var zoomInPoint = this._zoomIn.touchend(e, points, mapTouches);
	    var zoomOutPoint = this._zoomOut.touchend(e, points, mapTouches);
	    if (zoomInPoint) {
	        this._active = true;
	        e.preventDefault();
	        setTimeout(function () {
	            return this$1.reset();
	        }, 0);
	        return {
	            cameraAnimation: function (map) {
	                return map.easeTo({
	                    duration: 300,
	                    zoom: map.getZoom() + 1,
	                    around: map.unproject(zoomInPoint)
	                }, { originalEvent: e });
	            }
	        };
	    } else if (zoomOutPoint) {
	        this._active = true;
	        e.preventDefault();
	        setTimeout(function () {
	            return this$1.reset();
	        }, 0);
	        return {
	            cameraAnimation: function (map) {
	                return map.easeTo({
	                    duration: 300,
	                    zoom: map.getZoom() - 1,
	                    around: map.unproject(zoomOutPoint)
	                }, { originalEvent: e });
	            }
	        };
	    }
	};
	TapZoomHandler.prototype.touchcancel = function touchcancel() {
	    this.reset();
	};
	TapZoomHandler.prototype.enable = function enable() {
	    this._enabled = true;
	};
	TapZoomHandler.prototype.disable = function disable() {
	    this._enabled = false;
	    this.reset();
	};
	TapZoomHandler.prototype.isEnabled = function isEnabled() {
	    return this._enabled;
	};
	TapZoomHandler.prototype.isActive = function isActive() {
	    return this._active;
	};

	var LEFT_BUTTON = 0;
	var RIGHT_BUTTON = 2;
	var BUTTONS_FLAGS = {};
	BUTTONS_FLAGS[LEFT_BUTTON] = 1;
	BUTTONS_FLAGS[RIGHT_BUTTON] = 2;
	function buttonStillPressed(e, button) {
	    var flag = BUTTONS_FLAGS[button];
	    return e.buttons === undefined || (e.buttons & flag) !== flag;
	}
	var MouseHandler = function MouseHandler(options) {
	    this.reset();
	    this._clickTolerance = options.clickTolerance || 1;
	};
	MouseHandler.prototype.reset = function reset() {
	    this._active = false;
	    this._moved = false;
	    delete this._lastPoint;
	    delete this._eventButton;
	};
	MouseHandler.prototype._correctButton = function _correctButton(e, button) {
	    return false;
	};
	MouseHandler.prototype._move = function _move(lastPoint, point) {
	    return {};
	};
	MouseHandler.prototype.mousedown = function mousedown(e, point) {
	    if (this._lastPoint) {
	        return;
	    }
	    var eventButton = DOM.mouseButton(e);
	    if (!this._correctButton(e, eventButton)) {
	        return;
	    }
	    this._lastPoint = point;
	    this._eventButton = eventButton;
	};
	MouseHandler.prototype.mousemoveWindow = function mousemoveWindow(e, point) {
	    var lastPoint = this._lastPoint;
	    if (!lastPoint) {
	        return;
	    }
	    e.preventDefault();
	    if (buttonStillPressed(e, this._eventButton)) {
	        this.reset();
	        return;
	    }
	    if (!this._moved && point.dist(lastPoint) < this._clickTolerance) {
	        return;
	    }
	    this._moved = true;
	    this._lastPoint = point;
	    return this._move(lastPoint, point);
	};
	MouseHandler.prototype.mouseupWindow = function mouseupWindow(e) {
	    if (!this._lastPoint) {
	        return;
	    }
	    var eventButton = DOM.mouseButton(e);
	    if (eventButton !== this._eventButton) {
	        return;
	    }
	    if (this._moved) {
	        DOM.suppressClick();
	    }
	    this.reset();
	};
	MouseHandler.prototype.enable = function enable() {
	    this._enabled = true;
	};
	MouseHandler.prototype.disable = function disable() {
	    this._enabled = false;
	    this.reset();
	};
	MouseHandler.prototype.isEnabled = function isEnabled() {
	    return this._enabled;
	};
	MouseHandler.prototype.isActive = function isActive() {
	    return this._active;
	};
	var MousePanHandler = function (MouseHandler) {
	    function MousePanHandler() {
	        MouseHandler.apply(this, arguments);
	    }
	    if (MouseHandler)
	        MousePanHandler.__proto__ = MouseHandler;
	    MousePanHandler.prototype = Object.create(MouseHandler && MouseHandler.prototype);
	    MousePanHandler.prototype.constructor = MousePanHandler;
	    MousePanHandler.prototype.mousedown = function mousedown(e, point) {
	        MouseHandler.prototype.mousedown.call(this, e, point);
	        if (this._lastPoint) {
	            this._active = true;
	        }
	    };
	    MousePanHandler.prototype._correctButton = function _correctButton(e, button) {
	        return button === LEFT_BUTTON && !e.ctrlKey;
	    };
	    MousePanHandler.prototype._move = function _move(lastPoint, point) {
	        return {
	            around: point,
	            panDelta: point.sub(lastPoint)
	        };
	    };
	    return MousePanHandler;
	}(MouseHandler);
	var MouseRotateHandler = function (MouseHandler) {
	    function MouseRotateHandler() {
	        MouseHandler.apply(this, arguments);
	    }
	    if (MouseHandler)
	        MouseRotateHandler.__proto__ = MouseHandler;
	    MouseRotateHandler.prototype = Object.create(MouseHandler && MouseHandler.prototype);
	    MouseRotateHandler.prototype.constructor = MouseRotateHandler;
	    MouseRotateHandler.prototype._correctButton = function _correctButton(e, button) {
	        return button === LEFT_BUTTON && e.ctrlKey || button === RIGHT_BUTTON;
	    };
	    MouseRotateHandler.prototype._move = function _move(lastPoint, point) {
	        var degreesPerPixelMoved = 0.8;
	        var bearingDelta = (point.x - lastPoint.x) * degreesPerPixelMoved;
	        if (bearingDelta) {
	            this._active = true;
	            return { bearingDelta: bearingDelta };
	        }
	    };
	    MouseRotateHandler.prototype.contextmenu = function contextmenu(e) {
	        e.preventDefault();
	    };
	    return MouseRotateHandler;
	}(MouseHandler);
	var MousePitchHandler = function (MouseHandler) {
	    function MousePitchHandler() {
	        MouseHandler.apply(this, arguments);
	    }
	    if (MouseHandler)
	        MousePitchHandler.__proto__ = MouseHandler;
	    MousePitchHandler.prototype = Object.create(MouseHandler && MouseHandler.prototype);
	    MousePitchHandler.prototype.constructor = MousePitchHandler;
	    MousePitchHandler.prototype._correctButton = function _correctButton(e, button) {
	        return button === LEFT_BUTTON && e.ctrlKey || button === RIGHT_BUTTON;
	    };
	    MousePitchHandler.prototype._move = function _move(lastPoint, point) {
	        var degreesPerPixelMoved = -0.5;
	        var pitchDelta = (point.y - lastPoint.y) * degreesPerPixelMoved;
	        if (pitchDelta) {
	            this._active = true;
	            return { pitchDelta: pitchDelta };
	        }
	    };
	    MousePitchHandler.prototype.contextmenu = function contextmenu(e) {
	        e.preventDefault();
	    };
	    return MousePitchHandler;
	}(MouseHandler);

	var TouchPanHandler = function TouchPanHandler(options) {
	    this._minTouches = 1;
	    this._clickTolerance = options.clickTolerance || 1;
	    this.reset();
	};
	TouchPanHandler.prototype.reset = function reset() {
	    this._active = false;
	    this._touches = {};
	    this._sum = new performance.Point(0, 0);
	};
	TouchPanHandler.prototype.touchstart = function touchstart(e, points, mapTouches) {
	    return this._calculateTransform(e, points, mapTouches);
	};
	TouchPanHandler.prototype.touchmove = function touchmove(e, points, mapTouches) {
	    if (!this._active || mapTouches.length < this._minTouches) {
	        return;
	    }
	    e.preventDefault();
	    return this._calculateTransform(e, points, mapTouches);
	};
	TouchPanHandler.prototype.touchend = function touchend(e, points, mapTouches) {
	    this._calculateTransform(e, points, mapTouches);
	    if (this._active && mapTouches.length < this._minTouches) {
	        this.reset();
	    }
	};
	TouchPanHandler.prototype.touchcancel = function touchcancel() {
	    this.reset();
	};
	TouchPanHandler.prototype._calculateTransform = function _calculateTransform(e, points, mapTouches) {
	    if (mapTouches.length > 0) {
	        this._active = true;
	    }
	    var touches = indexTouches(mapTouches, points);
	    var touchPointSum = new performance.Point(0, 0);
	    var touchDeltaSum = new performance.Point(0, 0);
	    var touchDeltaCount = 0;
	    for (var identifier in touches) {
	        var point = touches[identifier];
	        var prevPoint = this._touches[identifier];
	        if (prevPoint) {
	            touchPointSum._add(point);
	            touchDeltaSum._add(point.sub(prevPoint));
	            touchDeltaCount++;
	            touches[identifier] = point;
	        }
	    }
	    this._touches = touches;
	    if (touchDeltaCount < this._minTouches || !touchDeltaSum.mag()) {
	        return;
	    }
	    var panDelta = touchDeltaSum.div(touchDeltaCount);
	    this._sum._add(panDelta);
	    if (this._sum.mag() < this._clickTolerance) {
	        return;
	    }
	    var around = touchPointSum.div(touchDeltaCount);
	    return {
	        around: around,
	        panDelta: panDelta
	    };
	};
	TouchPanHandler.prototype.enable = function enable() {
	    this._enabled = true;
	};
	TouchPanHandler.prototype.disable = function disable() {
	    this._enabled = false;
	    this.reset();
	};
	TouchPanHandler.prototype.isEnabled = function isEnabled() {
	    return this._enabled;
	};
	TouchPanHandler.prototype.isActive = function isActive() {
	    return this._active;
	};

	var TwoTouchHandler = function TwoTouchHandler() {
	    this.reset();
	};
	TwoTouchHandler.prototype.reset = function reset() {
	    this._active = false;
	    delete this._firstTwoTouches;
	};
	TwoTouchHandler.prototype._start = function _start(points) {
	};
	TwoTouchHandler.prototype._move = function _move(points, pinchAround, e) {
	    return {};
	};
	TwoTouchHandler.prototype.touchstart = function touchstart(e, points, mapTouches) {
	    if (this._firstTwoTouches || mapTouches.length < 2) {
	        return;
	    }
	    this._firstTwoTouches = [
	        mapTouches[0].identifier,
	        mapTouches[1].identifier
	    ];
	    this._start([
	        points[0],
	        points[1]
	    ]);
	};
	TwoTouchHandler.prototype.touchmove = function touchmove(e, points, mapTouches) {
	    if (!this._firstTwoTouches) {
	        return;
	    }
	    e.preventDefault();
	    var ref = this._firstTwoTouches;
	    var idA = ref[0];
	    var idB = ref[1];
	    var a = getTouchById(mapTouches, points, idA);
	    var b = getTouchById(mapTouches, points, idB);
	    if (!a || !b) {
	        return;
	    }
	    var pinchAround = this._aroundCenter ? null : a.add(b).div(2);
	    return this._move([
	        a,
	        b
	    ], pinchAround, e);
	};
	TwoTouchHandler.prototype.touchend = function touchend(e, points, mapTouches) {
	    if (!this._firstTwoTouches) {
	        return;
	    }
	    var ref = this._firstTwoTouches;
	    var idA = ref[0];
	    var idB = ref[1];
	    var a = getTouchById(mapTouches, points, idA);
	    var b = getTouchById(mapTouches, points, idB);
	    if (a && b) {
	        return;
	    }
	    if (this._active) {
	        DOM.suppressClick();
	    }
	    this.reset();
	};
	TwoTouchHandler.prototype.touchcancel = function touchcancel() {
	    this.reset();
	};
	TwoTouchHandler.prototype.enable = function enable(options) {
	    this._enabled = true;
	    this._aroundCenter = !!options && options.around === 'center';
	};
	TwoTouchHandler.prototype.disable = function disable() {
	    this._enabled = false;
	    this.reset();
	};
	TwoTouchHandler.prototype.isEnabled = function isEnabled() {
	    return this._enabled;
	};
	TwoTouchHandler.prototype.isActive = function isActive() {
	    return this._active;
	};
	function getTouchById(mapTouches, points, identifier) {
	    for (var i = 0; i < mapTouches.length; i++) {
	        if (mapTouches[i].identifier === identifier) {
	            return points[i];
	        }
	    }
	}
	var ZOOM_THRESHOLD = 0.1;
	function getZoomDelta(distance, lastDistance) {
	    return Math.log(distance / lastDistance) / Math.LN2;
	}
	var TouchZoomHandler = function (TwoTouchHandler) {
	    function TouchZoomHandler() {
	        TwoTouchHandler.apply(this, arguments);
	    }
	    if (TwoTouchHandler)
	        TouchZoomHandler.__proto__ = TwoTouchHandler;
	    TouchZoomHandler.prototype = Object.create(TwoTouchHandler && TwoTouchHandler.prototype);
	    TouchZoomHandler.prototype.constructor = TouchZoomHandler;
	    TouchZoomHandler.prototype.reset = function reset() {
	        TwoTouchHandler.prototype.reset.call(this);
	        delete this._distance;
	        delete this._startDistance;
	    };
	    TouchZoomHandler.prototype._start = function _start(points) {
	        this._startDistance = this._distance = points[0].dist(points[1]);
	    };
	    TouchZoomHandler.prototype._move = function _move(points, pinchAround) {
	        var lastDistance = this._distance;
	        this._distance = points[0].dist(points[1]);
	        if (!this._active && Math.abs(getZoomDelta(this._distance, this._startDistance)) < ZOOM_THRESHOLD) {
	            return;
	        }
	        this._active = true;
	        return {
	            zoomDelta: getZoomDelta(this._distance, lastDistance),
	            pinchAround: pinchAround
	        };
	    };
	    return TouchZoomHandler;
	}(TwoTouchHandler);
	var ROTATION_THRESHOLD = 25;
	function getBearingDelta(a, b) {
	    return a.angleWith(b) * 180 / Math.PI;
	}
	var TouchRotateHandler = function (TwoTouchHandler) {
	    function TouchRotateHandler() {
	        TwoTouchHandler.apply(this, arguments);
	    }
	    if (TwoTouchHandler)
	        TouchRotateHandler.__proto__ = TwoTouchHandler;
	    TouchRotateHandler.prototype = Object.create(TwoTouchHandler && TwoTouchHandler.prototype);
	    TouchRotateHandler.prototype.constructor = TouchRotateHandler;
	    TouchRotateHandler.prototype.reset = function reset() {
	        TwoTouchHandler.prototype.reset.call(this);
	        delete this._minDiameter;
	        delete this._startVector;
	        delete this._vector;
	    };
	    TouchRotateHandler.prototype._start = function _start(points) {
	        this._startVector = this._vector = points[0].sub(points[1]);
	        this._minDiameter = points[0].dist(points[1]);
	    };
	    TouchRotateHandler.prototype._move = function _move(points, pinchAround) {
	        var lastVector = this._vector;
	        this._vector = points[0].sub(points[1]);
	        if (!this._active && this._isBelowThreshold(this._vector)) {
	            return;
	        }
	        this._active = true;
	        return {
	            bearingDelta: getBearingDelta(this._vector, lastVector),
	            pinchAround: pinchAround
	        };
	    };
	    TouchRotateHandler.prototype._isBelowThreshold = function _isBelowThreshold(vector) {
	        this._minDiameter = Math.min(this._minDiameter, vector.mag());
	        var circumference = Math.PI * this._minDiameter;
	        var threshold = ROTATION_THRESHOLD / circumference * 360;
	        var bearingDeltaSinceStart = getBearingDelta(vector, this._startVector);
	        return Math.abs(bearingDeltaSinceStart) < threshold;
	    };
	    return TouchRotateHandler;
	}(TwoTouchHandler);
	function isVertical(vector) {
	    return Math.abs(vector.y) > Math.abs(vector.x);
	}
	var ALLOWED_SINGLE_TOUCH_TIME = 100;
	var TouchPitchHandler = function (TwoTouchHandler) {
	    function TouchPitchHandler() {
	        TwoTouchHandler.apply(this, arguments);
	    }
	    if (TwoTouchHandler)
	        TouchPitchHandler.__proto__ = TwoTouchHandler;
	    TouchPitchHandler.prototype = Object.create(TwoTouchHandler && TwoTouchHandler.prototype);
	    TouchPitchHandler.prototype.constructor = TouchPitchHandler;
	    TouchPitchHandler.prototype.reset = function reset() {
	        TwoTouchHandler.prototype.reset.call(this);
	        this._valid = undefined;
	        delete this._firstMove;
	        delete this._lastPoints;
	    };
	    TouchPitchHandler.prototype._start = function _start(points) {
	        this._lastPoints = points;
	        if (isVertical(points[0].sub(points[1]))) {
	            this._valid = false;
	        }
	    };
	    TouchPitchHandler.prototype._move = function _move(points, center, e) {
	        var vectorA = points[0].sub(this._lastPoints[0]);
	        var vectorB = points[1].sub(this._lastPoints[1]);
	        this._valid = this.gestureBeginsVertically(vectorA, vectorB, e.timeStamp);
	        if (!this._valid) {
	            return;
	        }
	        this._lastPoints = points;
	        this._active = true;
	        var yDeltaAverage = (vectorA.y + vectorB.y) / 2;
	        var degreesPerPixelMoved = -0.5;
	        return { pitchDelta: yDeltaAverage * degreesPerPixelMoved };
	    };
	    TouchPitchHandler.prototype.gestureBeginsVertically = function gestureBeginsVertically(vectorA, vectorB, timeStamp) {
	        if (this._valid !== undefined) {
	            return this._valid;
	        }
	        var threshold = 2;
	        var movedA = vectorA.mag() >= threshold;
	        var movedB = vectorB.mag() >= threshold;
	        if (!movedA && !movedB) {
	            return;
	        }
	        if (!movedA || !movedB) {
	            if (this._firstMove === undefined) {
	                this._firstMove = timeStamp;
	            }
	            if (timeStamp - this._firstMove < ALLOWED_SINGLE_TOUCH_TIME) {
	                return undefined;
	            } else {
	                return false;
	            }
	        }
	        var isSameDirection = vectorA.y > 0 === vectorB.y > 0;
	        return isVertical(vectorA) && isVertical(vectorB) && isSameDirection;
	    };
	    return TouchPitchHandler;
	}(TwoTouchHandler);

	var defaultOptions = {
	    panStep: 100,
	    bearingStep: 15,
	    pitchStep: 10
	};
	var KeyboardHandler = function KeyboardHandler() {
	    var stepOptions = defaultOptions;
	    this._panStep = stepOptions.panStep;
	    this._bearingStep = stepOptions.bearingStep;
	    this._pitchStep = stepOptions.pitchStep;
	    this._rotationDisabled = false;
	};
	KeyboardHandler.prototype.reset = function reset() {
	    this._active = false;
	};
	KeyboardHandler.prototype.keydown = function keydown(e) {
	    var this$1 = this;
	    if (e.altKey || e.ctrlKey || e.metaKey) {
	        return;
	    }
	    var zoomDir = 0;
	    var bearingDir = 0;
	    var pitchDir = 0;
	    var xDir = 0;
	    var yDir = 0;
	    switch (e.keyCode) {
	    case 61:
	    case 107:
	    case 171:
	    case 187:
	        zoomDir = 1;
	        break;
	    case 189:
	    case 109:
	    case 173:
	        zoomDir = -1;
	        break;
	    case 37:
	        if (e.shiftKey) {
	            bearingDir = -1;
	        } else {
	            e.preventDefault();
	            xDir = -1;
	        }
	        break;
	    case 39:
	        if (e.shiftKey) {
	            bearingDir = 1;
	        } else {
	            e.preventDefault();
	            xDir = 1;
	        }
	        break;
	    case 38:
	        if (e.shiftKey) {
	            pitchDir = 1;
	        } else {
	            e.preventDefault();
	            yDir = -1;
	        }
	        break;
	    case 40:
	        if (e.shiftKey) {
	            pitchDir = -1;
	        } else {
	            e.preventDefault();
	            yDir = 1;
	        }
	        break;
	    default:
	        return;
	    }
	    if (this._rotationDisabled) {
	        bearingDir = 0;
	        pitchDir = 0;
	    }
	    return {
	        cameraAnimation: function (map) {
	            var zoom = map.getZoom();
	            map.easeTo({
	                duration: 300,
	                easeId: 'keyboardHandler',
	                easing: easeOut,
	                zoom: zoomDir ? Math.round(zoom) + zoomDir * (e.shiftKey ? 2 : 1) : zoom,
	                bearing: map.getBearing() + bearingDir * this$1._bearingStep,
	                pitch: map.getPitch() + pitchDir * this$1._pitchStep,
	                offset: [
	                    -xDir * this$1._panStep,
	                    -yDir * this$1._panStep
	                ],
	                center: map.getCenter()
	            }, { originalEvent: e });
	        }
	    };
	};
	KeyboardHandler.prototype.enable = function enable() {
	    this._enabled = true;
	};
	KeyboardHandler.prototype.disable = function disable() {
	    this._enabled = false;
	    this.reset();
	};
	KeyboardHandler.prototype.isEnabled = function isEnabled() {
	    return this._enabled;
	};
	KeyboardHandler.prototype.isActive = function isActive() {
	    return this._active;
	};
	KeyboardHandler.prototype.disableRotation = function disableRotation() {
	    this._rotationDisabled = true;
	};
	KeyboardHandler.prototype.enableRotation = function enableRotation() {
	    this._rotationDisabled = false;
	};
	function easeOut(t) {
	    return t * (2 - t);
	}

	var wheelZoomDelta = 4.000244140625;
	var defaultZoomRate = 1 / 100;
	var wheelZoomRate = 1 / 450;
	var maxScalePerFrame = 2;
	var ScrollZoomHandler = function ScrollZoomHandler(map, handler) {
	    this._map = map;
	    this._el = map.getCanvasContainer();
	    this._handler = handler;
	    this._delta = 0;
	    this._defaultZoomRate = defaultZoomRate;
	    this._wheelZoomRate = wheelZoomRate;
	    performance.bindAll(['_onTimeout'], this);
	};
	ScrollZoomHandler.prototype.setZoomRate = function setZoomRate(zoomRate) {
	    this._defaultZoomRate = zoomRate;
	};
	ScrollZoomHandler.prototype.setWheelZoomRate = function setWheelZoomRate(wheelZoomRate) {
	    this._wheelZoomRate = wheelZoomRate;
	};
	ScrollZoomHandler.prototype.isEnabled = function isEnabled() {
	    return !!this._enabled;
	};
	ScrollZoomHandler.prototype.isActive = function isActive() {
	    return !!this._active || this._finishTimeout !== undefined;
	};
	ScrollZoomHandler.prototype.isZooming = function isZooming() {
	    return !!this._zooming;
	};
	ScrollZoomHandler.prototype.enable = function enable(options) {
	    if (this.isEnabled()) {
	        return;
	    }
	    this._enabled = true;
	    this._aroundCenter = options && options.around === 'center';
	};
	ScrollZoomHandler.prototype.disable = function disable() {
	    if (!this.isEnabled()) {
	        return;
	    }
	    this._enabled = false;
	};
	ScrollZoomHandler.prototype.wheel = function wheel(e) {
	    if (!this.isEnabled()) {
	        return;
	    }
	    var value = e.deltaMode === performance.window.WheelEvent.DOM_DELTA_LINE ? e.deltaY * 40 : e.deltaY;
	    var now = performance.browser.now(), timeDelta = now - (this._lastWheelEventTime || 0);
	    this._lastWheelEventTime = now;
	    if (value !== 0 && value % wheelZoomDelta === 0) {
	        this._type = 'wheel';
	    } else if (value !== 0 && Math.abs(value) < 4) {
	        this._type = 'trackpad';
	    } else if (timeDelta > 400) {
	        this._type = null;
	        this._lastValue = value;
	        this._timeout = setTimeout(this._onTimeout, 40, e);
	    } else if (!this._type) {
	        this._type = Math.abs(timeDelta * value) < 200 ? 'trackpad' : 'wheel';
	        if (this._timeout) {
	            clearTimeout(this._timeout);
	            this._timeout = null;
	            value += this._lastValue;
	        }
	    }
	    if (e.shiftKey && value) {
	        value = value / 4;
	    }
	    if (this._type) {
	        this._lastWheelEvent = e;
	        this._delta -= value;
	        if (!this._active) {
	            this._start(e);
	        }
	    }
	    e.preventDefault();
	};
	ScrollZoomHandler.prototype._onTimeout = function _onTimeout(initialEvent) {
	    this._type = 'wheel';
	    this._delta -= this._lastValue;
	    if (!this._active) {
	        this._start(initialEvent);
	    }
	};
	ScrollZoomHandler.prototype._start = function _start(e) {
	    if (!this._delta) {
	        return;
	    }
	    if (this._frameId) {
	        this._frameId = null;
	    }
	    this._active = true;
	    if (!this.isZooming()) {
	        this._zooming = true;
	    }
	    if (this._finishTimeout) {
	        clearTimeout(this._finishTimeout);
	        delete this._finishTimeout;
	    }
	    var pos = DOM.mousePos(this._el, e);
	    this._around = performance.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(pos));
	    this._aroundPoint = this._map.transform.locationPoint(this._around);
	    if (!this._frameId) {
	        this._frameId = true;
	        this._handler._triggerRenderFrame();
	    }
	};
	ScrollZoomHandler.prototype.renderFrame = function renderFrame() {
	    var this$1 = this;
	    if (!this._frameId) {
	        return;
	    }
	    this._frameId = null;
	    if (!this.isActive()) {
	        return;
	    }
	    var tr = this._map.transform;
	    if (this._delta !== 0) {
	        var zoomRate = this._type === 'wheel' && Math.abs(this._delta) > wheelZoomDelta ? this._wheelZoomRate : this._defaultZoomRate;
	        var scale = maxScalePerFrame / (1 + Math.exp(-Math.abs(this._delta * zoomRate)));
	        if (this._delta < 0 && scale !== 0) {
	            scale = 1 / scale;
	        }
	        var fromScale = typeof this._targetZoom === 'number' ? tr.zoomScale(this._targetZoom) : tr.scale;
	        this._targetZoom = Math.min(tr.maxZoom, Math.max(tr.minZoom, tr.scaleZoom(fromScale * scale)));
	        if (this._type === 'wheel') {
	            this._startZoom = tr.zoom;
	            this._easing = this._smoothOutEasing(200);
	        }
	        this._delta = 0;
	    }
	    var targetZoom = typeof this._targetZoom === 'number' ? this._targetZoom : tr.zoom;
	    var startZoom = this._startZoom;
	    var easing = this._easing;
	    var finished = false;
	    var zoom;
	    if (this._type === 'wheel' && startZoom && easing) {
	        var t = Math.min((performance.browser.now() - this._lastWheelEventTime) / 200, 1);
	        var k = easing(t);
	        zoom = performance.number(startZoom, targetZoom, k);
	        if (t < 1) {
	            if (!this._frameId) {
	                this._frameId = true;
	            }
	        } else {
	            finished = true;
	        }
	    } else {
	        zoom = targetZoom;
	        finished = true;
	    }
	    this._active = true;
	    if (finished) {
	        this._active = false;
	        this._finishTimeout = setTimeout(function () {
	            this$1._zooming = false;
	            this$1._handler._triggerRenderFrame();
	            delete this$1._targetZoom;
	            delete this$1._finishTimeout;
	        }, 200);
	    }
	    return {
	        noInertia: true,
	        needsRenderFrame: !finished,
	        zoomDelta: zoom - tr.zoom,
	        around: this._aroundPoint,
	        originalEvent: this._lastWheelEvent
	    };
	};
	ScrollZoomHandler.prototype._smoothOutEasing = function _smoothOutEasing(duration) {
	    var easing = performance.ease;
	    if (this._prevEase) {
	        var ease = this._prevEase, t = (performance.browser.now() - ease.start) / ease.duration, speed = ease.easing(t + 0.01) - ease.easing(t), x = 0.27 / Math.sqrt(speed * speed + 0.0001) * 0.01, y = Math.sqrt(0.27 * 0.27 - x * x);
	        easing = performance.bezier(x, y, 0.25, 1);
	    }
	    this._prevEase = {
	        start: performance.browser.now(),
	        duration: duration,
	        easing: easing
	    };
	    return easing;
	};
	ScrollZoomHandler.prototype.reset = function reset() {
	    this._active = false;
	};

	var DoubleClickZoomHandler = function DoubleClickZoomHandler(clickZoom, TapZoom) {
	    this._clickZoom = clickZoom;
	    this._tapZoom = TapZoom;
	};
	DoubleClickZoomHandler.prototype.enable = function enable() {
	    this._clickZoom.enable();
	    this._tapZoom.enable();
	};
	DoubleClickZoomHandler.prototype.disable = function disable() {
	    this._clickZoom.disable();
	    this._tapZoom.disable();
	};
	DoubleClickZoomHandler.prototype.isEnabled = function isEnabled() {
	    return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
	};
	DoubleClickZoomHandler.prototype.isActive = function isActive() {
	    return this._clickZoom.isActive() || this._tapZoom.isActive();
	};

	var ClickZoomHandler = function ClickZoomHandler() {
	    this.reset();
	};
	ClickZoomHandler.prototype.reset = function reset() {
	    this._active = false;
	};
	ClickZoomHandler.prototype.dblclick = function dblclick(e, point) {
	    e.preventDefault();
	    return {
	        cameraAnimation: function (map) {
	            map.easeTo({
	                duration: 300,
	                zoom: map.getZoom() + (e.shiftKey ? -1 : 1),
	                around: map.unproject(point)
	            }, { originalEvent: e });
	        }
	    };
	};
	ClickZoomHandler.prototype.enable = function enable() {
	    this._enabled = true;
	};
	ClickZoomHandler.prototype.disable = function disable() {
	    this._enabled = false;
	    this.reset();
	};
	ClickZoomHandler.prototype.isEnabled = function isEnabled() {
	    return this._enabled;
	};
	ClickZoomHandler.prototype.isActive = function isActive() {
	    return this._active;
	};

	var TapDragZoomHandler = function TapDragZoomHandler() {
	    this._tap = new TapRecognizer({
	        numTouches: 1,
	        numTaps: 1
	    });
	    this.reset();
	};
	TapDragZoomHandler.prototype.reset = function reset() {
	    this._active = false;
	    delete this._swipePoint;
	    delete this._swipeTouch;
	    delete this._tapTime;
	    this._tap.reset();
	};
	TapDragZoomHandler.prototype.touchstart = function touchstart(e, points, mapTouches) {
	    if (this._swipePoint) {
	        return;
	    }
	    if (this._tapTime && e.timeStamp - this._tapTime > MAX_TAP_INTERVAL) {
	        this.reset();
	    }
	    if (!this._tapTime) {
	        this._tap.touchstart(e, points, mapTouches);
	    } else if (mapTouches.length > 0) {
	        this._swipePoint = points[0];
	        this._swipeTouch = mapTouches[0].identifier;
	    }
	};
	TapDragZoomHandler.prototype.touchmove = function touchmove(e, points, mapTouches) {
	    if (!this._tapTime) {
	        this._tap.touchmove(e, points, mapTouches);
	    } else if (this._swipePoint) {
	        if (mapTouches[0].identifier !== this._swipeTouch) {
	            return;
	        }
	        var newSwipePoint = points[0];
	        var dist = newSwipePoint.y - this._swipePoint.y;
	        this._swipePoint = newSwipePoint;
	        e.preventDefault();
	        this._active = true;
	        return { zoomDelta: dist / 128 };
	    }
	};
	TapDragZoomHandler.prototype.touchend = function touchend(e, points, mapTouches) {
	    if (!this._tapTime) {
	        var point = this._tap.touchend(e, points, mapTouches);
	        if (point) {
	            this._tapTime = e.timeStamp;
	        }
	    } else if (this._swipePoint) {
	        if (mapTouches.length === 0) {
	            this.reset();
	        }
	    }
	};
	TapDragZoomHandler.prototype.touchcancel = function touchcancel() {
	    this.reset();
	};
	TapDragZoomHandler.prototype.enable = function enable() {
	    this._enabled = true;
	};
	TapDragZoomHandler.prototype.disable = function disable() {
	    this._enabled = false;
	    this.reset();
	};
	TapDragZoomHandler.prototype.isEnabled = function isEnabled() {
	    return this._enabled;
	};
	TapDragZoomHandler.prototype.isActive = function isActive() {
	    return this._active;
	};

	var DragPanHandler = function DragPanHandler(el, mousePan, touchPan) {
	    this._el = el;
	    this._mousePan = mousePan;
	    this._touchPan = touchPan;
	};
	DragPanHandler.prototype.enable = function enable(options) {
	    this._inertiaOptions = options || {};
	    this._mousePan.enable();
	    this._touchPan.enable();
	    this._el.classList.add('mapboxgl-touch-drag-pan');
	};
	DragPanHandler.prototype.disable = function disable() {
	    this._mousePan.disable();
	    this._touchPan.disable();
	    this._el.classList.remove('mapboxgl-touch-drag-pan');
	};
	DragPanHandler.prototype.isEnabled = function isEnabled() {
	    return this._mousePan.isEnabled() && this._touchPan.isEnabled();
	};
	DragPanHandler.prototype.isActive = function isActive() {
	    return this._mousePan.isActive() || this._touchPan.isActive();
	};

	var DragRotateHandler = function DragRotateHandler(options, mouseRotate, mousePitch) {
	    this._pitchWithRotate = options.pitchWithRotate;
	    this._mouseRotate = mouseRotate;
	    this._mousePitch = mousePitch;
	};
	DragRotateHandler.prototype.enable = function enable() {
	    this._mouseRotate.enable();
	    if (this._pitchWithRotate) {
	        this._mousePitch.enable();
	    }
	};
	DragRotateHandler.prototype.disable = function disable() {
	    this._mouseRotate.disable();
	    this._mousePitch.disable();
	};
	DragRotateHandler.prototype.isEnabled = function isEnabled() {
	    return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
	};
	DragRotateHandler.prototype.isActive = function isActive() {
	    return this._mouseRotate.isActive() || this._mousePitch.isActive();
	};

	var TouchZoomRotateHandler = function TouchZoomRotateHandler(el, touchZoom, touchRotate, tapDragZoom) {
	    this._el = el;
	    this._touchZoom = touchZoom;
	    this._touchRotate = touchRotate;
	    this._tapDragZoom = tapDragZoom;
	    this._rotationDisabled = false;
	    this._enabled = true;
	};
	TouchZoomRotateHandler.prototype.enable = function enable(options) {
	    this._touchZoom.enable(options);
	    if (!this._rotationDisabled) {
	        this._touchRotate.enable(options);
	    }
	    this._tapDragZoom.enable();
	    this._el.classList.add('mapboxgl-touch-zoom-rotate');
	};
	TouchZoomRotateHandler.prototype.disable = function disable() {
	    this._touchZoom.disable();
	    this._touchRotate.disable();
	    this._tapDragZoom.disable();
	    this._el.classList.remove('mapboxgl-touch-zoom-rotate');
	};
	TouchZoomRotateHandler.prototype.isEnabled = function isEnabled() {
	    return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
	};
	TouchZoomRotateHandler.prototype.isActive = function isActive() {
	    return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
	};
	TouchZoomRotateHandler.prototype.disableRotation = function disableRotation() {
	    this._rotationDisabled = true;
	    this._touchRotate.disable();
	};
	TouchZoomRotateHandler.prototype.enableRotation = function enableRotation() {
	    this._rotationDisabled = false;
	    if (this._touchZoom.isEnabled()) {
	        this._touchRotate.enable();
	    }
	};

	var isMoving = function (p) {
	    return p.zoom || p.drag || p.pitch || p.rotate;
	};
	var RenderFrameEvent = function (Event) {
	    function RenderFrameEvent() {
	        Event.apply(this, arguments);
	    }
	    if (Event)
	        RenderFrameEvent.__proto__ = Event;
	    RenderFrameEvent.prototype = Object.create(Event && Event.prototype);
	    RenderFrameEvent.prototype.constructor = RenderFrameEvent;
	    return RenderFrameEvent;
	}(performance.Event);
	function hasChange(result) {
	    return result.panDelta && result.panDelta.mag() || result.zoomDelta || result.bearingDelta || result.pitchDelta;
	}
	var HandlerManager = function HandlerManager(map, options) {
	    this._map = map;
	    this._el = this._map.getCanvasContainer();
	    this._handlers = [];
	    this._handlersById = {};
	    this._changes = [];
	    this._inertia = new HandlerInertia(map);
	    this._bearingSnap = options.bearingSnap;
	    this._previousActiveHandlers = {};
	    this._eventsInProgress = {};
	    this._addDefaultHandlers(options);
	    performance.bindAll([
	        'handleEvent',
	        'handleWindowEvent'
	    ], this);
	    var el = this._el;
	    this._listeners = [
	        [
	            el,
	            'touchstart',
	            { passive: true }
	        ],
	        [
	            el,
	            'touchmove',
	            { passive: false }
	        ],
	        [
	            el,
	            'touchend',
	            undefined
	        ],
	        [
	            el,
	            'touchcancel',
	            undefined
	        ],
	        [
	            el,
	            'mousedown',
	            undefined
	        ],
	        [
	            el,
	            'mousemove',
	            undefined
	        ],
	        [
	            el,
	            'mouseup',
	            undefined
	        ],
	        [
	            performance.window.document,
	            'mousemove',
	            { capture: true }
	        ],
	        [
	            performance.window.document,
	            'mouseup',
	            undefined
	        ],
	        [
	            el,
	            'mouseover',
	            undefined
	        ],
	        [
	            el,
	            'mouseout',
	            undefined
	        ],
	        [
	            el,
	            'dblclick',
	            undefined
	        ],
	        [
	            el,
	            'click',
	            undefined
	        ],
	        [
	            el,
	            'keydown',
	            { capture: false }
	        ],
	        [
	            el,
	            'keyup',
	            undefined
	        ],
	        [
	            el,
	            'wheel',
	            { passive: false }
	        ],
	        [
	            el,
	            'contextmenu',
	            undefined
	        ],
	        [
	            performance.window,
	            'blur',
	            undefined
	        ]
	    ];
	    for (var i = 0, list = this._listeners; i < list.length; i += 1) {
	        var ref = list[i];
	        var target = ref[0];
	        var type = ref[1];
	        var listenerOptions = ref[2];
	        DOM.addEventListener(target, type, target === performance.window.document ? this.handleWindowEvent : this.handleEvent, listenerOptions);
	    }
	};
	HandlerManager.prototype.destroy = function destroy() {
	    for (var i = 0, list = this._listeners; i < list.length; i += 1) {
	        var ref = list[i];
	        var target = ref[0];
	        var type = ref[1];
	        var listenerOptions = ref[2];
	        DOM.removeEventListener(target, type, target === performance.window.document ? this.handleWindowEvent : this.handleEvent, listenerOptions);
	    }
	};
	HandlerManager.prototype._addDefaultHandlers = function _addDefaultHandlers(options) {
	    var map = this._map;
	    var el = map.getCanvasContainer();
	    this._add('mapEvent', new MapEventHandler(map, options));
	    var boxZoom = map.boxZoom = new BoxZoomHandler(map, options);
	    this._add('boxZoom', boxZoom);
	    var tapZoom = new TapZoomHandler();
	    var clickZoom = new ClickZoomHandler();
	    map.doubleClickZoom = new DoubleClickZoomHandler(clickZoom, tapZoom);
	    this._add('tapZoom', tapZoom);
	    this._add('clickZoom', clickZoom);
	    var tapDragZoom = new TapDragZoomHandler();
	    this._add('tapDragZoom', tapDragZoom);
	    var touchPitch = map.touchPitch = new TouchPitchHandler();
	    this._add('touchPitch', touchPitch);
	    var mouseRotate = new MouseRotateHandler(options);
	    var mousePitch = new MousePitchHandler(options);
	    map.dragRotate = new DragRotateHandler(options, mouseRotate, mousePitch);
	    this._add('mouseRotate', mouseRotate, ['mousePitch']);
	    this._add('mousePitch', mousePitch, ['mouseRotate']);
	    var mousePan = new MousePanHandler(options);
	    var touchPan = new TouchPanHandler(options);
	    map.dragPan = new DragPanHandler(el, mousePan, touchPan);
	    this._add('mousePan', mousePan);
	    this._add('touchPan', touchPan, [
	        'touchZoom',
	        'touchRotate'
	    ]);
	    var touchRotate = new TouchRotateHandler();
	    var touchZoom = new TouchZoomHandler();
	    map.touchZoomRotate = new TouchZoomRotateHandler(el, touchZoom, touchRotate, tapDragZoom);
	    this._add('touchRotate', touchRotate, [
	        'touchPan',
	        'touchZoom'
	    ]);
	    this._add('touchZoom', touchZoom, [
	        'touchPan',
	        'touchRotate'
	    ]);
	    var scrollZoom = map.scrollZoom = new ScrollZoomHandler(map, this);
	    this._add('scrollZoom', scrollZoom, ['mousePan']);
	    var keyboard = map.keyboard = new KeyboardHandler();
	    this._add('keyboard', keyboard);
	    this._add('blockableMapEvent', new BlockableMapEventHandler(map));
	    for (var i = 0, list = [
	                'boxZoom',
	                'doubleClickZoom',
	                'tapDragZoom',
	                'touchPitch',
	                'dragRotate',
	                'dragPan',
	                'touchZoomRotate',
	                'scrollZoom',
	                'keyboard'
	            ]; i < list.length; i += 1) {
	        var name = list[i];
	        if (options.interactive && options[name]) {
	            map[name].enable(options[name]);
	        }
	    }
	};
	HandlerManager.prototype._add = function _add(handlerName, handler, allowed) {
	    this._handlers.push({
	        handlerName: handlerName,
	        handler: handler,
	        allowed: allowed
	    });
	    this._handlersById[handlerName] = handler;
	};
	HandlerManager.prototype.stop = function stop(allowEndAnimation) {
	    if (this._updatingCamera) {
	        return;
	    }
	    for (var i = 0, list = this._handlers; i < list.length; i += 1) {
	        var ref = list[i];
	        var handler = ref.handler;
	        handler.reset();
	    }
	    this._inertia.clear();
	    this._fireEvents({}, {}, allowEndAnimation);
	    this._changes = [];
	};
	HandlerManager.prototype.isActive = function isActive() {
	    for (var i = 0, list = this._handlers; i < list.length; i += 1) {
	        var ref = list[i];
	        var handler = ref.handler;
	        if (handler.isActive()) {
	            return true;
	        }
	    }
	    return false;
	};
	HandlerManager.prototype.isZooming = function isZooming() {
	    return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
	};
	HandlerManager.prototype.isRotating = function isRotating() {
	    return !!this._eventsInProgress.rotate;
	};
	HandlerManager.prototype.isMoving = function isMoving$1() {
	    return Boolean(isMoving(this._eventsInProgress)) || this.isZooming();
	};
	HandlerManager.prototype._blockedByActive = function _blockedByActive(activeHandlers, allowed, myName) {
	    for (var name in activeHandlers) {
	        if (name === myName) {
	            continue;
	        }
	        if (!allowed || allowed.indexOf(name) < 0) {
	            return true;
	        }
	    }
	    return false;
	};
	HandlerManager.prototype.handleWindowEvent = function handleWindowEvent(e) {
	    this.handleEvent(e, e.type + 'Window');
	};
	HandlerManager.prototype._getMapTouches = function _getMapTouches(touches) {
	    var mapTouches = [];
	    for (var i = 0, list = touches; i < list.length; i += 1) {
	        var t = list[i];
	        var target = t.target;
	        if (this._el.contains(target)) {
	            mapTouches.push(t);
	        }
	    }
	    return mapTouches;
	};
	HandlerManager.prototype.handleEvent = function handleEvent(e, eventName) {
	    if (e.type === 'blur') {
	        this.stop(true);
	        return;
	    }
	    this._updatingCamera = true;
	    var inputEvent = e.type === 'renderFrame' ? undefined : e;
	    var mergedHandlerResult = { needsRenderFrame: false };
	    var eventsInProgress = {};
	    var activeHandlers = {};
	    var mapTouches = e.touches ? this._getMapTouches(e.touches) : undefined;
	    var points = mapTouches ? DOM.touchPos(this._el, mapTouches) : DOM.mousePos(this._el, e);
	    for (var i = 0, list = this._handlers; i < list.length; i += 1) {
	        var ref = list[i];
	        var handlerName = ref.handlerName;
	        var handler = ref.handler;
	        var allowed = ref.allowed;
	        if (!handler.isEnabled()) {
	            continue;
	        }
	        var data = void 0;
	        if (this._blockedByActive(activeHandlers, allowed, handlerName)) {
	            handler.reset();
	        } else {
	            if (handler[eventName || e.type]) {
	                data = handler[eventName || e.type](e, points, mapTouches);
	                this.mergeHandlerResult(mergedHandlerResult, eventsInProgress, data, handlerName, inputEvent);
	                if (data && data.needsRenderFrame) {
	                    this._triggerRenderFrame();
	                }
	            }
	        }
	        if (data || handler.isActive()) {
	            activeHandlers[handlerName] = handler;
	        }
	    }
	    var deactivatedHandlers = {};
	    for (var name in this._previousActiveHandlers) {
	        if (!activeHandlers[name]) {
	            deactivatedHandlers[name] = inputEvent;
	        }
	    }
	    this._previousActiveHandlers = activeHandlers;
	    if (Object.keys(deactivatedHandlers).length || hasChange(mergedHandlerResult)) {
	        this._changes.push([
	            mergedHandlerResult,
	            eventsInProgress,
	            deactivatedHandlers
	        ]);
	        this._triggerRenderFrame();
	    }
	    if (Object.keys(activeHandlers).length || hasChange(mergedHandlerResult)) {
	        this._map._stop(true);
	    }
	    this._updatingCamera = false;
	    var cameraAnimation = mergedHandlerResult.cameraAnimation;
	    if (cameraAnimation) {
	        this._inertia.clear();
	        this._fireEvents({}, {}, true);
	        this._changes = [];
	        cameraAnimation(this._map);
	    }
	};
	HandlerManager.prototype.mergeHandlerResult = function mergeHandlerResult(mergedHandlerResult, eventsInProgress, handlerResult, name, e) {
	    if (!handlerResult) {
	        return;
	    }
	    performance.extend(mergedHandlerResult, handlerResult);
	    var eventData = {
	        handlerName: name,
	        originalEvent: handlerResult.originalEvent || e
	    };
	    if (handlerResult.zoomDelta !== undefined) {
	        eventsInProgress.zoom = eventData;
	    }
	    if (handlerResult.panDelta !== undefined) {
	        eventsInProgress.drag = eventData;
	    }
	    if (handlerResult.pitchDelta !== undefined) {
	        eventsInProgress.pitch = eventData;
	    }
	    if (handlerResult.bearingDelta !== undefined) {
	        eventsInProgress.rotate = eventData;
	    }
	};
	HandlerManager.prototype._applyChanges = function _applyChanges() {
	    var combined = {};
	    var combinedEventsInProgress = {};
	    var combinedDeactivatedHandlers = {};
	    for (var i = 0, list = this._changes; i < list.length; i += 1) {
	        var ref = list[i];
	        var change = ref[0];
	        var eventsInProgress = ref[1];
	        var deactivatedHandlers = ref[2];
	        if (change.panDelta) {
	            combined.panDelta = (combined.panDelta || new performance.Point(0, 0))._add(change.panDelta);
	        }
	        if (change.zoomDelta) {
	            combined.zoomDelta = (combined.zoomDelta || 0) + change.zoomDelta;
	        }
	        if (change.bearingDelta) {
	            combined.bearingDelta = (combined.bearingDelta || 0) + change.bearingDelta;
	        }
	        if (change.pitchDelta) {
	            combined.pitchDelta = (combined.pitchDelta || 0) + change.pitchDelta;
	        }
	        if (change.around !== undefined) {
	            combined.around = change.around;
	        }
	        if (change.pinchAround !== undefined) {
	            combined.pinchAround = change.pinchAround;
	        }
	        if (change.noInertia) {
	            combined.noInertia = change.noInertia;
	        }
	        performance.extend(combinedEventsInProgress, eventsInProgress);
	        performance.extend(combinedDeactivatedHandlers, deactivatedHandlers);
	    }
	    this._updateMapTransform(combined, combinedEventsInProgress, combinedDeactivatedHandlers);
	    this._changes = [];
	};
	HandlerManager.prototype._updateMapTransform = function _updateMapTransform(combinedResult, combinedEventsInProgress, deactivatedHandlers) {
	    var map = this._map;
	    var tr = map.transform;
	    if (!hasChange(combinedResult)) {
	        return this._fireEvents(combinedEventsInProgress, deactivatedHandlers, true);
	    }
	    var panDelta = combinedResult.panDelta;
	    var zoomDelta = combinedResult.zoomDelta;
	    var bearingDelta = combinedResult.bearingDelta;
	    var pitchDelta = combinedResult.pitchDelta;
	    var around = combinedResult.around;
	    var pinchAround = combinedResult.pinchAround;
	    if (pinchAround !== undefined) {
	        around = pinchAround;
	    }
	    map._stop(true);
	    around = around || map.transform.centerPoint;
	    var loc = tr.pointLocation(panDelta ? around.sub(panDelta) : around);
	    if (bearingDelta) {
	        tr.bearing += bearingDelta;
	    }
	    if (pitchDelta) {
	        tr.pitch += pitchDelta;
	    }
	    if (zoomDelta) {
	        tr.zoom += zoomDelta;
	    }
	    tr.setLocationAtPoint(loc, around);
	    this._map._update();
	    if (!combinedResult.noInertia) {
	        this._inertia.record(combinedResult);
	    }
	    this._fireEvents(combinedEventsInProgress, deactivatedHandlers, true);
	};
	HandlerManager.prototype._fireEvents = function _fireEvents(newEventsInProgress, deactivatedHandlers, allowEndAnimation) {
	    var this$1 = this;
	    var wasMoving = isMoving(this._eventsInProgress);
	    var nowMoving = isMoving(newEventsInProgress);
	    var startEvents = {};
	    for (var eventName in newEventsInProgress) {
	        var ref = newEventsInProgress[eventName];
	        var originalEvent = ref.originalEvent;
	        if (!this._eventsInProgress[eventName]) {
	            startEvents[eventName + 'start'] = originalEvent;
	        }
	        this._eventsInProgress[eventName] = newEventsInProgress[eventName];
	    }
	    if (!wasMoving && nowMoving) {
	        this._fireEvent('movestart', nowMoving.originalEvent);
	    }
	    for (var name in startEvents) {
	        this._fireEvent(name, startEvents[name]);
	    }
	    if (nowMoving) {
	        this._fireEvent('move', nowMoving.originalEvent);
	    }
	    for (var eventName$1 in newEventsInProgress) {
	        var ref$1 = newEventsInProgress[eventName$1];
	        var originalEvent$1 = ref$1.originalEvent;
	        this._fireEvent(eventName$1, originalEvent$1);
	    }
	    var endEvents = {};
	    var originalEndEvent;
	    for (var eventName$2 in this._eventsInProgress) {
	        var ref$2 = this._eventsInProgress[eventName$2];
	        var handlerName = ref$2.handlerName;
	        var originalEvent$2 = ref$2.originalEvent;
	        if (!this._handlersById[handlerName].isActive()) {
	            delete this._eventsInProgress[eventName$2];
	            originalEndEvent = deactivatedHandlers[handlerName] || originalEvent$2;
	            endEvents[eventName$2 + 'end'] = originalEndEvent;
	        }
	    }
	    for (var name$1 in endEvents) {
	        this._fireEvent(name$1, endEvents[name$1]);
	    }
	    var stillMoving = isMoving(this._eventsInProgress);
	    if (allowEndAnimation && (wasMoving || nowMoving) && !stillMoving) {
	        this._updatingCamera = true;
	        var inertialEase = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions);
	        var shouldSnapToNorth = function (bearing) {
	            return bearing !== 0 && -this$1._bearingSnap < bearing && bearing < this$1._bearingSnap;
	        };
	        if (inertialEase) {
	            if (shouldSnapToNorth(inertialEase.bearing || this._map.getBearing())) {
	                inertialEase.bearing = 0;
	            }
	            this._map.easeTo(inertialEase, { originalEvent: originalEndEvent });
	        } else {
	            this._map.fire(new performance.Event('moveend', { originalEvent: originalEndEvent }));
	            if (shouldSnapToNorth(this._map.getBearing())) {
	                this._map.resetNorth();
	            }
	        }
	        this._updatingCamera = false;
	    }
	};
	HandlerManager.prototype._fireEvent = function _fireEvent(type, e) {
	    this._map.fire(new performance.Event(type, e ? { originalEvent: e } : {}));
	};
	HandlerManager.prototype._requestFrame = function _requestFrame() {
	    var this$1 = this;
	    this._map.triggerRepaint();
	    return this._map._renderTaskQueue.add(function (timeStamp) {
	        delete this$1._frameId;
	        this$1.handleEvent(new RenderFrameEvent('renderFrame', { timeStamp: timeStamp }));
	        this$1._applyChanges();
	    });
	};
	HandlerManager.prototype._triggerRenderFrame = function _triggerRenderFrame() {
	    if (this._frameId === undefined) {
	        this._frameId = this._requestFrame();
	    }
	};

	var Camera = function (Evented) {
	    function Camera(transform, options) {
	        Evented.call(this);
	        this._moving = false;
	        this._zooming = false;
	        this.transform = transform;
	        this._bearingSnap = options.bearingSnap;
	        performance.bindAll(['_renderFrameCallback'], this);
	    }
	    if (Evented)
	        Camera.__proto__ = Evented;
	    Camera.prototype = Object.create(Evented && Evented.prototype);
	    Camera.prototype.constructor = Camera;
	    Camera.prototype.getCenter = function getCenter() {
	        return new performance.LngLat(this.transform.center.lng, this.transform.center.lat);
	    };
	    Camera.prototype.setCenter = function setCenter(center, eventData) {
	        return this.jumpTo({ center: center }, eventData);
	    };
	    Camera.prototype.panBy = function panBy(offset, options, eventData) {
	        offset = performance.Point.convert(offset).mult(-1);
	        return this.panTo(this.transform.center, performance.extend({ offset: offset }, options), eventData);
	    };
	    Camera.prototype.panTo = function panTo(lnglat, options, eventData) {
	        return this.easeTo(performance.extend({ center: lnglat }, options), eventData);
	    };
	    Camera.prototype.getZoom = function getZoom() {
	        return this.transform.zoom;
	    };
	    Camera.prototype.setZoom = function setZoom(zoom, eventData) {
	        this.jumpTo({ zoom: zoom }, eventData);
	        return this;
	    };
	    Camera.prototype.zoomTo = function zoomTo(zoom, options, eventData) {
	        return this.easeTo(performance.extend({ zoom: zoom }, options), eventData);
	    };
	    Camera.prototype.zoomIn = function zoomIn(options, eventData) {
	        this.zoomTo(this.getZoom() + 1, options, eventData);
	        return this;
	    };
	    Camera.prototype.zoomOut = function zoomOut(options, eventData) {
	        this.zoomTo(this.getZoom() - 1, options, eventData);
	        return this;
	    };
	    Camera.prototype.getBearing = function getBearing() {
	        return this.transform.bearing;
	    };
	    Camera.prototype.setBearing = function setBearing(bearing, eventData) {
	        this.jumpTo({ bearing: bearing }, eventData);
	        return this;
	    };
	    Camera.prototype.getPadding = function getPadding() {
	        return this.transform.padding;
	    };
	    Camera.prototype.setPadding = function setPadding(padding, eventData) {
	        this.jumpTo({ padding: padding }, eventData);
	        return this;
	    };
	    Camera.prototype.rotateTo = function rotateTo(bearing, options, eventData) {
	        return this.easeTo(performance.extend({ bearing: bearing }, options), eventData);
	    };
	    Camera.prototype.resetNorth = function resetNorth(options, eventData) {
	        this.rotateTo(0, performance.extend({ duration: 1000 }, options), eventData);
	        return this;
	    };
	    Camera.prototype.resetNorthPitch = function resetNorthPitch(options, eventData) {
	        this.easeTo(performance.extend({
	            bearing: 0,
	            pitch: 0,
	            duration: 1000
	        }, options), eventData);
	        return this;
	    };
	    Camera.prototype.snapToNorth = function snapToNorth(options, eventData) {
	        if (Math.abs(this.getBearing()) < this._bearingSnap) {
	            return this.resetNorth(options, eventData);
	        }
	        return this;
	    };
	    Camera.prototype.getPitch = function getPitch() {
	        return this.transform.pitch;
	    };
	    Camera.prototype.setPitch = function setPitch(pitch, eventData) {
	        this.jumpTo({ pitch: pitch }, eventData);
	        return this;
	    };
	    Camera.prototype.cameraForBounds = function cameraForBounds(bounds, options) {
	        bounds = performance.LngLatBounds.convert(bounds);
	        var bearing = options && options.bearing || 0;
	        return this._cameraForBoxAndBearing(bounds.getNorthWest(), bounds.getSouthEast(), bearing, options);
	    };
	    Camera.prototype._cameraForBoxAndBearing = function _cameraForBoxAndBearing(p0, p1, bearing, options) {
	        var defaultPadding = {
	            top: 0,
	            bottom: 0,
	            right: 0,
	            left: 0
	        };
	        options = performance.extend({
	            padding: defaultPadding,
	            offset: [
	                0,
	                0
	            ],
	            maxZoom: this.transform.maxZoom
	        }, options);
	        if (typeof options.padding === 'number') {
	            var p = options.padding;
	            options.padding = {
	                top: p,
	                bottom: p,
	                right: p,
	                left: p
	            };
	        }
	        options.padding = performance.extend(defaultPadding, options.padding);
	        var tr = this.transform;
	        var edgePadding = tr.padding;
	        var p0world = tr.project(performance.LngLat.convert(p0));
	        var p1world = tr.project(performance.LngLat.convert(p1));
	        var p0rotated = p0world.rotate(-bearing * Math.PI / 180);
	        var p1rotated = p1world.rotate(-bearing * Math.PI / 180);
	        var upperRight = new performance.Point(Math.max(p0rotated.x, p1rotated.x), Math.max(p0rotated.y, p1rotated.y));
	        var lowerLeft = new performance.Point(Math.min(p0rotated.x, p1rotated.x), Math.min(p0rotated.y, p1rotated.y));
	        var size = upperRight.sub(lowerLeft);
	        var scaleX = (tr.width - (edgePadding.left + edgePadding.right + options.padding.left + options.padding.right)) / size.x;
	        var scaleY = (tr.height - (edgePadding.top + edgePadding.bottom + options.padding.top + options.padding.bottom)) / size.y;
	        if (scaleY < 0 || scaleX < 0) {
	            performance.warnOnce('Map cannot fit within canvas with the given bounds, padding, and/or offset.');
	            return;
	        }
	        var zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);
	        var offset = typeof options.offset.x === 'number' ? new performance.Point(options.offset.x, options.offset.y) : performance.Point.convert(options.offset);
	        var paddingOffsetX = (options.padding.left - options.padding.right) / 2;
	        var paddingOffsetY = (options.padding.top - options.padding.bottom) / 2;
	        var paddingOffset = new performance.Point(paddingOffsetX, paddingOffsetY);
	        var rotatedPaddingOffset = paddingOffset.rotate(bearing * Math.PI / 180);
	        var offsetAtInitialZoom = offset.add(rotatedPaddingOffset);
	        var offsetAtFinalZoom = offsetAtInitialZoom.mult(tr.scale / tr.zoomScale(zoom));
	        var center = tr.unproject(p0world.add(p1world).div(2).sub(offsetAtFinalZoom));
	        return {
	            center: center,
	            zoom: zoom,
	            bearing: bearing
	        };
	    };
	    Camera.prototype.fitBounds = function fitBounds(bounds, options, eventData) {
	        return this._fitInternal(this.cameraForBounds(bounds, options), options, eventData);
	    };
	    Camera.prototype.fitScreenCoordinates = function fitScreenCoordinates(p0, p1, bearing, options, eventData) {
	        return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(performance.Point.convert(p0)), this.transform.pointLocation(performance.Point.convert(p1)), bearing, options), options, eventData);
	    };
	    Camera.prototype._fitInternal = function _fitInternal(calculatedOptions, options, eventData) {
	        if (!calculatedOptions) {
	            return this;
	        }
	        options = performance.extend(calculatedOptions, options);
	        delete options.padding;
	        return options.linear ? this.easeTo(options, eventData) : this.flyTo(options, eventData);
	    };
	    Camera.prototype.jumpTo = function jumpTo(options, eventData) {
	        this.stop();
	        var tr = this.transform;
	        var zoomChanged = false, bearingChanged = false, pitchChanged = false;
	        if ('zoom' in options && tr.zoom !== +options.zoom) {
	            zoomChanged = true;
	            tr.zoom = +options.zoom;
	        }
	        if (options.center !== undefined) {
	            tr.center = performance.LngLat.convert(options.center);
	        }
	        if ('bearing' in options && tr.bearing !== +options.bearing) {
	            bearingChanged = true;
	            tr.bearing = +options.bearing;
	        }
	        if ('pitch' in options && tr.pitch !== +options.pitch) {
	            pitchChanged = true;
	            tr.pitch = +options.pitch;
	        }
	        if (options.padding != null && !tr.isPaddingEqual(options.padding)) {
	            tr.padding = options.padding;
	        }
	        this.fire(new performance.Event('movestart', eventData)).fire(new performance.Event('move', eventData));
	        if (zoomChanged) {
	            this.fire(new performance.Event('zoomstart', eventData)).fire(new performance.Event('zoom', eventData)).fire(new performance.Event('zoomend', eventData));
	        }
	        if (bearingChanged) {
	            this.fire(new performance.Event('rotatestart', eventData)).fire(new performance.Event('rotate', eventData)).fire(new performance.Event('rotateend', eventData));
	        }
	        if (pitchChanged) {
	            this.fire(new performance.Event('pitchstart', eventData)).fire(new performance.Event('pitch', eventData)).fire(new performance.Event('pitchend', eventData));
	        }
	        return this.fire(new performance.Event('moveend', eventData));
	    };
	    Camera.prototype.easeTo = function easeTo(options, eventData) {
	        var this$1 = this;
	        this._stop(false, options.easeId);
	        options = performance.extend({
	            offset: [
	                0,
	                0
	            ],
	            duration: 500,
	            easing: performance.ease
	        }, options);
	        if (options.animate === false || !options.essential && performance.browser.prefersReducedMotion) {
	            options.duration = 0;
	        }
	        var tr = this.transform, startZoom = this.getZoom(), startBearing = this.getBearing(), startPitch = this.getPitch(), startPadding = this.getPadding(), zoom = 'zoom' in options ? +options.zoom : startZoom, bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing, pitch = 'pitch' in options ? +options.pitch : startPitch, padding = 'padding' in options ? options.padding : tr.padding;
	        var offsetAsPoint = performance.Point.convert(options.offset);
	        var pointAtOffset = tr.centerPoint.add(offsetAsPoint);
	        var locationAtOffset = tr.pointLocation(pointAtOffset);
	        var center = performance.LngLat.convert(options.center || locationAtOffset);
	        this._normalizeCenter(center);
	        var from = tr.project(locationAtOffset);
	        var delta = tr.project(center).sub(from);
	        var finalScale = tr.zoomScale(zoom - startZoom);
	        var around, aroundPoint;
	        if (options.around) {
	            around = performance.LngLat.convert(options.around);
	            aroundPoint = tr.locationPoint(around);
	        }
	        var currently = {
	            moving: this._moving,
	            zooming: this._zooming,
	            rotating: this._rotating,
	            pitching: this._pitching
	        };
	        this._zooming = this._zooming || zoom !== startZoom;
	        this._rotating = this._rotating || startBearing !== bearing;
	        this._pitching = this._pitching || pitch !== startPitch;
	        this._padding = !tr.isPaddingEqual(padding);
	        this._easeId = options.easeId;
	        this._prepareEase(eventData, options.noMoveStart, currently);
	        this._ease(function (k) {
	            if (this$1._zooming) {
	                tr.zoom = performance.number(startZoom, zoom, k);
	            }
	            if (this$1._rotating) {
	                tr.bearing = performance.number(startBearing, bearing, k);
	            }
	            if (this$1._pitching) {
	                tr.pitch = performance.number(startPitch, pitch, k);
	            }
	            if (this$1._padding) {
	                tr.interpolatePadding(startPadding, padding, k);
	                pointAtOffset = tr.centerPoint.add(offsetAsPoint);
	            }
	            if (around) {
	                tr.setLocationAtPoint(around, aroundPoint);
	            } else {
	                var scale = tr.zoomScale(tr.zoom - startZoom);
	                var base = zoom > startZoom ? Math.min(2, finalScale) : Math.max(0.5, finalScale);
	                var speedup = Math.pow(base, 1 - k);
	                var newCenter = tr.unproject(from.add(delta.mult(k * speedup)).mult(scale));
	                tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);
	            }
	            this$1._fireMoveEvents(eventData);
	        }, function (interruptingEaseId) {
	            this$1._afterEase(eventData, interruptingEaseId);
	        }, options);
	        return this;
	    };
	    Camera.prototype._prepareEase = function _prepareEase(eventData, noMoveStart, currently) {
	        if (currently === void 0)
	            currently = {};
	        this._moving = true;
	        if (!noMoveStart && !currently.moving) {
	            this.fire(new performance.Event('movestart', eventData));
	        }
	        if (this._zooming && !currently.zooming) {
	            this.fire(new performance.Event('zoomstart', eventData));
	        }
	        if (this._rotating && !currently.rotating) {
	            this.fire(new performance.Event('rotatestart', eventData));
	        }
	        if (this._pitching && !currently.pitching) {
	            this.fire(new performance.Event('pitchstart', eventData));
	        }
	    };
	    Camera.prototype._fireMoveEvents = function _fireMoveEvents(eventData) {
	        this.fire(new performance.Event('move', eventData));
	        if (this._zooming) {
	            this.fire(new performance.Event('zoom', eventData));
	        }
	        if (this._rotating) {
	            this.fire(new performance.Event('rotate', eventData));
	        }
	        if (this._pitching) {
	            this.fire(new performance.Event('pitch', eventData));
	        }
	    };
	    Camera.prototype._afterEase = function _afterEase(eventData, easeId) {
	        if (this._easeId && easeId && this._easeId === easeId) {
	            return;
	        }
	        delete this._easeId;
	        var wasZooming = this._zooming;
	        var wasRotating = this._rotating;
	        var wasPitching = this._pitching;
	        this._moving = false;
	        this._zooming = false;
	        this._rotating = false;
	        this._pitching = false;
	        this._padding = false;
	        if (wasZooming) {
	            this.fire(new performance.Event('zoomend', eventData));
	        }
	        if (wasRotating) {
	            this.fire(new performance.Event('rotateend', eventData));
	        }
	        if (wasPitching) {
	            this.fire(new performance.Event('pitchend', eventData));
	        }
	        this.fire(new performance.Event('moveend', eventData));
	    };
	    Camera.prototype.flyTo = function flyTo(options, eventData) {
	        var this$1 = this;
	        if (!options.essential && performance.browser.prefersReducedMotion) {
	            var coercedOptions = performance.pick(options, [
	                'center',
	                'zoom',
	                'bearing',
	                'pitch',
	                'around'
	            ]);
	            return this.jumpTo(coercedOptions, eventData);
	        }
	        this.stop();
	        options = performance.extend({
	            offset: [
	                0,
	                0
	            ],
	            speed: 1.2,
	            curve: 1.42,
	            easing: performance.ease
	        }, options);
	        var tr = this.transform, startZoom = this.getZoom(), startBearing = this.getBearing(), startPitch = this.getPitch(), startPadding = this.getPadding();
	        var zoom = 'zoom' in options ? performance.clamp(+options.zoom, tr.minZoom, tr.maxZoom) : startZoom;
	        var bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing;
	        var pitch = 'pitch' in options ? +options.pitch : startPitch;
	        var padding = 'padding' in options ? options.padding : tr.padding;
	        var scale = tr.zoomScale(zoom - startZoom);
	        var offsetAsPoint = performance.Point.convert(options.offset);
	        var pointAtOffset = tr.centerPoint.add(offsetAsPoint);
	        var locationAtOffset = tr.pointLocation(pointAtOffset);
	        var center = performance.LngLat.convert(options.center || locationAtOffset);
	        this._normalizeCenter(center);
	        var from = tr.project(locationAtOffset);
	        var delta = tr.project(center).sub(from);
	        var rho = options.curve;
	        var w0 = Math.max(tr.width, tr.height), w1 = w0 / scale, u1 = delta.mag();
	        if ('minZoom' in options) {
	            var minZoom = performance.clamp(Math.min(options.minZoom, startZoom, zoom), tr.minZoom, tr.maxZoom);
	            var wMax = w0 / tr.zoomScale(minZoom - startZoom);
	            rho = Math.sqrt(wMax / u1 * 2);
	        }
	        var rho2 = rho * rho;
	        function r(i) {
	            var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
	            return Math.log(Math.sqrt(b * b + 1) - b);
	        }
	        function sinh(n) {
	            return (Math.exp(n) - Math.exp(-n)) / 2;
	        }
	        function cosh(n) {
	            return (Math.exp(n) + Math.exp(-n)) / 2;
	        }
	        function tanh(n) {
	            return sinh(n) / cosh(n);
	        }
	        var r0 = r(0);
	        var w = function (s) {
	            return cosh(r0) / cosh(r0 + rho * s);
	        };
	        var u = function (s) {
	            return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1;
	        };
	        var S = (r(1) - r0) / rho;
	        if (Math.abs(u1) < 0.000001 || !isFinite(S)) {
	            if (Math.abs(w0 - w1) < 0.000001) {
	                return this.easeTo(options, eventData);
	            }
	            var k = w1 < w0 ? -1 : 1;
	            S = Math.abs(Math.log(w1 / w0)) / rho;
	            u = function () {
	                return 0;
	            };
	            w = function (s) {
	                return Math.exp(k * rho * s);
	            };
	        }
	        if ('duration' in options) {
	            options.duration = +options.duration;
	        } else {
	            var V = 'screenSpeed' in options ? +options.screenSpeed / rho : +options.speed;
	            options.duration = 1000 * S / V;
	        }
	        if (options.maxDuration && options.duration > options.maxDuration) {
	            options.duration = 0;
	        }
	        this._zooming = true;
	        this._rotating = startBearing !== bearing;
	        this._pitching = pitch !== startPitch;
	        this._padding = !tr.isPaddingEqual(padding);
	        this._prepareEase(eventData, false);
	        this._ease(function (k) {
	            var s = k * S;
	            var scale = 1 / w(s);
	            tr.zoom = k === 1 ? zoom : startZoom + tr.scaleZoom(scale);
	            if (this$1._rotating) {
	                tr.bearing = performance.number(startBearing, bearing, k);
	            }
	            if (this$1._pitching) {
	                tr.pitch = performance.number(startPitch, pitch, k);
	            }
	            if (this$1._padding) {
	                tr.interpolatePadding(startPadding, padding, k);
	                pointAtOffset = tr.centerPoint.add(offsetAsPoint);
	            }
	            var newCenter = k === 1 ? center : tr.unproject(from.add(delta.mult(u(s))).mult(scale));
	            tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);
	            this$1._fireMoveEvents(eventData);
	        }, function () {
	            return this$1._afterEase(eventData);
	        }, options);
	        return this;
	    };
	    Camera.prototype.isEasing = function isEasing() {
	        return !!this._easeFrameId;
	    };
	    Camera.prototype.stop = function stop() {
	        return this._stop();
	    };
	    Camera.prototype._stop = function _stop(allowGestures, easeId) {
	        if (this._easeFrameId) {
	            this._cancelRenderFrame(this._easeFrameId);
	            delete this._easeFrameId;
	            delete this._onEaseFrame;
	        }
	        if (this._onEaseEnd) {
	            var onEaseEnd = this._onEaseEnd;
	            delete this._onEaseEnd;
	            onEaseEnd.call(this, easeId);
	        }
	        if (!allowGestures) {
	            var handlers = this.handlers;
	            if (handlers) {
	                handlers.stop(false);
	            }
	        }
	        return this;
	    };
	    Camera.prototype._ease = function _ease(frame, finish, options) {
	        if (options.animate === false || options.duration === 0) {
	            frame(1);
	            finish();
	        } else {
	            this._easeStart = performance.browser.now();
	            this._easeOptions = options;
	            this._onEaseFrame = frame;
	            this._onEaseEnd = finish;
	            this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback);
	        }
	    };
	    Camera.prototype._renderFrameCallback = function _renderFrameCallback() {
	        var t = Math.min((performance.browser.now() - this._easeStart) / this._easeOptions.duration, 1);
	        this._onEaseFrame(this._easeOptions.easing(t));
	        if (t < 1) {
	            this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback);
	        } else {
	            this.stop();
	        }
	    };
	    Camera.prototype._normalizeBearing = function _normalizeBearing(bearing, currentBearing) {
	        bearing = performance.wrap(bearing, -180, 180);
	        var diff = Math.abs(bearing - currentBearing);
	        if (Math.abs(bearing - 360 - currentBearing) < diff) {
	            bearing -= 360;
	        }
	        if (Math.abs(bearing + 360 - currentBearing) < diff) {
	            bearing += 360;
	        }
	        return bearing;
	    };
	    Camera.prototype._normalizeCenter = function _normalizeCenter(center) {
	        var tr = this.transform;
	        if (!tr.renderWorldCopies || tr.lngRange) {
	            return;
	        }
	        var delta = center.lng - tr.center.lng;
	        center.lng += delta > 180 ? -360 : delta < -180 ? 360 : 0;
	    };
	    return Camera;
	}(performance.Evented);

	var AttributionControl = function AttributionControl(options) {
	    if (options === void 0)
	        options = {};
	    this.options = options;
	    performance.bindAll([
	        '_toggleAttribution',
	        '_updateEditLink',
	        '_updateData',
	        '_updateCompact'
	    ], this);
	};
	AttributionControl.prototype.getDefaultPosition = function getDefaultPosition() {
	    return 'bottom-right';
	};
	AttributionControl.prototype.onAdd = function onAdd(map) {
	    var compact = this.options && this.options.compact;
	    this._map = map;
	    this._container = DOM.create('div', 'mapboxgl-ctrl mapboxgl-ctrl-attrib');
	    this._compactButton = DOM.create('button', 'mapboxgl-ctrl-attrib-button', this._container);
	    this._compactButton.addEventListener('click', this._toggleAttribution);
	    this._setElementTitle(this._compactButton, 'ToggleAttribution');
	    this._innerContainer = DOM.create('div', 'mapboxgl-ctrl-attrib-inner', this._container);
	    this._innerContainer.setAttribute('role', 'list');
	    if (compact) {
	        this._container.classList.add('mapboxgl-compact');
	    }
	    this._updateAttributions();
	    this._updateEditLink();
	    this._map.on('styledata', this._updateData);
	    this._map.on('sourcedata', this._updateData);
	    this._map.on('moveend', this._updateEditLink);
	    if (compact === undefined) {
	        this._map.on('resize', this._updateCompact);
	        this._updateCompact();
	    }
	    return this._container;
	};
	AttributionControl.prototype.onRemove = function onRemove() {
	    DOM.remove(this._container);
	    this._map.off('styledata', this._updateData);
	    this._map.off('sourcedata', this._updateData);
	    this._map.off('moveend', this._updateEditLink);
	    this._map.off('resize', this._updateCompact);
	    this._map = undefined;
	    this._attribHTML = undefined;
	};
	AttributionControl.prototype._setElementTitle = function _setElementTitle(element, title) {
	    var str = this._map._getUIString('AttributionControl.' + title);
	    element.title = str;
	    element.setAttribute('aria-label', str);
	};
	AttributionControl.prototype._toggleAttribution = function _toggleAttribution() {
	    if (this._container.classList.contains('mapboxgl-compact-show')) {
	        this._container.classList.remove('mapboxgl-compact-show');
	        this._compactButton.setAttribute('aria-pressed', 'false');
	    } else {
	        this._container.classList.add('mapboxgl-compact-show');
	        this._compactButton.setAttribute('aria-pressed', 'true');
	    }
	};
	AttributionControl.prototype._updateEditLink = function _updateEditLink() {
	    var editLink = this._editLink;
	    if (!editLink) {
	        editLink = this._editLink = this._container.querySelector('.mapbox-improve-map');
	    }
	    var params = [
	        {
	            key: 'owner',
	            value: this.styleOwner
	        },
	        {
	            key: 'id',
	            value: this.styleId
	        },
	        {
	            key: 'access_token',
	            value: this._map._requestManager._customAccessToken || performance.config.ACCESS_TOKEN
	        }
	    ];
	    if (editLink) {
	        var paramString = params.reduce(function (acc, next, i) {
	            if (next.value) {
	                acc += next.key + '=' + next.value + (i < params.length - 1 ? '&' : '');
	            }
	            return acc;
	        }, '?');
	        editLink.href = performance.config.FEEDBACK_URL + '/' + paramString + (this._map._hash ? this._map._hash.getHashString(true) : '');
	        editLink.rel = 'noopener nofollow';
	        this._setElementTitle(editLink, 'MapFeedback');
	    }
	};
	AttributionControl.prototype._updateData = function _updateData(e) {
	    if (e && (e.sourceDataType === 'metadata' || e.sourceDataType === 'visibility' || e.dataType === 'style')) {
	        this._updateAttributions();
	        this._updateEditLink();
	    }
	};
	AttributionControl.prototype._updateAttributions = function _updateAttributions() {
	    if (!this._map.style) {
	        return;
	    }
	    var attributions = [];
	    if (this.options.customAttribution) {
	        if (Array.isArray(this.options.customAttribution)) {
	            attributions = attributions.concat(this.options.customAttribution.map(function (attribution) {
	                if (typeof attribution !== 'string') {
	                    return '';
	                }
	                return attribution;
	            }));
	        } else if (typeof this.options.customAttribution === 'string') {
	            attributions.push(this.options.customAttribution);
	        }
	    }
	    if (this._map.style.stylesheet) {
	        var stylesheet = this._map.style.stylesheet;
	        this.styleOwner = stylesheet.owner;
	        this.styleId = stylesheet.id;
	    }
	    var sourceCaches = this._map.style.sourceCaches;
	    for (var id in sourceCaches) {
	        var sourceCache = sourceCaches[id];
	        if (sourceCache.used) {
	            var source = sourceCache.getSource();
	            if (source.attribution && attributions.indexOf(source.attribution) < 0) {
	                attributions.push(source.attribution);
	            }
	        }
	    }
	    attributions.sort(function (a, b) {
	        return a.length - b.length;
	    });
	    attributions = attributions.filter(function (attrib, i) {
	        for (var j = i + 1; j < attributions.length; j++) {
	            if (attributions[j].indexOf(attrib) >= 0) {
	                return false;
	            }
	        }
	        return true;
	    });
	    var attribHTML = attributions.join(' | ');
	    if (attribHTML === this._attribHTML) {
	        return;
	    }
	    this._attribHTML = attribHTML;
	    if (attributions.length) {
	        this._innerContainer.innerHTML = attribHTML;
	        this._container.classList.remove('mapboxgl-attrib-empty');
	    } else {
	        this._container.classList.add('mapboxgl-attrib-empty');
	    }
	    this._editLink = null;
	};
	AttributionControl.prototype._updateCompact = function _updateCompact() {
	    if (this._map.getCanvasContainer().offsetWidth <= 640) {
	        this._container.classList.add('mapboxgl-compact');
	    } else {
	        this._container.classList.remove('mapboxgl-compact', 'mapboxgl-compact-show');
	    }
	};

	var LogoControl = function LogoControl() {
	    performance.bindAll(['_updateLogo'], this);
	    performance.bindAll(['_updateCompact'], this);
	};
	LogoControl.prototype.onAdd = function onAdd(map) {
	    this._map = map;
	    this._container = DOM.create('div', 'mapboxgl-ctrl');
	    var anchor = DOM.create('a', 'mapboxgl-ctrl-logo');
	    anchor.target = '_blank';
	    anchor.rel = 'noopener nofollow';
	    anchor.href = 'https://www.mapbox.com/';
	    anchor.setAttribute('aria-label', this._map._getUIString('LogoControl.Title'));
	    anchor.setAttribute('rel', 'noopener nofollow');
	    this._container.appendChild(anchor);
	    this._container.style.display = 'none';
	    this._map.on('sourcedata', this._updateLogo);
	    this._updateLogo();
	    this._map.on('resize', this._updateCompact);
	    this._updateCompact();
	    return this._container;
	};
	LogoControl.prototype.onRemove = function onRemove() {
	    DOM.remove(this._container);
	    this._map.off('sourcedata', this._updateLogo);
	    this._map.off('resize', this._updateCompact);
	};
	LogoControl.prototype.getDefaultPosition = function getDefaultPosition() {
	    return 'bottom-left';
	};
	LogoControl.prototype._updateLogo = function _updateLogo(e) {
	    if (!e || e.sourceDataType === 'metadata') {
	        this._container.style.display = this._logoRequired() ? 'block' : 'none';
	    }
	};
	LogoControl.prototype._logoRequired = function _logoRequired() {
	    if (!this._map.style) {
	        return;
	    }
	    var sourceCaches = this._map.style.sourceCaches;
	    for (var id in sourceCaches) {
	        var source = sourceCaches[id].getSource();
	        if (source.mapbox_logo) {
	            return true;
	        }
	    }
	    return false;
	};
	LogoControl.prototype._updateCompact = function _updateCompact() {
	    var containerChildren = this._container.children;
	    if (containerChildren.length) {
	        var anchor = containerChildren[0];
	        if (this._map.getCanvasContainer().offsetWidth < 250) {
	            anchor.classList.add('mapboxgl-compact');
	        } else {
	            anchor.classList.remove('mapboxgl-compact');
	        }
	    }
	};

	var TaskQueue = function TaskQueue() {
	    this._queue = [];
	    this._id = 0;
	    this._cleared = false;
	    this._currentlyRunning = false;
	};
	TaskQueue.prototype.add = function add(callback) {
	    var id = ++this._id;
	    var queue = this._queue;
	    queue.push({
	        callback: callback,
	        id: id,
	        cancelled: false
	    });
	    return id;
	};
	TaskQueue.prototype.remove = function remove(id) {
	    var running = this._currentlyRunning;
	    var queue = running ? this._queue.concat(running) : this._queue;
	    for (var i = 0, list = queue; i < list.length; i += 1) {
	        var task = list[i];
	        if (task.id === id) {
	            task.cancelled = true;
	            return;
	        }
	    }
	};
	TaskQueue.prototype.run = function run(timeStamp) {
	    if (timeStamp === void 0)
	        timeStamp = 0;
	    var queue = this._currentlyRunning = this._queue;
	    this._queue = [];
	    for (var i = 0, list = queue; i < list.length; i += 1) {
	        var task = list[i];
	        if (task.cancelled) {
	            continue;
	        }
	        task.callback(timeStamp);
	        if (this._cleared) {
	            break;
	        }
	    }
	    this._cleared = false;
	    this._currentlyRunning = false;
	};
	TaskQueue.prototype.clear = function clear() {
	    if (this._currentlyRunning) {
	        this._cleared = true;
	    }
	    this._queue = [];
	};

	var defaultLocale = {
	    'AttributionControl.ToggleAttribution': 'Toggle attribution',
	    'AttributionControl.MapFeedback': 'Map feedback',
	    'FullscreenControl.Enter': 'Enter fullscreen',
	    'FullscreenControl.Exit': 'Exit fullscreen',
	    'GeolocateControl.FindMyLocation': 'Find my location',
	    'GeolocateControl.LocationNotAvailable': 'Location not available',
	    'LogoControl.Title': 'Mapbox logo',
	    'NavigationControl.ResetBearing': 'Reset bearing to north',
	    'NavigationControl.ZoomIn': 'Zoom in',
	    'NavigationControl.ZoomOut': 'Zoom out',
	    'ScaleControl.Feet': 'ft',
	    'ScaleControl.Meters': 'm',
	    'ScaleControl.Kilometers': 'km',
	    'ScaleControl.Miles': 'mi',
	    'ScaleControl.NauticalMiles': 'nm'
	};

	var HTMLImageElement = performance.window.HTMLImageElement;
	var HTMLElement = performance.window.HTMLElement;
	var ImageBitmap = performance.window.ImageBitmap;
	var defaultMinZoom = -2;
	var defaultMaxZoom = 22;
	var defaultMinPitch = 0;
	var defaultMaxPitch = 60;
	var defaultOptions$1 = {
	    center: [
	        0,
	        0
	    ],
	    zoom: 0,
	    bearing: 0,
	    pitch: 0,
	    minZoom: defaultMinZoom,
	    maxZoom: defaultMaxZoom,
	    minPitch: defaultMinPitch,
	    maxPitch: defaultMaxPitch,
	    interactive: true,
	    scrollZoom: true,
	    boxZoom: true,
	    dragRotate: true,
	    dragPan: true,
	    keyboard: true,
	    doubleClickZoom: true,
	    touchZoomRotate: true,
	    touchPitch: true,
	    bearingSnap: 7,
	    clickTolerance: 3,
	    pitchWithRotate: true,
	    hash: false,
	    attributionControl: true,
	    failIfMajorPerformanceCaveat: false,
	    preserveDrawingBuffer: false,
	    trackResize: true,
	    renderWorldCopies: true,
	    refreshExpiredTiles: true,
	    maxTileCacheSize: null,
	    localIdeographFontFamily: 'sans-serif',
	    transformRequest: null,
	    accessToken: null,
	    fadeDuration: 300,
	    crossSourceCollisions: true
	};
	var Map = function (Camera) {
	    function Map(options) {
	        var this$1 = this;
	        options = performance.extend({}, defaultOptions$1, options);
	        if (options.minZoom != null && options.maxZoom != null && options.minZoom > options.maxZoom) {
	            throw new Error('maxZoom must be greater than or equal to minZoom');
	        }
	        if (options.minPitch != null && options.maxPitch != null && options.minPitch > options.maxPitch) {
	            throw new Error('maxPitch must be greater than or equal to minPitch');
	        }
	        if (options.minPitch != null && options.minPitch < defaultMinPitch) {
	            throw new Error('minPitch must be greater than or equal to ' + defaultMinPitch);
	        }
	        if (options.maxPitch != null && options.maxPitch > defaultMaxPitch) {
	            throw new Error('maxPitch must be less than or equal to ' + defaultMaxPitch);
	        }
	        var transform = new Transform(options.minZoom, options.maxZoom, options.minPitch, options.maxPitch, options.renderWorldCopies);
	        Camera.call(this, transform, options);
	        this._interactive = options.interactive;
	        this._maxTileCacheSize = options.maxTileCacheSize;
	        this._failIfMajorPerformanceCaveat = options.failIfMajorPerformanceCaveat;
	        this._preserveDrawingBuffer = options.preserveDrawingBuffer;
	        this._antialias = options.antialias;
	        this._trackResize = options.trackResize;
	        this._bearingSnap = options.bearingSnap;
	        this._refreshExpiredTiles = options.refreshExpiredTiles;
	        this._fadeDuration = options.fadeDuration;
	        this._crossSourceCollisions = options.crossSourceCollisions;
	        this._crossFadingFactor = 1;
	        this._collectResourceTiming = options.collectResourceTiming;
	        this._renderTaskQueue = new TaskQueue();
	        this._controls = [];
	        this._mapId = performance.uniqueId();
	        this._locale = performance.extend({}, defaultLocale, options.locale);
	        this._clickTolerance = options.clickTolerance;
	        this._requestManager = new performance.RequestManager(options.transformRequest, options.accessToken);
	        if (typeof options.container === 'string') {
	            this._container = performance.window.document.getElementById(options.container);
	            if (!this._container) {
	                throw new Error('Container \'' + options.container + '\' not found.');
	            }
	        } else if (options.container instanceof HTMLElement) {
	            this._container = options.container;
	        } else {
	            throw new Error('Invalid type: \'container\' must be a String or HTMLElement.');
	        }
	        if (options.maxBounds) {
	            this.setMaxBounds(options.maxBounds);
	        }
	        performance.bindAll([
	            '_onWindowOnline',
	            '_onWindowResize',
	            '_onMapScroll',
	            '_contextLost',
	            '_contextRestored'
	        ], this);
	        this._setupContainer();
	        this._setupPainter();
	        if (this.painter === undefined) {
	            throw new Error('Failed to initialize WebGL.');
	        }
	        this.on('move', function () {
	            return this$1._update(false);
	        });
	        this.on('moveend', function () {
	            return this$1._update(false);
	        });
	        this.on('zoom', function () {
	            return this$1._update(true);
	        });
	        if (typeof performance.window !== 'undefined') {
	            performance.window.addEventListener('online', this._onWindowOnline, false);
	            performance.window.addEventListener('resize', this._onWindowResize, false);
	            performance.window.addEventListener('orientationchange', this._onWindowResize, false);
	        }
	        this.handlers = new HandlerManager(this, options);
	        var hashName = typeof options.hash === 'string' && options.hash || undefined;
	        this._hash = options.hash && new Hash(hashName).addTo(this);
	        if (!this._hash || !this._hash._onHashChange()) {
	            this.jumpTo({
	                center: options.center,
	                zoom: options.zoom,
	                bearing: options.bearing,
	                pitch: options.pitch
	            });
	            if (options.bounds) {
	                this.resize();
	                this.fitBounds(options.bounds, performance.extend({}, options.fitBoundsOptions, { duration: 0 }));
	            }
	        }
	        this.resize();
	        this._localIdeographFontFamily = options.localIdeographFontFamily;
	        if (options.style) {
	            this.setStyle(options.style, { localIdeographFontFamily: options.localIdeographFontFamily });
	        }
	        if (options.attributionControl) {
	            this.addControl(new AttributionControl({ customAttribution: options.customAttribution }));
	        }
	        this.addControl(new LogoControl(), options.logoPosition);
	        this.on('style.load', function () {
	            if (this$1.transform.unmodified) {
	                this$1.jumpTo(this$1.style.stylesheet);
	            }
	        });
	        this.on('data', function (event) {
	            this$1._update(event.dataType === 'style');
	            this$1.fire(new performance.Event(event.dataType + 'data', event));
	        });
	        this.on('dataloading', function (event) {
	            this$1.fire(new performance.Event(event.dataType + 'dataloading', event));
	        });
	    }
	    if (Camera)
	        Map.__proto__ = Camera;
	    Map.prototype = Object.create(Camera && Camera.prototype);
	    Map.prototype.constructor = Map;
	    var prototypeAccessors = {
	        showTileBoundaries: { configurable: true },
	        showPadding: { configurable: true },
	        showCollisionBoxes: { configurable: true },
	        showOverdrawInspector: { configurable: true },
	        repaint: { configurable: true },
	        vertices: { configurable: true },
	        version: { configurable: true }
	    };
	    Map.prototype._getMapId = function _getMapId() {
	        return this._mapId;
	    };
	    Map.prototype.addControl = function addControl(control, position) {
	        if (position === undefined) {
	            if (control.getDefaultPosition) {
	                position = control.getDefaultPosition();
	            } else {
	                position = 'top-right';
	            }
	        }
	        if (!control || !control.onAdd) {
	            return this.fire(new performance.ErrorEvent(new Error('Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.')));
	        }
	        var controlElement = control.onAdd(this);
	        this._controls.push(control);
	        var positionContainer = this._controlPositions[position];
	        if (position.indexOf('bottom') !== -1) {
	            positionContainer.insertBefore(controlElement, positionContainer.firstChild);
	        } else {
	            positionContainer.appendChild(controlElement);
	        }
	        return this;
	    };
	    Map.prototype.removeControl = function removeControl(control) {
	        if (!control || !control.onRemove) {
	            return this.fire(new performance.ErrorEvent(new Error('Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.')));
	        }
	        var ci = this._controls.indexOf(control);
	        if (ci > -1) {
	            this._controls.splice(ci, 1);
	        }
	        control.onRemove(this);
	        return this;
	    };
	    Map.prototype.hasControl = function hasControl(control) {
	        return this._controls.indexOf(control) > -1;
	    };
	    Map.prototype.resize = function resize(eventData) {
	        var dimensions = this._containerDimensions();
	        var width = dimensions[0];
	        var height = dimensions[1];
	        this._resizeCanvas(width, height);
	        this.transform.resize(width, height);
	        this.painter.resize(width, height);
	        var fireMoving = !this._moving;
	        if (fireMoving) {
	            this.stop();
	            this.fire(new performance.Event('movestart', eventData)).fire(new performance.Event('move', eventData));
	        }
	        this.fire(new performance.Event('resize', eventData));
	        if (fireMoving) {
	            this.fire(new performance.Event('moveend', eventData));
	        }
	        return this;
	    };
	    Map.prototype.getBounds = function getBounds() {
	        return this.transform.getBounds();
	    };
	    Map.prototype.getMaxBounds = function getMaxBounds() {
	        return this.transform.getMaxBounds();
	    };
	    Map.prototype.setMaxBounds = function setMaxBounds(bounds) {
	        this.transform.setMaxBounds(performance.LngLatBounds.convert(bounds));
	        return this._update();
	    };
	    Map.prototype.setMinZoom = function setMinZoom(minZoom) {
	        minZoom = minZoom === null || minZoom === undefined ? defaultMinZoom : minZoom;
	        if (minZoom >= defaultMinZoom && minZoom <= this.transform.maxZoom) {
	            this.transform.minZoom = minZoom;
	            this._update();
	            if (this.getZoom() < minZoom) {
	                this.setZoom(minZoom);
	            }
	            return this;
	        } else {
	            throw new Error('minZoom must be between ' + defaultMinZoom + ' and the current maxZoom, inclusive');
	        }
	    };
	    Map.prototype.getMinZoom = function getMinZoom() {
	        return this.transform.minZoom;
	    };
	    Map.prototype.setMaxZoom = function setMaxZoom(maxZoom) {
	        maxZoom = maxZoom === null || maxZoom === undefined ? defaultMaxZoom : maxZoom;
	        if (maxZoom >= this.transform.minZoom) {
	            this.transform.maxZoom = maxZoom;
	            this._update();
	            if (this.getZoom() > maxZoom) {
	                this.setZoom(maxZoom);
	            }
	            return this;
	        } else {
	            throw new Error('maxZoom must be greater than the current minZoom');
	        }
	    };
	    Map.prototype.getMaxZoom = function getMaxZoom() {
	        return this.transform.maxZoom;
	    };
	    Map.prototype.setMinPitch = function setMinPitch(minPitch) {
	        minPitch = minPitch === null || minPitch === undefined ? defaultMinPitch : minPitch;
	        if (minPitch < defaultMinPitch) {
	            throw new Error('minPitch must be greater than or equal to ' + defaultMinPitch);
	        }
	        if (minPitch >= defaultMinPitch && minPitch <= this.transform.maxPitch) {
	            this.transform.minPitch = minPitch;
	            this._update();
	            if (this.getPitch() < minPitch) {
	                this.setPitch(minPitch);
	            }
	            return this;
	        } else {
	            throw new Error('minPitch must be between ' + defaultMinPitch + ' and the current maxPitch, inclusive');
	        }
	    };
	    Map.prototype.getMinPitch = function getMinPitch() {
	        return this.transform.minPitch;
	    };
	    Map.prototype.setMaxPitch = function setMaxPitch(maxPitch) {
	        maxPitch = maxPitch === null || maxPitch === undefined ? defaultMaxPitch : maxPitch;
	        if (maxPitch > defaultMaxPitch) {
	            throw new Error('maxPitch must be less than or equal to ' + defaultMaxPitch);
	        }
	        if (maxPitch >= this.transform.minPitch) {
	            this.transform.maxPitch = maxPitch;
	            this._update();
	            if (this.getPitch() > maxPitch) {
	                this.setPitch(maxPitch);
	            }
	            return this;
	        } else {
	            throw new Error('maxPitch must be greater than the current minPitch');
	        }
	    };
	    Map.prototype.getMaxPitch = function getMaxPitch() {
	        return this.transform.maxPitch;
	    };
	    Map.prototype.getRenderWorldCopies = function getRenderWorldCopies() {
	        return this.transform.renderWorldCopies;
	    };
	    Map.prototype.setRenderWorldCopies = function setRenderWorldCopies(renderWorldCopies) {
	        this.transform.renderWorldCopies = renderWorldCopies;
	        return this._update();
	    };
	    Map.prototype.project = function project(lnglat) {
	        return this.transform.locationPoint(performance.LngLat.convert(lnglat));
	    };
	    Map.prototype.unproject = function unproject(point) {
	        return this.transform.pointLocation(performance.Point.convert(point));
	    };
	    Map.prototype.isMoving = function isMoving() {
	        return this._moving || this.handlers.isMoving();
	    };
	    Map.prototype.isZooming = function isZooming() {
	        return this._zooming || this.handlers.isZooming();
	    };
	    Map.prototype.isRotating = function isRotating() {
	        return this._rotating || this.handlers.isRotating();
	    };
	    Map.prototype._createDelegatedListener = function _createDelegatedListener(type, layerId, listener) {
	        var this$1 = this;
	        var obj;
	        if (type === 'mouseenter' || type === 'mouseover') {
	            var mousein = false;
	            var mousemove = function (e) {
	                var features = this$1.getLayer(layerId) ? this$1.queryRenderedFeatures(e.point, { layers: [layerId] }) : [];
	                if (!features.length) {
	                    mousein = false;
	                } else if (!mousein) {
	                    mousein = true;
	                    listener.call(this$1, new MapMouseEvent(type, this$1, e.originalEvent, { features: features }));
	                }
	            };
	            var mouseout = function () {
	                mousein = false;
	            };
	            return {
	                layer: layerId,
	                listener: listener,
	                delegates: {
	                    mousemove: mousemove,
	                    mouseout: mouseout
	                }
	            };
	        } else if (type === 'mouseleave' || type === 'mouseout') {
	            var mousein$1 = false;
	            var mousemove$1 = function (e) {
	                var features = this$1.getLayer(layerId) ? this$1.queryRenderedFeatures(e.point, { layers: [layerId] }) : [];
	                if (features.length) {
	                    mousein$1 = true;
	                } else if (mousein$1) {
	                    mousein$1 = false;
	                    listener.call(this$1, new MapMouseEvent(type, this$1, e.originalEvent));
	                }
	            };
	            var mouseout$1 = function (e) {
	                if (mousein$1) {
	                    mousein$1 = false;
	                    listener.call(this$1, new MapMouseEvent(type, this$1, e.originalEvent));
	                }
	            };
	            return {
	                layer: layerId,
	                listener: listener,
	                delegates: {
	                    mousemove: mousemove$1,
	                    mouseout: mouseout$1
	                }
	            };
	        } else {
	            var delegate = function (e) {
	                var features = this$1.getLayer(layerId) ? this$1.queryRenderedFeatures(e.point, { layers: [layerId] }) : [];
	                if (features.length) {
	                    e.features = features;
	                    listener.call(this$1, e);
	                    delete e.features;
	                }
	            };
	            return {
	                layer: layerId,
	                listener: listener,
	                delegates: (obj = {}, obj[type] = delegate, obj)
	            };
	        }
	    };
	    Map.prototype.on = function on(type, layerId, listener) {
	        if (listener === undefined) {
	            return Camera.prototype.on.call(this, type, layerId);
	        }
	        var delegatedListener = this._createDelegatedListener(type, layerId, listener);
	        this._delegatedListeners = this._delegatedListeners || {};
	        this._delegatedListeners[type] = this._delegatedListeners[type] || [];
	        this._delegatedListeners[type].push(delegatedListener);
	        for (var event in delegatedListener.delegates) {
	            this.on(event, delegatedListener.delegates[event]);
	        }
	        return this;
	    };
	    Map.prototype.once = function once(type, layerId, listener) {
	        if (listener === undefined) {
	            return Camera.prototype.once.call(this, type, layerId);
	        }
	        var delegatedListener = this._createDelegatedListener(type, layerId, listener);
	        for (var event in delegatedListener.delegates) {
	            this.once(event, delegatedListener.delegates[event]);
	        }
	        return this;
	    };
	    Map.prototype.off = function off(type, layerId, listener) {
	        var this$1 = this;
	        if (listener === undefined) {
	            return Camera.prototype.off.call(this, type, layerId);
	        }
	        var removeDelegatedListener = function (delegatedListeners) {
	            var listeners = delegatedListeners[type];
	            for (var i = 0; i < listeners.length; i++) {
	                var delegatedListener = listeners[i];
	                if (delegatedListener.layer === layerId && delegatedListener.listener === listener) {
	                    for (var event in delegatedListener.delegates) {
	                        this$1.off(event, delegatedListener.delegates[event]);
	                    }
	                    listeners.splice(i, 1);
	                    return this$1;
	                }
	            }
	        };
	        if (this._delegatedListeners && this._delegatedListeners[type]) {
	            removeDelegatedListener(this._delegatedListeners);
	        }
	        return this;
	    };
	    Map.prototype.queryRenderedFeatures = function queryRenderedFeatures(geometry, options) {
	        if (!this.style) {
	            return [];
	        }
	        if (options === undefined && geometry !== undefined && !(geometry instanceof performance.Point) && !Array.isArray(geometry)) {
	            options = geometry;
	            geometry = undefined;
	        }
	        options = options || {};
	        geometry = geometry || [
	            [
	                0,
	                0
	            ],
	            [
	                this.transform.width,
	                this.transform.height
	            ]
	        ];
	        var queryGeometry;
	        if (geometry instanceof performance.Point || typeof geometry[0] === 'number') {
	            queryGeometry = [performance.Point.convert(geometry)];
	        } else {
	            var tl = performance.Point.convert(geometry[0]);
	            var br = performance.Point.convert(geometry[1]);
	            queryGeometry = [
	                tl,
	                new performance.Point(br.x, tl.y),
	                br,
	                new performance.Point(tl.x, br.y),
	                tl
	            ];
	        }
	        return this.style.queryRenderedFeatures(queryGeometry, options, this.transform);
	    };
	    Map.prototype.querySourceFeatures = function querySourceFeatures(sourceId, parameters) {
	        return this.style.querySourceFeatures(sourceId, parameters);
	    };
	    Map.prototype.setStyle = function setStyle(style, options) {
	        options = performance.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, options);
	        if (options.diff !== false && options.localIdeographFontFamily === this._localIdeographFontFamily && this.style && style) {
	            this._diffStyle(style, options);
	            return this;
	        } else {
	            this._localIdeographFontFamily = options.localIdeographFontFamily;
	            return this._updateStyle(style, options);
	        }
	    };
	    Map.prototype._getUIString = function _getUIString(key) {
	        var str = this._locale[key];
	        if (str == null) {
	            throw new Error('Missing UI string \'' + key + '\'');
	        }
	        return str;
	    };
	    Map.prototype._updateStyle = function _updateStyle(style, options) {
	        if (options === void 0)
	            options = {};
	        if (!options.stylePatch) {
	            if (this.style) {
	                this.style.setEventedParent(null);
	                this.style._remove();
	            }
	            if (!style) {
	                delete this.style;
	                return this;
	            } else {
	                this.style = new Style(this, options);
	            }
	            this.style.setEventedParent(this, { style: this.style });
	        } else {
	            if (!style) {
	                style = emptyStyle();
	            }
	        }
	        if (!this.style) {
	            this.style = new Style(this, options);
	            this.style.setEventedParent(this, { style: this.style });
	        }
	        if (typeof style === 'string') {
	            this.style.loadURL(style, options);
	        } else {
	            this.style.loadJSON(style, options);
	        }
	        return this;
	    };
	    Map.prototype._lazyInitEmptyStyle = function _lazyInitEmptyStyle() {
	        if (!this.style) {
	            this.style = new Style(this, {});
	            this.style.setEventedParent(this, { style: this.style });
	            this.style.loadEmpty();
	        }
	    };
	    Map.prototype._diffStyle = function _diffStyle(style, options) {
	        var this$1 = this;
	        if (options === void 0)
	            options = {};
	        if (typeof style === 'string') {
	            var url = this._requestManager.normalizeStyleURL(style);
	            var request = this._requestManager.transformRequest(url, performance.ResourceType.Style);
	            performance.getJSON(request, function (error, json) {
	                if (error) {
	                    this$1.fire(new performance.ErrorEvent(error));
	                } else if (json) {
	                    this$1._updateDiff(json, options);
	                }
	            });
	        } else if (typeof style === 'object') {
	            this._updateDiff(style, options);
	        }
	    };
	    Map.prototype._updateDiff = function _updateDiff(style, options) {
	        if (options === void 0)
	            options = {};
	        try {
	            if (this.style.setState(style, options)) {
	                this._update(true);
	            }
	        } catch (e) {
	            performance.warnOnce('Unable to perform style diff: ' + (e.message || e.error || e) + '.  Rebuilding the style from scratch.');
	            this._updateStyle(style, options);
	        }
	    };
	    Map.prototype.getStyle = function getStyle() {
	        if (this.style) {
	            return this.style.serialize();
	        }
	    };
	    Map.prototype.isStyleLoaded = function isStyleLoaded() {
	        if (!this.style) {
	            return performance.warnOnce('There is no style added to the map.');
	        }
	        return this.style.loaded();
	    };
	    Map.prototype.addSource = function addSource(id, source) {
	        this._lazyInitEmptyStyle();
	        this.style.addSource(id, source);
	        return this._update(true);
	    };
	    Map.prototype.isSourceLoaded = function isSourceLoaded(id) {
	        var source = this.style && this.style.sourceCaches[id];
	        if (source === undefined) {
	            this.fire(new performance.ErrorEvent(new Error('There is no source with ID \'' + id + '\'')));
	            return;
	        }
	        return source.loaded();
	    };
	    Map.prototype.areTilesLoaded = function areTilesLoaded() {
	        var sources = this.style && this.style.sourceCaches;
	        for (var id in sources) {
	            var source = sources[id];
	            var tiles = source._tiles;
	            for (var t in tiles) {
	                var tile = tiles[t];
	                if (!(tile.state === 'loaded' || tile.state === 'errored')) {
	                    return false;
	                }
	            }
	        }
	        return true;
	    };
	    Map.prototype.addSourceType = function addSourceType(name, SourceType, callback) {
	        this._lazyInitEmptyStyle();
	        return this.style.addSourceType(name, SourceType, callback);
	    };
	    Map.prototype.removeSource = function removeSource(id) {
	        this.style.removeSource(id);
	        return this._update(true);
	    };
	    Map.prototype.getSource = function getSource(id) {
	        return this.style.getSource(id);
	    };
	    Map.prototype.addImage = function addImage(id, image, ref) {
	        if (ref === void 0)
	            ref = {};
	        var pixelRatio = ref.pixelRatio;
	        if (pixelRatio === void 0)
	            pixelRatio = 1;
	        var sdf = ref.sdf;
	        if (sdf === void 0)
	            sdf = false;
	        var stretchX = ref.stretchX;
	        var stretchY = ref.stretchY;
	        var content = ref.content;
	        this._lazyInitEmptyStyle();
	        var version = 0;
	        if (image instanceof HTMLImageElement || ImageBitmap && image instanceof ImageBitmap) {
	            var ref$1 = performance.browser.getImageData(image);
	            var width = ref$1.width;
	            var height = ref$1.height;
	            var data = ref$1.data;
	            this.style.addImage(id, {
	                data: new performance.RGBAImage({
	                    width: width,
	                    height: height
	                }, data),
	                pixelRatio: pixelRatio,
	                stretchX: stretchX,
	                stretchY: stretchY,
	                content: content,
	                sdf: sdf,
	                version: version
	            });
	        } else if (image.width === undefined || image.height === undefined) {
	            return this.fire(new performance.ErrorEvent(new Error('Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, ' + 'or object with `width`, `height`, and `data` properties with the same format as `ImageData`')));
	        } else {
	            var width$1 = image.width;
	            var height$1 = image.height;
	            var data$1 = image.data;
	            var userImage = image;
	            this.style.addImage(id, {
	                data: new performance.RGBAImage({
	                    width: width$1,
	                    height: height$1
	                }, new Uint8Array(data$1)),
	                pixelRatio: pixelRatio,
	                stretchX: stretchX,
	                stretchY: stretchY,
	                content: content,
	                sdf: sdf,
	                version: version,
	                userImage: userImage
	            });
	            if (userImage.onAdd) {
	                userImage.onAdd(this, id);
	            }
	        }
	    };
	    Map.prototype.updateImage = function updateImage(id, image) {
	        var existingImage = this.style.getImage(id);
	        if (!existingImage) {
	            return this.fire(new performance.ErrorEvent(new Error('The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.')));
	        }
	        var imageData = image instanceof HTMLImageElement || ImageBitmap && image instanceof ImageBitmap ? performance.browser.getImageData(image) : image;
	        var width = imageData.width;
	        var height = imageData.height;
	        var data = imageData.data;
	        if (width === undefined || height === undefined) {
	            return this.fire(new performance.ErrorEvent(new Error('Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, ' + 'or object with `width`, `height`, and `data` properties with the same format as `ImageData`')));
	        }
	        if (width !== existingImage.data.width || height !== existingImage.data.height) {
	            return this.fire(new performance.ErrorEvent(new Error('The width and height of the updated image must be that same as the previous version of the image')));
	        }
	        var copy = !(image instanceof HTMLImageElement || ImageBitmap && image instanceof ImageBitmap);
	        existingImage.data.replace(data, copy);
	        this.style.updateImage(id, existingImage);
	    };
	    Map.prototype.hasImage = function hasImage(id) {
	        if (!id) {
	            this.fire(new performance.ErrorEvent(new Error('Missing required image id')));
	            return false;
	        }
	        return !!this.style.getImage(id);
	    };
	    Map.prototype.removeImage = function removeImage(id) {
	        this.style.removeImage(id);
	    };
	    Map.prototype.loadImage = function loadImage(url, callback) {
	        performance.getImage(this._requestManager.transformRequest(url, performance.ResourceType.Image), callback);
	    };
	    Map.prototype.listImages = function listImages() {
	        return this.style.listImages();
	    };
	    Map.prototype.addLayer = function addLayer(layer, beforeId) {
	        this._lazyInitEmptyStyle();
	        this.style.addLayer(layer, beforeId);
	        return this._update(true);
	    };
	    Map.prototype.moveLayer = function moveLayer(id, beforeId) {
	        this.style.moveLayer(id, beforeId);
	        return this._update(true);
	    };
	    Map.prototype.removeLayer = function removeLayer(id) {
	        this.style.removeLayer(id);
	        return this._update(true);
	    };
	    Map.prototype.getLayer = function getLayer(id) {
	        return this.style.getLayer(id);
	    };
	    Map.prototype.setLayerZoomRange = function setLayerZoomRange(layerId, minzoom, maxzoom) {
	        this.style.setLayerZoomRange(layerId, minzoom, maxzoom);
	        return this._update(true);
	    };
	    Map.prototype.setFilter = function setFilter(layerId, filter, options) {
	        if (options === void 0)
	            options = {};
	        this.style.setFilter(layerId, filter, options);
	        return this._update(true);
	    };
	    Map.prototype.getFilter = function getFilter(layerId) {
	        return this.style.getFilter(layerId);
	    };
	    Map.prototype.setPaintProperty = function setPaintProperty(layerId, name, value, options) {
	        if (options === void 0)
	            options = {};
	        this.style.setPaintProperty(layerId, name, value, options);
	        return this._update(true);
	    };
	    Map.prototype.getPaintProperty = function getPaintProperty(layerId, name) {
	        return this.style.getPaintProperty(layerId, name);
	    };
	    Map.prototype.setLayoutProperty = function setLayoutProperty(layerId, name, value, options) {
	        if (options === void 0)
	            options = {};
	        this.style.setLayoutProperty(layerId, name, value, options);
	        return this._update(true);
	    };
	    Map.prototype.getLayoutProperty = function getLayoutProperty(layerId, name) {
	        return this.style.getLayoutProperty(layerId, name);
	    };
	    Map.prototype.setLight = function setLight(light, options) {
	        if (options === void 0)
	            options = {};
	        this._lazyInitEmptyStyle();
	        this.style.setLight(light, options);
	        return this._update(true);
	    };
	    Map.prototype.getLight = function getLight() {
	        return this.style.getLight();
	    };
	    Map.prototype.setFeatureState = function setFeatureState(feature, state) {
	        this.style.setFeatureState(feature, state);
	        return this._update();
	    };
	    Map.prototype.removeFeatureState = function removeFeatureState(target, key) {
	        this.style.removeFeatureState(target, key);
	        return this._update();
	    };
	    Map.prototype.getFeatureState = function getFeatureState(feature) {
	        return this.style.getFeatureState(feature);
	    };
	    Map.prototype.getContainer = function getContainer() {
	        return this._container;
	    };
	    Map.prototype.getCanvasContainer = function getCanvasContainer() {
	        return this._canvasContainer;
	    };
	    Map.prototype.getCanvas = function getCanvas() {
	        return this._canvas;
	    };
	    Map.prototype._containerDimensions = function _containerDimensions() {
	        var width = 0;
	        var height = 0;
	        if (this._container) {
	            width = this._container.clientWidth || 400;
	            height = this._container.clientHeight || 300;
	        }
	        return [
	            width,
	            height
	        ];
	    };
	    Map.prototype._detectMissingCSS = function _detectMissingCSS() {
	        var computedColor = performance.window.getComputedStyle(this._missingCSSCanary).getPropertyValue('background-color');
	        if (computedColor !== 'rgb(250, 128, 114)') {
	            performance.warnOnce('This page appears to be missing CSS declarations for ' + 'Mapbox GL JS, which may cause the map to display incorrectly. ' + 'Please ensure your page includes mapbox-gl.css, as described ' + 'in https://www.mapbox.com/mapbox-gl-js/api/.');
	        }
	    };
	    Map.prototype._setupContainer = function _setupContainer() {
	        var container = this._container;
	        container.classList.add('mapboxgl-map');
	        var missingCSSCanary = this._missingCSSCanary = DOM.create('div', 'mapboxgl-canary', container);
	        missingCSSCanary.style.visibility = 'hidden';
	        this._detectMissingCSS();
	        var canvasContainer = this._canvasContainer = DOM.create('div', 'mapboxgl-canvas-container', container);
	        if (this._interactive) {
	            canvasContainer.classList.add('mapboxgl-interactive');
	        }
	        this._canvas = DOM.create('canvas', 'mapboxgl-canvas', canvasContainer);
	        this._canvas.addEventListener('webglcontextlost', this._contextLost, false);
	        this._canvas.addEventListener('webglcontextrestored', this._contextRestored, false);
	        this._canvas.setAttribute('tabindex', '0');
	        this._canvas.setAttribute('aria-label', 'Map');
	        this._canvas.setAttribute('role', 'region');
	        var dimensions = this._containerDimensions();
	        this._resizeCanvas(dimensions[0], dimensions[1]);
	        var controlContainer = this._controlContainer = DOM.create('div', 'mapboxgl-control-container', container);
	        var positions = this._controlPositions = {};
	        [
	            'top-left',
	            'top-right',
	            'bottom-left',
	            'bottom-right'
	        ].forEach(function (positionName) {
	            positions[positionName] = DOM.create('div', 'mapboxgl-ctrl-' + positionName, controlContainer);
	        });
	        this._container.addEventListener('scroll', this._onMapScroll, false);
	    };
	    Map.prototype._resizeCanvas = function _resizeCanvas(width, height) {
	        var pixelRatio = performance.browser.devicePixelRatio || 1;
	        this._canvas.width = pixelRatio * width;
	        this._canvas.height = pixelRatio * height;
	        this._canvas.style.width = width + 'px';
	        this._canvas.style.height = height + 'px';
	    };
	    Map.prototype._setupPainter = function _setupPainter() {
	        var attributes = performance.extend({}, mapboxGlSupported.webGLContextAttributes, {
	            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
	            preserveDrawingBuffer: this._preserveDrawingBuffer,
	            antialias: this._antialias || false
	        });
	        var gl = this._canvas.getContext('webgl', attributes) || this._canvas.getContext('experimental-webgl', attributes);
	        if (!gl) {
	            this.fire(new performance.ErrorEvent(new Error('Failed to initialize WebGL')));
	            return;
	        }
	        this.painter = new Painter(gl, this.transform);
	        performance.webpSupported.testSupport(gl);
	    };
	    Map.prototype._contextLost = function _contextLost(event) {
	        event.preventDefault();
	        if (this._frame) {
	            this._frame.cancel();
	            this._frame = null;
	        }
	        this.fire(new performance.Event('webglcontextlost', { originalEvent: event }));
	    };
	    Map.prototype._contextRestored = function _contextRestored(event) {
	        this._setupPainter();
	        this.resize();
	        this._update();
	        this.fire(new performance.Event('webglcontextrestored', { originalEvent: event }));
	    };
	    Map.prototype._onMapScroll = function _onMapScroll(event) {
	        if (event.target !== this._container) {
	            return;
	        }
	        this._container.scrollTop = 0;
	        this._container.scrollLeft = 0;
	        return false;
	    };
	    Map.prototype.loaded = function loaded() {
	        return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
	    };
	    Map.prototype._update = function _update(updateStyle) {
	        if (!this.style) {
	            return this;
	        }
	        this._styleDirty = this._styleDirty || updateStyle;
	        this._sourcesDirty = true;
	        this.triggerRepaint();
	        return this;
	    };
	    Map.prototype._requestRenderFrame = function _requestRenderFrame(callback) {
	        this._update();
	        return this._renderTaskQueue.add(callback);
	    };
	    Map.prototype._cancelRenderFrame = function _cancelRenderFrame(id) {
	        this._renderTaskQueue.remove(id);
	    };
	    Map.prototype._render = function _render(paintStartTimeStamp) {
	        var this$1 = this;
	        var gpuTimer, frameStartTime = 0;
	        var extTimerQuery = this.painter.context.extTimerQuery;
	        if (this.listens('gpu-timing-frame')) {
	            gpuTimer = extTimerQuery.createQueryEXT();
	            extTimerQuery.beginQueryEXT(extTimerQuery.TIME_ELAPSED_EXT, gpuTimer);
	            frameStartTime = performance.browser.now();
	        }
	        this.painter.context.setDirty();
	        this.painter.setBaseState();
	        this._renderTaskQueue.run(paintStartTimeStamp);
	        if (this._removed) {
	            return;
	        }
	        var crossFading = false;
	        if (this.style && this._styleDirty) {
	            this._styleDirty = false;
	            var zoom = this.transform.zoom;
	            var now = performance.browser.now();
	            this.style.zoomHistory.update(zoom, now);
	            var parameters = new performance.EvaluationParameters(zoom, {
	                now: now,
	                fadeDuration: this._fadeDuration,
	                zoomHistory: this.style.zoomHistory,
	                transition: this.style.getTransition()
	            });
	            var factor = parameters.crossFadingFactor();
	            if (factor !== 1 || factor !== this._crossFadingFactor) {
	                crossFading = true;
	                this._crossFadingFactor = factor;
	            }
	            this.style.update(parameters);
	        }
	        if (this.style && this._sourcesDirty) {
	            this._sourcesDirty = false;
	            this.style._updateSources(this.transform);
	        }
	        this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions);
	        this.painter.render(this.style, {
	            showTileBoundaries: this.showTileBoundaries,
	            showOverdrawInspector: this._showOverdrawInspector,
	            rotating: this.isRotating(),
	            zooming: this.isZooming(),
	            moving: this.isMoving(),
	            fadeDuration: this._fadeDuration,
	            showPadding: this.showPadding,
	            gpuTiming: !!this.listens('gpu-timing-layer')
	        });
	        this.fire(new performance.Event('render'));
	        if (this.loaded() && !this._loaded) {
	            this._loaded = true;
	            this.fire(new performance.Event('load'));
	        }
	        if (this.style && (this.style.hasTransitions() || crossFading)) {
	            this._styleDirty = true;
	        }
	        if (this.style && !this._placementDirty) {
	            this.style._releaseSymbolFadeTiles();
	        }
	        if (this.listens('gpu-timing-frame')) {
	            var renderCPUTime = performance.browser.now() - frameStartTime;
	            extTimerQuery.endQueryEXT(extTimerQuery.TIME_ELAPSED_EXT, gpuTimer);
	            setTimeout(function () {
	                var renderGPUTime = extTimerQuery.getQueryObjectEXT(gpuTimer, extTimerQuery.QUERY_RESULT_EXT) / (1000 * 1000);
	                extTimerQuery.deleteQueryEXT(gpuTimer);
	                this$1.fire(new performance.Event('gpu-timing-frame', {
	                    cpuTime: renderCPUTime,
	                    gpuTime: renderGPUTime
	                }));
	            }, 50);
	        }
	        if (this.listens('gpu-timing-layer')) {
	            var frameLayerQueries = this.painter.collectGpuTimers();
	            setTimeout(function () {
	                var renderedLayerTimes = this$1.painter.queryGpuTimers(frameLayerQueries);
	                this$1.fire(new performance.Event('gpu-timing-layer', { layerTimes: renderedLayerTimes }));
	            }, 50);
	        }
	        var somethingDirty = this._sourcesDirty || this._styleDirty || this._placementDirty;
	        if (somethingDirty || this._repaint) {
	            this.triggerRepaint();
	        } else if (!this.isMoving() && this.loaded()) {
	            this.fire(new performance.Event('idle'));
	        }
	        if (this._loaded && !this._fullyLoaded && !somethingDirty) {
	            this._fullyLoaded = true;
	        }
	        return this;
	    };
	    Map.prototype.remove = function remove() {
	        if (this._hash) {
	            this._hash.remove();
	        }
	        for (var i = 0, list = this._controls; i < list.length; i += 1) {
	            var control = list[i];
	            control.onRemove(this);
	        }
	        this._controls = [];
	        if (this._frame) {
	            this._frame.cancel();
	            this._frame = null;
	        }
	        this._renderTaskQueue.clear();
	        this.painter.destroy();
	        this.handlers.destroy();
	        delete this.handlers;
	        this.setStyle(null);
	        if (typeof performance.window !== 'undefined') {
	            performance.window.removeEventListener('resize', this._onWindowResize, false);
	            performance.window.removeEventListener('orientationchange', this._onWindowResize, false);
	            performance.window.removeEventListener('online', this._onWindowOnline, false);
	        }
	        var extension = this.painter.context.gl.getExtension('WEBGL_lose_context');
	        if (extension) {
	            extension.loseContext();
	        }
	        removeNode(this._canvasContainer);
	        removeNode(this._controlContainer);
	        removeNode(this._missingCSSCanary);
	        this._container.classList.remove('mapboxgl-map');
	        this._removed = true;
	        this.fire(new performance.Event('remove'));
	    };
	    Map.prototype.triggerRepaint = function triggerRepaint() {
	        var this$1 = this;
	        if (this.style && !this._frame) {
	            this._frame = performance.browser.frame(function (paintStartTimeStamp) {
	                this$1._frame = null;
	                this$1._render(paintStartTimeStamp);
	            });
	        }
	    };
	    Map.prototype._onWindowOnline = function _onWindowOnline() {
	        this._update();
	    };
	    Map.prototype._onWindowResize = function _onWindowResize(event) {
	        if (this._trackResize) {
	            this.resize({ originalEvent: event })._update();
	        }
	    };
	    prototypeAccessors.showTileBoundaries.get = function () {
	        return !!this._showTileBoundaries;
	    };
	    prototypeAccessors.showTileBoundaries.set = function (value) {
	        if (this._showTileBoundaries === value) {
	            return;
	        }
	        this._showTileBoundaries = value;
	        this._update();
	    };
	    prototypeAccessors.showPadding.get = function () {
	        return !!this._showPadding;
	    };
	    prototypeAccessors.showPadding.set = function (value) {
	        if (this._showPadding === value) {
	            return;
	        }
	        this._showPadding = value;
	        this._update();
	    };
	    prototypeAccessors.showCollisionBoxes.get = function () {
	        return !!this._showCollisionBoxes;
	    };
	    prototypeAccessors.showCollisionBoxes.set = function (value) {
	        if (this._showCollisionBoxes === value) {
	            return;
	        }
	        this._showCollisionBoxes = value;
	        if (value) {
	            this.style._generateCollisionBoxes();
	        } else {
	            this._update();
	        }
	    };
	    prototypeAccessors.showOverdrawInspector.get = function () {
	        return !!this._showOverdrawInspector;
	    };
	    prototypeAccessors.showOverdrawInspector.set = function (value) {
	        if (this._showOverdrawInspector === value) {
	            return;
	        }
	        this._showOverdrawInspector = value;
	        this._update();
	    };
	    prototypeAccessors.repaint.get = function () {
	        return !!this._repaint;
	    };
	    prototypeAccessors.repaint.set = function (value) {
	        if (this._repaint !== value) {
	            this._repaint = value;
	            this.triggerRepaint();
	        }
	    };
	    prototypeAccessors.vertices.get = function () {
	        return !!this._vertices;
	    };
	    prototypeAccessors.vertices.set = function (value) {
	        this._vertices = value;
	        this._update();
	    };
	    Map.prototype._setCacheLimits = function _setCacheLimits(limit, checkThreshold) {
	        performance.setCacheLimits(limit, checkThreshold);
	    };
	    prototypeAccessors.version.get = function () {
	        return performance.version;
	    };
	    Object.defineProperties(Map.prototype, prototypeAccessors);
	    return Map;
	}(Camera);
	function removeNode(node) {
	    if (node.parentNode) {
	        node.parentNode.removeChild(node);
	    }
	}

	var defaultOptions$2 = {
	    showCompass: true,
	    showZoom: true,
	    visualizePitch: false
	};
	var NavigationControl = function NavigationControl(options) {
	    var this$1 = this;
	    this.options = performance.extend({}, defaultOptions$2, options);
	    this._container = DOM.create('div', 'mapboxgl-ctrl mapboxgl-ctrl-group');
	    this._container.addEventListener('contextmenu', function (e) {
	        return e.preventDefault();
	    });
	    if (this.options.showZoom) {
	        performance.bindAll([
	            '_setButtonTitle',
	            '_updateZoomButtons'
	        ], this);
	        this._zoomInButton = this._createButton('mapboxgl-ctrl-zoom-in', function (e) {
	            return this$1._map.zoomIn({}, { originalEvent: e });
	        });
	        DOM.create('span', 'mapboxgl-ctrl-icon', this._zoomInButton).setAttribute('aria-hidden', true);
	        this._zoomOutButton = this._createButton('mapboxgl-ctrl-zoom-out', function (e) {
	            return this$1._map.zoomOut({}, { originalEvent: e });
	        });
	        DOM.create('span', 'mapboxgl-ctrl-icon', this._zoomOutButton).setAttribute('aria-hidden', true);
	    }
	    if (this.options.showCompass) {
	        performance.bindAll(['_rotateCompassArrow'], this);
	        this._compass = this._createButton('mapboxgl-ctrl-compass', function (e) {
	            if (this$1.options.visualizePitch) {
	                this$1._map.resetNorthPitch({}, { originalEvent: e });
	            } else {
	                this$1._map.resetNorth({}, { originalEvent: e });
	            }
	        });
	        this._compassIcon = DOM.create('span', 'mapboxgl-ctrl-icon', this._compass);
	        this._compassIcon.setAttribute('aria-hidden', true);
	    }
	};
	NavigationControl.prototype._updateZoomButtons = function _updateZoomButtons() {
	    var zoom = this._map.getZoom();
	    var isMax = zoom === this._map.getMaxZoom();
	    var isMin = zoom === this._map.getMinZoom();
	    this._zoomInButton.disabled = isMax;
	    this._zoomOutButton.disabled = isMin;
	    this._zoomInButton.setAttribute('aria-disabled', isMax.toString());
	    this._zoomOutButton.setAttribute('aria-disabled', isMin.toString());
	};
	NavigationControl.prototype._rotateCompassArrow = function _rotateCompassArrow() {
	    var rotate = this.options.visualizePitch ? 'scale(' + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5) + ') rotateX(' + this._map.transform.pitch + 'deg) rotateZ(' + this._map.transform.angle * (180 / Math.PI) + 'deg)' : 'rotate(' + this._map.transform.angle * (180 / Math.PI) + 'deg)';
	    this._compassIcon.style.transform = rotate;
	};
	NavigationControl.prototype.onAdd = function onAdd(map) {
	    this._map = map;
	    if (this.options.showZoom) {
	        this._setButtonTitle(this._zoomInButton, 'ZoomIn');
	        this._setButtonTitle(this._zoomOutButton, 'ZoomOut');
	        this._map.on('zoom', this._updateZoomButtons);
	        this._updateZoomButtons();
	    }
	    if (this.options.showCompass) {
	        this._setButtonTitle(this._compass, 'ResetBearing');
	        if (this.options.visualizePitch) {
	            this._map.on('pitch', this._rotateCompassArrow);
	        }
	        this._map.on('rotate', this._rotateCompassArrow);
	        this._rotateCompassArrow();
	        this._handler = new MouseRotateWrapper(this._map, this._compass, this.options.visualizePitch);
	    }
	    return this._container;
	};
	NavigationControl.prototype.onRemove = function onRemove() {
	    DOM.remove(this._container);
	    if (this.options.showZoom) {
	        this._map.off('zoom', this._updateZoomButtons);
	    }
	    if (this.options.showCompass) {
	        if (this.options.visualizePitch) {
	            this._map.off('pitch', this._rotateCompassArrow);
	        }
	        this._map.off('rotate', this._rotateCompassArrow);
	        this._handler.off();
	        delete this._handler;
	    }
	    delete this._map;
	};
	NavigationControl.prototype._createButton = function _createButton(className, fn) {
	    var a = DOM.create('button', className, this._container);
	    a.type = 'button';
	    a.addEventListener('click', fn);
	    return a;
	};
	NavigationControl.prototype._setButtonTitle = function _setButtonTitle(button, title) {
	    var str = this._map._getUIString('NavigationControl.' + title);
	    button.title = str;
	    button.setAttribute('aria-label', str);
	};
	var MouseRotateWrapper = function MouseRotateWrapper(map, element, pitch) {
	    if (pitch === void 0)
	        pitch = false;
	    this._clickTolerance = 10;
	    this.element = element;
	    this.mouseRotate = new MouseRotateHandler({ clickTolerance: map.dragRotate._mouseRotate._clickTolerance });
	    this.map = map;
	    if (pitch) {
	        this.mousePitch = new MousePitchHandler({ clickTolerance: map.dragRotate._mousePitch._clickTolerance });
	    }
	    performance.bindAll([
	        'mousedown',
	        'mousemove',
	        'mouseup',
	        'touchstart',
	        'touchmove',
	        'touchend',
	        'reset'
	    ], this);
	    DOM.addEventListener(element, 'mousedown', this.mousedown);
	    DOM.addEventListener(element, 'touchstart', this.touchstart, { passive: false });
	    DOM.addEventListener(element, 'touchmove', this.touchmove);
	    DOM.addEventListener(element, 'touchend', this.touchend);
	    DOM.addEventListener(element, 'touchcancel', this.reset);
	};
	MouseRotateWrapper.prototype.down = function down(e, point) {
	    this.mouseRotate.mousedown(e, point);
	    if (this.mousePitch) {
	        this.mousePitch.mousedown(e, point);
	    }
	    DOM.disableDrag();
	};
	MouseRotateWrapper.prototype.move = function move(e, point) {
	    var map = this.map;
	    var r = this.mouseRotate.mousemoveWindow(e, point);
	    if (r && r.bearingDelta) {
	        map.setBearing(map.getBearing() + r.bearingDelta);
	    }
	    if (this.mousePitch) {
	        var p = this.mousePitch.mousemoveWindow(e, point);
	        if (p && p.pitchDelta) {
	            map.setPitch(map.getPitch() + p.pitchDelta);
	        }
	    }
	};
	MouseRotateWrapper.prototype.off = function off() {
	    var element = this.element;
	    DOM.removeEventListener(element, 'mousedown', this.mousedown);
	    DOM.removeEventListener(element, 'touchstart', this.touchstart, { passive: false });
	    DOM.removeEventListener(element, 'touchmove', this.touchmove);
	    DOM.removeEventListener(element, 'touchend', this.touchend);
	    DOM.removeEventListener(element, 'touchcancel', this.reset);
	    this.offTemp();
	};
	MouseRotateWrapper.prototype.offTemp = function offTemp() {
	    DOM.enableDrag();
	    DOM.removeEventListener(performance.window, 'mousemove', this.mousemove);
	    DOM.removeEventListener(performance.window, 'mouseup', this.mouseup);
	};
	MouseRotateWrapper.prototype.mousedown = function mousedown(e) {
	    this.down(performance.extend({}, e, {
	        ctrlKey: true,
	        preventDefault: function () {
	            return e.preventDefault();
	        }
	    }), DOM.mousePos(this.element, e));
	    DOM.addEventListener(performance.window, 'mousemove', this.mousemove);
	    DOM.addEventListener(performance.window, 'mouseup', this.mouseup);
	};
	MouseRotateWrapper.prototype.mousemove = function mousemove(e) {
	    this.move(e, DOM.mousePos(this.element, e));
	};
	MouseRotateWrapper.prototype.mouseup = function mouseup(e) {
	    this.mouseRotate.mouseupWindow(e);
	    if (this.mousePitch) {
	        this.mousePitch.mouseupWindow(e);
	    }
	    this.offTemp();
	};
	MouseRotateWrapper.prototype.touchstart = function touchstart(e) {
	    if (e.targetTouches.length !== 1) {
	        this.reset();
	    } else {
	        this._startPos = this._lastPos = DOM.touchPos(this.element, e.targetTouches)[0];
	        this.down({
	            type: 'mousedown',
	            button: 0,
	            ctrlKey: true,
	            preventDefault: function () {
	                return e.preventDefault();
	            }
	        }, this._startPos);
	    }
	};
	MouseRotateWrapper.prototype.touchmove = function touchmove(e) {
	    if (e.targetTouches.length !== 1) {
	        this.reset();
	    } else {
	        this._lastPos = DOM.touchPos(this.element, e.targetTouches)[0];
	        this.move({
	            preventDefault: function () {
	                return e.preventDefault();
	            }
	        }, this._lastPos);
	    }
	};
	MouseRotateWrapper.prototype.touchend = function touchend(e) {
	    if (e.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance) {
	        this.element.click();
	    }
	    this.reset();
	};
	MouseRotateWrapper.prototype.reset = function reset() {
	    this.mouseRotate.reset();
	    if (this.mousePitch) {
	        this.mousePitch.reset();
	    }
	    delete this._startPos;
	    delete this._lastPos;
	    this.offTemp();
	};

	function smartWrap (lngLat, priorPos, transform) {
	    lngLat = new performance.LngLat(lngLat.lng, lngLat.lat);
	    if (priorPos) {
	        var left = new performance.LngLat(lngLat.lng - 360, lngLat.lat);
	        var right = new performance.LngLat(lngLat.lng + 360, lngLat.lat);
	        var delta = transform.locationPoint(lngLat).distSqr(priorPos);
	        if (transform.locationPoint(left).distSqr(priorPos) < delta) {
	            lngLat = left;
	        } else if (transform.locationPoint(right).distSqr(priorPos) < delta) {
	            lngLat = right;
	        }
	    }
	    while (Math.abs(lngLat.lng - transform.center.lng) > 180) {
	        var pos = transform.locationPoint(lngLat);
	        if (pos.x >= 0 && pos.y >= 0 && pos.x <= transform.width && pos.y <= transform.height) {
	            break;
	        }
	        if (lngLat.lng > transform.center.lng) {
	            lngLat.lng -= 360;
	        } else {
	            lngLat.lng += 360;
	        }
	    }
	    return lngLat;
	}

	var anchorTranslate = {
	    'center': 'translate(-50%,-50%)',
	    'top': 'translate(-50%,0)',
	    'top-left': 'translate(0,0)',
	    'top-right': 'translate(-100%,0)',
	    'bottom': 'translate(-50%,-100%)',
	    'bottom-left': 'translate(0,-100%)',
	    'bottom-right': 'translate(-100%,-100%)',
	    'left': 'translate(0,-50%)',
	    'right': 'translate(-100%,-50%)'
	};
	function applyAnchorClass(element, anchor, prefix) {
	    var classList = element.classList;
	    for (var key in anchorTranslate) {
	        classList.remove('mapboxgl-' + prefix + '-anchor-' + key);
	    }
	    classList.add('mapboxgl-' + prefix + '-anchor-' + anchor);
	}

	var Marker = function (Evented) {
	    function Marker(options, legacyOptions) {
	        Evented.call(this);
	        if (options instanceof performance.window.HTMLElement || legacyOptions) {
	            options = performance.extend({ element: options }, legacyOptions);
	        }
	        performance.bindAll([
	            '_update',
	            '_onMove',
	            '_onUp',
	            '_addDragHandler',
	            '_onMapClick',
	            '_onKeyPress'
	        ], this);
	        this._anchor = options && options.anchor || 'center';
	        this._color = options && options.color || '#3FB1CE';
	        this._scale = options && options.scale || 1;
	        this._draggable = options && options.draggable || false;
	        this._clickTolerance = options && options.clickTolerance || 0;
	        this._isDragging = false;
	        this._state = 'inactive';
	        this._rotation = options && options.rotation || 0;
	        this._rotationAlignment = options && options.rotationAlignment || 'auto';
	        this._pitchAlignment = options && options.pitchAlignment && options.pitchAlignment !== 'auto' ? options.pitchAlignment : this._rotationAlignment;
	        if (!options || !options.element) {
	            this._defaultMarker = true;
	            this._element = DOM.create('div');
	            this._element.setAttribute('aria-label', 'Map marker');
	            var svg = DOM.createNS('http://www.w3.org/2000/svg', 'svg');
	            var defaultHeight = 41;
	            var defaultWidth = 27;
	            svg.setAttributeNS(null, 'display', 'block');
	            svg.setAttributeNS(null, 'height', defaultHeight + 'px');
	            svg.setAttributeNS(null, 'width', defaultWidth + 'px');
	            svg.setAttributeNS(null, 'viewBox', '0 0 ' + defaultWidth + ' ' + defaultHeight);
	            var markerLarge = DOM.createNS('http://www.w3.org/2000/svg', 'g');
	            markerLarge.setAttributeNS(null, 'stroke', 'none');
	            markerLarge.setAttributeNS(null, 'stroke-width', '1');
	            markerLarge.setAttributeNS(null, 'fill', 'none');
	            markerLarge.setAttributeNS(null, 'fill-rule', 'evenodd');
	            var page1 = DOM.createNS('http://www.w3.org/2000/svg', 'g');
	            page1.setAttributeNS(null, 'fill-rule', 'nonzero');
	            var shadow = DOM.createNS('http://www.w3.org/2000/svg', 'g');
	            shadow.setAttributeNS(null, 'transform', 'translate(3.0, 29.0)');
	            shadow.setAttributeNS(null, 'fill', '#000000');
	            var ellipses = [
	                {
	                    'rx': '10.5',
	                    'ry': '5.25002273'
	                },
	                {
	                    'rx': '10.5',
	                    'ry': '5.25002273'
	                },
	                {
	                    'rx': '9.5',
	                    'ry': '4.77275007'
	                },
	                {
	                    'rx': '8.5',
	                    'ry': '4.29549936'
	                },
	                {
	                    'rx': '7.5',
	                    'ry': '3.81822308'
	                },
	                {
	                    'rx': '6.5',
	                    'ry': '3.34094679'
	                },
	                {
	                    'rx': '5.5',
	                    'ry': '2.86367051'
	                },
	                {
	                    'rx': '4.5',
	                    'ry': '2.38636864'
	                }
	            ];
	            for (var i = 0, list = ellipses; i < list.length; i += 1) {
	                var data = list[i];
	                var ellipse = DOM.createNS('http://www.w3.org/2000/svg', 'ellipse');
	                ellipse.setAttributeNS(null, 'opacity', '0.04');
	                ellipse.setAttributeNS(null, 'cx', '10.5');
	                ellipse.setAttributeNS(null, 'cy', '5.80029008');
	                ellipse.setAttributeNS(null, 'rx', data['rx']);
	                ellipse.setAttributeNS(null, 'ry', data['ry']);
	                shadow.appendChild(ellipse);
	            }
	            var background = DOM.createNS('http://www.w3.org/2000/svg', 'g');
	            background.setAttributeNS(null, 'fill', this._color);
	            var bgPath = DOM.createNS('http://www.w3.org/2000/svg', 'path');
	            bgPath.setAttributeNS(null, 'd', 'M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z');
	            background.appendChild(bgPath);
	            var border = DOM.createNS('http://www.w3.org/2000/svg', 'g');
	            border.setAttributeNS(null, 'opacity', '0.25');
	            border.setAttributeNS(null, 'fill', '#000000');
	            var borderPath = DOM.createNS('http://www.w3.org/2000/svg', 'path');
	            borderPath.setAttributeNS(null, 'd', 'M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z');
	            border.appendChild(borderPath);
	            var maki = DOM.createNS('http://www.w3.org/2000/svg', 'g');
	            maki.setAttributeNS(null, 'transform', 'translate(6.0, 7.0)');
	            maki.setAttributeNS(null, 'fill', '#FFFFFF');
	            var circleContainer = DOM.createNS('http://www.w3.org/2000/svg', 'g');
	            circleContainer.setAttributeNS(null, 'transform', 'translate(8.0, 8.0)');
	            var circle1 = DOM.createNS('http://www.w3.org/2000/svg', 'circle');
	            circle1.setAttributeNS(null, 'fill', '#000000');
	            circle1.setAttributeNS(null, 'opacity', '0.25');
	            circle1.setAttributeNS(null, 'cx', '5.5');
	            circle1.setAttributeNS(null, 'cy', '5.5');
	            circle1.setAttributeNS(null, 'r', '5.4999962');
	            var circle2 = DOM.createNS('http://www.w3.org/2000/svg', 'circle');
	            circle2.setAttributeNS(null, 'fill', '#FFFFFF');
	            circle2.setAttributeNS(null, 'cx', '5.5');
	            circle2.setAttributeNS(null, 'cy', '5.5');
	            circle2.setAttributeNS(null, 'r', '5.4999962');
	            circleContainer.appendChild(circle1);
	            circleContainer.appendChild(circle2);
	            page1.appendChild(shadow);
	            page1.appendChild(background);
	            page1.appendChild(border);
	            page1.appendChild(maki);
	            page1.appendChild(circleContainer);
	            svg.appendChild(page1);
	            svg.setAttributeNS(null, 'height', defaultHeight * this._scale + 'px');
	            svg.setAttributeNS(null, 'width', defaultWidth * this._scale + 'px');
	            this._element.appendChild(svg);
	            this._offset = performance.Point.convert(options && options.offset || [
	                0,
	                -14
	            ]);
	        } else {
	            this._element = options.element;
	            this._offset = performance.Point.convert(options && options.offset || [
	                0,
	                0
	            ]);
	        }
	        this._element.classList.add('mapboxgl-marker');
	        this._element.addEventListener('dragstart', function (e) {
	            e.preventDefault();
	        });
	        this._element.addEventListener('mousedown', function (e) {
	            e.preventDefault();
	        });
	        applyAnchorClass(this._element, this._anchor, 'marker');
	        this._popup = null;
	    }
	    if (Evented)
	        Marker.__proto__ = Evented;
	    Marker.prototype = Object.create(Evented && Evented.prototype);
	    Marker.prototype.constructor = Marker;
	    Marker.prototype.addTo = function addTo(map) {
	        this.remove();
	        this._map = map;
	        map.getCanvasContainer().appendChild(this._element);
	        map.on('move', this._update);
	        map.on('moveend', this._update);
	        this.setDraggable(this._draggable);
	        this._update();
	        this._map.on('click', this._onMapClick);
	        return this;
	    };
	    Marker.prototype.remove = function remove() {
	        if (this._map) {
	            this._map.off('click', this._onMapClick);
	            this._map.off('move', this._update);
	            this._map.off('moveend', this._update);
	            this._map.off('mousedown', this._addDragHandler);
	            this._map.off('touchstart', this._addDragHandler);
	            this._map.off('mouseup', this._onUp);
	            this._map.off('touchend', this._onUp);
	            this._map.off('mousemove', this._onMove);
	            this._map.off('touchmove', this._onMove);
	            delete this._map;
	        }
	        DOM.remove(this._element);
	        if (this._popup) {
	            this._popup.remove();
	        }
	        return this;
	    };
	    Marker.prototype.getLngLat = function getLngLat() {
	        return this._lngLat;
	    };
	    Marker.prototype.setLngLat = function setLngLat(lnglat) {
	        this._lngLat = performance.LngLat.convert(lnglat);
	        this._pos = null;
	        if (this._popup) {
	            this._popup.setLngLat(this._lngLat);
	        }
	        this._update();
	        return this;
	    };
	    Marker.prototype.getElement = function getElement() {
	        return this._element;
	    };
	    Marker.prototype.setPopup = function setPopup(popup) {
	        if (this._popup) {
	            this._popup.remove();
	            this._popup = null;
	            this._element.removeEventListener('keypress', this._onKeyPress);
	            if (!this._originalTabIndex) {
	                this._element.removeAttribute('tabindex');
	            }
	        }
	        if (popup) {
	            if (!('offset' in popup.options)) {
	                var markerHeight = 41 - 5.8 / 2;
	                var markerRadius = 13.5;
	                var linearOffset = Math.sqrt(Math.pow(markerRadius, 2) / 2);
	                popup.options.offset = this._defaultMarker ? {
	                    'top': [
	                        0,
	                        0
	                    ],
	                    'top-left': [
	                        0,
	                        0
	                    ],
	                    'top-right': [
	                        0,
	                        0
	                    ],
	                    'bottom': [
	                        0,
	                        -markerHeight
	                    ],
	                    'bottom-left': [
	                        linearOffset,
	                        (markerHeight - markerRadius + linearOffset) * -1
	                    ],
	                    'bottom-right': [
	                        -linearOffset,
	                        (markerHeight - markerRadius + linearOffset) * -1
	                    ],
	                    'left': [
	                        markerRadius,
	                        (markerHeight - markerRadius) * -1
	                    ],
	                    'right': [
	                        -markerRadius,
	                        (markerHeight - markerRadius) * -1
	                    ]
	                } : this._offset;
	            }
	            this._popup = popup;
	            if (this._lngLat) {
	                this._popup.setLngLat(this._lngLat);
	            }
	            this._originalTabIndex = this._element.getAttribute('tabindex');
	            if (!this._originalTabIndex) {
	                this._element.setAttribute('tabindex', '0');
	            }
	            this._element.addEventListener('keypress', this._onKeyPress);
	        }
	        return this;
	    };
	    Marker.prototype._onKeyPress = function _onKeyPress(e) {
	        var code = e.code;
	        var legacyCode = e.charCode || e.keyCode;
	        if (code === 'Space' || code === 'Enter' || legacyCode === 32 || legacyCode === 13) {
	            this.togglePopup();
	        }
	    };
	    Marker.prototype._onMapClick = function _onMapClick(e) {
	        var targetElement = e.originalEvent.target;
	        var element = this._element;
	        if (this._popup && (targetElement === element || element.contains(targetElement))) {
	            this.togglePopup();
	        }
	    };
	    Marker.prototype.getPopup = function getPopup() {
	        return this._popup;
	    };
	    Marker.prototype.togglePopup = function togglePopup() {
	        var popup = this._popup;
	        if (!popup) {
	            return this;
	        } else if (popup.isOpen()) {
	            popup.remove();
	        } else {
	            popup.addTo(this._map);
	        }
	        return this;
	    };
	    Marker.prototype._update = function _update(e) {
	        if (!this._map) {
	            return;
	        }
	        if (this._map.transform.renderWorldCopies) {
	            this._lngLat = smartWrap(this._lngLat, this._pos, this._map.transform);
	        }
	        this._pos = this._map.project(this._lngLat)._add(this._offset);
	        var rotation = '';
	        if (this._rotationAlignment === 'viewport' || this._rotationAlignment === 'auto') {
	            rotation = 'rotateZ(' + this._rotation + 'deg)';
	        } else if (this._rotationAlignment === 'map') {
	            rotation = 'rotateZ(' + (this._rotation - this._map.getBearing()) + 'deg)';
	        }
	        var pitch = '';
	        if (this._pitchAlignment === 'viewport' || this._pitchAlignment === 'auto') {
	            pitch = 'rotateX(0deg)';
	        } else if (this._pitchAlignment === 'map') {
	            pitch = 'rotateX(' + this._map.getPitch() + 'deg)';
	        }
	        if (!e || e.type === 'moveend') {
	            this._pos = this._pos.round();
	        }
	        DOM.setTransform(this._element, anchorTranslate[this._anchor] + ' translate(' + this._pos.x + 'px, ' + this._pos.y + 'px) ' + pitch + ' ' + rotation);
	    };
	    Marker.prototype.getOffset = function getOffset() {
	        return this._offset;
	    };
	    Marker.prototype.setOffset = function setOffset(offset) {
	        this._offset = performance.Point.convert(offset);
	        this._update();
	        return this;
	    };
	    Marker.prototype._onMove = function _onMove(e) {
	        if (!this._isDragging) {
	            var clickTolerance = this._clickTolerance || this._map._clickTolerance;
	            this._isDragging = e.point.dist(this._pointerdownPos) >= clickTolerance;
	        }
	        if (!this._isDragging) {
	            return;
	        }
	        this._pos = e.point.sub(this._positionDelta);
	        this._lngLat = this._map.unproject(this._pos);
	        this.setLngLat(this._lngLat);
	        this._element.style.pointerEvents = 'none';
	        if (this._state === 'pending') {
	            this._state = 'active';
	            this.fire(new performance.Event('dragstart'));
	        }
	        this.fire(new performance.Event('drag'));
	    };
	    Marker.prototype._onUp = function _onUp() {
	        this._element.style.pointerEvents = 'auto';
	        this._positionDelta = null;
	        this._pointerdownPos = null;
	        this._isDragging = false;
	        this._map.off('mousemove', this._onMove);
	        this._map.off('touchmove', this._onMove);
	        if (this._state === 'active') {
	            this.fire(new performance.Event('dragend'));
	        }
	        this._state = 'inactive';
	    };
	    Marker.prototype._addDragHandler = function _addDragHandler(e) {
	        if (this._element.contains(e.originalEvent.target)) {
	            e.preventDefault();
	            this._positionDelta = e.point.sub(this._pos).add(this._offset);
	            this._pointerdownPos = e.point;
	            this._state = 'pending';
	            this._map.on('mousemove', this._onMove);
	            this._map.on('touchmove', this._onMove);
	            this._map.once('mouseup', this._onUp);
	            this._map.once('touchend', this._onUp);
	        }
	    };
	    Marker.prototype.setDraggable = function setDraggable(shouldBeDraggable) {
	        this._draggable = !!shouldBeDraggable;
	        if (this._map) {
	            if (shouldBeDraggable) {
	                this._map.on('mousedown', this._addDragHandler);
	                this._map.on('touchstart', this._addDragHandler);
	            } else {
	                this._map.off('mousedown', this._addDragHandler);
	                this._map.off('touchstart', this._addDragHandler);
	            }
	        }
	        return this;
	    };
	    Marker.prototype.isDraggable = function isDraggable() {
	        return this._draggable;
	    };
	    Marker.prototype.setRotation = function setRotation(rotation) {
	        this._rotation = rotation || 0;
	        this._update();
	        return this;
	    };
	    Marker.prototype.getRotation = function getRotation() {
	        return this._rotation;
	    };
	    Marker.prototype.setRotationAlignment = function setRotationAlignment(alignment) {
	        this._rotationAlignment = alignment || 'auto';
	        this._update();
	        return this;
	    };
	    Marker.prototype.getRotationAlignment = function getRotationAlignment() {
	        return this._rotationAlignment;
	    };
	    Marker.prototype.setPitchAlignment = function setPitchAlignment(alignment) {
	        this._pitchAlignment = alignment && alignment !== 'auto' ? alignment : this._rotationAlignment;
	        this._update();
	        return this;
	    };
	    Marker.prototype.getPitchAlignment = function getPitchAlignment() {
	        return this._pitchAlignment;
	    };
	    return Marker;
	}(performance.Evented);

	var defaultOptions$3 = {
	    positionOptions: {
	        enableHighAccuracy: false,
	        maximumAge: 0,
	        timeout: 6000
	    },
	    fitBoundsOptions: { maxZoom: 15 },
	    trackUserLocation: false,
	    showAccuracyCircle: true,
	    showUserLocation: true
	};
	var supportsGeolocation;
	function checkGeolocationSupport(callback) {
	    if (supportsGeolocation !== undefined) {
	        callback(supportsGeolocation);
	    } else if (performance.window.navigator.permissions !== undefined) {
	        performance.window.navigator.permissions.query({ name: 'geolocation' }).then(function (p) {
	            supportsGeolocation = p.state !== 'denied';
	            callback(supportsGeolocation);
	        });
	    } else {
	        supportsGeolocation = !!performance.window.navigator.geolocation;
	        callback(supportsGeolocation);
	    }
	}
	var numberOfWatches = 0;
	var noTimeout = false;
	var GeolocateControl = function (Evented) {
	    function GeolocateControl(options) {
	        Evented.call(this);
	        this.options = performance.extend({}, defaultOptions$3, options);
	        performance.bindAll([
	            '_onSuccess',
	            '_onError',
	            '_onZoom',
	            '_finish',
	            '_setupUI',
	            '_updateCamera',
	            '_updateMarker'
	        ], this);
	    }
	    if (Evented)
	        GeolocateControl.__proto__ = Evented;
	    GeolocateControl.prototype = Object.create(Evented && Evented.prototype);
	    GeolocateControl.prototype.constructor = GeolocateControl;
	    GeolocateControl.prototype.onAdd = function onAdd(map) {
	        this._map = map;
	        this._container = DOM.create('div', 'mapboxgl-ctrl mapboxgl-ctrl-group');
	        checkGeolocationSupport(this._setupUI);
	        return this._container;
	    };
	    GeolocateControl.prototype.onRemove = function onRemove() {
	        if (this._geolocationWatchID !== undefined) {
	            performance.window.navigator.geolocation.clearWatch(this._geolocationWatchID);
	            this._geolocationWatchID = undefined;
	        }
	        if (this.options.showUserLocation && this._userLocationDotMarker) {
	            this._userLocationDotMarker.remove();
	        }
	        if (this.options.showAccuracyCircle && this._accuracyCircleMarker) {
	            this._accuracyCircleMarker.remove();
	        }
	        DOM.remove(this._container);
	        this._map.off('zoom', this._onZoom);
	        this._map = undefined;
	        numberOfWatches = 0;
	        noTimeout = false;
	    };
	    GeolocateControl.prototype._isOutOfMapMaxBounds = function _isOutOfMapMaxBounds(position) {
	        var bounds = this._map.getMaxBounds();
	        var coordinates = position.coords;
	        return bounds && (coordinates.longitude < bounds.getWest() || coordinates.longitude > bounds.getEast() || coordinates.latitude < bounds.getSouth() || coordinates.latitude > bounds.getNorth());
	    };
	    GeolocateControl.prototype._setErrorState = function _setErrorState() {
	        switch (this._watchState) {
	        case 'WAITING_ACTIVE':
	            this._watchState = 'ACTIVE_ERROR';
	            this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');
	            this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active-error');
	            break;
	        case 'ACTIVE_LOCK':
	            this._watchState = 'ACTIVE_ERROR';
	            this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');
	            this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active-error');
	            this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');
	            break;
	        case 'BACKGROUND':
	            this._watchState = 'BACKGROUND_ERROR';
	            this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background');
	            this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background-error');
	            this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');
	            break;
	        }
	    };
	    GeolocateControl.prototype._onSuccess = function _onSuccess(position) {
	        if (!this._map) {
	            return;
	        }
	        if (this._isOutOfMapMaxBounds(position)) {
	            this._setErrorState();
	            this.fire(new performance.Event('outofmaxbounds', position));
	            this._updateMarker();
	            this._finish();
	            return;
	        }
	        if (this.options.trackUserLocation) {
	            this._lastKnownPosition = position;
	            switch (this._watchState) {
	            case 'WAITING_ACTIVE':
	            case 'ACTIVE_LOCK':
	            case 'ACTIVE_ERROR':
	                this._watchState = 'ACTIVE_LOCK';
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active-error');
	                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active');
	                break;
	            case 'BACKGROUND':
	            case 'BACKGROUND_ERROR':
	                this._watchState = 'BACKGROUND';
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background-error');
	                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background');
	                break;
	            }
	        }
	        if (this.options.showUserLocation && this._watchState !== 'OFF') {
	            this._updateMarker(position);
	        }
	        if (!this.options.trackUserLocation || this._watchState === 'ACTIVE_LOCK') {
	            this._updateCamera(position);
	        }
	        if (this.options.showUserLocation) {
	            this._dotElement.classList.remove('mapboxgl-user-location-dot-stale');
	        }
	        this.fire(new performance.Event('geolocate', position));
	        this._finish();
	    };
	    GeolocateControl.prototype._updateCamera = function _updateCamera(position) {
	        var center = new performance.LngLat(position.coords.longitude, position.coords.latitude);
	        var radius = position.coords.accuracy;
	        var bearing = this._map.getBearing();
	        var options = performance.extend({ bearing: bearing }, this.options.fitBoundsOptions);
	        this._map.fitBounds(center.toBounds(radius), options, { geolocateSource: true });
	    };
	    GeolocateControl.prototype._updateMarker = function _updateMarker(position) {
	        if (position) {
	            var center = new performance.LngLat(position.coords.longitude, position.coords.latitude);
	            this._accuracyCircleMarker.setLngLat(center).addTo(this._map);
	            this._userLocationDotMarker.setLngLat(center).addTo(this._map);
	            this._accuracy = position.coords.accuracy;
	            if (this.options.showUserLocation && this.options.showAccuracyCircle) {
	                this._updateCircleRadius();
	            }
	        } else {
	            this._userLocationDotMarker.remove();
	            this._accuracyCircleMarker.remove();
	        }
	    };
	    GeolocateControl.prototype._updateCircleRadius = function _updateCircleRadius() {
	        var y = this._map._container.clientHeight / 2;
	        var a = this._map.unproject([
	            0,
	            y
	        ]);
	        var b = this._map.unproject([
	            1,
	            y
	        ]);
	        var metersPerPixel = a.distanceTo(b);
	        var circleDiameter = Math.ceil(2 * this._accuracy / metersPerPixel);
	        this._circleElement.style.width = circleDiameter + 'px';
	        this._circleElement.style.height = circleDiameter + 'px';
	    };
	    GeolocateControl.prototype._onZoom = function _onZoom() {
	        if (this.options.showUserLocation && this.options.showAccuracyCircle) {
	            this._updateCircleRadius();
	        }
	    };
	    GeolocateControl.prototype._onError = function _onError(error) {
	        if (!this._map) {
	            return;
	        }
	        if (this.options.trackUserLocation) {
	            if (error.code === 1) {
	                this._watchState = 'OFF';
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active-error');
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background');
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background-error');
	                this._geolocateButton.disabled = true;
	                var title = this._map._getUIString('GeolocateControl.LocationNotAvailable');
	                this._geolocateButton.title = title;
	                this._geolocateButton.setAttribute('aria-label', title);
	                if (this._geolocationWatchID !== undefined) {
	                    this._clearWatch();
	                }
	            } else if (error.code === 3 && noTimeout) {
	                return;
	            } else {
	                this._setErrorState();
	            }
	        }
	        if (this._watchState !== 'OFF' && this.options.showUserLocation) {
	            this._dotElement.classList.add('mapboxgl-user-location-dot-stale');
	        }
	        this.fire(new performance.Event('error', error));
	        this._finish();
	    };
	    GeolocateControl.prototype._finish = function _finish() {
	        if (this._timeoutId) {
	            clearTimeout(this._timeoutId);
	        }
	        this._timeoutId = undefined;
	    };
	    GeolocateControl.prototype._setupUI = function _setupUI(supported) {
	        var this$1 = this;
	        this._container.addEventListener('contextmenu', function (e) {
	            return e.preventDefault();
	        });
	        this._geolocateButton = DOM.create('button', 'mapboxgl-ctrl-geolocate', this._container);
	        DOM.create('span', 'mapboxgl-ctrl-icon', this._geolocateButton).setAttribute('aria-hidden', true);
	        this._geolocateButton.type = 'button';
	        if (supported === false) {
	            performance.warnOnce('Geolocation support is not available so the GeolocateControl will be disabled.');
	            var title = this._map._getUIString('GeolocateControl.LocationNotAvailable');
	            this._geolocateButton.disabled = true;
	            this._geolocateButton.title = title;
	            this._geolocateButton.setAttribute('aria-label', title);
	        } else {
	            var title$1 = this._map._getUIString('GeolocateControl.FindMyLocation');
	            this._geolocateButton.title = title$1;
	            this._geolocateButton.setAttribute('aria-label', title$1);
	        }
	        if (this.options.trackUserLocation) {
	            this._geolocateButton.setAttribute('aria-pressed', 'false');
	            this._watchState = 'OFF';
	        }
	        if (this.options.showUserLocation) {
	            this._dotElement = DOM.create('div', 'mapboxgl-user-location-dot');
	            this._userLocationDotMarker = new Marker(this._dotElement);
	            this._circleElement = DOM.create('div', 'mapboxgl-user-location-accuracy-circle');
	            this._accuracyCircleMarker = new Marker({
	                element: this._circleElement,
	                pitchAlignment: 'map'
	            });
	            if (this.options.trackUserLocation) {
	                this._watchState = 'OFF';
	            }
	            this._map.on('zoom', this._onZoom);
	        }
	        this._geolocateButton.addEventListener('click', this.trigger.bind(this));
	        this._setup = true;
	        if (this.options.trackUserLocation) {
	            this._map.on('movestart', function (event) {
	                var fromResize = event.originalEvent && event.originalEvent.type === 'resize';
	                if (!event.geolocateSource && this$1._watchState === 'ACTIVE_LOCK' && !fromResize) {
	                    this$1._watchState = 'BACKGROUND';
	                    this$1._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background');
	                    this$1._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');
	                    this$1.fire(new performance.Event('trackuserlocationend'));
	                }
	            });
	        }
	    };
	    GeolocateControl.prototype.trigger = function trigger() {
	        if (!this._setup) {
	            performance.warnOnce('Geolocate control triggered before added to a map');
	            return false;
	        }
	        if (this.options.trackUserLocation) {
	            switch (this._watchState) {
	            case 'OFF':
	                this._watchState = 'WAITING_ACTIVE';
	                this.fire(new performance.Event('trackuserlocationstart'));
	                break;
	            case 'WAITING_ACTIVE':
	            case 'ACTIVE_LOCK':
	            case 'ACTIVE_ERROR':
	            case 'BACKGROUND_ERROR':
	                numberOfWatches--;
	                noTimeout = false;
	                this._watchState = 'OFF';
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active-error');
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background');
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background-error');
	                this.fire(new performance.Event('trackuserlocationend'));
	                break;
	            case 'BACKGROUND':
	                this._watchState = 'ACTIVE_LOCK';
	                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background');
	                if (this._lastKnownPosition) {
	                    this._updateCamera(this._lastKnownPosition);
	                }
	                this.fire(new performance.Event('trackuserlocationstart'));
	                break;
	            }
	            switch (this._watchState) {
	            case 'WAITING_ACTIVE':
	                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');
	                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active');
	                break;
	            case 'ACTIVE_LOCK':
	                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active');
	                break;
	            case 'ACTIVE_ERROR':
	                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');
	                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active-error');
	                break;
	            case 'BACKGROUND':
	                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background');
	                break;
	            case 'BACKGROUND_ERROR':
	                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');
	                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background-error');
	                break;
	            }
	            if (this._watchState === 'OFF' && this._geolocationWatchID !== undefined) {
	                this._clearWatch();
	            } else if (this._geolocationWatchID === undefined) {
	                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');
	                this._geolocateButton.setAttribute('aria-pressed', 'true');
	                numberOfWatches++;
	                var positionOptions;
	                if (numberOfWatches > 1) {
	                    positionOptions = {
	                        maximumAge: 600000,
	                        timeout: 0
	                    };
	                    noTimeout = true;
	                } else {
	                    positionOptions = this.options.positionOptions;
	                    noTimeout = false;
	                }
	                this._geolocationWatchID = performance.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, positionOptions);
	            }
	        } else {
	            performance.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions);
	            this._timeoutId = setTimeout(this._finish, 10000);
	        }
	        return true;
	    };
	    GeolocateControl.prototype._clearWatch = function _clearWatch() {
	        performance.window.navigator.geolocation.clearWatch(this._geolocationWatchID);
	        this._geolocationWatchID = undefined;
	        this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');
	        this._geolocateButton.setAttribute('aria-pressed', 'false');
	        if (this.options.showUserLocation) {
	            this._updateMarker(null);
	        }
	    };
	    return GeolocateControl;
	}(performance.Evented);

	var defaultOptions$4 = {
	    maxWidth: 100,
	    unit: 'metric'
	};
	var ScaleControl = function ScaleControl(options) {
	    this.options = performance.extend({}, defaultOptions$4, options);
	    performance.bindAll([
	        '_onMove',
	        'setUnit'
	    ], this);
	};
	ScaleControl.prototype.getDefaultPosition = function getDefaultPosition() {
	    return 'bottom-left';
	};
	ScaleControl.prototype._onMove = function _onMove() {
	    updateScale(this._map, this._container, this.options);
	};
	ScaleControl.prototype.onAdd = function onAdd(map) {
	    this._map = map;
	    this._container = DOM.create('div', 'mapboxgl-ctrl mapboxgl-ctrl-scale', map.getContainer());
	    this._map.on('move', this._onMove);
	    this._onMove();
	    return this._container;
	};
	ScaleControl.prototype.onRemove = function onRemove() {
	    DOM.remove(this._container);
	    this._map.off('move', this._onMove);
	    this._map = undefined;
	};
	ScaleControl.prototype.setUnit = function setUnit(unit) {
	    this.options.unit = unit;
	    updateScale(this._map, this._container, this.options);
	};
	function updateScale(map, container, options) {
	    var maxWidth = options && options.maxWidth || 100;
	    var y = map._container.clientHeight / 2;
	    var left = map.unproject([
	        0,
	        y
	    ]);
	    var right = map.unproject([
	        maxWidth,
	        y
	    ]);
	    var maxMeters = left.distanceTo(right);
	    if (options && options.unit === 'imperial') {
	        var maxFeet = 3.2808 * maxMeters;
	        if (maxFeet > 5280) {
	            var maxMiles = maxFeet / 5280;
	            setScale(container, maxWidth, maxMiles, map._getUIString('ScaleControl.Miles'));
	        } else {
	            setScale(container, maxWidth, maxFeet, map._getUIString('ScaleControl.Feet'));
	        }
	    } else if (options && options.unit === 'nautical') {
	        var maxNauticals = maxMeters / 1852;
	        setScale(container, maxWidth, maxNauticals, map._getUIString('ScaleControl.NauticalMiles'));
	    } else if (maxMeters >= 1000) {
	        setScale(container, maxWidth, maxMeters / 1000, map._getUIString('ScaleControl.Kilometers'));
	    } else {
	        setScale(container, maxWidth, maxMeters, map._getUIString('ScaleControl.Meters'));
	    }
	}
	function setScale(container, maxWidth, maxDistance, unit) {
	    var distance = getRoundNum(maxDistance);
	    var ratio = distance / maxDistance;
	    container.style.width = maxWidth * ratio + 'px';
	    container.innerHTML = distance + '&nbsp;' + unit;
	}
	function getDecimalRoundNum(d) {
	    var multiplier = Math.pow(10, Math.ceil(-Math.log(d) / Math.LN10));
	    return Math.round(d * multiplier) / multiplier;
	}
	function getRoundNum(num) {
	    var pow10 = Math.pow(10, ('' + Math.floor(num)).length - 1);
	    var d = num / pow10;
	    d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : d >= 1 ? 1 : getDecimalRoundNum(d);
	    return pow10 * d;
	}

	var FullscreenControl = function FullscreenControl(options) {
	    this._fullscreen = false;
	    if (options && options.container) {
	        if (options.container instanceof performance.window.HTMLElement) {
	            this._container = options.container;
	        } else {
	            performance.warnOnce('Full screen control \'container\' must be a DOM element.');
	        }
	    }
	    performance.bindAll([
	        '_onClickFullscreen',
	        '_changeIcon'
	    ], this);
	    if ('onfullscreenchange' in performance.window.document) {
	        this._fullscreenchange = 'fullscreenchange';
	    } else if ('onmozfullscreenchange' in performance.window.document) {
	        this._fullscreenchange = 'mozfullscreenchange';
	    } else if ('onwebkitfullscreenchange' in performance.window.document) {
	        this._fullscreenchange = 'webkitfullscreenchange';
	    } else if ('onmsfullscreenchange' in performance.window.document) {
	        this._fullscreenchange = 'MSFullscreenChange';
	    }
	};
	FullscreenControl.prototype.onAdd = function onAdd(map) {
	    this._map = map;
	    if (!this._container) {
	        this._container = this._map.getContainer();
	    }
	    this._controlContainer = DOM.create('div', 'mapboxgl-ctrl mapboxgl-ctrl-group');
	    if (this._checkFullscreenSupport()) {
	        this._setupUI();
	    } else {
	        this._controlContainer.style.display = 'none';
	        performance.warnOnce('This device does not support fullscreen mode.');
	    }
	    return this._controlContainer;
	};
	FullscreenControl.prototype.onRemove = function onRemove() {
	    DOM.remove(this._controlContainer);
	    this._map = null;
	    performance.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
	};
	FullscreenControl.prototype._checkFullscreenSupport = function _checkFullscreenSupport() {
	    return !!(performance.window.document.fullscreenEnabled || performance.window.document.mozFullScreenEnabled || performance.window.document.msFullscreenEnabled || performance.window.document.webkitFullscreenEnabled);
	};
	FullscreenControl.prototype._setupUI = function _setupUI() {
	    var button = this._fullscreenButton = DOM.create('button', 'mapboxgl-ctrl-fullscreen', this._controlContainer);
	    DOM.create('span', 'mapboxgl-ctrl-icon', button).setAttribute('aria-hidden', true);
	    button.type = 'button';
	    this._updateTitle();
	    this._fullscreenButton.addEventListener('click', this._onClickFullscreen);
	    performance.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
	};
	FullscreenControl.prototype._updateTitle = function _updateTitle() {
	    var title = this._getTitle();
	    this._fullscreenButton.setAttribute('aria-label', title);
	    this._fullscreenButton.title = title;
	};
	FullscreenControl.prototype._getTitle = function _getTitle() {
	    return this._map._getUIString(this._isFullscreen() ? 'FullscreenControl.Exit' : 'FullscreenControl.Enter');
	};
	FullscreenControl.prototype._isFullscreen = function _isFullscreen() {
	    return this._fullscreen;
	};
	FullscreenControl.prototype._changeIcon = function _changeIcon() {
	    var fullscreenElement = performance.window.document.fullscreenElement || performance.window.document.mozFullScreenElement || performance.window.document.webkitFullscreenElement || performance.window.document.msFullscreenElement;
	    if (fullscreenElement === this._container !== this._fullscreen) {
	        this._fullscreen = !this._fullscreen;
	        this._fullscreenButton.classList.toggle('mapboxgl-ctrl-shrink');
	        this._fullscreenButton.classList.toggle('mapboxgl-ctrl-fullscreen');
	        this._updateTitle();
	    }
	};
	FullscreenControl.prototype._onClickFullscreen = function _onClickFullscreen() {
	    if (this._isFullscreen()) {
	        if (performance.window.document.exitFullscreen) {
	            performance.window.document.exitFullscreen();
	        } else if (performance.window.document.mozCancelFullScreen) {
	            performance.window.document.mozCancelFullScreen();
	        } else if (performance.window.document.msExitFullscreen) {
	            performance.window.document.msExitFullscreen();
	        } else if (performance.window.document.webkitCancelFullScreen) {
	            performance.window.document.webkitCancelFullScreen();
	        }
	    } else if (this._container.requestFullscreen) {
	        this._container.requestFullscreen();
	    } else if (this._container.mozRequestFullScreen) {
	        this._container.mozRequestFullScreen();
	    } else if (this._container.msRequestFullscreen) {
	        this._container.msRequestFullscreen();
	    } else if (this._container.webkitRequestFullscreen) {
	        this._container.webkitRequestFullscreen();
	    }
	};

	var defaultOptions$5 = {
	    closeButton: true,
	    closeOnClick: true,
	    focusAfterOpen: true,
	    className: '',
	    maxWidth: '240px'
	};
	var focusQuerySelector = [
	    'a[href]',
	    '[tabindex]:not([tabindex=\'-1\'])',
	    '[contenteditable]:not([contenteditable=\'false\'])',
	    'button:not([disabled])',
	    'input:not([disabled])',
	    'select:not([disabled])',
	    'textarea:not([disabled])'
	].join(', ');
	var Popup = function (Evented) {
	    function Popup(options) {
	        Evented.call(this);
	        this.options = performance.extend(Object.create(defaultOptions$5), options);
	        performance.bindAll([
	            '_update',
	            '_onClose',
	            'remove',
	            '_onMouseMove',
	            '_onMouseUp',
	            '_onDrag'
	        ], this);
	    }
	    if (Evented)
	        Popup.__proto__ = Evented;
	    Popup.prototype = Object.create(Evented && Evented.prototype);
	    Popup.prototype.constructor = Popup;
	    Popup.prototype.addTo = function addTo(map) {
	        if (this._map) {
	            this.remove();
	        }
	        this._map = map;
	        if (this.options.closeOnClick) {
	            this._map.on('click', this._onClose);
	        }
	        if (this.options.closeOnMove) {
	            this._map.on('move', this._onClose);
	        }
	        this._map.on('remove', this.remove);
	        this._update();
	        this._focusFirstElement();
	        if (this._trackPointer) {
	            this._map.on('mousemove', this._onMouseMove);
	            this._map.on('mouseup', this._onMouseUp);
	            if (this._container) {
	                this._container.classList.add('mapboxgl-popup-track-pointer');
	            }
	            this._map._canvasContainer.classList.add('mapboxgl-track-pointer');
	        } else {
	            this._map.on('move', this._update);
	        }
	        this.fire(new performance.Event('open'));
	        return this;
	    };
	    Popup.prototype.isOpen = function isOpen() {
	        return !!this._map;
	    };
	    Popup.prototype.remove = function remove() {
	        if (this._content) {
	            DOM.remove(this._content);
	        }
	        if (this._container) {
	            DOM.remove(this._container);
	            delete this._container;
	        }
	        if (this._map) {
	            this._map.off('move', this._update);
	            this._map.off('move', this._onClose);
	            this._map.off('click', this._onClose);
	            this._map.off('remove', this.remove);
	            this._map.off('mousemove', this._onMouseMove);
	            this._map.off('mouseup', this._onMouseUp);
	            this._map.off('drag', this._onDrag);
	            delete this._map;
	        }
	        this.fire(new performance.Event('close'));
	        return this;
	    };
	    Popup.prototype.getLngLat = function getLngLat() {
	        return this._lngLat;
	    };
	    Popup.prototype.setLngLat = function setLngLat(lnglat) {
	        this._lngLat = performance.LngLat.convert(lnglat);
	        this._pos = null;
	        this._trackPointer = false;
	        this._update();
	        if (this._map) {
	            this._map.on('move', this._update);
	            this._map.off('mousemove', this._onMouseMove);
	            if (this._container) {
	                this._container.classList.remove('mapboxgl-popup-track-pointer');
	            }
	            this._map._canvasContainer.classList.remove('mapboxgl-track-pointer');
	        }
	        return this;
	    };
	    Popup.prototype.trackPointer = function trackPointer() {
	        this._trackPointer = true;
	        this._pos = null;
	        this._update();
	        if (this._map) {
	            this._map.off('move', this._update);
	            this._map.on('mousemove', this._onMouseMove);
	            this._map.on('drag', this._onDrag);
	            if (this._container) {
	                this._container.classList.add('mapboxgl-popup-track-pointer');
	            }
	            this._map._canvasContainer.classList.add('mapboxgl-track-pointer');
	        }
	        return this;
	    };
	    Popup.prototype.getElement = function getElement() {
	        return this._container;
	    };
	    Popup.prototype.setText = function setText(text) {
	        return this.setDOMContent(performance.window.document.createTextNode(text));
	    };
	    Popup.prototype.setHTML = function setHTML(html) {
	        var frag = performance.window.document.createDocumentFragment();
	        var temp = performance.window.document.createElement('body');
	        var child;
	        temp.innerHTML = html;
	        while (true) {
	            child = temp.firstChild;
	            if (!child) {
	                break;
	            }
	            frag.appendChild(child);
	        }
	        return this.setDOMContent(frag);
	    };
	    Popup.prototype.getMaxWidth = function getMaxWidth() {
	        return this._container && this._container.style.maxWidth;
	    };
	    Popup.prototype.setMaxWidth = function setMaxWidth(maxWidth) {
	        this.options.maxWidth = maxWidth;
	        this._update();
	        return this;
	    };
	    Popup.prototype.setDOMContent = function setDOMContent(htmlNode) {
	        if (this._content) {
	            while (this._content.hasChildNodes()) {
	                if (this._content.firstChild) {
	                    this._content.removeChild(this._content.firstChild);
	                }
	            }
	        } else {
	            this._content = DOM.create('div', 'mapboxgl-popup-content', this._container);
	        }
	        this._content.appendChild(htmlNode);
	        this._createCloseButton();
	        this._update();
	        this._focusFirstElement();
	        return this;
	    };
	    Popup.prototype.addClassName = function addClassName(className) {
	        if (this._container) {
	            this._container.classList.add(className);
	        }
	    };
	    Popup.prototype.removeClassName = function removeClassName(className) {
	        if (this._container) {
	            this._container.classList.remove(className);
	        }
	    };
	    Popup.prototype.setOffset = function setOffset(offset) {
	        this.options.offset = offset;
	        this._update();
	        return this;
	    };
	    Popup.prototype.toggleClassName = function toggleClassName(className) {
	        if (this._container) {
	            return this._container.classList.toggle(className);
	        }
	    };
	    Popup.prototype._createCloseButton = function _createCloseButton() {
	        if (this.options.closeButton) {
	            this._closeButton = DOM.create('button', 'mapboxgl-popup-close-button', this._content);
	            this._closeButton.type = 'button';
	            this._closeButton.setAttribute('aria-label', 'Close popup');
	            this._closeButton.innerHTML = '&#215;';
	            this._closeButton.addEventListener('click', this._onClose);
	        }
	    };
	    Popup.prototype._onMouseUp = function _onMouseUp(event) {
	        this._update(event.point);
	    };
	    Popup.prototype._onMouseMove = function _onMouseMove(event) {
	        this._update(event.point);
	    };
	    Popup.prototype._onDrag = function _onDrag(event) {
	        this._update(event.point);
	    };
	    Popup.prototype._update = function _update(cursor) {
	        var this$1 = this;
	        var hasPosition = this._lngLat || this._trackPointer;
	        if (!this._map || !hasPosition || !this._content) {
	            return;
	        }
	        if (!this._container) {
	            this._container = DOM.create('div', 'mapboxgl-popup', this._map.getContainer());
	            this._tip = DOM.create('div', 'mapboxgl-popup-tip', this._container);
	            this._container.appendChild(this._content);
	            if (this.options.className) {
	                this.options.className.split(' ').forEach(function (name) {
	                    return this$1._container.classList.add(name);
	                });
	            }
	            if (this._trackPointer) {
	                this._container.classList.add('mapboxgl-popup-track-pointer');
	            }
	        }
	        if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth) {
	            this._container.style.maxWidth = this.options.maxWidth;
	        }
	        if (this._map.transform.renderWorldCopies && !this._trackPointer) {
	            this._lngLat = smartWrap(this._lngLat, this._pos, this._map.transform);
	        }
	        if (this._trackPointer && !cursor) {
	            return;
	        }
	        var pos = this._pos = this._trackPointer && cursor ? cursor : this._map.project(this._lngLat);
	        var anchor = this.options.anchor;
	        var offset = normalizeOffset(this.options.offset);
	        if (!anchor) {
	            var width = this._container.offsetWidth;
	            var height = this._container.offsetHeight;
	            var anchorComponents;
	            if (pos.y + offset.bottom.y < height) {
	                anchorComponents = ['top'];
	            } else if (pos.y > this._map.transform.height - height) {
	                anchorComponents = ['bottom'];
	            } else {
	                anchorComponents = [];
	            }
	            if (pos.x < width / 2) {
	                anchorComponents.push('left');
	            } else if (pos.x > this._map.transform.width - width / 2) {
	                anchorComponents.push('right');
	            }
	            if (anchorComponents.length === 0) {
	                anchor = 'bottom';
	            } else {
	                anchor = anchorComponents.join('-');
	            }
	        }
	        var offsetedPos = pos.add(offset[anchor]).round();
	        DOM.setTransform(this._container, anchorTranslate[anchor] + ' translate(' + offsetedPos.x + 'px,' + offsetedPos.y + 'px)');
	        applyAnchorClass(this._container, anchor, 'popup');
	    };
	    Popup.prototype._focusFirstElement = function _focusFirstElement() {
	        if (!this.options.focusAfterOpen || !this._container) {
	            return;
	        }
	        var firstFocusable = this._container.querySelector(focusQuerySelector);
	        if (firstFocusable) {
	            firstFocusable.focus();
	        }
	    };
	    Popup.prototype._onClose = function _onClose() {
	        this.remove();
	    };
	    return Popup;
	}(performance.Evented);
	function normalizeOffset(offset) {
	    if (!offset) {
	        return normalizeOffset(new performance.Point(0, 0));
	    } else if (typeof offset === 'number') {
	        var cornerOffset = Math.round(Math.sqrt(0.5 * Math.pow(offset, 2)));
	        return {
	            'center': new performance.Point(0, 0),
	            'top': new performance.Point(0, offset),
	            'top-left': new performance.Point(cornerOffset, cornerOffset),
	            'top-right': new performance.Point(-cornerOffset, cornerOffset),
	            'bottom': new performance.Point(0, -offset),
	            'bottom-left': new performance.Point(cornerOffset, -cornerOffset),
	            'bottom-right': new performance.Point(-cornerOffset, -cornerOffset),
	            'left': new performance.Point(offset, 0),
	            'right': new performance.Point(-offset, 0)
	        };
	    } else if (offset instanceof performance.Point || Array.isArray(offset)) {
	        var convertedOffset = performance.Point.convert(offset);
	        return {
	            'center': convertedOffset,
	            'top': convertedOffset,
	            'top-left': convertedOffset,
	            'top-right': convertedOffset,
	            'bottom': convertedOffset,
	            'bottom-left': convertedOffset,
	            'bottom-right': convertedOffset,
	            'left': convertedOffset,
	            'right': convertedOffset
	        };
	    } else {
	        return {
	            'center': performance.Point.convert(offset['center'] || [
	                0,
	                0
	            ]),
	            'top': performance.Point.convert(offset['top'] || [
	                0,
	                0
	            ]),
	            'top-left': performance.Point.convert(offset['top-left'] || [
	                0,
	                0
	            ]),
	            'top-right': performance.Point.convert(offset['top-right'] || [
	                0,
	                0
	            ]),
	            'bottom': performance.Point.convert(offset['bottom'] || [
	                0,
	                0
	            ]),
	            'bottom-left': performance.Point.convert(offset['bottom-left'] || [
	                0,
	                0
	            ]),
	            'bottom-right': performance.Point.convert(offset['bottom-right'] || [
	                0,
	                0
	            ]),
	            'left': performance.Point.convert(offset['left'] || [
	                0,
	                0
	            ]),
	            'right': performance.Point.convert(offset['right'] || [
	                0,
	                0
	            ])
	        };
	    }
	}

	var exported = {
	    version: performance.version,
	    supported: mapboxGlSupported,
	    setRTLTextPlugin: performance.setRTLTextPlugin,
	    getRTLTextPluginStatus: performance.getRTLTextPluginStatus,
	    Map: Map,
	    NavigationControl: NavigationControl,
	    GeolocateControl: GeolocateControl,
	    AttributionControl: AttributionControl,
	    ScaleControl: ScaleControl,
	    FullscreenControl: FullscreenControl,
	    Popup: Popup,
	    Marker: Marker,
	    Style: Style,
	    LngLat: performance.LngLat,
	    LngLatBounds: performance.LngLatBounds,
	    Point: performance.Point,
	    MercatorCoordinate: performance.MercatorCoordinate,
	    Evented: performance.Evented,
	    config: performance.config,
	    prewarm: prewarm,
	    clearPrewarmedResources: clearPrewarmedResources,
	    get accessToken() {
	        return performance.config.ACCESS_TOKEN;
	    },
	    set accessToken(token) {
	        performance.config.ACCESS_TOKEN = token;
	    },
	    get baseApiUrl() {
	        return performance.config.API_URL;
	    },
	    set baseApiUrl(url) {
	        performance.config.API_URL = url;
	    },
	    get workerCount() {
	        return WorkerPool.workerCount;
	    },
	    set workerCount(count) {
	        WorkerPool.workerCount = count;
	    },
	    get maxParallelImageRequests() {
	        return performance.config.MAX_PARALLEL_IMAGE_REQUESTS;
	    },
	    set maxParallelImageRequests(numRequests) {
	        performance.config.MAX_PARALLEL_IMAGE_REQUESTS = numRequests;
	    },
	    clearStorage: function clearStorage(callback) {
	        performance.clearTileCache(callback);
	    },
	    workerUrl: ''
	};

	return exported;

	});

	//

	return maplibregl;

	})));

	});
	var azuremapsMaplibreGlUnminified_1 = azuremapsMaplibreGlUnminified.Map;
	var azuremapsMaplibreGlUnminified_2 = azuremapsMaplibreGlUnminified.setRTLTextPlugin;
	var azuremapsMaplibreGlUnminified_3 = azuremapsMaplibreGlUnminified.supported;
	var azuremapsMaplibreGlUnminified_4 = azuremapsMaplibreGlUnminified.Marker;

	var env = {
		domain: "atlas.microsoft.com",
		staticAssetsDomain: "atlas.microsoft.com",
		stylePath: "styling",
		styleDefinitionsVersion: "2021-02-01",
		appInsightsKey: "e96cb745-c6f5-409c-a775-c4313e468c1d",
		aadInstance: "https://login.microsoftonline.com/"
	};
	var constants = {
		apiVersionQueryParameter: "api-version",
		authorizationHeaderName: "Authorization",
		authorizationTokenPrefix: "Bearer ",
		domainPlaceHolder: "{{azMapsDomain}}",
		legacyDomainPlaceHolder: "{azMapsDomain}",
		viewPlaceHolder: "{{azMapsView}}",
		viewParameter: "view",
		languagePlaceHolder: "{{azMapsLanguage}}",
		stylePathHolder: "{{azMapsStylingPath}}",
		styleResourcePlaceholder: "{{azMapsStylePath}}",
		stylePath: "styling",
		styleResourcePath: "styles",
		styleApiVersion: "2.0",
		mapAgentHeaderName: "Map-Agent",
		msClientIdHeaderName: "x-ms-client-id",
		msOriginHeaderName: "Ms-Am-Request-Origin",
		msOriginHeaderValue: "MapControl",
		resourceId: "https://atlas.microsoft.com/",
		sessionIdHeaderName: "Session-Id"
	};

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics = function(d, b) {
	    extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics(d, b);
	};

	function __extends(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign = function() {
	    __assign = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};

	function __decorate(decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	}

	function __awaiter(thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	}

	function __generator(thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	}

	function __values(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	}

	function __read(o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	}

	function __spread() {
	    for (var ar = [], i = 0; i < arguments.length; i++)
	        ar = ar.concat(__read(arguments[i]));
	    return ar;
	}

	/**
	 * @private
	 */
	var Options = /** @class */ (function () {
	    function Options() {
	    }
	    /**
	     * @internal
	     */
	    Options.prototype.merge = function () {
	        var e_1, _a;
	        var valuesList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valuesList[_i] = arguments[_i];
	        }
	        var defaults;
	        try {
	            for (var valuesList_1 = __values(valuesList), valuesList_1_1 = valuesList_1.next(); !valuesList_1_1.done; valuesList_1_1 = valuesList_1.next()) {
	                var values = valuesList_1_1.value;
	                if (!values) {
	                    continue;
	                }
	                for (var property in values) {
	                    if (values.hasOwnProperty(property) && this.hasOwnProperty(property)) {
	                        if (values[property] !== undefined && values[property] != null) {
	                            // Check for nested options and merge them rather than simply overwriting.
	                            if (this[property] instanceof Options) {
	                                this[property].merge(values[property]);
	                            }
	                            else {
	                                this[property] = values[property];
	                            }
	                        }
	                        else {
	                            // Assume a value of undefined or null intends to take the default value.
	                            // Create a new object to access its defaults.
	                            if (!defaults) {
	                                defaults = new (Object.getPrototypeOf(this).constructor)();
	                            }
	                            this[property] = defaults[property];
	                        }
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (valuesList_1_1 && !valuesList_1_1.done && (_a = valuesList_1.return)) _a.call(valuesList_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return this;
	    };
	    return Options;
	}());

	/**
	 * @private
	 */
	var UrlOptions = /** @class */ (function (_super) {
	    __extends(UrlOptions, _super);
	    function UrlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.domain = undefined;
	        _this.headers = {};
	        _this.path = "";
	        _this.protocol = "https";
	        _this.queryParams = {};
	        _this.subdomain = "";
	        return _this;
	    }
	    return UrlOptions;
	}(Options));
	/**
	 * @private
	 */
	// tslint:disable-next-line:max-classes-per-file
	var Url = /** @class */ (function () {
	    function Url(options) {
	        this.options = new UrlOptions().merge(options);
	    }
	    // tslint:disable-next-line:no-reserved-keywords
	    Url.prototype.get = function () {
	        return fetch(this.toString(), {
	            method: "GET",
	            mode: "cors",
	            headers: new Headers(this.options.headers),
	        }).then(function (response) {
	            if (response.ok) {
	                return response.json();
	            }
	            else {
	                throw new Error("HTTP " + response.status + ": " + response.statusText);
	            }
	        });
	    };
	    Url.prototype.toString = function () {
	        var self = this;
	        var queryParamsString = Object.entries(self.options.queryParams)
	            .map(function (_a) {
	            var _b = __read(_a, 2), key = _b[0], value = _b[1];
	            return key + "=" + value;
	        })
	            .join("&");
	        var url = [];
	        var path = self.options.path || "";
	        // If path contains the protocol, don't add domain to the url.
	        if (Url.protoRegEx.test(path)) {
	            url.push(path);
	        }
	        else {
	            // domain may be empty for absolute paths or
	            // path itself might start with '/' for absolute paths
	            if (self.options.domain) {
	                if (!Url.protoRegEx.test(self.options.domain)) {
	                    // If the domain doesn't include a protocol use the separate protocol and subdomain properties.
	                    // If the domain includes a protocol assume it also includes the subdomain.
	                    url.push(self.options.protocol + "://");
	                    url.push(self.options.subdomain ? self.options.subdomain + "." : "");
	                }
	                url.push(self.options.domain);
	            }
	            url.push(self.options.path ? "/" + path : "");
	        }
	        url.push(queryParamsString ? "?" + queryParamsString : "");
	        return url.join("");
	    };
	    Url.protoRegEx = new RegExp(/^(((file|http|https):\/\/)|blob:)/i);
	    return Url;
	}());

	var version = "2.1.4";

	/**
	 * A helper class that provides methods for getting various forms of the map controls current version.
	 */
	var Version = /** @class */ (function () {
	    function Version() {
	    }
	    /**
	     * Returns the full version string for the map control.
	     * For example, `"1.3.5"`.
	     */
	    Version.getFullVersion = function () {
	        return version;
	    };
	    /**
	     * Returns the endpoint compatible version string for the map control.
	     * For example, `"1.3.5"` becomes `"1.3"`.
	     */
	    Version.getEndpointVersion = function () {
	        // Get the index of the second "."
	        var index = version.indexOf(".");
	        index = version.indexOf(".", index + 1);
	        // If the index of the second "." can't be found just return the whole version string.
	        if (index === -1) {
	            return version;
	        }
	        return version.substring(0, index);
	    };
	    return Version;
	}());

	(function (ControlPosition) {
	    /**
	     * Places the control in the top left of the map.
	     * Literal value `"top-left"`
	     */
	    ControlPosition["TopLeft"] = "top-left";
	    /**
	     * Places the control in the top right of the map.
	     * Literal value `"top-right"`
	     */
	    ControlPosition["TopRight"] = "top-right";
	    /**
	     * Places the control in the bottom left of the map.
	     * Literal value `"bottom-left"`
	     */
	    ControlPosition["BottomLeft"] = "bottom-left";
	    /**
	     * Places the control in the bottom right of the map.
	     * Literal value `"bottom-right"`
	     */
	    ControlPosition["BottomRight"] = "bottom-right";
	    /**
	     * The control will place itself in its default location.
	     * Literal value `"non-fixed"`
	     */
	    ControlPosition["NonFixed"] = "non-fixed";
	})(exports.ControlPosition || (exports.ControlPosition = {}));
	/**
	 * The options for adding a control to the map.
	 */
	var ControlOptions = /** @class */ (function (_super) {
	    __extends(ControlOptions, _super);
	    function ControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The position the control will be placed on the map. If not specified, the control will be located at the
	         * default position it defines.
	         * default `ControlPosition.NonFixed`
	         * @default ControlPosition.NonFixed
	         */
	        _this.position = exports.ControlPosition.NonFixed;
	        return _this;
	    }
	    return ControlOptions;
	}(Options));

	/**
	 * Color helper class to get the RGBA and luminosity of the color
	 * @private
	 */
	var Color = /** @class */ (function () {
	    function Color(color) {
	        if (color) {
	            var rgba = void 0;
	            if (typeof color === "string") {
	                rgba = this.getRBGA(color);
	            }
	            else {
	                rgba = color;
	            }
	            if (rgba.length >= 3) {
	                this.r = rgba[0];
	                this.g = rgba[1];
	                this.b = rgba[2];
	                if (rgba.length > 3) {
	                    this.a = rgba[3];
	                }
	            }
	        }
	    }
	    /**
	     * Get Luminosity of color
	     */
	    Color.prototype.getLuminosity = function () {
	        // http://www.w3.org/TR/WCAG20/#relativeluminancedef
	        var rgb = [this.r, this.g, this.b];
	        var luminosity = [];
	        for (var i = 0; i < rgb.length; i++) {
	            var chan = rgb[i] / 255;
	            luminosity[i] =
	                chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
	        }
	        return (0.2126 * luminosity[0] + 0.7152 * luminosity[1] + 0.0722 * luminosity[2]);
	    };
	    /**
	     * Get RGBA value of the color
	     */
	    Color.prototype.getRBGA = function (color) {
	        var canvas = document.createElement("canvas");
	        var ctx = canvas.getContext("2d");
	        ctx.globalAlpha = 1;
	        ctx.fillStyle = color;
	        ctx.fillRect(0, 0, 1, 1);
	        var data = ctx.getImageData(0, 0, 1, 1).data;
	        return [data[0], data[1], data[2], data[3]];
	    };
	    return Color;
	}());

	/**
	 * Available styles for a Control.
	 */
	(function (ControlStyle) {
	    /**
	     * The control will be in the light style.
	     * Literal value `"light"`
	     */
	    ControlStyle["light"] = "light";
	    /**
	     * The control will be in the dark style.
	     * Literal value `"dark"`
	     */
	    ControlStyle["dark"] = "dark";
	    /**
	     * The control will automatically switch styles based on the style of the map.
	     * If a control doesn't support automatic styling the light style will be used by default.
	     * Literal value `"auto"`
	     */
	    ControlStyle["auto"] = "auto";
	})(exports.ControlStyle || (exports.ControlStyle = {}));

	var Dictionary = Map;

	/**
	 * An internal abstract class that can be extended to provide event listening/firing.
	 * This class is for internal use only, and users will find little use with it.
	 * Not to be used by the Map class. MapCallbackHandler implements the more complex logic for handling map events.
	 */
	var EventEmitter = /** @class */ (function () {
	    function EventEmitter() {
	        // Event listeners.
	        this.listeners = new Dictionary();
	    }
	    EventEmitter.prototype._addEventListener = function (eventType, callback, once) {
	        if (!this.listeners.has(eventType)) {
	            this.listeners.set(eventType, new Dictionary());
	        }
	        this.listeners.get(eventType).set(callback, once);
	    };
	    EventEmitter.prototype._removeEventListener = function (eventType, callback) {
	        if (this.listeners.has(eventType)) {
	            this.listeners.get(eventType).delete(callback);
	        }
	    };
	    /**
	     * Invokes a given event type.
	     * @param eventType The event name.
	     * @param eventData The data to pass to the listener callbacks.
	     */
	    EventEmitter.prototype._invokeEvent = function (eventType, eventData) {
	        var _this = this;
	        if (this.listeners.has(eventType)) {
	            this.listeners.get(eventType).forEach(function (once, callback) {
	                if (once) {
	                    _this._removeEventListener(eventType, callback);
	                }
	                try {
	                    callback(eventData);
	                }
	                catch (error) {
	                    // tslint:disable-next-line:no-console
	                    console.error(error);
	                }
	            });
	        }
	    };
	    return EventEmitter;
	}());



	var index = /*#__PURE__*/Object.freeze({
		__proto__: null,
		EventEmitter: EventEmitter
	});

	/**
	 * For internal use only.
	 * Implements control interface and provides support for automatic styling based on the map style.
	 */
	var ControlBase = /** @class */ (function (_super) {
	    __extends(ControlBase, _super);
	    function ControlBase() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A callback for when the map's style changes.
	         * Used for auto styling.
	         */
	        _this._onStyleChange = function () {
	            if (_this._map.getStyle().style.toLowerCase().startsWith("blank")) {
	                // If the style is blank the div background should decide the theme.
	                if (!_this._observer) {
	                    // Add an observer to see changes to the background.
	                    _this._onBackgroundChange();
	                    _this._observer = new MutationObserver(_this._onBackgroundChange);
	                    _this._observer.observe(_this._map.getMapContainer(), { attributes: true, attributeFilter: ["style"] });
	                }
	            }
	            else {
	                if (_this._observer) {
	                    // Remove any existing observer for non-blank styles.
	                    _this._observer.disconnect();
	                    delete _this._observer;
	                }
	                // If the style is anything but blank the style definition should decide the theme.
	                var theme = _this._map.styles.getTheme(_this._map.getStyle());
	                _this._setTheme(theme);
	            }
	        };
	        /**
	         * A callback for when the map's
	         */
	        _this._onBackgroundChange = function () {
	            // Calculate the luminosity of the map div's background to determine the theme.
	            // Try to parse the color, could fail if something complex like a gradient is used.
	            var color = new Color(_this._map.getMapContainer().style.backgroundColor);
	            var luminosity = color.getLuminosity();
	            // If the background color can't be parsed assume it is light.
	            var theme = isNaN(luminosity) || luminosity > 0.5
	                ? exports.ControlStyle.light
	                : exports.ControlStyle.dark;
	            _this._setTheme(theme);
	        };
	        return _this;
	    }
	    /**
	     * Method that is called when the control is removed from the map. Should perform any necessary cleanup for the
	     * control.
	     */
	    ControlBase.prototype.onRemove = function () {
	        if (this._container) {
	            this._container.remove();
	            delete this._container;
	        }
	        if (this._map) {
	            this._map.events.remove("styledata", this._onStyleChange);
	            delete this._map;
	        }
	        if (this._observer) {
	            this._observer.disconnect();
	            delete this._observer;
	        }
	        delete this._theme;
	    };
	    /**
	     * Build the outermost container for the control, applies styling including any listeners for auto styling.
	     */
	    ControlBase.prototype.buildContainer = function (map, style, ariaLabel, tagName) {
	        var _this = this;
	        this._map = map;
	        this._container = document.createElement(tagName || "div");
	        this._container.classList.add("azure-maps-control-container");
	        if (typeof ariaLabel === "string") {
	            this._container.setAttribute("aria-label", ariaLabel);
	        }
	        // Set the style or add the auto listener.
	        if (style.toLowerCase() === exports.ControlStyle.auto) {
	            this._map.styles.initialize().then(function () {
	                if (_this._map) {
	                    _this._onStyleChange();
	                    _this._map.events.add("styledata", _this._onStyleChange);
	                }
	            });
	        }
	        else {
	            this._container.classList.add(style);
	        }
	        return this._container;
	    };
	    /**
	     * Sets the control's theme (light/dark).
	     * Only applies changes if the theme is different than the previous.
	     */
	    ControlBase.prototype._setTheme = function (theme) {
	        // Only update if the theme is different.
	        if (this._theme !== theme) {
	            this._container.classList.remove(this._theme);
	            this._container.classList.add(theme);
	            this._theme = theme;
	        }
	    };
	    /** The delay between activating the control and when a click should occur, else assume it's a touch */
	    ControlBase.activateClickDelay = 100;
	    return ControlBase;
	}(EventEmitter));

	/**
	 * The options for a CompassControl object.
	 */
	var CompassControlOptions = /** @class */ (function (_super) {
	    __extends(CompassControlOptions, _super);
	    function CompassControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The angle that the map will rotate with each click of the control.
	         * Default `15`.
	         * @default 15
	         */
	        _this.rotationDegreesDelta = 15;
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        return _this;
	    }
	    return CompassControlOptions;
	}(Options));

	/**
	 * A control for changing the rotation of the map.
	 */
	var CompassControl = /** @class */ (function (_super) {
	    __extends(CompassControl, _super);
	    /**
	     * Constructs a CompassControl.
	     * @param options The options for the control.
	     */
	    function CompassControl(options) {
	        var _this = _super.call(this) || this;
	        _this.hasMouse = false;
	        _this.hasFocus = false;
	        _this.options = new CompassControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    CompassControl.prototype.onAdd = function (map, options) {
	        var _this = this;
	        var container = this.buildContainer(map, this.options.style, "Rotation Control");
	        var rotationButton = this.constructRotationButton(map);
	        var grid = this.constructRotationGrid(map, options);
	        container.addEventListener("mouseover", function (event) {
	            _this.lastActiveTime = _this.lastActiveTime || event.timeStamp;
	            _this.hasMouse = true;
	            container.classList.add("in-use");
	            grid.classList.remove("hidden-accessible-element");
	        });
	        container.addEventListener("focusin", function (event) {
	            _this.lastActiveTime = _this.lastActiveTime || event.timeStamp;
	            _this.hasFocus = true;
	            container.classList.add("in-use");
	            grid.classList.remove("hidden-accessible-element");
	        });
	        container.addEventListener("mouseleave", function () {
	            _this.hasMouse = false;
	            if (!_this.hasFocus) {
	                delete _this.lastActiveTime;
	                container.classList.remove("in-use");
	                grid.classList.add("hidden-accessible-element");
	            }
	        });
	        container.addEventListener("focusout", function (event) {
	            if (!(event.relatedTarget instanceof Node && container.contains(event.relatedTarget))) {
	                _this.hasFocus = false;
	                if (!_this.hasMouse) {
	                    delete _this.lastActiveTime;
	                    container.classList.remove("in-use");
	                    grid.classList.add("hidden-accessible-element");
	                }
	            }
	        });
	        // If the control's position will require inverting the element order
	        // add them in the opposite order to preserve tabindex.
	        if (options && CompassControl.InvertOrderPositions.includes(options.position)) {
	            container.appendChild(grid);
	            container.appendChild(rotationButton);
	        }
	        else {
	            container.appendChild(rotationButton);
	            container.appendChild(grid);
	        }
	        return container;
	    };
	    CompassControl.prototype.constructRotationGrid = function (map, options) {
	        var grid = document.createElement("div");
	        grid.classList.add("sub-container");
	        grid.classList.add("hidden-accessible-element");
	        var rotationRightButton = this.constructRightRotationButton(map);
	        var rotationLeftButton = this.constructLeftRotationButton(map);
	        if (options && CompassControl.InvertOrderPositions.includes(options.position)) {
	            grid.appendChild(rotationRightButton);
	            grid.appendChild(rotationLeftButton);
	        }
	        else {
	            grid.appendChild(rotationLeftButton);
	            grid.appendChild(rotationRightButton);
	        }
	        return grid;
	    };
	    CompassControl.prototype.constructRotationButton = function (map) {
	        var _this = this;
	        var rotationButton = document.createElement("button");
	        rotationButton.classList.add("azure-maps-control-button");
	        rotationButton.classList.add("rotation");
	        rotationButton.setAttribute("title", "Reset to Default Rotation");
	        rotationButton.setAttribute("alt", "Reset to Default Rotation");
	        rotationButton.setAttribute("type", "button");
	        var icon = document.createElement("div");
	        rotationButton.appendChild(icon);
	        rotationButton.addEventListener("click", function (event) {
	            // If the click is happening just after the control became active assume it's a touch event from Edge.
	            if (event.timeStamp - _this.lastActiveTime > ControlBase.activateClickDelay) {
	                map.setCamera({
	                    bearing: CompassControl.DefaultRotation
	                }, true);
	            }
	        });
	        map.events.add("rotate", function (e) {
	            icon.style.transform = "rotate(" + -e.map.getCamera().bearing + "deg)";
	        });
	        return rotationButton;
	    };
	    CompassControl.prototype.constructRightRotationButton = function (map) {
	        var _this = this;
	        var rotationRightButton = document.createElement("button");
	        rotationRightButton.classList.add("azure-maps-control-button");
	        rotationRightButton.classList.add("rotation-right");
	        rotationRightButton.setAttribute("title", "Rotate Right");
	        rotationRightButton.setAttribute("alt", "Rotate Right");
	        rotationRightButton.setAttribute("type", "button");
	        rotationRightButton.addEventListener("click", function () {
	            map.setCamera({
	                bearing: map.getCamera().bearing - _this.options.rotationDegreesDelta,
	                duration: CompassControl.RotationDuration,
	                type: "ease",
	            }, true);
	        });
	        return rotationRightButton;
	    };
	    CompassControl.prototype.constructLeftRotationButton = function (map) {
	        var _this = this;
	        var rotationLeftButton = document.createElement("button");
	        rotationLeftButton.classList.add("azure-maps-control-button");
	        rotationLeftButton.classList.add("rotation-left");
	        rotationLeftButton.setAttribute("title", "Rotate Left");
	        rotationLeftButton.setAttribute("alt", "Rotate Left");
	        rotationLeftButton.setAttribute("type", "button");
	        rotationLeftButton.addEventListener("click", function () {
	            map.setCamera({
	                bearing: map.getCamera().bearing + _this.options.rotationDegreesDelta,
	                duration: CompassControl.RotationDuration,
	                type: "ease"
	            }, true);
	        });
	        return rotationLeftButton;
	    };
	    CompassControl.DefaultRotation = 0;
	    /** @internal */ CompassControl.RotationDuration = 100;
	    CompassControl.InvertOrderPositions = [exports.ControlPosition.BottomRight, exports.ControlPosition.TopRight];
	    return CompassControl;
	}(ControlBase));

	/**
	 * The options for a PitchControl object.
	 */
	var PitchControlOptions = /** @class */ (function (_super) {
	    __extends(PitchControlOptions, _super);
	    function PitchControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The angle that the map will tilt with each click of the control.
	         * Default `10`.
	         * @default 10
	         */
	        _this.pitchDegreesDelta = 10;
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`.
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        return _this;
	    }
	    return PitchControlOptions;
	}(Options));

	/**
	 * A control for changing the pitch of the map.
	 */
	var PitchControl = /** @class */ (function (_super) {
	    __extends(PitchControl, _super);
	    /**
	     * Constructs a PitchControl.
	     * @param options The options for the control.
	     */
	    function PitchControl(options) {
	        var _this = _super.call(this) || this;
	        _this.container = null;
	        _this.map = null;
	        _this.pitchIncrementButton = null;
	        _this.pitchDecrementButton = null;
	        _this.hasMouse = false;
	        _this.hasFocus = false;
	        _this.pitchChanged = function (map) { return _this.updatePitchButtonsState(); };
	        _this.updatePitchButtonsState = function () {
	            var minPitchReached = _this.map.getCamera().pitch <= 0;
	            var maxPitchReached = _this.map.getCamera().pitch >= 60;
	            if (_this.pitchIncrementButton && _this.pitchIncrementButton.disabled != maxPitchReached) {
	                _this.pitchIncrementButton.disabled = maxPitchReached;
	            }
	            if (_this.pitchDecrementButton && _this.pitchDecrementButton.disabled != minPitchReached) {
	                _this.pitchDecrementButton.disabled = minPitchReached;
	            }
	        };
	        _this.options = new PitchControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    PitchControl.prototype.onAdd = function (map, options) {
	        var _this = this;
	        var container = this.buildContainer(map, this.options.style, "Pitch Control");
	        var pitchButton = this.constructPitchButton(map);
	        var grid = this.constructPitchGrid(map, options);
	        container.addEventListener("mouseover", function (event) {
	            _this.lastActiveTime = _this.lastActiveTime || event.timeStamp;
	            _this.hasMouse = true;
	            container.classList.add("in-use");
	            grid.classList.remove("hidden-accessible-element");
	        });
	        container.addEventListener("focusin", function (event) {
	            _this.lastActiveTime = _this.lastActiveTime || event.timeStamp;
	            _this.hasFocus = true;
	            container.classList.add("in-use");
	            grid.classList.remove("hidden-accessible-element");
	        });
	        container.addEventListener("mouseleave", function () {
	            _this.hasMouse = false;
	            if (!_this.hasFocus) {
	                delete _this.lastActiveTime;
	                container.classList.remove("in-use");
	                grid.classList.add("hidden-accessible-element");
	            }
	        });
	        container.addEventListener("focusout", function (event) {
	            if (!(event.relatedTarget instanceof Node && container.contains(event.relatedTarget))) {
	                _this.hasFocus = false;
	                if (!_this.hasMouse) {
	                    delete _this.lastActiveTime;
	                    container.classList.remove("in-use");
	                    grid.classList.add("hidden-accessible-element");
	                }
	            }
	        });
	        // If the control's position will require inverting the element order
	        // add them in the opposite order to preserve tabindex.
	        if (options && PitchControl.INVERT_ORDER_POSITIONS.includes(options.position)) {
	            container.appendChild(grid);
	            container.appendChild(pitchButton);
	        }
	        else {
	            container.appendChild(pitchButton);
	            container.appendChild(grid);
	        }
	        this.map = map;
	        this.container = container;
	        map.events.add('pitch', this.pitchChanged);
	        return container;
	    };
	    PitchControl.prototype.onRemove = function () {
	        if (this.container) {
	            this.container.remove();
	            this.container = null;
	            this.pitchIncrementButton = null;
	            this.pitchDecrementButton = null;
	        }
	        if (this.map) {
	            this.map.events.remove('pitch', this.pitchChanged);
	            this.map = null;
	        }
	    };
	    PitchControl.prototype.constructPitchGrid = function (map, options) {
	        var grid = document.createElement("div");
	        grid.classList.add("sub-container");
	        grid.classList.add("hidden-accessible-element");
	        this.pitchIncrementButton = this.constructPitchIncrementButton(map);
	        this.pitchDecrementButton = this.constructPitchDecrementButton(map);
	        if (options && PitchControl.INVERT_ORDER_POSITIONS.includes(options.position)) {
	            grid.appendChild(this.pitchDecrementButton);
	            grid.appendChild(this.pitchIncrementButton);
	        }
	        else {
	            grid.appendChild(this.pitchIncrementButton);
	            grid.appendChild(this.pitchDecrementButton);
	        }
	        return grid;
	    };
	    PitchControl.prototype.constructPitchButton = function (map) {
	        var _this = this;
	        var pitchButton = document.createElement("button");
	        pitchButton.classList.add("azure-maps-control-button");
	        pitchButton.classList.add("pitch");
	        pitchButton.setAttribute("title", "Reset to Default Pitch");
	        pitchButton.setAttribute("alt", "Reset to Default Pitch");
	        pitchButton.setAttribute("type", "button");
	        pitchButton.addEventListener("click", function () {
	            // If the click is happening just after the control became active assume it's a touch event from Edge.
	            if (event.timeStamp - _this.lastActiveTime > ControlBase.activateClickDelay) {
	                map.setCamera({
	                    pitch: PitchControl.DEFAULT_PITCH
	                }, true);
	            }
	        });
	        return pitchButton;
	    };
	    PitchControl.prototype.constructPitchDecrementButton = function (map) {
	        var _this = this;
	        var pitchDecrementButton = document.createElement("button");
	        pitchDecrementButton.classList.add("azure-maps-control-button");
	        pitchDecrementButton.classList.add("pitch-down");
	        pitchDecrementButton.setAttribute("title", "Decrease Pitch");
	        pitchDecrementButton.setAttribute("alt", "Decrease Pitch");
	        pitchDecrementButton.setAttribute("type", "button");
	        pitchDecrementButton.addEventListener("click", function () {
	            map.setCamera({
	                pitch: map.getCamera().pitch - _this.options.pitchDegreesDelta,
	                duration: PitchControl.PITCH_DURATION_MS,
	                type: "ease"
	            }, true);
	        });
	        return pitchDecrementButton;
	    };
	    PitchControl.prototype.constructPitchIncrementButton = function (map) {
	        var _this = this;
	        var pitchIncrementButton = document.createElement("button");
	        pitchIncrementButton.classList.add("azure-maps-control-button");
	        pitchIncrementButton.classList.add("pitch-up");
	        pitchIncrementButton.setAttribute("title", "Increase Pitch");
	        pitchIncrementButton.setAttribute("alt", "Increase Pitch");
	        pitchIncrementButton.setAttribute("type", "button");
	        pitchIncrementButton.addEventListener("click", function () {
	            map.setCamera({
	                pitch: map.getCamera().pitch + _this.options.pitchDegreesDelta,
	                duration: PitchControl.PITCH_DURATION_MS,
	                type: "ease"
	            }, true);
	        });
	        return pitchIncrementButton;
	    };
	    PitchControl.PITCH_DURATION_MS = 100;
	    PitchControl.DEFAULT_PITCH = 0;
	    PitchControl.INVERT_ORDER_POSITIONS = [exports.ControlPosition.BottomRight, exports.ControlPosition.TopRight];
	    return PitchControl;
	}(ControlBase));

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq_1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return _assocIndexOf(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = _listCacheClear;
	ListCache.prototype['delete'] = _listCacheDelete;
	ListCache.prototype.get = _listCacheGet;
	ListCache.prototype.has = _listCacheHas;
	ListCache.prototype.set = _listCacheSet;

	var _ListCache = ListCache;

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new _ListCache;
	  this.size = 0;
	}

	var _stackClear = stackClear;

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	var _stackDelete = stackDelete;

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	var _stackGet = stackGet;

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	var _stackHas = stackHas;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	var _freeGlobal = freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = _freeGlobal || freeSelf || Function('return this')();

	var _root = root;

	/** Built-in value references. */
	var Symbol$1 = _root.Symbol;

	var _Symbol = Symbol$1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}

	var _objectToString = objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag$1 && symToStringTag$1 in Object(value))
	    ? _getRawTag(value)
	    : _objectToString(value);
	}

	var _baseGetTag = baseGetTag;

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject_1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = _baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = _root['__core-js_shared__'];

	var _coreJsData = coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked;

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject_1(value) || _isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(_toSource(value));
	}

	var _baseIsNative = baseIsNative;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = _getValue(object, key);
	  return _baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative;

	/* Built-in method references that are verified to be native. */
	var Map$1 = _getNative(_root, 'Map');

	var _Map = Map$1;

	/* Built-in method references that are verified to be native. */
	var nativeCreate = _getNative(Object, 'create');

	var _nativeCreate = nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (_nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet;

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
	}

	var _hashHas = hashHas;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = _hashClear;
	Hash.prototype['delete'] = _hashDelete;
	Hash.prototype.get = _hashGet;
	Hash.prototype.has = _hashHas;
	Hash.prototype.set = _hashSet;

	var _Hash = Hash;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new _Hash,
	    'map': new (_Map || _ListCache),
	    'string': new _Hash
	  };
	}

	var _mapCacheClear = mapCacheClear;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return _isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = _getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return _getMapData(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return _getMapData(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = _getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = _mapCacheClear;
	MapCache.prototype['delete'] = _mapCacheDelete;
	MapCache.prototype.get = _mapCacheGet;
	MapCache.prototype.has = _mapCacheHas;
	MapCache.prototype.set = _mapCacheSet;

	var _MapCache = MapCache;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof _ListCache) {
	    var pairs = data.__data__;
	    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new _MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	var _stackSet = stackSet;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new _ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = _stackClear;
	Stack.prototype['delete'] = _stackDelete;
	Stack.prototype.get = _stackGet;
	Stack.prototype.has = _stackHas;
	Stack.prototype.set = _stackSet;

	var _Stack = Stack;

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	var _arrayEach = arrayEach;

	var defineProperty = (function() {
	  try {
	    var func = _getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	var _defineProperty = defineProperty;

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && _defineProperty) {
	    _defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	var _baseAssignValue = baseAssignValue;

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty$4.call(object, key) && eq_1(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    _baseAssignValue(object, key, value);
	  }
	}

	var _assignValue = assignValue;

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      _baseAssignValue(object, key, newValue);
	    } else {
	      _assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	var _copyObject = copyObject;

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	var _baseTimes = baseTimes;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
	}

	var _baseIsArguments = baseIsArguments;

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
	  return isObjectLike_1(value) && hasOwnProperty$5.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	var isArguments_1 = isArguments;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	var isArray_1 = isArray;

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	var stubFalse_1 = stubFalse;

	var isBuffer_1 = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? _root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse_1;

	module.exports = isBuffer;
	});

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	var _isIndex = isIndex;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
	}

	var isLength_1 = isLength;

	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag$1 = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike_1(value) &&
	    isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
	}

	var _baseIsTypedArray = baseIsTypedArray;

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	var _baseUnary = baseUnary;

	var _nodeUtil = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && _freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule && freeModule.require && freeModule.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;
	});

	/* Node.js helper references. */
	var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

	var isTypedArray_1 = isTypedArray;

	/** Used for built-in method references. */
	var objectProto$7 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray_1(value),
	      isArg = !isArr && isArguments_1(value),
	      isBuff = !isArr && !isArg && isBuffer_1(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? _baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$6.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           _isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _arrayLikeKeys = arrayLikeKeys;

	/** Used for built-in method references. */
	var objectProto$8 = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$8;

	  return value === proto;
	}

	var _isPrototype = isPrototype;

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	var _overArg = overArg;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = _overArg(Object.keys, Object);

	var _nativeKeys = nativeKeys;

	/** Used for built-in method references. */
	var objectProto$9 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!_isPrototype(object)) {
	    return _nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$7.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeys = baseKeys;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength_1(value.length) && !isFunction_1(value);
	}

	var isArrayLike_1 = isArrayLike;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
	}

	var keys_1 = keys;

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && _copyObject(source, keys_1(source), object);
	}

	var _baseAssign = baseAssign;

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _nativeKeysIn = nativeKeysIn;

	/** Used for built-in method references. */
	var objectProto$a = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject_1(object)) {
	    return _nativeKeysIn(object);
	  }
	  var isProto = _isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty$8.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeysIn = baseKeysIn;

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn$1(object) {
	  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
	}

	var keysIn_1 = keysIn$1;

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn(object, source) {
	  return object && _copyObject(source, keysIn_1(source), object);
	}

	var _baseAssignIn = baseAssignIn;

	var _cloneBuffer = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? _root.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	module.exports = cloneBuffer;
	});

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	var _copyArray = copyArray;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	var _arrayFilter = arrayFilter;

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	var stubArray_1 = stubArray;

	/** Used for built-in method references. */
	var objectProto$b = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return _arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable$1.call(object, symbol);
	  });
	};

	var _getSymbols = getSymbols;

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return _copyObject(source, _getSymbols(source), object);
	}

	var _copySymbols = copySymbols;

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	var _arrayPush = arrayPush;

	/** Built-in value references. */
	var getPrototype = _overArg(Object.getPrototypeOf, Object);

	var _getPrototype = getPrototype;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
	  var result = [];
	  while (object) {
	    _arrayPush(result, _getSymbols(object));
	    object = _getPrototype(object);
	  }
	  return result;
	};

	var _getSymbolsIn = getSymbolsIn;

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn(source, object) {
	  return _copyObject(source, _getSymbolsIn(source), object);
	}

	var _copySymbolsIn = copySymbolsIn;

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
	}

	var _baseGetAllKeys = baseGetAllKeys;

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return _baseGetAllKeys(object, keys_1, _getSymbols);
	}

	var _getAllKeys = getAllKeys;

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn(object) {
	  return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
	}

	var _getAllKeysIn = getAllKeysIn;

	/* Built-in method references that are verified to be native. */
	var DataView = _getNative(_root, 'DataView');

	var _DataView = DataView;

	/* Built-in method references that are verified to be native. */
	var Promise$1 = _getNative(_root, 'Promise');

	var _Promise = Promise$1;

	/* Built-in method references that are verified to be native. */
	var Set$1 = _getNative(_root, 'Set');

	var _Set = Set$1;

	/* Built-in method references that are verified to be native. */
	var WeakMap = _getNative(_root, 'WeakMap');

	var _WeakMap = WeakMap;

	/** `Object#toString` result references. */
	var mapTag$1 = '[object Map]',
	    objectTag$1 = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag$1 = '[object Set]',
	    weakMapTag$1 = '[object WeakMap]';

	var dataViewTag$1 = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = _toSource(_DataView),
	    mapCtorString = _toSource(_Map),
	    promiseCtorString = _toSource(_Promise),
	    setCtorString = _toSource(_Set),
	    weakMapCtorString = _toSource(_WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = _baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$1) ||
	    (_Map && getTag(new _Map) != mapTag$1) ||
	    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
	    (_Set && getTag(new _Set) != setTag$1) ||
	    (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
	  getTag = function(value) {
	    var result = _baseGetTag(value),
	        Ctor = result == objectTag$1 ? value.constructor : undefined,
	        ctorString = Ctor ? _toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag$1;
	        case mapCtorString: return mapTag$1;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag$1;
	        case weakMapCtorString: return weakMapTag$1;
	      }
	    }
	    return result;
	  };
	}

	var _getTag = getTag;

	/** Used for built-in method references. */
	var objectProto$c = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty$9.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	var _initCloneArray = initCloneArray;

	/** Built-in value references. */
	var Uint8Array$1 = _root.Uint8Array;

	var _Uint8Array = Uint8Array$1;

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
	  return result;
	}

	var _cloneArrayBuffer = cloneArrayBuffer;

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView(dataView, isDeep) {
	  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	var _cloneDataView = cloneDataView;

	/** Used to match `RegExp` flags from their coerced string values. */
	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	var _cloneRegExp = cloneRegExp;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = _Symbol ? _Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol(symbol) {
	  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}

	var _cloneSymbol = cloneSymbol;

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	var _cloneTypedArray = cloneTypedArray;

	/** `Object#toString` result references. */
	var boolTag$1 = '[object Boolean]',
	    dateTag$1 = '[object Date]',
	    mapTag$2 = '[object Map]',
	    numberTag$1 = '[object Number]',
	    regexpTag$1 = '[object RegExp]',
	    setTag$2 = '[object Set]',
	    stringTag$1 = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag$1 = '[object ArrayBuffer]',
	    dataViewTag$2 = '[object DataView]',
	    float32Tag$1 = '[object Float32Array]',
	    float64Tag$1 = '[object Float64Array]',
	    int8Tag$1 = '[object Int8Array]',
	    int16Tag$1 = '[object Int16Array]',
	    int32Tag$1 = '[object Int32Array]',
	    uint8Tag$1 = '[object Uint8Array]',
	    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
	    uint16Tag$1 = '[object Uint16Array]',
	    uint32Tag$1 = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag$1:
	      return _cloneArrayBuffer(object);

	    case boolTag$1:
	    case dateTag$1:
	      return new Ctor(+object);

	    case dataViewTag$2:
	      return _cloneDataView(object, isDeep);

	    case float32Tag$1: case float64Tag$1:
	    case int8Tag$1: case int16Tag$1: case int32Tag$1:
	    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
	      return _cloneTypedArray(object, isDeep);

	    case mapTag$2:
	      return new Ctor;

	    case numberTag$1:
	    case stringTag$1:
	      return new Ctor(object);

	    case regexpTag$1:
	      return _cloneRegExp(object);

	    case setTag$2:
	      return new Ctor;

	    case symbolTag:
	      return _cloneSymbol(object);
	  }
	}

	var _initCloneByTag = initCloneByTag;

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject_1(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	var _baseCreate = baseCreate;

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !_isPrototype(object))
	    ? _baseCreate(_getPrototype(object))
	    : {};
	}

	var _initCloneObject = initCloneObject;

	/** `Object#toString` result references. */
	var mapTag$3 = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap(value) {
	  return isObjectLike_1(value) && _getTag(value) == mapTag$3;
	}

	var _baseIsMap = baseIsMap;

	/* Node.js helper references. */
	var nodeIsMap = _nodeUtil && _nodeUtil.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;

	var isMap_1 = isMap;

	/** `Object#toString` result references. */
	var setTag$3 = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet(value) {
	  return isObjectLike_1(value) && _getTag(value) == setTag$3;
	}

	var _baseIsSet = baseIsSet;

	/* Node.js helper references. */
	var nodeIsSet = _nodeUtil && _nodeUtil.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;

	var isSet_1 = isSet;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG = 4;

	/** `Object#toString` result references. */
	var argsTag$2 = '[object Arguments]',
	    arrayTag$1 = '[object Array]',
	    boolTag$2 = '[object Boolean]',
	    dateTag$2 = '[object Date]',
	    errorTag$1 = '[object Error]',
	    funcTag$2 = '[object Function]',
	    genTag$1 = '[object GeneratorFunction]',
	    mapTag$4 = '[object Map]',
	    numberTag$2 = '[object Number]',
	    objectTag$2 = '[object Object]',
	    regexpTag$2 = '[object RegExp]',
	    setTag$4 = '[object Set]',
	    stringTag$2 = '[object String]',
	    symbolTag$1 = '[object Symbol]',
	    weakMapTag$2 = '[object WeakMap]';

	var arrayBufferTag$2 = '[object ArrayBuffer]',
	    dataViewTag$3 = '[object DataView]',
	    float32Tag$2 = '[object Float32Array]',
	    float64Tag$2 = '[object Float64Array]',
	    int8Tag$2 = '[object Int8Array]',
	    int16Tag$2 = '[object Int16Array]',
	    int32Tag$2 = '[object Int32Array]',
	    uint8Tag$2 = '[object Uint8Array]',
	    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
	    uint16Tag$2 = '[object Uint16Array]',
	    uint32Tag$2 = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] =
	cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] =
	cloneableTags[boolTag$2] = cloneableTags[dateTag$2] =
	cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] =
	cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] =
	cloneableTags[int32Tag$2] = cloneableTags[mapTag$4] =
	cloneableTags[numberTag$2] = cloneableTags[objectTag$2] =
	cloneableTags[regexpTag$2] = cloneableTags[setTag$4] =
	cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] =
	cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] =
	cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
	cloneableTags[errorTag$1] = cloneableTags[funcTag$2] =
	cloneableTags[weakMapTag$2] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject_1(value)) {
	    return value;
	  }
	  var isArr = isArray_1(value);
	  if (isArr) {
	    result = _initCloneArray(value);
	    if (!isDeep) {
	      return _copyArray(value, result);
	    }
	  } else {
	    var tag = _getTag(value),
	        isFunc = tag == funcTag$2 || tag == genTag$1;

	    if (isBuffer_1(value)) {
	      return _cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag$2 || tag == argsTag$2 || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : _initCloneObject(value);
	      if (!isDeep) {
	        return isFlat
	          ? _copySymbolsIn(value, _baseAssignIn(result, value))
	          : _copySymbols(value, _baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = _initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new _Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet_1(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap_1(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? _getAllKeysIn : _getAllKeys)
	    : (isFlat ? keysIn : keys_1);

	  var props = isArr ? undefined : keysFunc(value);
	  _arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	var _baseClone = baseClone;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$1 = 1,
	    CLONE_SYMBOLS_FLAG$1 = 4;

	/**
	 * This method is like `_.clone` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.clone
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var deep = _.cloneDeep(objects);
	 * console.log(deep[0] === objects[0]);
	 * // => false
	 */
	function cloneDeep(value) {
	  return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
	}

	var cloneDeep_1 = cloneDeep;

	/**
	 * The options for a StyleControl object.
	 */
	var StyleControlOptions = /** @class */ (function (_super) {
	    __extends(StyleControlOptions, _super);
	    function StyleControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The layout to display the styles in.
	         * <p>`"icons"`: A row of clickable icons for each style.</p>
	         * <p>`"list"`: A scrollable list with the icons and names for each style.</p>
	         * Default `"icons"`
	         * @default "icons"
	         */
	        _this.layout = "icons";
	        /**
	         * The map styles to show in the control.
	         * Style names are case sensitive.
	         * If an included style isn't supported by the map it will be ignored.
	         * Available styles can be found in the
	         * [supported styles]{@link https://docs.microsoft.com/en-us/azure/azure-maps/supported-map-styles} article.
	         * If "all" is specified, all map styles will be shown.
	         * Default `["road", "grayscale_light", "grayscale_dark", "night", "road_shaded_relief"]`
	         * @default ["road", "grayscale_light", "grayscale_dark", "night", "road_shaded_relief"]
	         */
	        _this.mapStyles = [
	            "road",
	            "grayscale_light",
	            "grayscale_dark",
	            "night",
	            "road_shaded_relief",
	        ];
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`.
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        /**
	         * Whether to let style control automatically set the style, once user select a map style.
	         * If set to `false`, then clicking on style will not set the set the style automatically.
	         * Default `true`
	         */
	        _this.autoSelectionMode = true;
	        return _this;
	    }
	    return StyleControlOptions;
	}(Options));

	/**
	 * A control for changing the style of the map.
	 */
	var StyleControl = /** @class */ (function (_super) {
	    __extends(StyleControl, _super);
	    /**
	     * Constructs a StyleControl.
	     * @param options The options for the control.
	     */
	    function StyleControl(options) {
	        var _this = _super.call(this) || this;
	        _this.hasMouse = false;
	        _this.hasFocus = false;
	        _this.styleButtons = new Dictionary();
	        _this.styleIcons = new Dictionary();
	        /**
	         * Callback handler for the style changing.
	         */
	        _this.onStyleChange = function () {
	            if (_this.options.autoSelectionMode) {
	                var newStyle = _this.map.getStyle().style;
	                _this.setSelectedStyle(newStyle);
	            }
	        };
	        _this.options = new StyleControlOptions().merge(cloneDeep_1(options));
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    StyleControl.prototype.onAdd = function (map, options) {
	        var _this = this;
	        this.map = map;
	        var container = this.buildContainer(map, this.options.style, "Map Style Control");
	        var styleOpsGrid = this.buildStyleOpsGrid(container);
	        var currStyleButton = this.buildCurrStyleBtn(container, styleOpsGrid);
	        container.addEventListener("mouseover", function () {
	            _this.hasMouse = true;
	            container.classList.add(StyleControl.Css.inUse);
	            styleOpsGrid.classList.remove("hidden-accessible-element");
	        });
	        container.addEventListener("focusin", function () {
	            _this.hasFocus = true;
	            container.classList.add(StyleControl.Css.inUse);
	            styleOpsGrid.classList.remove("hidden-accessible-element");
	        });
	        container.addEventListener("mouseleave", function () {
	            _this.hasMouse = false;
	            if (!_this.hasFocus) {
	                container.classList.remove(StyleControl.Css.inUse);
	                styleOpsGrid.classList.add("hidden-accessible-element");
	            }
	        });
	        container.addEventListener("focusout", function (event) {
	            if (!(event.relatedTarget instanceof Node && container.contains(event.relatedTarget))) {
	                _this.hasFocus = false;
	                if (!_this.hasMouse) {
	                    container.classList.remove(StyleControl.Css.inUse);
	                    styleOpsGrid.classList.add("hidden-accessible-element");
	                }
	            }
	        });
	        if (options && StyleControl.InvertOrderPositions.includes(options.position)) {
	            container.appendChild(styleOpsGrid);
	            container.appendChild(currStyleButton);
	        }
	        else {
	            container.appendChild(currStyleButton);
	            container.appendChild(styleOpsGrid);
	        }
	        return container;
	    };
	    /**
	     * Method that is called when the control is removed from the map. Should perform any necessary cleanup for the
	     * control.
	     */
	    StyleControl.prototype.onRemove = function () {
	        _super.prototype.onRemove.call(this);
	        this.styleButtons.clear();
	        this.map.events.remove("styledata", this.onStyleChange);
	    };
	    /**
	     * Set the style that need to be displayed as currently selected.
	     * Style will automatically get selected if `StyleControlOptions.autoSelectionMode` is `true`
	     * @param styleName - Style name that need to be disabled as currently selected
	     */
	    StyleControl.prototype.setSelectedStyle = function (styleName) {
	        if (this.styleIcons.has(styleName)) {
	            var image = this.currStyleImage;
	            var newSrc = this.styleIcons.get(styleName);
	            if (image.src !== newSrc) {
	                image.src = newSrc;
	            }
	            var newAlt = this.mapToFriendlyStyleName(styleName);
	            if (image.alt !== newAlt) {
	                image.alt = newAlt;
	            }
	        }
	    };
	    /**
	     * Set style in a disabled state
	     * @param styleName Style to be disabled
	     */
	    StyleControl.prototype.disableStyle = function (styleName) {
	        var styleButton = this.styleButtons[styleName];
	        if (styleButton) {
	            styleButton.setAttribute("disabled", "true");
	        }
	    };
	    /**
	     * Enabled style that was previously disabled
	     * @param styleName Style to be disabled
	     */
	    StyleControl.prototype.enableStyle = function (styleName) {
	        var styleButton = this.styleButtons[styleName];
	        if (styleButton) {
	            styleButton.removeAttribute("disabled");
	        }
	    };
	    StyleControl.prototype.buildSelectStyleBtn = function (name, icon) {
	        var _this = this;
	        var styleOptionButton = document.createElement("button");
	        var friendlyName = this.mapToFriendlyStyleName(name);
	        styleOptionButton.setAttribute("title", friendlyName);
	        styleOptionButton.setAttribute("alt", friendlyName);
	        styleOptionButton.setAttribute("type", "button");
	        var styleIconImage = new Image();
	        styleIconImage.src = icon;
	        styleIconImage.alt = friendlyName;
	        styleOptionButton.appendChild(styleIconImage);
	        if (this.options.layout === "icons") {
	            styleOptionButton.classList.add(StyleControl.Css.button);
	        }
	        else {
	            styleOptionButton.appendChild(document.createTextNode(friendlyName));
	        }
	        styleOptionButton.addEventListener("click", function () {
	            var styleButton = _this.styleButtons[name];
	            if (styleButton && !styleButton.hasAttribute("disabled")) {
	                _this._invokeEvent("styleselected", name);
	                if (_this.options.autoSelectionMode) {
	                    _this.map.setStyle({ style: name });
	                }
	            }
	        });
	        return styleOptionButton;
	    };
	    StyleControl.prototype.buildCurrStyleBtn = function (container, opsGrid) {
	        var selectCurrButton = document.createElement("button");
	        selectCurrButton.classList.add(StyleControl.Css.button);
	        selectCurrButton.classList.add(StyleControl.Css.currentStyle);
	        selectCurrButton.setAttribute("title", "Select Style");
	        selectCurrButton.setAttribute("alt", "Select Style");
	        selectCurrButton.setAttribute("type", "button");
	        this.currStyleImage = new Image();
	        selectCurrButton.appendChild(this.currStyleImage);
	        var selectCurrButtonIcon = document.createElement("div");
	        selectCurrButtonIcon.classList.add("icon");
	        selectCurrButton.appendChild(selectCurrButtonIcon);
	        return selectCurrButton;
	    };
	    StyleControl.prototype.buildStyleOpsGrid = function (container) {
	        var _this = this;
	        var styleOpsGrid = document.createElement("div");
	        styleOpsGrid.classList.add(StyleControl.Css.styleOptions);
	        styleOpsGrid.classList.add(this.options.layout);
	        styleOpsGrid.setAttribute("aria-label", "Style Options");
	        styleOpsGrid.classList.add("hidden-accessible-element");
	        // Once the map's style definition is initialized create a map between style names and icons.
	        // If a style is one of those to be shown by the style picker also create it's element.
	        this.map.styles.initialize().then(function () {
	            var e_1, _a, _b;
	            var styleDef = _this.map.styles.getDef();
	            var currStyle = _this.map.getStyle().style;
	            try {
	                for (var _c = __values(styleDef.styles), _d = _c.next(); !_d.done; _d = _c.next()) {
	                    var style = _d.value;
	                    var iconUrl = style.thumbnail;
	                    // It will make sure anyone using custom endpoint for style definition,
	                    // can use there own custom thumbnail url.
	                    if (iconUrl.indexOf(constants.stylePathHolder) > -1 ||
	                        iconUrl.indexOf(constants.styleResourcePlaceholder) > -1) {
	                        iconUrl = new Url({
	                            domain: env.staticAssetsDomain,
	                            path: style.thumbnail
	                                .replace(constants.stylePathHolder, constants.stylePath)
	                                .replace(constants.styleResourcePlaceholder, constants.styleResourcePath),
	                            queryParams: (_b = {},
	                                _b[constants.apiVersionQueryParameter] = constants.styleApiVersion,
	                                _b)
	                        }).toString();
	                    }
	                    // Always add a style even if it won't be shown by the style picker.
	                    // This way the map's style can be set to something other than the picker.
	                    // The style picker will still show the correct icon.
	                    _this.styleIcons.set(style.name, iconUrl);
	                    if (style.name === currStyle) {
	                        _this.currStyleImage.src = iconUrl;
	                        _this.currStyleImage.alt = _this.mapToFriendlyStyleName(style.name);
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            if (_this.options.mapStyles === "all") {
	                _this.styleIcons.forEach(function (iconUrl, styleName) {
	                    var styleOptionButton = _this.buildSelectStyleBtn(styleName, iconUrl);
	                    styleOpsGrid.appendChild(styleOptionButton);
	                    _this.styleButtons[styleName] = styleOptionButton;
	                });
	            }
	            else {
	                _this.options.mapStyles.filter(function (styleName) { return _this.styleIcons.has(styleName); }).forEach(function (styleName) {
	                    var iconUrl = _this.styleIcons.get(styleName);
	                    var styleOptionButton = _this.buildSelectStyleBtn(styleName, iconUrl);
	                    styleOpsGrid.appendChild(styleOptionButton);
	                    _this.styleButtons[styleName] = styleOptionButton;
	                });
	            }
	            _this.map.events.add("styledata", _this.onStyleChange);
	        });
	        return styleOpsGrid;
	    };
	    StyleControl.prototype.mapToFriendlyStyleName = function (name) {
	        // TODO: Bug 9984684 - Revert indoor specific logic her.
	        return StyleControl.StyleNamesMap[name] ?
	            StyleControl.StyleNamesMap[name] :
	            StyleControl.StyleNamesMap[name + "_indoor"] ?
	                StyleControl.StyleNamesMap[name + "_indoor"] :
	                name;
	    };
	    StyleControl.InvertOrderPositions = [exports.ControlPosition.TopRight, exports.ControlPosition.BottomRight];
	    StyleControl.Css = {
	        button: "azure-maps-control-button",
	        currentStyle: "curr-style",
	        inUse: "in-use",
	        styleOptions: "style-options"
	    };
	    StyleControl.StyleNamesMap = {
	        road: "Road",
	        satellite: "Satellite",
	        satellite_road_labels: "Hybrid",
	        grayscale_dark: "Grayscale (Dark)",
	        grayscale_light: "Grayscale (Light)",
	        night: "Night",
	        road_shaded_relief: "Terra",
	        blank: "Blank",
	        blank_accessible: "Blank (Accessible)",
	        high_contrast_dark: "High contrast (Dark)",
	        high_contrast_light: "High contrast (Light)"
	    };
	    return StyleControl;
	}(ControlBase));

	/**
	 * The options for a TrafficControl object.
	 */
	var TrafficControlOptions = /** @class */ (function (_super) {
	    __extends(TrafficControlOptions, _super);
	    function TrafficControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The type of traffic flow to display:
	         * <p>"none" is to display no traffic flow data</p>
	         * <p>"relative" is the speed of the road relative to free-flow</p>
	         * <p>"absolute" is the absolute speed of the road</p>
	         * <p>"relative-delay" displays relative speed only where they differ from free-flow;
	         * false to stop displaying the traffic flow.</p>
	         * default `"relative"``
	         * @default "relative"
	         */
	        _this.flow = "relative";
	        /**
	         * Whether to display incidents on the map.
	         * default `true`
	         * @default true
	         */
	        _this.incidents = true;
	        /**
	         * Specifies if the control is in the active state (displaying traffic).
	         * Default: false
	         * @default false
	         */
	        _this.isActive = false;
	        /**
	         * The style of the control. Can be; light, dark, auto, or any CSS3 color. When set to auto, the style will change based on the map style.
	         * Default `light'.
	         * @default light
	         */
	        _this.style = exports.ControlStyle.light;
	        return _this;
	    }
	    return TrafficControlOptions;
	}(Options));

	/**
	 * A control that toggles traffic data on the map.
	 */
	var TrafficControl = /** @class */ (function (_super) {
	    __extends(TrafficControl, _super);
	    /**
	     * Constructs a TrafficControl
	     * @param options The options for the control.
	     */
	    function TrafficControl(options) {
	        var _this = _super.call(this) || this;
	        _this.hasMouse = false;
	        _this.hasFocus = false;
	        _this.options = new TrafficControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    TrafficControl.prototype.onAdd = function (map) {
	        this.container = this.buildContainer(map, this.options.style, "Traffic Control");
	        this.container.style.flexDirection = "column";
	        var trafficButton = this.constructTrafficButton(map);
	        this.container.appendChild(trafficButton);
	        return this.container;
	    };
	    /**
	     * Get the TrafficControlOptions
	     */
	    TrafficControl.prototype.getOptions = function () {
	        return cloneDeep_1(this.options);
	    };
	    TrafficControl.prototype.constructTrafficButton = function (map) {
	        var _this = this;
	        var trafficButton = document.createElement("button");
	        trafficButton.classList.add("azure-maps-control-button");
	        trafficButton.classList.add("traffic");
	        trafficButton.setAttribute("title", "Toggle Traffic Display");
	        trafficButton.setAttribute("alt", "Toggle Traffic Display");
	        trafficButton.setAttribute("type", "button");
	        // toggle button
	        trafficButton.addEventListener("click", function () {
	            var t = map.getTraffic();
	            _this.options.isActive = !(t.flow !== "none" || t.incidents);
	            if (_this.options.isActive) {
	                map.setTraffic({
	                    flow: _this.options.flow,
	                    incidents: _this.options.incidents
	                });
	                _this.container.classList.add("in-use");
	            }
	            else {
	                map.setTraffic({
	                    flow: "none",
	                    incidents: false
	                });
	                _this.container.classList.remove("in-use");
	            }
	        });
	        map.events.addOnce("styledata", function () {
	            if (_this.options.isActive) {
	                trafficButton.dispatchEvent(new Event("click"));
	            }
	        });
	        return trafficButton;
	    };
	    return TrafficControl;
	}(ControlBase));

	/**
	 * A control that display traffic legend on the map.
	 */
	var TrafficLegendControl = /** @class */ (function (_super) {
	    __extends(TrafficLegendControl, _super);
	    /**
	     * Construct a traffic legend control
	     */
	    function TrafficLegendControl() {
	        var _this = _super.call(this) || this;
	        _this.table = ["Fast",
	            ["green", "yellow", "red", "dark-red"],
	            "Slow"];
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    TrafficLegendControl.prototype.onAdd = function (map) {
	        var container = this.buildContainer(map, exports.ControlStyle.auto, "Traffic Legend");
	        var TrafficLegendDiv = this.buildTrafficLegendDiv(map);
	        container.appendChild(TrafficLegendDiv);
	        return container;
	    };
	    TrafficLegendControl.prototype.buildTrafficLegendDiv = function (map) {
	        var e_1, _a, e_2, _b;
	        var trafficLegend = document.createElement("div");
	        trafficLegend.classList.add("traffic-legend", "hidden");
	        trafficLegend.setAttribute("title", "Traffic Legend");
	        trafficLegend.setAttribute("alt", "Traffic Legend");
	        var trafficLegendTable = document.createElement("table");
	        // legend table title
	        var tr1 = document.createElement("tr");
	        var td = document.createElement("td");
	        td.setAttribute("title", "Traffic");
	        td.setAttribute("alt", "Traffic");
	        td.appendChild(document.createTextNode("Traffic"));
	        td.classList.add("traffic-legend-title");
	        td.colSpan = 6;
	        tr1.appendChild(td);
	        trafficLegendTable.appendChild(tr1);
	        // legend table contents
	        var tr2 = document.createElement("tr");
	        try {
	            for (var _c = __values(this.table), _d = _c.next(); !_d.done; _d = _c.next()) {
	                var col = _d.value;
	                var data = document.createElement("td");
	                if (col === "Fast" || col === "Slow") {
	                    data.setAttribute("title", col);
	                    data.setAttribute("alt", col);
	                    data.appendChild(document.createTextNode(col));
	                    data.classList.add("traffic-legend-text");
	                }
	                else {
	                    data.classList.add("traffic-legend-colors");
	                    try {
	                        for (var col_1 = (e_2 = void 0, __values(col)), col_1_1 = col_1.next(); !col_1_1.done; col_1_1 = col_1.next()) {
	                            var color = col_1_1.value;
	                            var div = document.createElement("div");
	                            div.classList.add(color);
	                            data.appendChild(div);
	                        }
	                    }
	                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                    finally {
	                        try {
	                            if (col_1_1 && !col_1_1.done && (_b = col_1.return)) _b.call(col_1);
	                        }
	                        finally { if (e_2) throw e_2.error; }
	                    }
	                }
	                tr2.appendChild(data);
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        trafficLegendTable.appendChild(tr2);
	        trafficLegend.appendChild(trafficLegendTable);
	        // display legend when the traffic flow is shown, hide it otherwise
	        map.events.add("styledata", function (eventData) {
	            if (eventData.dataType === "style") {
	                var trafficOptions = map.getTraffic();
	                if (trafficOptions.flow && trafficOptions.flow !== "none") {
	                    trafficLegend.classList.remove("hidden");
	                }
	                else {
	                    trafficLegend.classList.add("hidden");
	                }
	            }
	        });
	        return trafficLegend;
	    };
	    return TrafficLegendControl;
	}(ControlBase));

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED$2);
	  return this;
	}

	var _setCacheAdd = setCacheAdd;

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	var _setCacheHas = setCacheHas;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new _MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
	SetCache.prototype.has = _setCacheHas;

	var _SetCache = SetCache;

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	var _arraySome = arraySome;

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	var _cacheHas = cacheHas;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!_arraySome(other, function(othValue, othIndex) {
	            if (!_cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	var _equalArrays = equalArrays;

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	var _mapToArray = mapToArray;

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	var _setToArray = setToArray;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$1 = 1,
	    COMPARE_UNORDERED_FLAG$1 = 2;

	/** `Object#toString` result references. */
	var boolTag$3 = '[object Boolean]',
	    dateTag$3 = '[object Date]',
	    errorTag$2 = '[object Error]',
	    mapTag$5 = '[object Map]',
	    numberTag$3 = '[object Number]',
	    regexpTag$3 = '[object RegExp]',
	    setTag$5 = '[object Set]',
	    stringTag$3 = '[object String]',
	    symbolTag$2 = '[object Symbol]';

	var arrayBufferTag$3 = '[object ArrayBuffer]',
	    dataViewTag$4 = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
	    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag$4:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag$3:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag$3:
	    case dateTag$3:
	    case numberTag$3:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq_1(+object, +other);

	    case errorTag$2:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag$3:
	    case stringTag$3:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag$5:
	      var convert = _mapToArray;

	    case setTag$5:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
	      convert || (convert = _setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG$1;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag$2:
	      if (symbolValueOf$1) {
	        return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
	      }
	  }
	  return false;
	}

	var _equalByTag = equalByTag;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$2 = 1;

	/** Used for built-in method references. */
	var objectProto$d = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$a = objectProto$d.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
	      objProps = _getAllKeys(object),
	      objLength = objProps.length,
	      othProps = _getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty$a.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	var _equalObjects = equalObjects;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$3 = 1;

	/** `Object#toString` result references. */
	var argsTag$3 = '[object Arguments]',
	    arrayTag$2 = '[object Array]',
	    objectTag$3 = '[object Object]';

	/** Used for built-in method references. */
	var objectProto$e = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$b = objectProto$e.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray_1(object),
	      othIsArr = isArray_1(other),
	      objTag = objIsArr ? arrayTag$2 : _getTag(object),
	      othTag = othIsArr ? arrayTag$2 : _getTag(other);

	  objTag = objTag == argsTag$3 ? objectTag$3 : objTag;
	  othTag = othTag == argsTag$3 ? objectTag$3 : othTag;

	  var objIsObj = objTag == objectTag$3,
	      othIsObj = othTag == objectTag$3,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer_1(object)) {
	    if (!isBuffer_1(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new _Stack);
	    return (objIsArr || isTypedArray_1(object))
	      ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
	    var objIsWrapped = objIsObj && hasOwnProperty$b.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty$b.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new _Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new _Stack);
	  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	var _baseIsEqualDeep = baseIsEqualDeep;

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
	    return value !== value && other !== other;
	  }
	  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	var _baseIsEqual = baseIsEqual;

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return _baseIsEqual(value, other);
	}

	var isEqual_1 = isEqual;

	var _nodeResolve_empty = {};

	var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': _nodeResolve_empty
	});

	var require$$0 = getCjsExportFromNamespace(_nodeResolve_empty$1);

	var uuidRandom = createCommonjsModule(function (module) {

	(function(){

	  var
	    buf,
	    bufIdx = 0,
	    hexBytes = [],
	    i
	  ;

	  // Pre-calculate toString(16) for speed
	  for (i = 0; i < 256; i++) {
	    hexBytes[i] = (i + 0x100).toString(16).substr(1);
	  }

	  // Buffer random numbers for speed
	  // Reduce memory usage by decreasing this number (min 16)
	  // or improve speed by increasing this number (try 16384)
	  uuid.BUFFER_SIZE = 4096;

	  // Binary uuids
	  uuid.bin = uuidBin;

	  // Clear buffer
	  uuid.clearBuffer = function() {
	    buf = null;
	    bufIdx = 0;
	  };

	  // Test for uuid
	  uuid.test = function(uuid) {
	    if (typeof uuid === 'string') {
	      return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid);
	    }
	    return false;
	  };

	  // Node & Browser support
	  var crypt0;
	  if (typeof crypto !== 'undefined') {
	    crypt0 = crypto;
	  } else if( (typeof window !== 'undefined') && (typeof window.msCrypto !== 'undefined')) {
	    crypt0 = window.msCrypto; // IE11
	  }

	  if ( (typeof commonjsRequire === 'function')) {
	    crypt0 = crypt0 || require$$0;
	    module.exports = uuid;
	  } else if (typeof window !== 'undefined') {
	    window.uuid = uuid;
	  }

	  // Use best available PRNG
	  // Also expose this so you can override it.
	  uuid.randomBytes = (function(){
	    if (crypt0) {
	      if (crypt0.randomBytes) {
	        return crypt0.randomBytes;
	      }
	      if (crypt0.getRandomValues) {
	        if (typeof Uint8Array.prototype.slice !== 'function') {
	          return function(n) {
	            var bytes = new Uint8Array(n);
	            crypt0.getRandomValues(bytes);
	            return Array.from(bytes);
	          };
	        }
	        return function(n) {
	          var bytes = new Uint8Array(n);
	          crypt0.getRandomValues(bytes);
	          return bytes;
	        };
	      }
	    }
	    return function(n) {
	      var i, r = [];
	      for (i = 0; i < n; i++) {
	        r.push(Math.floor(Math.random() * 256));
	      }
	      return r;
	    };
	  })();

	  // Buffer some random bytes for speed
	  function randomBytesBuffered(n) {
	    if (!buf || ((bufIdx + n) > uuid.BUFFER_SIZE)) {
	      bufIdx = 0;
	      buf = uuid.randomBytes(uuid.BUFFER_SIZE);
	    }
	    return buf.slice(bufIdx, bufIdx += n);
	  }

	  // uuid.bin
	  function uuidBin() {
	    var b = randomBytesBuffered(16);
	    b[6] = (b[6] & 0x0f) | 0x40;
	    b[8] = (b[8] & 0x3f) | 0x80;
	    return b;
	  }

	  // String UUIDv4 (Random)
	  function uuid() {
	    var b = uuidBin();
	    return hexBytes[b[0]] + hexBytes[b[1]] +
	      hexBytes[b[2]] + hexBytes[b[3]] + '-' +
	      hexBytes[b[4]] + hexBytes[b[5]] + '-' +
	      hexBytes[b[6]] + hexBytes[b[7]] + '-' +
	      hexBytes[b[8]] + hexBytes[b[9]] + '-' +
	      hexBytes[b[10]] + hexBytes[b[11]] +
	      hexBytes[b[12]] + hexBytes[b[13]] +
	      hexBytes[b[14]] + hexBytes[b[15]]
	    ;
	  }

	})();
	});

	/**
	 * A GeoJSON Feature object - a JSON object representing a spatially bounded entity. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.2}.
	 */
	var Feature = /** @class */ (function () {
	    /**
	     * Constructs a Feature.
	     * @param geometry The geometry of the feature.
	     * @param properties The properties of the feature.
	     * @param id The id of the feature.
	     * @param bbox The bounding box of the feature.
	     */
	    function Feature(geometry, properties, id, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "Feature".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "Feature";
	        this.type = Feature.TYPE;
	        this.properties = properties || {};
	        this.id = id;
	        this.geometry = geometry;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the Feature class to be used in runtime comparisons.
	     */
	    Feature.TYPE = "Feature";
	    return Feature;
	}());

	/**
	 * Represent a pixel coordinate or offset. Extends an array of [x, y].
	 */
	var Pixel = /** @class */ (function (_super) {
	    __extends(Pixel, _super);
	    /**
	     * Constructs a Pixel object and initializes it with the specified x and y coordinates.
	     * @param x The horizontal pixel offset.
	     * @param y The vertical pixel offset.
	     */
	    function Pixel(x, y) {
	        return _super.call(this, x, y) || this;
	    }
	    /**
	     * Generates a Pixel object from an object that contains coordinate information.
	     * The object is scanned for x and y properties using a case insensitive test.
	     * @param data The object to extract coordinate information from.
	     * @returns A Pixel object that represents the provided data information.
	     */
	    Pixel.fromData = function (data) {
	        var x = NaN;
	        var y = NaN;
	        var xNames = new Set(["y"]);
	        var yNames = new Set(["x"]);
	        // Do a case insensitive search through the object properties.
	        Object.keys(data).forEach(function (key) {
	            var smallKey = key.toLowerCase();
	            if (isNaN(x) && xNames.has(smallKey) && typeof data[key] === "number") {
	                x = data[key];
	            }
	            else if (isNaN(y) && yNames.has(smallKey) && typeof data[key] === "number") {
	                y = data[key];
	            }
	        });
	        // If an x and y value were found return the Pixel constructed from them.
	        if (!isNaN(x) && !isNaN(y)) {
	            return new Pixel(x, y);
	        }
	        return null;
	    };
	    /**
	     * Return the x coordinate of the specified pixel.
	     * @param pixel The pixel to get the x coordinate of.
	     */
	    Pixel.getX = function (pixel) {
	        if (pixel.length > 0) {
	            return pixel[0];
	        }
	        return NaN;
	    };
	    /**
	     * Return the y coordinate of the specified pixel.
	     * @param pixel The pixel to get the y coordinate of.
	     */
	    Pixel.getY = function (pixel) {
	        if (pixel.length > 1) {
	            return pixel[1];
	        }
	        return NaN;
	    };
	    /**
	     * Calculates a destination pixel given an origin pixel,​
	     * a heading relative to the y-axis (0 = north) with clockwise-rotation,​
	     * and a distance in pixel units.​
	     * @param origin The starting pixel.​
	     * @param heading The heading at which to move away from the origin pixel.​
	     * @param distance The distance to move from the origin pixel.​
	     */
	    Pixel.getDestination = function (origin, heading, distance) {
	        return new Pixel(Pixel.getX(origin) + distance * Math.cos((heading + 270) * Math.PI / 180), Pixel.getY(origin) + distance * Math.sin((heading + 270) * Math.PI / 180));
	    };
	    /**
	     * Calculates the distance between two pixels.
	     * Returned value is in screen pixel units.
	     * @param p1 The first pixel.
	     * @param p2 The second pixel.
	     */
	    Pixel.getDistance = function (p1, p2) {
	        var dx = Pixel.getX(p1) - Pixel.getX(p2);
	        var dy = Pixel.getY(p1) - Pixel.getY(p2);
	        return Math.sqrt(dx * dx + dy * dy);
	    };
	    /**​
	     * Calculates the heading between two pixels.​ The heading value is relative to the y-axis (0 = north) with clockwise-rotation.
	     * @param origin The pixel the heading will point away from.​
	     * @param destination The pixel the heading will point toward.​
	     */
	    Pixel.getHeading = function (origin, destination) {
	        var dx = Pixel.getX(destination) - Pixel.getX(origin);
	        var dy = Pixel.getY(origin) - Pixel.getY(destination);
	        return ((5 / 2 * Math.PI) - Math.atan2(dy, dx)) * 180 / Math.PI % 360;
	    };
	    return Pixel;
	}(Array));

	/**
	 * A GeoJSON Point object - a JSON object that represents a geographic position. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.2}.
	 */
	var Point = /** @class */ (function () {
	    /**
	     * Constructs a Point.
	     * @param coordinates The position defining the point.
	     */
	    function Point(coordinates) {
	        /**
	         * A GeoJSON type descriptor with value "Point".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "Point";
	        this.type = Point.TYPE;
	        this.coordinates = coordinates;
	    }
	    /**
	     * A static GeoJSON type descriptor for the Point class to be used in runtime comparisons.
	     */
	    Point.TYPE = "Point";
	    return Point;
	}());

	var arrayPoints = createCommonjsModule(function (module, exports) {
	exports.__esModule = true;
	function getAddedSquaresAP(dx, dy) {
	    return dx * dx + dy * dy;
	}
	function getSqDistAP(p1, p2) {
	    return getAddedSquaresAP(p1[0] - p2[0], p1[1] - p2[1]);
	}
	function getSqSegDistAP(p, p1, p2) {
	    var x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;
	    if (dx !== 0 || dy !== 0) {
	        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / getAddedSquaresAP(dx, dy);
	        if (t > 1) {
	            x = p2[0];
	            y = p2[1];
	        }
	        else if (t > 0) {
	            x += dx * t;
	            y += dy * t;
	        }
	    }
	    return getAddedSquaresAP(p[0] - x, p[1] - y);
	}
	function simplifyRadialDistAP(points, sqTolerance) {
	    var prevPoint = points[0], point;
	    var newPoints = [prevPoint];
	    for (var i = 1, len = points.length; i < len; i++) {
	        point = points[i];
	        if (getSqDistAP(point, prevPoint) > sqTolerance) {
	            newPoints.push(point);
	            prevPoint = point;
	        }
	    }
	    if (prevPoint !== point) {
	        newPoints.push(point);
	    }
	    return newPoints;
	}
	function simplifyDPStepAP(points, first, last, sqTolerance, simplified) {
	    var maxSqDist = sqTolerance, index;
	    for (var i = first + 1; i < last; i++) {
	        var sqDist = getSqSegDistAP(points[i], points[first], points[last]);
	        if (sqDist > maxSqDist) {
	            index = i;
	            maxSqDist = sqDist;
	        }
	    }
	    if (maxSqDist > sqTolerance) {
	        if (index - first > 1) {
	            simplifyDPStepAP(points, first, index, sqTolerance, simplified);
	        }
	        simplified.push(points[index]);
	        if (last - index > 1) {
	            simplifyDPStepAP(points, index, last, sqTolerance, simplified);
	        }
	    }
	}
	function simplifyDouglasPeuckerAP(points, sqTolerance) {
	    var last = points.length - 1;
	    var simplified = [points[0]];
	    simplifyDPStepAP(points, 0, last, sqTolerance, simplified);
	    simplified.push(points[last]);
	    return simplified;
	}
	function SimplifyAP(points, tolerance, highestQuality) {
	    if (tolerance === void 0) { tolerance = 1; }
	    if (highestQuality === void 0) { highestQuality = false; }
	    if (points.length <= 2) {
	        return points;
	    }
	    var sqTolerance = tolerance * tolerance;
	    points = highestQuality ? points : simplifyRadialDistAP(points, sqTolerance);
	    points = simplifyDouglasPeuckerAP(points, sqTolerance);
	    return points;
	}
	exports.SimplifyAP = SimplifyAP;
	});

	unwrapExports(arrayPoints);
	var arrayPoints_1 = arrayPoints.SimplifyAP;

	//////////////////////
	/// Constants
	//////////////////////
	/**
	 * Earth Radius Semi Major Axis in meters
	 */
	var EARTH_RADIUS_SEMI_MAJOR_AXIS = 6378137;
	/**
	 * A constant for Math.PI/180. Using this constant is upto 3 times faster than always doing the calculation.
	 */
	var PI_BY_180 = Math.PI / 180;
	/**
	 * A constant for 180 / Math.PI. Using this constant is upto 3 times faster than always doing the calculation.
	 */
	var INV_PI_BY_180 = 180 / Math.PI;
	/**
	 * Cached array of powers of 10. This will be faster than call Math.pow.
	 */
	var POWERS_OF_10 = [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];
	//////////////////////
	/// Private Functions
	//////////////////////
	/**
	 * Converts an angle that is in degrees to radians. Angle * (PI / 180).
	 * @param angle An angle in degrees.
	 * @returns An angle in radians.
	 */
	function _toRadians(angle) {
	    return angle * PI_BY_180;
	}
	/**
	 * Converts an angle that is in radians to degrees. Angle * (180 / PI).
	 * @param angle An angle in radians.
	 * @returns An angle in degrees.
	 */
	function _toDegrees(angle) {
	    return angle * INV_PI_BY_180;
	}
	/**
	 * Clips a number to the specified minimum and maximum values.
	 * @param val The number to clip.
	 * @param minValue Minimum allowable value.
	 * @param maxValue Maximum allowable value.
	 * @returns The clipped value.
	 */
	function _clip(val, minValue, maxValue) {
	    return Math.min(Math.max(val, minValue), maxValue);
	}
	/**
	 * Calculates geodetic distance between two Position objects using Haversine formula in meters.
	 * @param origin Position to calculate distance from.
	 * @param destination Position to calculate distance to.
	 * @returns A distance in meters between the two positions.
	 */
	function _haversineDistance(origin, destination) {
	    // https://en.wikipedia.org/wiki/Haversine_formula
	    var dLat = _toRadians(destination[1] - origin[1]);
	    var dLon = _toRadians(destination[0] - origin[0]);
	    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(_toRadians(origin[1])) * Math.cos(_toRadians(destination[1])) * Math.pow(Math.sin(dLon / 2), 2);
	    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	    return Math.round(EARTH_RADIUS_SEMI_MAJOR_AXIS * c * 100) / 100; // Round to 1cm precision.
	}
	/**
	 * Normalizes a distance unit string. Defaults to meters.
	 * @param units The distance units to normalize.
	 * @returns A normalized distance unit string.
	 */
	function _normalizeDistanceUnit(units) {
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "feet":
	            case "foot":
	            case "ft":
	                return DistanceUnits.feet;
	            case "kilometers":
	            case "kilometer":
	            case "kilometres":
	            case "kilometre":
	            case "km":
	            case "kms":
	                return DistanceUnits.kilometers;
	            case "miles":
	            case "mile":
	            case "mi":
	                return DistanceUnits.miles;
	            case "nauticalmiles":
	            case "nauticalmile":
	            case "nms":
	            case "nm":
	                return DistanceUnits.nauticalMiles;
	            case "yards":
	            case "yard":
	            case "yds":
	            case "yrd":
	            case "yrds":
	                return DistanceUnits.yards;
	            case "meters":
	            case "metres":
	            case "m":
	            default:
	                return DistanceUnits.meters;
	        }
	    }
	    return DistanceUnits.meters;
	}
	/**
	 * Normailzes a acceleration unit string. Defaults to metersPerSecondSquared.
	 * Supported units:
	 *    milesPerSecondSquared, kilometersPerSecondSquared, metersPerSecondSquared, feetPerSecondSquared
	 *    yardsPerSecondSquared, kilometersPerHoursSecond, milesPerHourSecond, knotsPerSecond, standardGravity
	 * @param units The acceleration units to normalize.
	 * @returns A normailzed acceleration unit string.
	 */
	function _normalizeAccelerationUnit(units) {
	    // Convert to metersPerSecondSquared
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "milespersecondsquared": // mi/s^2
	            case "milepersecondsquared":
	            case "mi/s^2":
	            case "mi/s2":
	                return AccelerationUnits.milesPerSecondSquared;
	            case "kilometerspersecondsquared": // km/s^2
	            case "kilometrespersecondsquared":
	            case "kilometerpersecondsquared":
	            case "kilometrepersecondsquared":
	            case "km/s^2":
	            case "km/s2":
	                return AccelerationUnits.kilometersPerSecondSquared;
	            case "knotspersecond": // knts/s
	            case "knotpersecond":
	            case "knts/s":
	            case "kn/s":
	            case "kt/s":
	                return AccelerationUnits.knotsPerSecond;
	            case "standardgravity": // g
	            case "g":
	                return AccelerationUnits.standardGravity;
	            case "feetpersecondsquared": // ft/s^2
	            case "footpersecondsquared":
	            case "ft/s^2":
	            case "ft/s2":
	                return AccelerationUnits.feetPerSecondSquared;
	            case "yardspersecondsquared": // yds/s^2
	            case "yardpersecondsquared":
	            case "yds/s^2":
	            case "yds/s2":
	            case "yd/s^2":
	            case "yd/s2":
	                return AccelerationUnits.yardsPerSecondSquared;
	            case "milesperhoursecond": // mi/h/s
	            case "mileperhoursecond":
	            case "milesperhourseconds":
	            case "mileperhourseconds":
	            case "mi/h/s":
	                return AccelerationUnits.milesPerHourSecond;
	            case "kilometersperhoursecond": // km/h/s
	            case "kilometrespersoursecond":
	            case "kilometerperhoursecond":
	            case "kilometrepersoursecond":
	            case "kilometersperhourssecond":
	            case "kilometrespersourssecond":
	            case "kilometerperhourssecond":
	            case "kilometrepersourssecond":
	            case "kmhs":
	            case "km/h/s":
	                return AccelerationUnits.kilometersPerHourSecond;
	            case "meterspersecondsquared": // m/s^2
	            case "metrespersecondsquared":
	            case "meterpersecondsquared":
	            case "metrepersecondsquared":
	            case "m/s^2":
	            case "m/s2":
	            default:
	                return AccelerationUnits.metersPerSecondSquared;
	        }
	    }
	    return AccelerationUnits.metersPerSecondSquared;
	}
	/**
	 * Normailzes an area unit string. Defaults to squareMeters.
	 * @param units The area units to normalize.
	 * @returns A normailzed area unit string.
	 */
	function _normalizeAreaUnits(units) {
	    if (units) {
	        switch (units) {
	            case "acres":
	            case "ac":
	                return AreaUnits.acres;
	            case "hectares":
	            case "ha":
	                return AreaUnits.hectares;
	            case "squareFeet":
	            case "ft^2":
	            case "ft2":
	                return AreaUnits.squareFeet;
	            case "squareYards":
	            case "squareYard":
	            case "yds^2":
	            case "yds2":
	            case "yd^2":
	            case "yd2":
	                return AreaUnits.squareYards;
	            case "squareKilometers":
	            case "squareKilometres":
	            case "squareKilometer":
	            case "squareKilometre":
	            case "km^2":
	            case "km2":
	                return AreaUnits.squareKilometers;
	            case "squareMiles":
	            case "squareMile":
	            case "mi^2":
	            case "mi2":
	                return AreaUnits.squareMiles;
	            case "squareMeters":
	            case "squareMetres":
	            case "squareMeter":
	            case "squareMetre":
	            case "m^2":
	            case "m2":
	            default:
	                return AreaUnits.squareMeters;
	        }
	    }
	    return AreaUnits.squareMeters;
	}
	/**
	 * Normailzes a speed unit string. Defaults to metersPerSecond.
	 * Supported units:
	 *    kilometersPerHour, milesPerHour, metersPerSecond, feetPerSecond, knots, mach
	 * @param units The speed units to normalize.
	 * @returns A normailzed speed unit string.
	 */
	function _normalizeSpeedUnit(units) {
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "feetpersecond":
	            case "footsecond":
	            case "ftps":
	            case "ft/s":
	                return SpeedUnits.feetPerSecond;
	            case "milesperhour":
	            case "mileperhour":
	            case "mph":
	            case "mi/hr":
	            case "mi/h":
	                return SpeedUnits.milesPerHour;
	            case "knots":
	            case "knot":
	            case "knts":
	            case "knt":
	            case "kn":
	            case "kt":
	                return SpeedUnits.knots;
	            case "mach":
	            case "m":
	                return SpeedUnits.mach;
	            case "kilometersperhour":
	            case "kilometresperhour":
	            case "kmperhour":
	            case "kmph":
	            case "km/hr":
	            case "km/h":
	                return SpeedUnits.kilometersPerHour;
	            case "meterspersecond":
	            case "metrespersecond":
	            case "mps":
	            case "ms":
	            case "m/s":
	            default:
	                return SpeedUnits.metersPerSecond;
	        }
	    }
	    return SpeedUnits.metersPerSecond;
	}
	/**
	 * Normailzes a time unit string. Defaults to seconds.
	 * Supported units:
	 *    ms (milliseconds), hours, minutes, seconds
	 * @param units The time units to normalize.
	 * @returns A normailzed time unit string.
	 */
	function _normalizeTimeUnit(units) {
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "milliseconds":
	            case "ms":
	                return TimeUnits.ms;
	            case "minutes":
	            case "minute":
	            case "mins":
	            case "min":
	                return TimeUnits.minutes;
	            case "hours":
	            case "hour":
	            case "hr":
	            case "h":
	                return TimeUnits.hours;
	            case "days":
	            case "day":
	            case "d":
	                return TimeUnits.days;
	            case "seconds":
	            case "second":
	            case "secs":
	            case "sec":
	            case "s":
	            default:
	                return TimeUnits.seconds;
	        }
	    }
	    return TimeUnits.seconds;
	}
	/**
	 * Calculates the area of a polygon in square meters.
	 * @param coordinates The coordinates of the polygon ring.
	 * The first ring is the outer/exterior ring and all other rings are the interior ring.
	 * @returns The area of a polygon in square meters.
	 */
	function _calculatePolygonArea(coordinates) {
	    // Based on https://trs-new.jpl.nasa.gov/handle/2014/40409
	    var area = 0;
	    if (coordinates && coordinates.length > 0) {
	        // Calculate the area of the outer/exterior ring of the polygon.
	        area = Math.abs(_calculatePolygonRingArea(coordinates[0]));
	        // Subtract the area of the holes of the polygon.
	        for (var i = 1, len = coordinates.length; i < len; i++) {
	            area -= Math.abs(_calculatePolygonRingArea(coordinates[i]));
	        }
	    }
	    return area;
	}
	/**
	 * Calculates the area of a polygon ring  in square meters.
	 * The area value will be positive if the coordinates in the ring are ordered clockwise,
	 * and negative if ordered counter-clockwise.
	 * @param coordinates The coordinates of the polygon ring.
	 * @returns The area of the ring in square meters.
	 */
	function _calculatePolygonRingArea(coordinates) {
	    // Based on https://trs-new.jpl.nasa.gov/handle/2014/40409
	    var area = 0;
	    if (coordinates.length >= 3) {
	        var p1 = void 0;
	        var p2 = void 0;
	        var p3 = void 0;
	        for (var i = 0, len = coordinates.length; i < len; i++) {
	            // Create triangles from the coordinates.
	            if (i === len - 2) { // i = N-2
	                p1 = len - 2;
	                p2 = len - 1;
	                p3 = 0;
	            }
	            else if (i === len - 1) { // i = N-1
	                p1 = len - 1;
	                p2 = 0;
	                p3 = 1;
	            }
	            else { // i = 0 to N-3
	                p1 = i;
	                p2 = i + 1;
	                p3 = i + 2;
	            }
	            area += (_toRadians(coordinates[p3][0]) - _toRadians(coordinates[p1][0])) * Math.sin(_toRadians(coordinates[p2][1]));
	        }
	        area = area * EARTH_RADIUS_SEMI_MAJOR_AXIS * EARTH_RADIUS_SEMI_MAJOR_AXIS / 2;
	    }
	    return area;
	}
	/**
	 * 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product.
	 * Returns a positive value, if OAB makes a counter-clockwise turn,
	 * negative for clockwise turn, and zero if the points are collinear.
	 * @param a Position A
	 * @param b Position B
	 * @param o Position O
	 * @returns The 2D cross product of OA and OB vectors.
	 */
	function _cross(a, b, o) {
	    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
	}
	/**
	 * Takes an array of positions that form a path and calculates the closest point on the path to a specified position.
	 * @param pos The position to find the closest point to.
	 * @param px The pixel value of the position at zoom level 22.
	 * @param path An array of positions that form a path.
	 * @returns The closest point on the path to the specified position.
	 */
	function _closestPointOnPath(pos, px, path) {
	    // Need atleast two points
	    if (path.length >= 2) {
	        var minDis = Infinity;
	        var d = void 0;
	        var closest = null;
	        // Convert path to pixels.
	        var pixels = mercatorPositionsToPixels(path, 22);
	        var cPx = void 0;
	        for (var i = 0, len = pixels.length - 1; i < len; i++) {
	            cPx = _closestPixelOnLineSegment(px, pixels[i], pixels[i + 1]);
	            d = Pixel.getDistance(px, cPx);
	            if (d < minDis) {
	                minDis = d;
	                closest = cPx;
	            }
	        }
	        if (closest) {
	            var cPos = mercatorPixelsToPositions([closest], 22)[0];
	            return new Feature(new Point(cPos), {
	                distance: getDistanceTo(pos, cPos)
	            });
	        }
	    }
	    else if (path.length === 1) {
	        return new Feature(new Point(path[0]), {
	            distance: getDistanceTo(pos, path[0])
	        });
	    }
	    return null;
	}
	/**
	 * Calculates the closest pixel on a line segment from a given point in 2D space.
	 * @param px The pixel near the line that we are working with.
	 * @param sPx Start pixel of the line segment.
	 * @param ePx End pixel of the line segment.
	 * @returns The closest pixel on the line segement to the specified pixel.
	 */
	function _closestPixelOnLineSegment(px, sPx, ePx) {
	    // If start and end points of line are equal, then that is the closest point.
	    if (sPx[0] === ePx[0] && sPx[1] === ePx[1]) {
	        return sPx;
	    }
	    var APx = px[0] - sPx[0];
	    var APy = px[1] - sPx[1];
	    var ABx = ePx[0] - sPx[0];
	    var ABy = ePx[1] - sPx[1];
	    var magAB2 = ABx * ABx + ABy * ABy;
	    var ABdotAP = ABx * APx + ABy * APy;
	    var t = ABdotAP / magAB2;
	    if (t < 0) {
	        return sPx;
	    }
	    else if (t > 1) {
	        return ePx;
	    }
	    else {
	        return [sPx[0] + ABx * t, sPx[1] + ABy * t];
	    }
	}
	//////////////////////
	/// Internal Functions
	//////////////////////
	/**
	 * Round a number to the specified number of decimal places.
	 * @param val The value to round.
	 * @param decimals The number of decimals.
	 * @returns A number rounded to the specified number of decimal places.
	 * @internal
	 */
	function _precision(val, decimals) {
	    if (!isNaN(val) && typeof decimals === "number" && decimals >= 0) {
	        var power = void 0;
	        if (decimals < POWERS_OF_10.length) {
	            power = POWERS_OF_10[decimals];
	        }
	        else {
	            power = Math.pow(10, decimals);
	        }
	        val = Math.round(val * power) / power;
	    }
	    return val;
	}
	//////////////////////
	/// Public Enums
	//////////////////////
	/**
	 * Units of measurement for areas.
	 */
	var AreaUnits;
	(function (AreaUnits) {
	    /**
	     * Represents areas in square meters (m^2).
	     * Literal value `""`
	     */
	    AreaUnits["squareMeters"] = "squareMeters";
	    /**
	     * Represents areas in acres (ac).
	     * Literal value `"acres"`
	     */
	    AreaUnits["acres"] = "acres";
	    /**
	     * Represents areas in hectares (ha).
	     * Literal value `"hectares"`
	     */
	    AreaUnits["hectares"] = "hectares";
	    /**
	     * Represents areas in feet (ft^2).
	     * Literal value `"squareFeet"`
	     */
	    AreaUnits["squareFeet"] = "squareFeet";
	    /**
	     * Represents areas in square kilometers (km^2).
	     * Literal value `"squareKilometers"`
	     */
	    AreaUnits["squareKilometers"] = "squareKilometers";
	    /**
	     * Represents areas in miles (mi^2).
	     * Literal value `"squareMiles"`
	     */
	    AreaUnits["squareMiles"] = "squareMiles";
	    /**
	     * Represents areas in yards (yds^2).
	     * Literal value `"squareYards"`
	     */
	    AreaUnits["squareYards"] = "squareYards";
	})(AreaUnits || (AreaUnits = {}));
	/**
	 * Units of measurement for distances.
	 */
	var DistanceUnits;
	(function (DistanceUnits) {
	    /**
	     * Represents a distance in meters (m).
	     * Literal value `"meters"`
	     */
	    DistanceUnits["meters"] = "meters";
	    /**
	     * Represents a distance in kilometers (km).
	     * Literal value `"kilometers"`
	     */
	    DistanceUnits["kilometers"] = "kilometers";
	    /**
	     * Represents a distance in feet (ft).
	     * Literal value `"feet"`
	     */
	    DistanceUnits["feet"] = "feet";
	    /**
	     * Represents a distance in miles (mi).
	     * Literal value `"miles"`
	     */
	    DistanceUnits["miles"] = "miles";
	    /**
	     * Represents a distance in nautical miles.
	     * Literal value `"nauticalMiles"`
	     */
	    DistanceUnits["nauticalMiles"] = "nauticalMiles";
	    /**
	     * Represents a distance in yards (yds).
	     * Literal value `"yards"`
	     */
	    DistanceUnits["yards"] = "yards";
	})(DistanceUnits || (DistanceUnits = {}));
	/**
	 * Units of measurement for time.
	 */
	var TimeUnits;
	(function (TimeUnits) {
	    /**
	     * Represents a time in seconds (s).
	     * Literal value `"seconds"`
	     */
	    TimeUnits["seconds"] = "seconds";
	    /**
	     * Represents a time in hours (hr).
	     * Literal value `"hours"`
	     */
	    TimeUnits["hours"] = "hours";
	    /**
	     * Represents a time in milliseconds (ms).
	     * Literal value `"ms"`
	     */
	    TimeUnits["ms"] = "ms";
	    /**
	     * Represents a time in minutes (min).
	     * Literal value `"minutes"`
	     */
	    TimeUnits["minutes"] = "minutes";
	    /**
	     * Represents a time in days (d).
	     * Literal value `"days"`
	     */
	    TimeUnits["days"] = "days";
	})(TimeUnits || (TimeUnits = {}));
	/**
	 * Units of measurement for speed.
	 */
	var SpeedUnits;
	(function (SpeedUnits) {
	    /**
	     * Represents a speed in meters per second (m/s).
	     * Literal value `"metersPerSecond"`
	     */
	    SpeedUnits["metersPerSecond"] = "metersPerSecond";
	    /**
	     * Represents a speed in kilometers per hour (km/h).
	     * Literal value `"kilometersPerHour"`
	     */
	    SpeedUnits["kilometersPerHour"] = "kilometersPerHour";
	    /**
	     * Represents a speed in feet per second (ft/s).
	     * Literal value `"feetPerSecond"`
	     */
	    SpeedUnits["feetPerSecond"] = "feetPerSecond";
	    /**
	     * Represents a speed in miles per hour (mph).
	     * Literal value `"milesPerHour"`
	     */
	    SpeedUnits["milesPerHour"] = "milesPerHour";
	    /**
	     * Represents a speed in knots (knts).
	     * Literal value `"knots"`
	     */
	    SpeedUnits["knots"] = "knots";
	    /**
	     * Represents a speed in mach.
	     * Literal value `"mach"`
	     */
	    SpeedUnits["mach"] = "mach";
	})(SpeedUnits || (SpeedUnits = {}));
	/**
	 * Units of measurement for acceleration.
	 */
	var AccelerationUnits;
	(function (AccelerationUnits) {
	    /**
	     * Represents an acceleration in miles per second squared (mi/s^2).
	     * Literal value `"milesPerSecondSquared"`
	     */
	    AccelerationUnits["milesPerSecondSquared"] = "milesPerSecondSquared";
	    /**
	     * Represents an acceleration in kilometers per second squared (km/s^2).
	     * Literal value `"kilometersPerSecondSquared"`
	     */
	    AccelerationUnits["kilometersPerSecondSquared"] = "kilometersPerSecondSquared";
	    /**
	     * Represents an acceleration in knots per second (knts/s).
	     * Literal value `"knotsPerSecond"`
	     */
	    AccelerationUnits["knotsPerSecond"] = "knotsPerSecond";
	    /**
	     * Represents an acceleration in standard gravity units (g).
	     * Literal value `"standardGravity"`
	     */
	    AccelerationUnits["standardGravity"] = "standardGravity";
	    /**
	     * Represents an acceleration in feet per second squared (ft/s^2).
	     * Literal value `"feetPerSecondSquared"`
	     */
	    AccelerationUnits["feetPerSecondSquared"] = "feetPerSecondSquared";
	    /**
	     * Represents an acceleration in yards per second squared (yds/s^2).
	     * Literal value `"yardsPerSecondSquared"`
	     */
	    AccelerationUnits["yardsPerSecondSquared"] = "yardsPerSecondSquared";
	    /**
	     * Represents an acceleration in miles per hour second (mi/h/s).
	     * Literal value `"milesPerHourSecond"`
	     */
	    AccelerationUnits["milesPerHourSecond"] = "milesPerHourSecond";
	    /**
	     * Represents an acceleration in kilometers per hours second (km/h/s).
	     * Literal value `"kilometersPerHourSecond"`
	     */
	    AccelerationUnits["kilometersPerHourSecond"] = "kilometersPerHourSecond";
	    /**
	     * Represents an acceleration in meters per second squared (m/s^2).
	     * Literal value `"metersPerSecondSquared"`
	     */
	    AccelerationUnits["metersPerSecondSquared"] = "metersPerSecondSquared";
	})(AccelerationUnits || (AccelerationUnits = {}));
	//////////////////////
	/// Public Methods
	//////////////////////
	/**
	 * Takes a BoundingBox and converts it to a polygon.
	 * @param bounds The BoundingBox to convert to a Polygon.
	 * @returns A polygon representation of the BoundingBox.
	 */
	function boundingBoxToPolygon(bounds) {
	    var w = normalizeLongitude(BoundingBox.getWest(bounds));
	    var e = normalizeLongitude(BoundingBox.getEast(bounds));
	    var n = normalizeLatitude(BoundingBox.getNorth(bounds));
	    var s = normalizeLatitude(BoundingBox.getSouth(bounds));
	    var center = BoundingBox.getCenter(bounds);
	    var pos = [
	        [w, n],
	        [w, s],
	        [center[0], s],
	        [e, s],
	        [e, n],
	        [center[0], n],
	        [w, n]
	    ];
	    return new Polygon([pos]);
	}
	/**
	 * Converts a distance from one distance units to another. Supported units: miles, nauticalMiles, yards, meters, kilometers, feet
	 * @param distance A number that represents a distance to convert.
	 * @param fromUnits The distance units the original distance is in.
	 * @param toUnits The desired distance units to convert to.
	 * @param decimals Specifies the number of decimal places to round the result to. If undefined, no rounding will occur.
	 * @returns A distance in the new units.
	 */
	function convertDistance(distance, fromUnits, toUnits, decimals) {
	    // Convert the distance to kilometers
	    switch (_normalizeDistanceUnit(fromUnits)) {
	        case DistanceUnits.meters:
	            distance /= 1000;
	            break;
	        case DistanceUnits.feet:
	            distance /= 3280.8399;
	            break;
	        case DistanceUnits.miles:
	            distance /= 0.62137119;
	            break;
	        case DistanceUnits.yards:
	            distance /= 1093.6133;
	            break;
	        case DistanceUnits.nauticalMiles:
	            distance /= 0.5399568;
	            break;
	        case DistanceUnits.kilometers:
	            break;
	    }
	    // Convert from kilometers to output distance unit
	    switch (_normalizeDistanceUnit(toUnits)) {
	        case DistanceUnits.meters:
	            distance *= 1000;
	            break;
	        case DistanceUnits.feet:
	            distance *= 3280.8399;
	            break;
	        case DistanceUnits.miles:
	            distance *= 0.62137119;
	            break;
	        case DistanceUnits.yards:
	            distance *= 1093.6133;
	            break;
	        case DistanceUnits.nauticalMiles:
	            distance *= 0.5399568;
	            break;
	        case DistanceUnits.kilometers:
	            break;
	    }
	    if (typeof decimals === "number" && decimals >= 0) {
	        var power = Math.pow(10, decimals);
	        distance = Math.round(distance * power) / power;
	    }
	    return distance;
	}
	/**
	 * Calculates an array of positions that form a cardinal spline between the specified array of positions.
	 * @param positions The array of positions to calculate the spline through.
	 * @param tension A number that indicates the tightness of the curve. Can be any number, although a value between 0 and 1 is usually used. Default: 0.5
	 * @param nodeSize Number of nodes to insert between each position. Default: 15
	 * @param close A boolean indicating if the spline should be a closed ring or not. Default: false
	 * @returns An array of positions that form a cardinal spline between the specified array of positions.
	 */
	function getCardinalSpline(positions, tension, nodeSize, close) {
	    // Resources:
	    // http://www.cubic.org/docs/hermite.htm
	    // http://codeplea.com/introduction-to-splines
	    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms536358(v=vs.85).aspx
	    var locs;
	    if (!positions || positions.length <= 2) {
	        return locs;
	    }
	    if (typeof tension !== "number") {
	        tension = 0.5;
	    }
	    if (typeof nodeSize !== "number" || nodeSize <= 0) {
	        nodeSize = 15;
	    }
	    // Get the number of locations the spline passs through.
	    var len = positions.length;
	    // Create a copy of the array of locations so that we don't alter the original array.
	    locs = positions.slice(0);
	    // Add additional locations to array so that tangents can be calculated for end points.
	    if (close) {
	        // If the location array forms a closed ring, remove the last location.
	        if (Position.areEqual(locs[0], locs[len - 1])) {
	            locs.pop();
	            len--;
	        }
	        // Insert the last coordinate as the first point.
	        locs.unshift(positions[len - 1]);
	        // Add the first two points to the end of the array.
	        locs.push(positions[0]);
	        locs.push(positions[1]);
	        // Increase index so that spline wraps back around to starting location.
	        len++;
	    }
	    else {
	        // In this case the spline is not closed, so tanget of end points will be 0.
	        // Buffer the end-points so that tanget calculations can be performed.
	        locs.unshift(positions[0]);
	        locs.push(positions[len - 1]);
	    }
	    // Precalculate the hermite basis function steps along the spline.
	    var hermiteSteps = [];
	    // Force the first step between two locations to be the first location.
	    hermiteSteps.push([1, 0, 0, 0]);
	    var step;
	    var step2;
	    var step3;
	    // Calculate the steps along the spline between two locations.
	    for (var i = 1; i < nodeSize - 1; i++) {
	        step = i / nodeSize; // Scale step to go from 0 to 1.
	        step2 = step * step; // s^2
	        step3 = step * step2; // s^3
	        hermiteSteps.push([
	            2 * step3 - 3 * step2 + 1,
	            -2 * step3 + 3 * step2,
	            step3 - 2 * step2 + step,
	            step3 - step2
	        ]); // Calculate hermite basis function 4.
	    }
	    // Force the last step between two locations to be the last location.
	    hermiteSteps.push([0, 1, 0, 0]);
	    var splineLocs = [];
	    var hermiteStep;
	    // Tangents
	    var t1x;
	    var t1y;
	    var t2x;
	    var t2y;
	    var lat;
	    var lon;
	    // Loop through and calculate the spline path between each location pair.
	    for (var i = 1; i < len; i++) {
	        t1x = tension * (locs[i + 1][0] - locs[i - 1][0]);
	        t1y = tension * (locs[i + 1][1] - locs[i - 1][1]);
	        t2x = tension * (locs[i + 2][0] - locs[i][0]);
	        t2y = tension * (locs[i + 2][1] - locs[i][1]);
	        for (step = 0; step < nodeSize; step++) {
	            hermiteStep = hermiteSteps[step];
	            lon = hermiteStep[0] * locs[i][0] + hermiteStep[1] * locs[i + 1][0] + hermiteStep[2] * t1x + hermiteStep[3] * t2x;
	            lat = hermiteStep[0] * locs[i][1] + hermiteStep[1] * locs[i + 1][1] + hermiteStep[2] * t1y + hermiteStep[3] * t2y;
	            lat = _clip(lat, -85, 85);
	            splineLocs.push([lon, lat]);
	        }
	    }
	    return splineLocs;
	}
	/**
	 * Calculates a destination position based on a starting position, a heading, a distance, and a distance unit type.
	 * @param origin Position that the destination is relative to.
	 * @param heading A heading angle between 0 - 360 degrees. 0 - North, 90 - East, 180 - South, 270 - West.
	 * @param distance Distance that destination is away.
	 * @param units Unit of distance measurement. Default is meters.
	 * @returns A position that is the specified distance away from the origin.
	 */
	function getDestination(origin, heading, distance, units) {
	    units = units || "meters";
	    origin = getPosition(origin);
	    var radius = getEarthRadius(units);
	    // convert latitude, longitude and heading into radians
	    var latRad = _toRadians(origin[1]);
	    var lonRad = _toRadians(origin[0]);
	    var headingRad = _toRadians(heading);
	    var centralAngle = distance / radius;
	    var desLatRad = Math.asin(Math.sin(latRad) * Math.cos(centralAngle) + Math.cos(latRad) * Math.sin(centralAngle) * Math.cos(headingRad));
	    var desLonRad = lonRad + Math.atan2(Math.sin(headingRad) * Math.sin(centralAngle) * Math.cos(latRad), Math.cos(centralAngle) - Math.sin(latRad) * Math.sin(desLatRad));
	    var lat = _clip(normalizeLatitude(_toDegrees(desLatRad)), -85, 85);
	    var lon = normalizeLongitude(_toDegrees(desLonRad));
	    return [lon, lat];
	}
	/**
	 * Calculate the distance between two position objects on the surface of the earth using the Haversine formula.
	 * @param origin First position to calculate distance between.
	 * @param destination Second position to calculate distance between.
	 * @param units Unit of distance measurement. Default is meters.
	 * @returns The shortest distance between two positions in the specified units.
	 */
	function getDistanceTo(origin, destination, units) {
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    var d = _haversineDistance(origin, destination);
	    if (units === "meters") {
	        return d;
	    }
	    return convertDistance(d, "meters", units || "meters");
	}
	/**
	 * Retrieves the radius of the earth in a specific distance unit for WGS84.
	 * @param units Unit of distance measurement. Default: meters
	 * @returns A number that represents the radius of the earth in a specific distance unit.
	 */
	function getEarthRadius(units) {
	    var normalUnit = _normalizeDistanceUnit(units);
	    return convertDistance(EARTH_RADIUS_SEMI_MAJOR_AXIS, DistanceUnits.meters, normalUnit);
	}
	/**
	 * Takes an array of positions objects and fills in the space between them with accurately positioned positions to form an approximated Geodesic path.
	 * @param path Array of position objects that form a path to fill in.
	 * @param nodeSize Number of nodes to insert between each position. Default: 15
	 * @returns An array of position objects that form a geodesic paths.
	 */
	function getGeodesicPath(path, nodeSize) {
	    if (!nodeSize || nodeSize <= 0) {
	        nodeSize = 15;
	    }
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    var len = locs.length - 1;
	    var outputLocs = [];
	    for (var i = 0; i < len; i++) {
	        // Convert positions from degrees to Radians
	        var lat1 = _toRadians(locs[i][1]);
	        var lon1 = _toRadians(locs[i][0]);
	        var lat2 = _toRadians(locs[i + 1][1]);
	        var lon2 = _toRadians(locs[i + 1][0]);
	        // Calculate the total extent of the route
	        var d = 2 * Math.asin(Math.sqrt(Math.pow((Math.sin((lat1 - lat2) / 2)), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow((Math.sin((lon1 - lon2) / 2)), 2)));
	        // Calculate positions at fixed intervals along the route
	        for (var k = 0; k <= nodeSize; k++) {
	            var f = (k / nodeSize);
	            var A = Math.sin((1 - f) * d) / Math.sin(d);
	            var B = Math.sin(f * d) / Math.sin(d);
	            // Obtain 3D Cartesian coordinates of each point
	            var x = A * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2);
	            var y = A * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2);
	            var z = A * Math.sin(lat1) + B * Math.sin(lat2);
	            // Convert these to latitude/longitude
	            var lat = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
	            var lon = Math.atan2(y, x);
	            lat = _clip(_toDegrees(lat), -85, 85);
	            lon = _toDegrees(lon);
	            // Add this to the array
	            outputLocs.push([lon, lat]);
	        }
	    }
	    // TODO: Check for crossing the antimeridian, consider splitting path by -180/180 longitude
	    return outputLocs;
	}
	/**
	 * Calculates the heading from one position object to another.
	 * @param origin Point of origin.
	 * @param destination Destination to calculate relative heading to.
	 * @returns A heading in degrees between 0 and 360. 0 degrees points due North.
	 */
	function getHeading(origin, destination) {
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    if (origin && origin.length >= 2 && destination && destination.length >= 2) {
	        var radianLat1 = _toRadians(origin[1]);
	        var radianLat2 = _toRadians(destination[1]);
	        var dLon = _toRadians(destination[0] - origin[0]);
	        var dy = Math.sin(dLon) * Math.cos(radianLat2);
	        var dx = Math.cos(radianLat1) * Math.sin(radianLat2) - Math.sin(radianLat1) * Math.cos(radianLat2) * Math.cos(dLon);
	        return (_toDegrees(Math.atan2(dy, dx)) + 360) % 360;
	    }
	    return NaN;
	}
	/**
	 * Calculates the distance between all position objects in an array.
	 * @param path The array of position objects that make up the path to calculate the length of.
	 * @param units Unit of distance measurement. Default: meters
	 * @returns The distance between all positions in between all position objects in an array on the surface of a earth in the specified units.
	 */
	function getLengthOfPath(path, units) {
	    var totalLength = 0;
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    for (var i = 0, len = locs.length - 1; i < len; i++) {
	        totalLength += _haversineDistance(locs[i], locs[i + 1]);
	    }
	    return convertDistance(totalLength, "meters", units || "meters");
	}
	/**
	 * Calculates the position object on a path that is a specified distance away from the start of the path. If the specified distance is longer
	 * than the length of the path, the last position of the path will be returned.
	 * @param path A polyline or array of position coordinates that form a path.
	 * @param distance The distance along the path (from the start) to calculate the position for.
	 * @param units Unit of distance measurement. Default is meters.
	 * @returns A position object that is the specified distance away from the start of the path when following the path.
	 */
	function getPositionAlongPath(path, distance, units) {
	    units = units || "meters";
	    var travelled = 0;
	    var dx;
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    if (locs.length >= 2) {
	        var len = locs.length;
	        for (var i = 1; i < len; i++) {
	            dx = getDistanceTo(locs[i - 1], locs[i], units);
	            if (travelled + dx >= distance) {
	                // Overshot
	                var heading = getHeading(locs[i - 1], locs[i]);
	                return getDestination(locs[i - 1], heading, distance - travelled, units);
	            }
	            travelled += dx;
	        }
	        if (distance >= travelled) {
	            return locs[len - 1];
	        }
	        return locs[0];
	    }
	    return null;
	}
	/**
	 * Calculates an array of position objects that are an equal distance away from a central point to create a regular polygon.
	 * @param origin Center of the regular polygon.
	 * @param radius Radius of the regular polygon.
	 * @param numberOfPositions Number of positions the polygon should have.
	 * @param units Unit of distance measurement. Default is meters.
	 * @param offset An offset to rotate the polygon. When 0 the first position will align with North.
	 * @returns An array of position objects that form a regular polygon.
	 */
	function getRegularPolygonPath(origin, radius, numberOfPositions, units, offset) {
	    units = units || "meters";
	    offset = (offset) ? offset : 0;
	    origin = getPosition(origin);
	    var points = [];
	    var centralAngle = 360 / numberOfPositions;
	    for (var i = 0; i <= numberOfPositions; i++) {
	        points.push(getDestination(origin, (i * centralAngle + offset) % 360, radius, units));
	    }
	    // TODO: Check for crossing the antimeridian, consider splitting path by -180/180 longitude
	    return points;
	}
	/**
	 * Calculates a position object that is a fractional distance between two position objects.
	 * @param origin First position to calculate mid-point between.
	 * @param destination Second position to calculate mid-point between.
	 * @param fraction The fractional parameter to calculate a mid-point for. Default 0.5.
	 * @returns A position that lies a fraction of the distance between two position objects, relative to the first position object.
	 */
	function interpolate(origin, destination, fraction) {
	    fraction = (typeof fraction === "undefined") ? 0.5 : fraction;
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    var arcLength = getDistanceTo(origin, destination, "kilometers");
	    var brng = getHeading(origin, destination);
	    return getDestination(origin, brng, arcLength * fraction, "kilometers");
	}
	/**
	 * Normalizes a latitude value between -90 and 90 degrees.
	 * @param lat The latitude value to normalize.
	 */
	function normalizeLatitude(lat) {
	    if (lat > 90) {
	        lat = (lat + 90) % 360;
	        return lat > 180 ? 90 - (lat - 180) : lat - 90;
	    }
	    else if (lat < -90) {
	        lat = (lat - 90) % 360;
	        return lat < -180 ? -90 - (lat + 180) : lat + 90;
	    }
	    else {
	        return lat;
	    }
	}
	/**
	 * Normalizes a longitude value between -180 and 180 degrees.
	 * @param lng The longitude value to normalize.
	 */
	function normalizeLongitude(lng) {
	    if (lng > 180) {
	        return ((lng + 180) % 360) - 180;
	    }
	    else if (lng < -180) {
	        return ((lng - 180) % 360) + 180;
	    }
	    else {
	        return lng;
	    }
	}
	/**
	 * Takes an array of positions and rotates them around a given position for the specified angle of rotation.
	 * @param positions An array of positions to be rotated.
	 * @param origin The position to rotate the positions around.
	 * @param angle The amount to rotate the array of positions in degrees clockwise.
	 */
	function rotatePositions(positions, origin, angle) {
	    if (angle === 0) {
	        // When the rotation is 0 the results can sometimes be odd if the coordinates are on the meridians.
	        return Object.assign({}, positions);
	    }
	    origin = getPosition(origin);
	    var rotatedPositions = [];
	    var distance;
	    var heading;
	    for (var i = 0, len = positions.length; i < len; i++) {
	        distance = getDistanceTo(origin, positions[i]);
	        heading = getHeading(origin, positions[i]);
	        rotatedPositions.push(getDestination(origin, heading + angle, distance));
	    }
	    return rotatedPositions;
	}
	/**
	 * Calculates the pixel accurate heading from one position to another based on the Mercator map projection. This heading is visually accurate.
	 * @param origin
	 * @param destination
	 */
	function getPixelHeading(origin, destination) {
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    var _a = __read(mercatorPositionsToPixels([origin, destination], 21), 2), p1 = _a[0], p2 = _a[1];
	    var dx = (p2[0] - p1[0]);
	    var dy = (p1[1] - p2[1]);
	    var alpha = ((5 / 2 * Math.PI) - Math.atan2(dy, dx)) * INV_PI_BY_180 % 360;
	    return alpha;
	}
	/**
	 * Converts an array of global Mercator pixel coordinates into an array of geospatial positions at a specified zoom level.
	 * Global pixel coordinates are relative to the top left corner of the map [-180, 90].
	 * @param pixels Array of pixel coordinates.
	 * @param zoom Zoom level.
	 * @returns An array of positions.
	 */
	function mercatorPixelsToPositions(pixels, zoom) {
	    // 512 is our tile size in pixels.
	    var mapSize = 512 * Math.pow(2, zoom);
	    var positions = [];
	    var x;
	    var y;
	    for (var i = 0, len = pixels.length; i < len; i++) {
	        x = (pixels[i][0] / mapSize) - 0.5;
	        y = 0.5 - (pixels[i][1] / mapSize);
	        positions.push([
	            360 * x,
	            90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI
	        ]);
	    }
	    return positions;
	}
	/**
	 * Converts an array of positions into an array of global Mercator pixel coordinates at a specified zoom level.
	 * @param positions Array of positions.
	 * @param zoom Zoom level.
	 * @returns Array of global Mercator pixels.
	 */
	function mercatorPositionsToPixels(positions, zoom) {
	    // 512 is our tile size in pixels.
	    var mapSize = 512 * Math.pow(2, zoom);
	    var pixels = [];
	    var x;
	    var y;
	    var sinLatitude;
	    for (var i = 0, len = positions.length; i < len; i++) {
	        sinLatitude = Math.sin(positions[i][1] * Math.PI / 180);
	        x = (positions[i][0] + 180) / 360;
	        y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
	        pixels.push([
	            Math.round(x * mapSize),
	            Math.round(y * mapSize)
	        ]);
	    }
	    return pixels;
	}
	/**
	 * Converts an acceleration value from one unit to another.
	 * Supported units:
	 *    milesPerSecondSquared, kilometersPerSecondSquared, metersPerSecondSquared, feetPerSecondSquared
	 *    yardsPerSecondSquared, kilometersPerHoursSecond, milesPerHourSecond, knotsPerSecond, standardGravity
	 * @param acceleration The acceleration value to convert.
	 * @param fromUnits The acceleration units the value is in.
	 * @param toUnits The acceleration units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration value convertered from one unit to another.
	 */
	function convertAcceleration(acceleration, fromUnits, toUnits, decimals) {
	    // Convert the speed to meters per second squared and then convert to the toUnits.
	    switch (_normalizeAccelerationUnit(fromUnits)) {
	        case AccelerationUnits.kilometersPerHourSecond:
	            acceleration /= 3.6;
	            break;
	        case AccelerationUnits.milesPerHourSecond:
	            acceleration /= 2.236936292054;
	            break;
	        case AccelerationUnits.knotsPerSecond:
	            acceleration /= 1.943844492441;
	            break;
	        case AccelerationUnits.standardGravity:
	            acceleration /= 0.1019716212978;
	            break;
	        case AccelerationUnits.kilometersPerSecondSquared:
	            acceleration /= 0.001;
	            break;
	        case AccelerationUnits.milesPerSecondSquared:
	            acceleration /= 0.000621371192;
	            break;
	        case AccelerationUnits.feetPerSecondSquared:
	            acceleration /= 3.280839895012;
	            break;
	        case AccelerationUnits.yardsPerSecondSquared:
	            acceleration /= 1.093613298338;
	            break;
	        case AccelerationUnits.metersPerSecondSquared:
	    }
	    // metersPerSecondSquared to toUnit.
	    switch (_normalizeAccelerationUnit(toUnits)) {
	        case AccelerationUnits.kilometersPerHourSecond:
	            acceleration *= 3.6;
	            break;
	        case AccelerationUnits.milesPerHourSecond:
	            acceleration *= 2.236936292054;
	            break;
	        case AccelerationUnits.knotsPerSecond:
	            acceleration *= 1.943844492441;
	            break;
	        case AccelerationUnits.standardGravity:
	            acceleration *= 0.1019716212978;
	            break;
	        case AccelerationUnits.kilometersPerSecondSquared:
	            acceleration *= 0.001;
	            break;
	        case AccelerationUnits.milesPerSecondSquared:
	            acceleration *= 0.000621371192;
	            break;
	        case AccelerationUnits.feetPerSecondSquared:
	            acceleration *= 3.280839895012;
	            break;
	        case AccelerationUnits.yardsPerSecondSquared:
	            acceleration *= 1.093613298338;
	            break;
	        case AccelerationUnits.metersPerSecondSquared:
	    }
	    return _precision(acceleration, decimals);
	}
	/**
	 * Converts an area value from one unit to another.
	 * Supported units: squareMeters, acres, hectares, squareFeet, squareYards, squareMiles, squareKilometers
	 * @param area The area value to convert.
	 * @param fromUnits The area units the value is in.
	 * @param toUnits The area units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An area value convertered from one unit to another.
	 */
	function convertArea(area, fromUnits, toUnits, decimals) {
	    switch (_normalizeAreaUnits(fromUnits)) {
	        case AreaUnits.acres:
	            area *= 4046.8564224;
	            break;
	        case AreaUnits.hectares:
	            area *= 10000;
	            break;
	        case AreaUnits.squareFeet:
	            area *= 0.09290304;
	            break;
	        case AreaUnits.squareKilometers:
	            area *= 1000000;
	            break;
	        case AreaUnits.squareMiles:
	            area *= 2590000;
	            break;
	        case AreaUnits.squareYards:
	            area *= 0.83612736;
	            break;
	        case AreaUnits.squareMeters:
	    }
	    switch (_normalizeAreaUnits(toUnits)) {
	        case AreaUnits.acres:
	            area /= 4046.8564224;
	            break;
	        case AreaUnits.hectares:
	            area /= 10000;
	            break;
	        case AreaUnits.squareFeet:
	            area /= 0.09290304;
	            break;
	        case AreaUnits.squareKilometers:
	            area /= 1000000;
	            break;
	        case AreaUnits.squareMiles:
	            area /= 2590000;
	            break;
	        case AreaUnits.squareYards:
	            area /= 0.83612736;
	            break;
	        case AreaUnits.squareMeters:
	    }
	    return _precision(area, decimals);
	}
	/**
	 * Converts a speed value from one unit to another.
	 * Supported units:
	 *    kilometersPerHour, milesPerHour, metersPerSecond, feetPerSecond, knots, mach
	 * @param speed The speed value to convert.
	 * @param fromUnits The speed units to convert from.
	 * @param toUnits The speed units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns A speed value convertered from one unit to another.
	 */
	function convertSpeed(speed, fromUnits, toUnits, decimals) {
	    // Convert the speed to kilometers per hour and then convert to the toUnits.
	    switch (_normalizeSpeedUnit(fromUnits)) {
	        case SpeedUnits.feetPerSecond:
	            speed *= 1.09728;
	            break;
	        case SpeedUnits.milesPerHour:
	            speed *= 1.6093;
	            break;
	        case SpeedUnits.knots:
	            speed *= 1.852;
	            break;
	        case SpeedUnits.metersPerSecond:
	            speed *= 3.6;
	            break;
	        case SpeedUnits.mach:
	            speed *= 1234.8;
	            break;
	        case SpeedUnits.kilometersPerHour:
	    }
	    // KMPH to toUnit.
	    switch (_normalizeSpeedUnit(toUnits)) {
	        case SpeedUnits.feetPerSecond:
	            speed /= 1.09728;
	            break;
	        case SpeedUnits.milesPerHour:
	            speed /= 1.6093;
	            break;
	        case SpeedUnits.knots:
	            speed /= 1.852;
	            break;
	        case SpeedUnits.metersPerSecond:
	            speed /= 3.6;
	            break;
	        case SpeedUnits.mach:
	            speed /= 1234.8;
	            break;
	        case SpeedUnits.kilometersPerHour:
	    }
	    return _precision(speed, decimals);
	}
	/**
	 * Converts a timespan value from one unit to another.
	 * Supported units:
	 *    ms (milliseconds), hours, minutes, seconds
	 * @param timespan The time value to convert.
	 * @param fromUnits The time units to convert from.
	 * @param toUnits The time units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns A time value convertered from one unit to another.
	 */
	function convertTimespan(timespan, fromUnits, toUnits, decimals) {
	    // Convert the time to seconds as base units.
	    switch (_normalizeTimeUnit(fromUnits)) {
	        case TimeUnits.ms:
	            timespan /= 1000;
	            break;
	        case TimeUnits.hours:
	            timespan *= 3600;
	            break;
	        case TimeUnits.minutes:
	            timespan *= 60;
	            break;
	        case TimeUnits.days:
	            timespan *= 86400;
	            break;
	        case TimeUnits.seconds:
	    }
	    // seconds to toUnit.
	    switch (_normalizeTimeUnit(toUnits)) {
	        case TimeUnits.ms:
	            timespan *= 1000;
	            break;
	        case TimeUnits.hours:
	            timespan /= 3600;
	            break;
	        case TimeUnits.minutes:
	            timespan /= 60;
	            break;
	        case TimeUnits.days:
	            timespan /= 86400;
	            break;
	        case TimeUnits.seconds:
	    }
	    return _precision(timespan, decimals);
	}
	/**
	 * Calculates an acceleration based on an initial speed, travel distance and timespan. Formula: a = 2*(d - v*t)/t^2
	 * @param initialSpeed The initial speed.
	 * @param distance The distance that has been travelled.
	 * @param timespan The timespan that was travelled.
	 * @param distanceUnits The units of the distance information. If not specified meters are used.
	 * @param timeUnits The units of the timespan information. If not specified seconds are used.
	 * @param speedUnits The units of the speed information. If not specified m/s are used.
	 * @param accelerationUnits The units to return the acceleration value in. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration based on an initial speed, travel distance and timespan.
	 */
	function getAcceleration(initialSpeed, distance, timespan, speedUnits, distanceUnits, timeUnits, accelerationUnits, decimals) {
	    var d = convertDistance(distance, distanceUnits, DistanceUnits.meters);
	    var t = convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	    var v = convertSpeed(initialSpeed, speedUnits, SpeedUnits.metersPerSecond);
	    return convertAcceleration(2 * (d - v * t) / (t * t), AccelerationUnits.metersPerSecondSquared, accelerationUnits, decimals);
	}
	/**
	 * Calculates an acceleration based on an initial speed, final speed and timespan. Formula: a = 2* (v2 - v1)/t
	 * @param initialSpeed The initial speed.
	 * @param finalSpeed The final speed.
	 * @param timespan The timespan that was travelled.
	 * @param speedUnits The units of the speed information. If not specified meters are used.
	 * @param timeUnits The units of the timespan information. If not specified seconds are used.
	 * @param accelerationUnits The units to return the acceleration value in. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration based on an initial speed, final speed and timespan.
	 */
	function getAccelerationFromSpeeds(initialSpeed, finalSpeed, timespan, speedUnits, timeUnits, accelerationUnits, decimals) {
	    var v1 = convertSpeed(initialSpeed, speedUnits, SpeedUnits.metersPerSecond);
	    var v2 = convertSpeed(finalSpeed, speedUnits, SpeedUnits.metersPerSecond);
	    var t = convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	    return convertAcceleration((v2 - v1) / t, AccelerationUnits.metersPerSecondSquared, accelerationUnits, decimals);
	}
	/**
	 * Calculates an acceleration between two point features that have a timestamp property and optionally a speed property.
	 * if speeds are provided, ignore distance between points as the path may not have been straight and calculate: a = (v2 - v1)/(t2 - t1)
	 * if speeds not provided or only provided on first point, calculate straight line distance between points and calculate: a = 2*(d - v*t)/t^2
	 * @param origin The initial point in which the acceleration is calculated from.
	 * @param destination The final point in which the acceleration is calculated from.
	 * @param timestampProperty The name of the property on the features that contains the timestamp information.
	 * @param speedProperty The name of the property on the features that contains a speed information.
	 * @param speedUnits The units of the speed information. If not specified m/s is used.
	 * @param accelerationUnits The units to return the acceleration value in. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration between two point features that have a timestamp property and optionally a speed property. Returns NaN if unable to parse timestamp.
	 */
	function getAccelerationFromFeatures(origin, destination, timestampProperty, speedProperty, speedUnits, accelerationUnits, decimals) {
	    if (typeof timestampProperty === "string" && origin.type === "Feature" && origin.geometry.type === "Point" &&
	        destination.type === "Feature" && destination.geometry.type === "Point") {
	        var timespan = getTimespan(origin.properties[timestampProperty], destination.properties[timestampProperty], TimeUnits.seconds);
	        // Ensure that the start and end point features have the specified timeStamp
	        if (!isNaN(timespan)) {
	            var v = 0;
	            if (speedProperty && typeof speedProperty === "string") {
	                var v1 = origin.properties[speedProperty];
	                var v2 = destination.properties[speedProperty];
	                if (typeof v1 === "number") {
	                    v = v1;
	                    if (typeof v2 === "number") {
	                        return getAccelerationFromSpeeds(v1, v2, timespan, speedUnits, TimeUnits.seconds, accelerationUnits, decimals);
	                    }
	                }
	            }
	            var d = getDistanceTo(origin.geometry.coordinates, destination.geometry.coordinates, DistanceUnits.meters);
	            return getAcceleration(v, d, timespan, speedUnits, DistanceUnits.meters, TimeUnits.seconds, accelerationUnits, decimals);
	        }
	    }
	    return NaN;
	}
	/**
	 * Calculates the approximate area of a geometry in the specified units
	 * @param coordinates The coordinates of the polyon ring.
	 * The first ring is the outer/exterior ring and all other rings are the interior ring.
	 * @param areaUnits Unit of area measurement. Default is squareMeters.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The area of a geometry in the specified units.
	 */
	function getArea(data, areaUnits, decimals) {
	    // https://github.com/Turfjs/turf/blob/master/packages/turf-area/index.ts#L68-L75
	    if (data) {
	        var area = 0;
	        data = data instanceof Shape ? data.toJson() : data;
	        switch (data.type) {
	            case "Feature":
	                var f = data;
	                if (f.geometry) {
	                    return getArea(f.geometry, areaUnits, decimals);
	                }
	                break;
	            case "Polygon":
	                var p = data;
	                if (p.coordinates) {
	                    area = _calculatePolygonArea(p.coordinates);
	                }
	                break;
	            case "MultiPolygon":
	                var mp = data;
	                if (mp.coordinates) {
	                    for (var i = 0, len = mp.coordinates.length; i < len; i++) {
	                        area += _calculatePolygonArea(mp.coordinates[i]);
	                    }
	                }
	                break;
	        }
	        return convertArea(area, AreaUnits.squareMeters, areaUnits, decimals);
	    }
	    return 0;
	}
	/**
	 * Calculates the average speed of travel between two points based on the provided amount of time.
	 * @param origin The initial point in which the speed is calculated from.
	 * @param destination The final point in which the speed is calculated from.
	 * @param time The time take to travel between the start and end points.
	 * @param timeUnits The units of the time value. If not specified seconds are used.
	 * @param speedUnits The units to return the speed value in. If not specified m/s are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The average speed of travel between two points based on the provided amount of time.
	 */
	function getSpeed(origin, destination, timespan, timeUnits, speedUnits, decimals) {
	    var org = getPosition(origin);
	    var dest = getPosition(destination);
	    if (org && dest) {
	        // Convert the time value to seconds.
	        var t = convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	        // Calculate the distance`between the points in meters.
	        var d = getDistanceTo(org, dest, DistanceUnits.meters);
	        // Calculate the speed and convert it into the requested units.
	        return convertSpeed(d / t, SpeedUnits.metersPerSecond, speedUnits, decimals);
	    }
	    return 0;
	}
	/**
	 * Calculates the average speed of travel between two point features that have a property containing a timestamp.
	 * The timestamp can be;
	 *  - A JavaScript Date object
	 *  - A number which represents the number of milliseconds since Jan 1st, 1970.
	 *  - A string which uses one of the following formats:
	 *      - ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	 *      - RFC282 / IETF date syntax (section 3.3)
	 *      - OData Date string (i.e. "/Date(1235764800000)/")
	 * @param origin The initial point in which the speed is calculated from.
	 * @param destination The final point in which the speed is calculated from.
	 * @param timestampProperty The name of the property on the features which has the timestamp information.
	 * @param speedUnits The units to return the speed value in. If not specified m/s are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The speed in the specified units or NaN if valid timestamps are not found.
	 */
	function getSpeedFromFeatures(origin, destination, timestampProperty, speedUnits, decimals) {
	    if (typeof timestampProperty === "string" &&
	        origin.type === "Feature" && origin.geometry.type === "Point" &&
	        destination.type === "Feature" && destination.geometry.type === "Point") {
	        var timespan = this.getTimespan(origin.properties[timestampProperty], destination.properties[timestampProperty], TimeUnits.seconds);
	        // Ensure that the start and end point features have the specified timeStamp
	        if (!isNaN(timespan)) {
	            // Calculate the distance`between the points in meters.
	            var d = this.getDistanceTo(origin.geometry.coordinates, destination.geometry.coordinates, DistanceUnits.meters);
	            return this.convertSpeed(d / timespan, SpeedUnits.metersPerSecond, speedUnits, decimals);
	        }
	    }
	    return NaN;
	}
	/**
	 * Calculates the timespan between two dates or timestamps.
	 * Timestamps can be;
	 *  - A JavaScript Date object
	 *  - A number which represents the number of milliseconds since Jan 1st, 1970.
	 *  - A string which uses one of the following formats:
	 *      - ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	 *      - RFC282 / IETF date syntax (section 3.3)
	 *      - OData Date string (i.e. "/Date(1235764800000)/")
	 * @param startTime The start date or time.
	 * @param endTime The end date or time.
	 * @param units The units to return the time value in. If not specified seconds are used.
	 * @returns A timespan between two dates or timestamps. Returns NaN if unable to parse timestamps.
	 */
	function getTimespan(startTime, endTime, units, decimals) {
	    var st = parseTimestamp(startTime);
	    var et = parseTimestamp(endTime);
	    // Ensure that the start and end point features have the specified timeStamp
	    if (st != null && et != null) {
	        // Calculate timespan between the time stamps in seconds.
	        return convertTimespan(et.getTime() - st.getTime(), TimeUnits.ms, units, decimals);
	    }
	    return NaN;
	}
	/**
	 * Calculates the distance traveled for a specified timespan, speed and optionally an acceleration.
	 * Formula: d = v*t + 0.5*a*t^2
	 * @param distanceUnits The distance units in which to return the distance in.
	 * @param timespan The timespan to calculate the distance for.
	 * @param speed The initial or constant speed.
	 * @param acceleration Optional. An acceleration which increases the speed over time.
	 * @param timeUnits The units of the timespan. If not specified seconds are used.
	 * @param speedUnits The units of the speed value. If not specified m/s are used.
	 * @param accelerationUnits Optional. The units of the acceleration value. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The distance traveled for a specified timespan, speed and optionally an acceleration.
	 */
	function getTravelDistance(distanceUnits, timespan, speed, acceleration, timeUnits, speedUnits, accelerationUnits, decimals) {
	    // Convert timespan to seconds.
	    timespan = this.convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	    // Convert speed to meters per second.
	    speed = this.convertSpeed(speed, speedUnits, SpeedUnits.metersPerSecond);
	    var distance = speed * timespan;
	    if (typeof acceleration === "number") {
	        // Convert acceleration to meters per second squared.
	        distance += 0.5 * this.convertAcceleration(acceleration, accelerationUnits, AccelerationUnits.metersPerSecondSquared) * timespan * timespan;
	    }
	    return this.convertDistance(distance, DistanceUnits.meters, distanceUnits, decimals);
	}
	/**
	 * Parses a timestamp into a JavaScript Date object.
	 * Timestamps can be;
	 *  - A JavaScript Date object
	 *  - A number which represents the number of milliseconds since Jan 1st, 1970.
	 *  - A string which uses one of the following formats:
	 *      - ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	 *      - RFC282 / IETF date syntax (section 3.3)
	 *      - OData Date string (i.e. "/Date(1235764800000)/")
	 * @param timestamp The timestamp value to parse.
	 * @returns A Date object that represents the timestamp or null if the timestamp could not be parsed.
	 */
	function parseTimestamp(timestamp) {
	    if (Object.prototype.toString.call(timestamp) === "[object Date]") {
	        return timestamp;
	    }
	    if (typeof timestamp === "string") {
	        // ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	        // RFC282 / IETF date syntax (section 3.3)
	        var d = Date.parse(timestamp);
	        if (!isNaN(d)) {
	            return new Date(d);
	        }
	        // OData Date format "/Date(1235764800000)/"
	        if (timestamp.indexOf("Date(") >= 0) {
	            timestamp = timestamp.replace("/Date(", "").replace(")/", "");
	            var ms = 0; // number of milliseconds since midnight Jan 1, 1970
	            if (timestamp.indexOf("+") > 0) {
	                ms = parseInt(timestamp.substr(0, timestamp.indexOf("+")), 10);
	            }
	            else if (timestamp.indexOf("-") > 0) {
	                ms = parseInt(timestamp.substr(0, timestamp.indexOf("-")), 10);
	            }
	            else {
	                ms = parseInt(timestamp, 10);
	            }
	            return new Date(ms);
	        }
	    }
	    else if (typeof timestamp === "number") {
	        // Assume the number is the number of milliseconds from Jan 1st, 1970.
	        return new Date(timestamp);
	    }
	    return null;
	}
	/**
	 * Calculates a Convex Hull from an array of positions, geometries or features.
	 * @param data The array of positions, geometries or features to calculate a convex hull for.
	 * @returns A Convex Hull from an array of positions, geometries or features.
	 */
	function getConvexHull(data) {
	    var e_1, _a;
	    // Uses a Monotone chain algorithm for convex hulls:
	    // https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
	    var positions = getPositions(data).map(function (pos) {
	        return [normalizeLongitude(pos[0]), normalizeLatitude(pos[1])];
	    });
	    positions.sort(function (a, b) {
	        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
	    });
	    var lower = [];
	    try {
	        for (var positions_1 = __values(positions), positions_1_1 = positions_1.next(); !positions_1_1.done; positions_1_1 = positions_1.next()) {
	            var position = positions_1_1.value;
	            while (lower.length >= 2 && _cross(lower[lower.length - 2], lower[lower.length - 1], position) <= 0) {
	                lower.pop();
	            }
	            lower.push(position);
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (positions_1_1 && !positions_1_1.done && (_a = positions_1.return)) _a.call(positions_1);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    var upper = [];
	    for (var i = positions.length - 1; i >= 0; i--) {
	        while (upper.length >= 2 && _cross(upper[upper.length - 2], upper[upper.length - 1], positions[i]) <= 0) {
	            upper.pop();
	        }
	        upper.push(positions[i]);
	    }
	    return new Polygon([lower.concat(upper)]);
	}
	/**
	 * Retrieves an array of all positions in the provided geometry, feature or array of geometries/features.
	 * @param data The geometries or features to retrieve the positions from.
	 * @returns An array of all positions in the provided geometry, feature or array of geometries/features.
	 */
	function getPositions(data) {
	    var loc = [];
	    var loc2d = null;
	    var loc3d = null;
	    if (Array.isArray(data) && data.length > 0) {
	        if (Array.isArray(data[0]) && typeof data[0][0] === "number") {
	            loc = data;
	        }
	        else {
	            var len = data.length;
	            for (var i = 0; i < len; i++) {
	                loc = loc.concat(getPositions(data[i]));
	            }
	        }
	    }
	    else if (data["type"]) {
	        switch (data["type"]) {
	            case "Point":
	                loc = [data.coordinates];
	                break;
	            case "LineString":
	                loc = data.coordinates;
	                break;
	            case "Polygon":
	                loc2d = data.coordinates;
	                break;
	            case "MultiPoint":
	                loc = data.coordinates;
	                break;
	            case "MultiLineString":
	                loc2d = data.coordinates;
	                break;
	            case "MultiPolygon":
	                loc3d = data.coordinates;
	                break;
	            case "Feature":
	                var f = data;
	                if (Shape._isCircle(f)) {
	                    loc = Shape._getCirclePositions(f);
	                }
	                else {
	                    loc = getPositions(f.geometry);
	                }
	                break;
	            case "FeatureCollection":
	                loc = getPositions(data.features);
	                break;
	            case "GeometryCollection":
	                loc = getPositions(data.geometries);
	                break;
	        }
	    }
	    else if (data instanceof Shape) {
	        return getPositions(data.toJson());
	    }
	    if (loc2d) {
	        var len = loc2d.length;
	        for (var i = 0; i < len; i++) {
	            loc = loc.concat(loc2d[i]);
	        }
	    }
	    else if (loc3d) {
	        var outerLen = loc3d.length;
	        for (var i = 0; i < outerLen; i++) {
	            var innerLen = loc3d[i].length;
	            for (var j = 0; j < innerLen; j++) {
	                loc = loc.concat(loc3d[i][j]);
	            }
	        }
	    }
	    return loc;
	}
	/**
	 * Gets the position of an object that is a position, point, point feature, or circle. If it is a circle, its center coordinate will be returned.
	 * @param data The data object to extract the position from.
	 * @returns The position of an object that is a position, point, or point feature. Returns null if invalid data passed in.
	 */
	function getPosition(data) {
	    if (Array.isArray(data) && typeof data[0] === "number") {
	        return data;
	    }
	    else if (data["type"]) {
	        if (data["type"] === "Point") {
	            return data.coordinates;
	        }
	        else if (data["type"] === "Feature" && data["geometry"]["type"] === "Point") {
	            return data.geometry.coordinates;
	        }
	    }
	    else if (data instanceof Shape && data.getType() === "Point") {
	        return data.getCoordinates();
	    }
	    return null;
	}
	/**
	 * Gets an array of evenly spaced positions along a path.
	 * @param path The path to get the positions from.
	 * @param numPositions The number of positions to get.
	 * @returns An array of evenly spaced positions along a path.
	 */
	function getPositionsAlongPath(path, numPositions) {
	    if (numPositions < 2) {
	        return [];
	    }
	    var positions = [];
	    var len = getLengthOfPath(path, DistanceUnits.meters);
	    // Calculate the gaps between the positions. There is one less gap than there are positions.
	    var dx = len / (numPositions - 1);
	    for (var i = 0; i < numPositions; i++) {
	        var p = getPositionAlongPath(path, dx * i, DistanceUnits.meters);
	        if (p != null) {
	            positions.push(p);
	        }
	    }
	    return positions;
	}
	/**
	 * Gets a point with heading a specified distance along a path.
	 * @param path The path to get the point from.
	 * @param distance The distance along the path to get the point at.
	 * @param units The distance units.
	 * @returns A point with heading a specified distance along a path.
	 */
	function getPointWithHeadingAlongPath(path, distance, units) {
	    units = units || "meters";
	    var travelled = 0;
	    var dx;
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    if (locs.length >= 2) {
	        var len = locs.length;
	        for (var i = 1; i < len; i++) {
	            dx = getDistanceTo(locs[i - 1], locs[i], units);
	            if (travelled + dx >= distance) {
	                // Overshot
	                var heading = getHeading(locs[i - 1], locs[i]);
	                var p = getDestination(locs[i - 1], heading, distance - travelled, units);
	                return new Feature(new Point(p), {
	                    heading: heading
	                });
	            }
	            travelled += dx;
	        }
	        if (distance >= travelled) {
	            return new Feature(new Point(locs[len - 1]), {
	                heading: getHeading(locs[len - 2], locs[len - 1])
	            });
	        }
	        return new Feature(new Point(locs[0]), {
	            heading: getHeading(locs[0], locs[1])
	        });
	    }
	    return null;
	}
	/**
	 * Gets an array of evenly spaced points with headings along a path.
	 * @param path The path to get the positions from.
	 * @param numPoints The number of points to get.
	 * @returns An array of evenly spaced points with headings along a path.
	 */
	function getPointsWithHeadingsAlongPath(path, numPoints) {
	    if (numPoints <= 0) {
	        return [];
	    }
	    var points = [];
	    var len = getLengthOfPath(path, DistanceUnits.meters);
	    // Calculate the gaps between the points. There is one less gap than there are points.
	    var dx = len / (numPoints - 1);
	    for (var i = 0; i < numPoints; i++) {
	        var p = getPointWithHeadingAlongPath(path, dx * i, DistanceUnits.meters);
	        if (p != null) {
	            points.push(p);
	        }
	    }
	    return points;
	}
	/**
	 * Calculates the closest point on the edge of a geometry to a specified point or position.
	 * The returned point feature will have a `distance` property that specifies the distance between the two points in the specified units.
	 * If the geometry is a Point, that points position will be used for the result.
	 * If the geometry is a MultiPoint, the distances to the individual positions will be used.
	 * If the geometry is a Polygon or MultiPolygon, the point closest to any edge will be returned regardless of if the point intersects the geometry or not.
	 * @param pt The point or position to find the closest point on the edge of the geometry.
	 * @param geom The geometry to find the closest point on.
	 * @param units Unit of distance measurement. Default is meters.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns
	 */
	function getClosestPointOnGeometry(pt, geom, units, decimals) {
	    // Does not support geometries that cross the antimerdian.
	    var pos = getPosition(pt);
	    var px = mercatorPositionsToPixels([pos], 22)[0];
	    var result = null;
	    var paths;
	    var minDis = Infinity;
	    geom = geom instanceof Shape ? geom.toJson() : geom;
	    switch (geom.type) {
	        case "Feature":
	            return getClosestPointOnGeometry(pt, geom.geometry, units);
	        case "Point":
	            paths = [[geom.coordinates]];
	            break;
	        case "MultiPoint":
	            var d = void 0;
	            var mp = geom.coordinates;
	            for (var i = 0, len = mp.length; i < len; i++) {
	                d = getDistanceTo(pos, mp[i]);
	                if (d < minDis) {
	                    minDis = d;
	                    result = new Feature(new Point(mp[i]), {
	                        distance: d
	                    });
	                }
	            }
	            break;
	        case "LineString":
	            paths = [geom.coordinates];
	            break;
	        case "Polygon":
	        case "MultiLineString":
	            paths = geom.coordinates;
	            break;
	        case "MultiPolygon":
	            var mPaths = geom.coordinates;
	            if (mPaths.length > 0) {
	                paths = mPaths[0];
	                for (var i = 1, len = mPaths.length; i < len; i++) {
	                    paths = paths.concat(mPaths[i]);
	                }
	            }
	            break;
	    }
	    if (paths) {
	        var temp = void 0;
	        for (var i = 0, len = paths.length; i < len; i++) {
	            temp = _closestPointOnPath(pos, px, paths[i]);
	            if (temp && temp.properties.distance < minDis) {
	                minDis = temp.properties.distance;
	                result = temp;
	            }
	        }
	    }
	    if (result) {
	        result.properties.distance = convertDistance(result.properties.distance, "meters", units, decimals);
	    }
	    return result;
	}
	/**
	 * Perform a Douglas-Peucker simplification on an array of positions or pixels.
	 * @param points The position or pixel points to simplify.
	 * @param tolerance A tolerance to use in the simplification.
	 * @returns A new array of the simplified set of points.
	 */
	function simplify(points, tolerance) {
	    //Perform a Douglas-Peucker simplification of the pixels.
	    return arrayPoints_1(points, tolerance, true);
	}

	/**
	 * A GeoJSON Position object - an array that specifies the longitude and latitude of a location. The
	 * full description is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.1}.
	 */
	var Position = /** @class */ (function (_super) {
	    __extends(Position, _super);
	    /**
	     * Constructs a Position.
	     * @param longitude The position's longitude.
	     * @param latitude The position's latitude.
	     * @param elevation The position's elevation.
	     */
	    function Position(longitude, latitude, elevation) {
	        var _this = this;
	        if (elevation) {
	            _this = _super.call(this, longitude, latitude, elevation) || this;
	        }
	        else {
	            _this = _super.call(this, longitude, latitude) || this;
	        }
	        return _this;
	    }
	    /**
	     * Clones a position.
	     * @param position The position to clone.
	     */
	    Position.fromPosition = function (position) {
	        if (position.length === 2) {
	            return new Position(position[0], position[1]);
	        }
	        else if (position.length > 2) {
	            return new Position(position[0], position[1], position[2]);
	        }
	        return null;
	    };
	    /**
	     * Compares the longitude and latitude values of two positions to see if they are equal at an accuracy of 6 decimal places.
	     * @param pos1 First position to compare.
	     * @param pos2 Second position to compare.
	     * @param precision The number of decimal places to compare to. Default: 6.
	     * @returns A boolean indicating if two positions to see if they are equal at an accuracy of the specified precision or 6 decimal places.
	     */
	    Position.areEqual = function (pos1, pos2, precision) {
	        if (typeof (precision) === "undefined") {
	            precision = 6;
	        }
	        if (pos1 && pos1.length >= 2 && pos2 && pos2.length >= 2) {
	            var offset = Math.pow(10, precision);
	            var lat1 = normalizeLatitude(pos1[1]);
	            var lat2 = normalizeLatitude(pos2[1]);
	            var lon1 = normalizeLongitude(pos1[0]);
	            var lon2 = normalizeLongitude(pos2[0]);
	            var latDiff = Math.round((lat1 - lat2) * offset) / offset;
	            if (latDiff !== 0) {
	                return false;
	            }
	            // A diff of 360 is also allowed because -180 and 180 are the same longitude
	            var lonDiff = Math.round((lon1 - lon2) * offset) / offset;
	            if (lonDiff !== 0 && lonDiff !== 360) {
	                return false;
	            }
	            return true;
	        }
	        return false;
	    };
	    Position.fromLatLng = function (y, x, z) {
	        var position = [];
	        if (typeof y === "number") {
	            position.push(y);
	            if (typeof x === "number") {
	                position.push(x);
	            }
	            if (typeof z === "number") {
	                position.push(z);
	            }
	        }
	        else if (Array.isArray(y)) {
	            // Assume array is in the form [lat, lng] or [lat, lng, elv]
	            if (y.length >= 2 && typeof y[0] === "number" && typeof y[1] === "number") {
	                if (y.length >= 3 && typeof y[2] === "number") {
	                    position.push(y[0], y[1], y[2]);
	                }
	                else {
	                    position.push(y[0], y[1]);
	                }
	            }
	        }
	        else if (typeof y === "object") {
	            // Consider pulling these out into static variable so that we don't constantly create instances of these.
	            var latNames_1 = ["lat", "latitude", "y"];
	            var lngNames_1 = ["lng", "longitude", "lon", "x"];
	            var elvNames_1 = ["elv", "elevation", "alt", "altitude", "z"];
	            var lat_1 = NaN;
	            var lng_1 = NaN;
	            var elv_1 = NaN;
	            // Do a case insensitive search through the object properties.
	            Object.keys(y).forEach(function (key, idx, arr) {
	                var smallKey = key.toLowerCase();
	                if (isNaN(lat_1) && latNames_1.indexOf(smallKey) >= 0 && typeof y[key] === "number") {
	                    lat_1 = y[key];
	                }
	                else if (isNaN(lng_1) && lngNames_1.indexOf(smallKey) >= 0 && typeof y[key] === "number") {
	                    lng_1 = y[key];
	                }
	                else if (isNaN(elv_1) && elvNames_1.indexOf(smallKey) >= 0 && typeof y[key] === "number") {
	                    elv_1 = y[key];
	                }
	            });
	            if (!isNaN(lat_1) && !isNaN(lng_1)) {
	                position.push(lng_1, lat_1);
	                if (!isNaN(elv_1)) {
	                    position.push(elv_1);
	                }
	            }
	        }
	        if (position.length >= 2) {
	            return position;
	        }
	        return null;
	    };
	    /**
	     * Converts an array of objects that contain coordinate information into an array of Positions. Objects that can't be converted are discarded.
	     * Each object is either an array in the format; [lat, lng] or [lat, lng, elv], or an object with the any combination of the following properties:
	     * Longitude: lng, longitude, lon, x
	     * Latitude: lat, latitude, y
	     * Elevation: elv, elevation, alt, altitude, z
	     * @param latLngs The objects that contain coordinate information.
	     * @returns An array of Position objects that contain all the provided coordinate information.
	     */
	    Position.fromLatLngs = function (latLngs) {
	        var positions = [];
	        if (Array.isArray(latLngs)) {
	            for (var i = 0, len = latLngs.length; i < len; i++) {
	                var p = Position.fromLatLng(latLngs[i]);
	                // skip undetermined positions.
	                if (p) {
	                    positions.push(p);
	                }
	            }
	        }
	        return positions;
	    };
	    /**
	     * Returns the number of dimensions in the specified coordinates.
	     * Does not include the extra dimension form the Position type.
	     * @param coords The coordinates to get the dimension count for.
	     * @private
	     */
	    Position._getDimensions = function (coords) {
	        var count = 0;
	        while (Array.isArray(coords)) {
	            coords = coords[0];
	            count++;
	        }
	        // If the inner most array has a number for it's first
	        // element it is a position and the count must be reduced by 1.
	        if (typeof coords === "number") {
	            count--;
	        }
	        return count;
	    };
	    return Position;
	}(Array));

	/**
	 * A GeoJSON Polygon object - a JSON object that represents a geographic polygon. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.6}.
	 */
	var Polygon = /** @class */ (function () {
	    /**
	     * Constructs a Polygon.
	     * @param coordinates The array of linear ring coordinate arrays defining the polygon.
	     * @param bbox The bounding box of the polygon.
	     */
	    function Polygon(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "Polygon".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "Polygon";
	        this.type = Polygon.TYPE;
	        // check if it has only one ring
	        if (Position._getDimensions(coordinates) === 1) {
	            this.coordinates = [coordinates];
	        }
	        else {
	            this.coordinates = coordinates;
	        }
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the Polygon class to be used in runtime comparisons.
	     */
	    Polygon.TYPE = "Polygon";
	    return Polygon;
	}());

	/**
	 * An Affine Transform class generated from a set of reference points.
	 */
	var AffineTransform = /** @class */ (function () {
	    /**
	     * An Affine Transform class generated from a set of reference points.
	     * @param source A set of reference points from the source reference system to transform from.
	     * @param target A set of reference points from the target reference system to transform to.
	     */
	    function AffineTransform(source, target) {
	        this.M = AffineTransform._calculateAffineTransform(source, target);
	        this.inverseM = AffineTransform._calculateAffineTransform(target, source);
	    }
	    /**
	     * Converts an array of points from the source reference system to the target reference system.
	     * @param sourcePoints An array of points from the source reference system to transform.
	     * @param decimals Number of decimal places to round the results off to.
	     * @returns An array of points that have been transformed to the target reference system.
	     */
	    AffineTransform.prototype.toTarget = function (sourcePoints, decimals) {
	        if (typeof sourcePoints !== undefined) {
	            return this.transformArray(sourcePoints, this.M, decimals);
	        }
	        throw new Error("Invalid sourcePoints specified.");
	    };
	    /**
	     * Converts an array of points from the target reference system to the source reference system.
	     * @param targetPoints An array of points from the target reference system to transform.
	     * @param decimals Number of decimal places to round the results off to.
	     * @returns An array of points that have been transformed to the source reference system.
	     */
	    AffineTransform.prototype.toSource = function (targetPoints, decimals) {
	        if (typeof targetPoints !== undefined) {
	            return this.transformArray(targetPoints, this.inverseM, decimals);
	        }
	        throw new Error("Invalid targetPoints specified.");
	    };
	    /**
	     * Applies a transform matrix over a set of points and optionally rounds off the values to a specified number of decimals.
	     * @param points The array of points to transform.
	     * @param transformMatrix The transform matrix to apply.
	     * @param decimals The number of decimals to round each calculated point value off to.
	     * @returns An array of points that have been transformed.
	     */
	    AffineTransform.prototype.transformArray = function (points, transformMatrix, decimals) {
	        var e_1, _a;
	        if (points && Array.isArray(points) && Array.isArray(points[0])) {
	            var pos = [];
	            try {
	                for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
	                    var subPoints = points_1_1.value;
	                    pos.push(this.transform(subPoints, transformMatrix, decimals));
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (points_1_1 && !points_1_1.done && (_a = points_1.return)) _a.call(points_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            return pos;
	        }
	        return null;
	    };
	    /**
	     * Applies a transform matrix on a point and optionally rounds off the values to a specified number of decimals.
	     * @param point The point to transform.
	     * @param transformMatrix The transform matrix to apply.
	     * @param decimals The number of decimals to round each calculated point value off to.
	     * @returns An array of points that have been transformed.
	     */
	    AffineTransform.prototype.transform = function (point, transformMatrix, decimals) {
	        var x = point[0] * transformMatrix[0][3] + point[1] * transformMatrix[1][3] + transformMatrix[2][3];
	        var y = point[0] * transformMatrix[0][4] + point[1] * transformMatrix[1][4] + transformMatrix[2][4];
	        return typeof decimals === "number" && decimals >= 0 ?
	            [_precision(x, decimals), _precision(y, decimals)] :
	            [_precision(x, 6), _precision(y, 6)];
	    };
	    /**
	     * Takes in a set of source and target points can calculates an approximate Affine Transform matrix that best fits the data.
	     * Modified version of this code: https://github.com/commenthol/affinefit
	     * @param sourcePoints A set of source points to transform from.
	     * @param targetPoints A set of target points to transform to.
	     * @returns An Affine Tranform matrix.
	     */
	    AffineTransform._calculateAffineTransform = function (sourcePoints, targetPoints) {
	        if (sourcePoints.length !== targetPoints.length || sourcePoints.length < 1) {
	            throw new Error("Error: source and target arrays must have the same length.");
	        }
	        // Use the smallest dimension of the input.
	        var dim = Math.min(sourcePoints[0].length, targetPoints[0].length);
	        var dimPlusOne = dim + 1;
	        if (sourcePoints.length < dim) {
	            throw new Error("Erorr: At least " + dim + " reference points required.");
	        }
	        // Create an empty (dim + 1) x (dim) matrix and fill it.
	        var c = [];
	        var transformMatrix = [];
	        for (var i = 0; i < dimPlusOne; i++) {
	            transformMatrix[i] = [];
	            for (var j = 0; j < dimPlusOne; j++) {
	                if (j < dim) {
	                    c[j] = 0;
	                }
	                transformMatrix[i][j] = 0;
	                for (var k = 0; k < sourcePoints.length; k++) {
	                    if (j < dim) {
	                        if (i < dim) {
	                            c[j] += sourcePoints[k][i] * targetPoints[k][j];
	                        }
	                        else {
	                            c[j] += targetPoints[k][j];
	                        }
	                    }
	                    if (i >= dim && j >= dim) {
	                        transformMatrix[i][j] += 1;
	                    }
	                    else if (i >= dim) {
	                        transformMatrix[i][j] += sourcePoints[k][j];
	                    }
	                    else if (j >= dim) {
	                        transformMatrix[i][j] += sourcePoints[k][i];
	                    }
	                    else {
	                        transformMatrix[i][j] += sourcePoints[k][i] * sourcePoints[k][j];
	                    }
	                }
	            }
	            transformMatrix[i] = transformMatrix[i].concat(c);
	        }
	        if (!this._gaussJordanElimination(transformMatrix)) {
	            throw new Error("Error: Singular matrix. Points are likely coplanar.");
	        }
	        return transformMatrix;
	    };
	    /**
	     * Puts a given matrix (2D array) into the Reduced Row Echelon Form.
	     * Returns True if successful, False if the transformMatrix is singular.
	     * Code from: https://github.com/commenthol/affinefit
	     */
	    AffineTransform._gaussJordanElimination = function (transformMatrix) {
	        var eps = 1e-10; // 1.0 / Math.pow(10, 10)
	        var dimPlusOne = transformMatrix.length;
	        var w = 2 * dimPlusOne - 1;
	        var tempNum;
	        var tempArray;
	        for (var j = 0; j < dimPlusOne; j++) {
	            var maxrow = j;
	            for (var i = j + 1; i < dimPlusOne; i++) {
	                // Find max pivot.
	                if (Math.abs(transformMatrix[i][j]) > Math.abs(transformMatrix[maxrow][j])) {
	                    maxrow = i;
	                }
	            }
	            tempArray = transformMatrix[maxrow];
	            transformMatrix[maxrow] = transformMatrix[j];
	            transformMatrix[j] = tempArray;
	            if (Math.abs(transformMatrix[j][j]) <= eps) {
	                // Is Singular?
	                return false;
	            }
	            for (var _j = j + 1; _j < dimPlusOne; _j++) {
	                // Eliminate column y.
	                tempNum = transformMatrix[_j][j] / transformMatrix[j][j];
	                for (var _i = j; _i < w; _i++) {
	                    transformMatrix[_j][_i] -= transformMatrix[j][_i] * tempNum;
	                }
	            }
	        }
	        for (var j = dimPlusOne - 1; j > -1; j--) {
	            // Backsubstitute.
	            tempNum = transformMatrix[j][j];
	            for (var i = 0; i < j; i++) {
	                for (var _x = w - 1; _x > j - 1; _x--) {
	                    transformMatrix[i][_x] -= transformMatrix[j][_x] * transformMatrix[i][j] / tempNum;
	                }
	            }
	            transformMatrix[j][j] /= tempNum;
	            for (var _x2 = dimPlusOne; _x2 < w; _x2++) {
	                // Normalize row y.
	                transformMatrix[j][_x2] /= tempNum;
	            }
	        }
	        return true;
	    };
	    return AffineTransform;
	}());



	var index$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		AffineTransform: AffineTransform,
		_precision: _precision,
		get AreaUnits () { return AreaUnits; },
		get DistanceUnits () { return DistanceUnits; },
		get TimeUnits () { return TimeUnits; },
		get SpeedUnits () { return SpeedUnits; },
		get AccelerationUnits () { return AccelerationUnits; },
		boundingBoxToPolygon: boundingBoxToPolygon,
		convertDistance: convertDistance,
		getCardinalSpline: getCardinalSpline,
		getDestination: getDestination,
		getDistanceTo: getDistanceTo,
		getEarthRadius: getEarthRadius,
		getGeodesicPath: getGeodesicPath,
		getHeading: getHeading,
		getLengthOfPath: getLengthOfPath,
		getPositionAlongPath: getPositionAlongPath,
		getRegularPolygonPath: getRegularPolygonPath,
		interpolate: interpolate,
		normalizeLatitude: normalizeLatitude,
		normalizeLongitude: normalizeLongitude,
		rotatePositions: rotatePositions,
		getPixelHeading: getPixelHeading,
		mercatorPixelsToPositions: mercatorPixelsToPositions,
		mercatorPositionsToPixels: mercatorPositionsToPixels,
		convertAcceleration: convertAcceleration,
		convertArea: convertArea,
		convertSpeed: convertSpeed,
		convertTimespan: convertTimespan,
		getAcceleration: getAcceleration,
		getAccelerationFromSpeeds: getAccelerationFromSpeeds,
		getAccelerationFromFeatures: getAccelerationFromFeatures,
		getArea: getArea,
		getSpeed: getSpeed,
		getSpeedFromFeatures: getSpeedFromFeatures,
		getTimespan: getTimespan,
		getTravelDistance: getTravelDistance,
		parseTimestamp: parseTimestamp,
		getConvexHull: getConvexHull,
		getPositions: getPositions,
		getPosition: getPosition,
		getPositionsAlongPath: getPositionsAlongPath,
		getPointWithHeadingAlongPath: getPointWithHeadingAlongPath,
		getPointsWithHeadingsAlongPath: getPointsWithHeadingsAlongPath,
		getClosestPointOnGeometry: getClosestPointOnGeometry,
		simplify: simplify
	});

	/**
	 * A helper class that wraps a Geometry or Feature and makes it easy to update and maintain.
	 */
	var Shape = /** @class */ (function (_super) {
	    __extends(Shape, _super);
	    function Shape(data, id, properties) {
	        var _this = _super.call(this) || this;
	        var geometry;
	        if (data.type === "Feature") {
	            var feature = data;
	            geometry = cloneDeep_1(feature.geometry);
	            properties = feature.properties ? cloneDeep_1(feature.properties) : {};
	            id = feature.id == null || feature.id === "" ? uuidRandom() : feature.id;
	        }
	        else {
	            geometry = cloneDeep_1(data);
	            id = id == null || id === "" ? uuidRandom() : id;
	            properties = properties ? cloneDeep_1(properties) : {};
	        }
	        // Assign the feature's id to another property to workaround the Mapbox bug
	        // that prevents non-numerical ids from being returned by some functions.
	        // TODO Remove once this issue if fixed. https://github.com/mapbox/mapbox-gl-js/issues/2716
	        properties[Shape._shapeIdPropName] = id;
	        // Always create a new feature to guarantee the data matches our definition of a Feature.
	        _this.data = new Feature(geometry, properties, id);
	        _this._handleCircle();
	        return _this;
	    }
	    /**
	     * Adds or updates an existing property value in the shape.
	     * @param key
	     * @param value
	     */
	    Shape.prototype.addProperty = function (key, value) {
	        // Only add the property if it is a new value.
	        if (!isEqual_1(this.data.properties[key], value)) {
	            this.data.properties[key] = cloneDeep_1(value);
	            if (key === "subType" || key === "radius") {
	                this._handleCircle();
	            }
	            if (this.dataSource) {
	                this.dataSource._updateSource();
	            }
	            this._invokeEvent("shapechanged", this);
	        }
	    };
	    /**
	     * Gets the bounding box of the shape
	     */
	    Shape.prototype.getBounds = function () {
	        var e_1, _a, e_2, _b;
	        var positions = this.getCoordinates();
	        var bbox;
	        var geoType = this.getType();
	        if (geoType === "Point") {
	            if (this.circlePolygon) { // If a circle from the extended GeoJSON spec.
	                var pos = this.circlePolygon.geometry.coordinates;
	                bbox = BoundingBox.fromPositions(pos[0]);
	            }
	            else {
	                var pos = positions;
	                bbox = new BoundingBox(pos, pos);
	            }
	        }
	        else if (geoType === "MultiPoint" || geoType === "LineString") {
	            var pos = positions;
	            bbox = BoundingBox.fromPositions(pos);
	        }
	        else if (geoType === "Polygon") {
	            var pos = positions;
	            // only need to check the exterior ring of Polygon
	            bbox = BoundingBox.fromPositions(pos[0]);
	        }
	        else if (geoType === "MultiLineString") {
	            var pos = positions;
	            try {
	                for (var pos_1 = __values(pos), pos_1_1 = pos_1.next(); !pos_1_1.done; pos_1_1 = pos_1.next()) {
	                    var p = pos_1_1.value;
	                    bbox = BoundingBox.merge(bbox, BoundingBox.fromPositions(p));
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (pos_1_1 && !pos_1_1.done && (_a = pos_1.return)) _a.call(pos_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else if (geoType === "MultiPolygon") {
	            var pos = positions;
	            try {
	                for (var pos_2 = __values(pos), pos_2_1 = pos_2.next(); !pos_2_1.done; pos_2_1 = pos_2.next()) {
	                    var p1 = pos_2_1.value;
	                    // only need to check the exterior ring of Polygon
	                    bbox = BoundingBox.merge(bbox, BoundingBox.fromPositions(p1[0]));
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (pos_2_1 && !pos_2_1.done && (_b = pos_2.return)) _b.call(pos_2);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        return bbox;
	    };
	    /**
	     * Gets the coordinates of the shape.
	     */
	    Shape.prototype.getCoordinates = function () {
	        return cloneDeep_1(this.data.geometry.coordinates);
	    };
	    /**
	     * If the shape is a circle, this gets its coordinates. Otherwise returns null.
	     */
	    Shape.prototype.getCircleCoordinates = function () {
	        if (this.circlePolygon) {
	            return cloneDeep_1(this.circlePolygon.geometry.coordinates[0]);
	        }
	        else {
	            return null;
	        }
	    };
	    /**
	     * Gets the id of the shape.
	     */
	    Shape.prototype.getId = function () {
	        return this.data.id;
	    };
	    /**
	     * Gets the properties of the shape.
	     */
	    Shape.prototype.getProperties = function () {
	        return cloneDeep_1(this.data.properties);
	    };
	    /**
	     * Returns a string indicating the type of geometry this shape contains.
	     */
	    Shape.prototype.getType = function () {
	        return this.data.geometry.type;
	    };
	    /**
	     * Indicates if the contained shape is a Circle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     */
	    Shape.prototype.isCircle = function () {
	        return Shape._isCircle(this.data);
	    };
	    /**
	     * Indicates if the contained shape is a Rectangle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     */
	    Shape.prototype.isRectangle = function () {
	        return Shape._isRectangle(this.data);
	    };
	    /**
	     * Updates the coordinates of the shape
	     * @param coords Point: Position, LineString: Position[], Polygon: Position[][],
	     * MultiPoint: Position[], MultiLineString: Position[][], MultiPolygon: Position[][]
	     */
	    Shape.prototype.setCoordinates = function (coords) {
	        // If a Position[] is supplied for a polygon wrap it in an array.
	        var newCoords;
	        if (this.getType() === "Polygon" &&
	            Position._getDimensions(coords) === 1) {
	            newCoords = [coords];
	        }
	        else {
	            newCoords = coords;
	        }
	        // Only update the coordinates if they've actually changed.
	        if (!isEqual_1(this.data.geometry.coordinates, newCoords)) {
	            this.data.geometry.coordinates = cloneDeep_1(newCoords);
	            this._handleCircle();
	            if (this.dataSource) {
	                this.dataSource._updateSource();
	            }
	            this._invokeEvent("shapechanged", this);
	        }
	    };
	    /**
	     * Sets the properties on the shape. Overwrites all existing properties.
	     * @param properties
	     */
	    Shape.prototype.setProperties = function (properties) {
	        // Assign the feature's id to another property to workaround the Mapbox bug
	        // that prevents non-numerical ids from being returned by some functions.
	        // TODO Remove once this issue if fixed. https://github.com/mapbox/mapbox-gl-js/issues/2716
	        properties[Shape._shapeIdPropName] = this.data.id;
	        // Only update the properties if they've actually changed.
	        if (!isEqual_1(this.data.properties, properties)) {
	            this.data.properties = cloneDeep_1(properties);
	            this._handleCircle();
	            if (this.dataSource) {
	                this.dataSource._updateSource();
	            }
	            this._invokeEvent("shapechanged", this);
	        }
	    };
	    /**
	     * Returns a GeoJSON feature that represents the shape.
	     */
	    Shape.prototype.toJson = function () {
	        return JSON.parse(JSON.stringify(this.data));
	    };
	    /**
	     * Just like the toJson() function but will return a polygon feature
	     * for any circles as defined by the extended GeoJSON spec.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    Shape.prototype._toJson = function () {
	        return this.circlePolygon || this.data;
	    };
	    /**
	     * @internal
	     */
	    Shape.prototype._setDataSource = function (dataSource) {
	        if (dataSource === undefined || dataSource == null) {
	            delete this.dataSource;
	        }
	        else {
	            this.dataSource = dataSource;
	        }
	    };
	    /**
	     * Check if the shape's wrapped feature is a circle form the extended GeoJSON spec.
	     * If so it will calculate a polygon feature that approximates the specified circle.
	     * @private
	     */
	    Shape.prototype._handleCircle = function () {
	        if (this.isCircle()) {
	            var coords = Shape._getCirclePositions(this.data);
	            this.circlePolygon = new Feature(new Polygon([coords]), this.data.properties, this.data.id);
	            // Set the subType to "Circle" to make sure the case is correct.
	            this.data.properties.subType = "Circle";
	        }
	        else {
	            delete this.circlePolygon;
	        }
	    };
	    /**
	     * Indicates if the specified feature is a circle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    Shape._isCircle = function (data) {
	        return data && data.geometry &&
	            data.geometry.type === "Point" &&
	            data.geometry.coordinates && data.properties &&
	            typeof data.properties.subType === "string" &&
	            data.properties.subType.toLowerCase() === "circle" &&
	            typeof data.properties.radius === "number";
	    };
	    /**
	     * Indicates if the specified feature is a rectangle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    Shape._isRectangle = function (data) {
	        if (data.geometry.type === "Polygon" &&
	            data.geometry.coordinates &&
	            typeof data.properties.subType === "string" &&
	            data.properties.subType.toLowerCase() === "rectangle") {
	            // If type is Polygon we can assume the coordinates are a Position[][].
	            var coords = data.geometry.coordinates;
	            if (coords.length === 1) {
	                var ring = coords[0];
	                if (ring.length === 5) {
	                    return ring[0][0] === ring[4][0] &&
	                        ring[0][1] === ring[4][1];
	                }
	                else if (ring.length === 4) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    };
	    /**
	     * Calculates to positions that should be used to approximate the specified circle feature.
	     * @internal
	     */
	    Shape._getCirclePositions = function (data) {
	        return getRegularPolygonPath(data.geometry.coordinates, data.properties.radius, 72, "meters");
	    };
	    /**
	     * Represents the feature property name that the shape's id will be assigned to.
	     * This is a workaround for the Mapbox bug preventing non-numerical ids from being returned by some functions.
	     * TODO Remove once this issue if fixed.
	     * {@link https://github.com/mapbox/mapbox-gl-js/issues/2716}
	     * @internal
	     */
	    // tslint:disable-next-line: variable-name
	    Shape._shapeIdPropName = "_azureMapsShapeId";
	    return Shape;
	}(EventEmitter));

	/**
	 * A GeoJSON BoundingBox object - an array that defines a shape whose edges follow lines of constant longitude,
	 * latitude, and elevation. All axes of the most southwesterly point are followed by all axes of the more northeasterly
	 * point. The axes order of the BoundingBox follows the axes order of geometries. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-5}.
	 */
	var BoundingBox = /** @class */ (function (_super) {
	    __extends(BoundingBox, _super);
	    function BoundingBox(southwestPositionOrPositions, northeastPosition) {
	        var _this = this;
	        if (southwestPositionOrPositions && northeastPosition) {
	            var southwestPosition = southwestPositionOrPositions;
	            if (southwestPosition[2] && northeastPosition[2]) {
	                _this = _super.call(this, southwestPosition[0], southwestPosition[1], southwestPosition[2] || 0, northeastPosition[0], northeastPosition[1], northeastPosition[2] || 0) || this;
	            }
	            else {
	                _this = _super.call(this, southwestPosition[0], southwestPosition[1], northeastPosition[0], northeastPosition[1]) || this;
	            }
	        }
	        else if (southwestPositionOrPositions) {
	            var positions = southwestPositionOrPositions;
	            if (positions) {
	                if (positions.length === 4) {
	                    // [west, south, east, north]
	                    _this = _super.call(this, positions[0], positions[1], positions[2], positions[3]) || this;
	                }
	                else if (positions.length >= 6) {
	                    // [west, south, elevation1, east, north, elevation2]
	                    _this = _super.call(this, positions[0], positions[1], positions[2], positions[3], positions[4], positions[5]) || this;
	                }
	            }
	        }
	        return _this;
	    }
	    /**
	     * Clones a bounding box.
	     * @param boundingBox The bounding box to clone.
	     */
	    BoundingBox.fromBoundingBox = function (boundingBox) {
	        var west = BoundingBox.getWest(boundingBox);
	        var south = BoundingBox.getSouth(boundingBox);
	        var east = BoundingBox.getEast(boundingBox);
	        var north = BoundingBox.getNorth(boundingBox);
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Constructs a BoundingBox from the specified dimensions.
	     * @param center The center position of the bounding box.
	     * @param width The width of the bounding box.
	     * @param height The height of the bounding box.
	     */
	    BoundingBox.fromDimensions = function (center, width, height) {
	        var lon = center[0];
	        var lat = center[1];
	        var north = Math.min(Math.max(lat + height / 2, -85.5), 85.5);
	        var south = Math.min(Math.max(lat - height / 2, -85.5), 85.5);
	        var east = normalizeLongitude(lon + width / 2);
	        var west = normalizeLongitude(lon - width / 2);
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Constructs a BoundingBox from the specified edges.
	     * @param west The west edge of the bounding box.
	     * @param south The south edge of the bounding box.
	     * @param east The east edge of the bounding box.
	     * @param north The north edge of the bounding box.
	     */
	    BoundingBox.fromEdges = function (west, south, east, north) {
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Determines if a position is within a bounding box.
	     * @param bounds The bounding box to see if the position is in.
	     * @param position The position to see if it is in the bounding box.
	     * @returns True if the position is within the bounding box.
	     */
	    BoundingBox.containsPosition = function (bounds, position) {
	        // Allow a small difference to account for arithmetic accuracy errors.
	        // This is important for points on the edge of the bounding box which is the case when using BoundingBox.fromLocations
	        var accuracyAllowance = 0.00000001;
	        // Use the distance between the position and center of the bounding box to determine if they intersect.
	        var center = BoundingBox.getCenter(bounds);
	        var diffLatitude = Math.abs(center[1] - position[1]);
	        var diffLongitude = Math.abs(center[0] - position[0]);
	        if (diffLongitude > 180.0) {
	            // We want the shortest distance between the 2 points.
	            diffLongitude = 360 - diffLongitude;
	        }
	        var height = BoundingBox.getHeight(bounds);
	        var width = BoundingBox.getWidth(bounds);
	        return (diffLatitude <= (height / 2) + accuracyAllowance) && (diffLongitude <= (width / 2) + accuracyAllowance);
	    };
	    /**
	     * Determines if a bounding box is within another bounding box
	     * @param outer The outer bounding box
	     * @param inner The inner bounding box (the one that should be contained within outer)
	     * @returns True if the inner bounding box is fully container in outer
	     */
	    BoundingBox.containsBoundingBox = function (outer, inner) {
	        var outerValid = outer && outer.length === 4;
	        var innerValid = inner && inner.length === 4;
	        if (!outerValid || !innerValid) {
	            return false;
	        }
	        return BoundingBox.getWest(outer) < BoundingBox.getWest(inner) && BoundingBox.getWest(inner) < BoundingBox.getEast(outer) &&
	            BoundingBox.getWest(outer) < BoundingBox.getEast(inner) && BoundingBox.getEast(inner) < BoundingBox.getEast(outer) &&
	            BoundingBox.getSouth(outer) < BoundingBox.getSouth(inner) && BoundingBox.getSouth(inner) < BoundingBox.getNorth(outer) &&
	            BoundingBox.getSouth(outer) < BoundingBox.getNorth(inner) && BoundingBox.getNorth(inner) < BoundingBox.getNorth(outer);
	    };
	    /**
	     * Returns a boolean indicating if the bounding box crosses the antimeridian or not.
	     * @param bounds The bounding box to check.
	     * @returns A boolean indicating if the bounding box crosses the antimeridian or not.
	     */
	    BoundingBox.crossesAntimeridian = function (bounds) {
	        var east = normalizeLongitude(BoundingBox.getEast(bounds));
	        var west = normalizeLongitude(BoundingBox.getWest(bounds));
	        return (east - west) < 0
	            || BoundingBox.isBoundingBoxWithSixOrMoreElementsLargerThanGlobe(bounds)
	            || BoundingBox.isBoundingBoxWithLessThanSixElementsLargerThanGlobe(bounds);
	    };
	    /**
	     * Calculates the center of a bounding box.
	     * @param bounds A bounding box to calculate the center of.
	     * @returns A position that represents the center of the bounding box.
	     */
	    BoundingBox.getCenter = function (bounds) {
	        // [west, south, east, north]
	        var east = normalizeLongitude(BoundingBox.getEast(bounds));
	        var west = normalizeLongitude(BoundingBox.getWest(bounds));
	        if (west > east) {
	            east += 360.0;
	        }
	        var centerLongitude = normalizeLongitude((west + east) / 2.0);
	        var south = normalizeLatitude(BoundingBox.getSouth(bounds));
	        var north = normalizeLatitude(BoundingBox.getNorth(bounds));
	        var centerLatitude = normalizeLatitude((south + north) / 2.0);
	        return [centerLongitude, centerLatitude];
	    };
	    /**
	     * Gets the height of a bounding box in degrees.
	     * @param bounds The bounding box to check.
	     * @returns The height of the bounding box in degrees.
	     */
	    BoundingBox.getHeight = function (bounds) {
	        var north = normalizeLatitude(BoundingBox.getNorth(bounds));
	        var south = normalizeLatitude(BoundingBox.getSouth(bounds));
	        var height = north - south;
	        return isNaN(height) ? 0 : height;
	    };
	    /**
	     * Gets the width of a bounding box in degrees.
	     * @param bounds The bounding box to check.
	     * @returns The width of the bounding box in degrees.
	     */
	    BoundingBox.getWidth = function (bounds) {
	        var east = normalizeLongitude(BoundingBox.getEast(bounds));
	        var west = normalizeLongitude(BoundingBox.getWest(bounds));
	        var width = east - west;
	        // Check to see if bounds crosses antimeridian
	        return isNaN(width) ? 0 : width < 0 ? width += 360 : width;
	    };
	    /**
	     * Returns the south west position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The south west position of the bounding box.
	     */
	    BoundingBox.getSouthWest = function (bounds) {
	        var south = this.getSouth(bounds);
	        var west = this.getWest(bounds);
	        return (isNaN(south) || isNaN(west)) ? null : [west, south];
	    };
	    /**
	     * Returns the north east position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The north east position of the bounding box.
	     */
	    BoundingBox.getNorthEast = function (bounds) {
	        var north = this.getNorth(bounds);
	        var east = this.getEast(bounds);
	        return (isNaN(north) || isNaN(east)) ? null : [east, north];
	    };
	    /**
	     * Returns the north west position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The north west position of the bounding box.
	     */
	    BoundingBox.getNorthWest = function (bounds) {
	        var north = this.getNorth(bounds);
	        var west = this.getWest(bounds);
	        return (isNaN(north) || isNaN(west)) ? null : [west, north];
	    };
	    /**
	     * Returns the south east position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The south east position of the bounding box.
	     */
	    BoundingBox.getSouthEast = function (bounds) {
	        var south = this.getSouth(bounds);
	        var east = this.getEast(bounds);
	        return (isNaN(south) || isNaN(east)) ? null : [east, south];
	    };
	    /**
	     * Returns the south position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The south position value of the bounding box.
	     */
	    BoundingBox.getSouth = function (bounds) {
	        if (bounds && bounds.length >= 4) {
	            return Number(bounds[1]);
	        }
	        return NaN;
	    };
	    /**
	     * Returns the west position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The west position value of the bounding box.
	     */
	    BoundingBox.getWest = function (bounds) {
	        if (bounds && bounds.length >= 4) {
	            return Number(bounds[0]);
	        }
	        return NaN;
	    };
	    /**
	     * Returns the north position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The north position value of the bounding box.
	     */
	    BoundingBox.getNorth = function (bounds) {
	        if (bounds) {
	            if (bounds.length === 4) {
	                return Number(bounds[3]);
	            }
	            else if (bounds.length === 6) {
	                return Number(bounds[4]);
	            }
	        }
	        return NaN;
	    };
	    /**
	     * Returns the east position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The east position value of the bounding box.
	     */
	    BoundingBox.getEast = function (bounds) {
	        if (bounds) {
	            if (bounds.length === 4) {
	                return Number(bounds[2]);
	            }
	            else if (bounds.length === 6) {
	                return Number(bounds[3]);
	            }
	        }
	        return NaN;
	    };
	    /**
	     * Determines is two bounding boxes intersect.
	     * @param bounds1 The first bounding box to compare with.
	     * @param bounds2 The second bounding box to compare with.
	     * @returns true if the provided bounding boxes intersect.
	     */
	    BoundingBox.intersect = function (bounds1, bounds2) {
	        var center1 = BoundingBox.getCenter(bounds1);
	        var center2 = BoundingBox.getCenter(bounds2);
	        // Use the distance between the 2 centers to determine if they intersect.
	        var diffLatitude = Math.abs(center1[1] - center2[1]);
	        var diffLongitude = Math.abs(center1[0] - center2[0]);
	        if (diffLongitude > 180.0) {
	            // We want the shortest distance between the 2 points.
	            diffLongitude = 360 - diffLongitude;
	        }
	        var height1 = BoundingBox.getHeight(bounds1);
	        var width1 = BoundingBox.getWidth(bounds1);
	        var height2 = BoundingBox.getHeight(bounds2);
	        var width2 = BoundingBox.getWidth(bounds2);
	        return (diffLatitude <= (height1 / 2 + height2 / 2) && diffLongitude <= (width1 / 2 + width2 / 2));
	    };
	    /**
	     * Merges two bounding boxes together.
	     * @param bounds1 The first bounding box to merge with.
	     * @param bounds2 The second bounding box to merge with.
	     * @returns A bounding box in the format [minLon, minLat, maxLon, maxLat].
	     */
	    BoundingBox.merge = function (bounds1, bounds2) {
	        var bb1Valid = bounds1 && bounds1.length === 4;
	        var bb2Valid = bounds2 && bounds2.length === 4;
	        if (bb1Valid && !bb2Valid) {
	            return bounds1;
	        }
	        else if (bb2Valid && !bb1Valid) {
	            return bounds2;
	        }
	        else if (!bb1Valid && !bb2Valid) {
	            return null;
	        }
	        var north = Math.max(normalizeLatitude(BoundingBox.getNorth(bounds1)), normalizeLatitude(BoundingBox.getNorth(bounds2)));
	        var south = Math.min(normalizeLatitude(BoundingBox.getSouth(bounds1)), normalizeLatitude(BoundingBox.getSouth(bounds2)));
	        // Find out the longitude spans of the two bounding boxes.
	        var boundingBoxes = [bounds1, bounds2];
	        var longIntervals = [];
	        var i = 0;
	        for (i = 0; i < boundingBoxes.length; i++) {
	            var b = boundingBoxes[i];
	            var w = normalizeLongitude(BoundingBox.getWest(b));
	            var e = normalizeLongitude(BoundingBox.getEast(b));
	            if (BoundingBox.crossesAntimeridian(b)) {
	                longIntervals.push([w, 180]);
	                longIntervals.push([-180, e]);
	            }
	            else {
	                longIntervals.push([w, e]);
	            }
	        }
	        // sort and merge (overlaped intervals) these intervals
	        // after the sort and merge we should have a list of intervals that don't overlap with each other.
	        longIntervals.sort(function (a, b) { return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]; });
	        var mergedIntervals = [];
	        var currentInterval = longIntervals[0];
	        i = 1;
	        while (i < longIntervals.length) {
	            var nextInterval = longIntervals[i];
	            if (currentInterval[1] >= nextInterval[0]) {
	                currentInterval[1] = Math.max(currentInterval[1], nextInterval[1]);
	            }
	            else {
	                mergedIntervals.push(currentInterval);
	                currentInterval = nextInterval;
	            }
	            i++;
	        }
	        mergedIntervals.push(currentInterval);
	        // find out the biggest gap between these intervals. suppose this gap is [A, B], then A will be the east bound and B will be the west bound of the merged rectangle.
	        var length = mergedIntervals.length;
	        var maxGapSpan = mergedIntervals[0][0] + 360 - mergedIntervals[length - 1][1];
	        var maxGap = [mergedIntervals[length - 1][1], mergedIntervals[0][0]];
	        for (i = 1; i < length; i++) {
	            var thisGapSpan = mergedIntervals[i][0] - mergedIntervals[i - 1][1];
	            if (thisGapSpan > maxGapSpan) {
	                maxGapSpan = thisGapSpan;
	                maxGap = [mergedIntervals[i - 1][1], mergedIntervals[i][0]];
	            }
	        }
	        // now we have all the edges of the rectangle
	        return new BoundingBox([maxGap[1], south], [maxGap[0], north]);
	    };
	    /**
	     * Creates a BoundingBox that contains all provided Position objects.
	     * @param positions An array of locations to use to generate the bounding box.
	     * @returns A bounding box that contains all given positions.
	     */
	    BoundingBox.fromPositions = function (positions) {
	        var north = NaN;
	        var south = NaN;
	        var west = NaN;
	        var east = NaN;
	        var position;
	        var i = positions.length;
	        var longitudes = new Array(i);
	        var longCount = 0;
	        while (i--) {
	            position = positions[i];
	            if (position && position.length >= 2) {
	                var normalizedPosition1 = normalizeLatitude(position[1]);
	                north = isNaN(north) ? normalizedPosition1 : Math.max(north, normalizedPosition1);
	                south = isNaN(south) ? normalizedPosition1 : Math.min(south, normalizedPosition1);
	                longitudes[longCount++] = normalizeLongitude(position[0]);
	            }
	        }
	        if (longCount) {
	            // Find largest gap between longitudes
	            longitudes.length = longCount;
	            longitudes.sort(function (a, b) { return a - b; });
	            var maxGap = (longitudes[0] + 360) - longitudes[longCount - 1];
	            var maxGapIndex = 0;
	            for (i = 1; i < longCount; i++) {
	                var gap = longitudes[i] - longitudes[i - 1];
	                if (gap > maxGap) {
	                    maxGap = gap;
	                    maxGapIndex = i;
	                }
	            }
	            west = longitudes[maxGapIndex];
	            east = longitudes[(maxGapIndex || longCount) - 1];
	        }
	        if (isNaN(west) || isNaN(south) || isNaN(east) || isNaN(north)) {
	            return null;
	        }
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Creates a BoundingBox from any array of objects that contain coordinate information.
	     * Each object is either an array in the format; [lat, lng] or [lat, lng, elv], or an object with the any combination of the following properties:
	     * Longitude: lng, longitude, lon, x
	     * Latitude: lat, latitude, y
	     * Elevation: elv, elevation, alt, altitude, z
	     * @param latLngs The objects that contain coordinate information.
	     * @returns A BoundingBox that contains all the provided coordinate information.
	     */
	    BoundingBox.fromLatLngs = function (latLngs) {
	        return BoundingBox.fromPositions(Position.fromLatLngs(latLngs));
	    };
	    /**
	     * Calculates the bounding box of a FeatureCollection, Feature, Geometry, Shape or array of these objects.
	     * @param data The FeatureCollection, Feature, Geometry, Shape or array of these objects to calculate the bounding box for.
	     * @returns A bounding box in the format [minLon, minLat, maxLon, maxLat].
	     */
	    BoundingBox.fromData = function (data) {
	        var e_1, _a;
	        var tempBounds;
	        var bounds = null;
	        if (Array.isArray(data) && data.length > 0) {
	            try {
	                for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
	                    var datum = data_1_1.value;
	                    tempBounds = BoundingBox.fromData(datum);
	                    if (tempBounds != null) {
	                        if (bounds === null) {
	                            bounds = tempBounds;
	                        }
	                        else {
	                            bounds = BoundingBox.merge(bounds, tempBounds);
	                        }
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            return bounds;
	        }
	        else if (data instanceof Shape) {
	            return data.getBounds();
	        }
	        else if (data && data["type"]) {
	            // Data is a GeoJson object.
	            var geoJsonObj = data;
	            // Check to see if the GeoJSON object has a bbox, property, and if it does, use that.
	            if (geoJsonObj["bbox"] && geoJsonObj["bbox"].length === 4) {
	                return geoJsonObj["bbox"];
	            }
	            else {
	                switch (geoJsonObj.type) {
	                    case "FeatureCollection":
	                        // features: Array<Feature<Geometry>>
	                        return BoundingBox.fromData(geoJsonObj.features);
	                    case "Feature":
	                        // geometry: G
	                        if (Shape._isCircle(geoJsonObj)) {
	                            return BoundingBox.fromPositions(Shape._getCirclePositions(geoJsonObj));
	                        }
	                        else {
	                            return BoundingBox.fromData(geoJsonObj.geometry);
	                        }
	                    case "GeometryCollection":
	                        // geometries: Geometry[]
	                        return BoundingBox.fromData(geoJsonObj.geometries);
	                    case "Point":
	                        // coordinates: Position
	                        var p = geoJsonObj.coordinates;
	                        if (p && p.length >= 2) {
	                            return [p[0], p[1], p[0], p[1]];
	                        }
	                        break;
	                    case "LineString":
	                    case "MultiPoint":
	                        // coordinates: Position[]
	                        return BoundingBox.fromPositions(geoJsonObj.coordinates);
	                    case "Polygon":
	                    case "MultiLineString":
	                        // coordinates: Position[][]
	                        var ml = geoJsonObj.coordinates;
	                        if (ml && ml.length > 0) {
	                            for (var i = 0, len = ml.length; i < len; i++) {
	                                tempBounds = BoundingBox.fromPositions(ml[i]);
	                                if (tempBounds != null) {
	                                    if (bounds === null) {
	                                        bounds = tempBounds;
	                                    }
	                                    else {
	                                        bounds = BoundingBox.merge(bounds, tempBounds);
	                                    }
	                                }
	                            }
	                            if (bounds != null) {
	                                return bounds;
	                            }
	                        }
	                        break;
	                    case "MultiPolygon":
	                        // coordinates: Position[][][]
	                        var mp = geoJsonObj.coordinates;
	                        if (mp && mp.length > 0) {
	                            for (var i = 0, len = mp.length; i < len; i++) {
	                                for (var j = 0, cnt = mp[i].length; j < cnt; j++) {
	                                    tempBounds = BoundingBox.fromPositions(mp[i][j]);
	                                    if (tempBounds != null) {
	                                        if (bounds === null) {
	                                            bounds = tempBounds;
	                                        }
	                                        else {
	                                            bounds = BoundingBox.merge(bounds, tempBounds);
	                                        }
	                                    }
	                                }
	                            }
	                            return bounds;
	                        }
	                        break;
	                }
	            }
	        }
	        return null;
	    };
	    /**
	     * Splits a BoundingBox that crosses the Antimeridian into two BoundingBox's. One entirely west of the Antimerdian and another entirely east of the Antimerdian.
	     * @param bounds
	     */
	    BoundingBox.splitOnAntimeridian = function (bounds) {
	        var bboxes = [];
	        //Test the case when the bounding box is wider than a single globe.
	        if (BoundingBox.isBoundingBoxWithSixOrMoreElementsLargerThanGlobe(bounds)) {
	            return [[-180, bounds[1], bounds[2], 180, bounds[4], bounds[5]]];
	        }
	        else if (BoundingBox.isBoundingBoxWithLessThanSixElementsLargerThanGlobe(bounds)) {
	            return [[-180, bounds[1], 180, bounds[3]]];
	        }
	        else if (BoundingBox.crossesAntimeridian(bounds)) {
	            //Case when map less than full globe width, but crosses anti-meridian.
	            var bbox1 = void 0;
	            var bbox2 = void 0;
	            var west = normalizeLongitude(BoundingBox.getWest(bounds));
	            var east = normalizeLongitude(BoundingBox.getEast(bounds));
	            var north = normalizeLatitude(BoundingBox.getNorth(bounds));
	            var south = normalizeLatitude(BoundingBox.getSouth(bounds));
	            // has elevations
	            if (bounds.length >= 6) {
	                bbox1 = [west, south, bounds[2], 180, north, bounds[5]];
	                bbox2 = [-180, south, bounds[2], east, north, bounds[5]];
	            }
	            else {
	                bbox1 = [west, south, 180, north];
	                bbox2 = [-180, south, east, north];
	            }
	            bboxes.push(bbox1, bbox2);
	        }
	        else {
	            bboxes.push(bounds);
	        }
	        return bboxes;
	    };
	    BoundingBox.isBoundingBoxWithSixOrMoreElementsLargerThanGlobe = function (bounds) {
	        return bounds.length >= 6 && bounds[3] - bounds[0] > 360;
	    };
	    BoundingBox.isBoundingBoxWithLessThanSixElementsLargerThanGlobe = function (bounds) {
	        return bounds.length < 6 && bounds[2] - bounds[0] > 360;
	    };
	    return BoundingBox;
	}(Array));

	/**
	 * A GeoJSON FeatureCollection object - a JSON object that contains a collection of GeoJSON features. The full
	 * description is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.3}.
	 */
	var FeatureCollection = /** @class */ (function () {
	    /**
	     * Constructs a FeatureCollection.
	     * @param features The collection of features that make up the feature collection.
	     * @param bbox The bounding box of the feature collection.
	     */
	    function FeatureCollection(features, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "FeatureCollection".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "FeatureCollection";
	        this.type = FeatureCollection.TYPE;
	        this.features = features;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the FeatureCollection class to be used in runtime comparisons.
	     */
	    FeatureCollection.TYPE = "FeatureCollection";
	    return FeatureCollection;
	}());

	/**
	 * A GeoJSON GeometryCollection object - a JSON object that contains a collection of a GeoJSON Geometry objects. The
	 * full description is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.8}.
	 */
	var GeometryCollection = /** @class */ (function () {
	    /**
	     * Constructs a GeometryCollection.
	     * @param geometries The collection of geometries that make up the geometry collection.
	     */
	    function GeometryCollection(geometries) {
	        /**
	         * A GeoJSON type descriptor with value "GeometryCollection".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "GeometryCollection";
	        this.type = GeometryCollection.TYPE;
	        this.geometries = geometries;
	    }
	    /**
	     * A static GeoJSON type descriptor for the GeometryCollection class to be used in runtime comparisons.
	     */
	    GeometryCollection.TYPE = "GeometryCollection";
	    return GeometryCollection;
	}());

	/**
	 * A GeoJSON LineString object - a JSON object that represents a geographic curve. The full description is detailed
	 * in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.4}.
	 */
	var LineString = /** @class */ (function () {
	    /**
	     * Constructs a LineString.
	     * @param coordinates The ordered list of positions defining the linestring.
	     * @param bbox The bounding box of the linestring.
	     */
	    function LineString(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "LineString".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "LineString";
	        this.type = LineString.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the LineString class to be used in runtime comparisons.
	     */
	    LineString.TYPE = "LineString";
	    return LineString;
	}());

	/**
	 * A GeoJSON MultiLineString object - a JSON object that represents multiple geographic curves. The full description
	 * is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.5}.
	 */
	var MultiLineString = /** @class */ (function () {
	    /**
	     * Constructs a MultiLineString.
	     * @param coordinates The array of LineString coordinate arrays defining the multilinestring.
	     * @param bbox The bounding box of the multilinestring.
	     */
	    function MultiLineString(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "MutliLineString".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "MultiLineString";
	        this.type = MultiLineString.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the MultiLineString class to be used in runtime comparisons.
	     */
	    MultiLineString.TYPE = "MultiLineString";
	    return MultiLineString;
	}());

	/**
	 * A GeoJSON MultiPoint object - a JSON object that represents multiple geographic positions. The full description
	 * is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.3}.
	 */
	var MultiPoint = /** @class */ (function () {
	    /**
	     * Constructs a MultiPoint.
	     * @param coordinates The array of multiple positions defining the multipoint.
	     * @param bbox The bounding box of the multipoint.
	     */
	    function MultiPoint(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "MutliPoint".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "MultiPoint";
	        this.type = MultiPoint.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the MultiPoint class to be used in runtime comparisons.
	     */
	    MultiPoint.TYPE = "MultiPoint";
	    return MultiPoint;
	}());

	/**
	 * A GeoJSON MultiPolygon object - a JSON object that represents multiple geographic polygons. The full description is
	 * detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.7}.
	 */
	var MultiPolygon = /** @class */ (function () {
	    /**
	     * Constructs a MultiPolygon.
	     * @param coordinates The array of polygon coordinate arrays defining the multipolygon.
	     * @param bbox The bounding box of the multipolygon.
	     */
	    function MultiPolygon(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "MutliPolygon".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "MultiPolygon";
	        this.type = MultiPolygon.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the MultiPolygon class to be used in runtime comparisons.
	     */
	    MultiPolygon.TYPE = "MultiPolygon";
	    return MultiPolygon;
	}());



	var index$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Feature: Feature,
		FeatureCollection: FeatureCollection,
		LineString: LineString,
		Point: Point,
		Polygon: Polygon,
		Position: Position,
		BoundingBox: BoundingBox,
		MultiLineString: MultiLineString,
		MultiPoint: MultiPoint,
		MultiPolygon: MultiPolygon,
		GeometryCollection: GeometryCollection
	});

	/**
	 * The options for a ZoomControl object.
	 */
	var ZoomControlOptions = /** @class */ (function (_super) {
	    __extends(ZoomControlOptions, _super);
	    function ZoomControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The extent to which the map will zoom with each click of the control.
	         * Default `1`.
	         * @default 1
	         */
	        _this.zoomDelta = 1;
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`.
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        return _this;
	    }
	    return ZoomControlOptions;
	}(Options));

	/**
	 * A control for changing the zoom of the map.
	 */
	var ZoomControl = /** @class */ (function (_super) {
	    __extends(ZoomControl, _super);
	    /**
	     * Constructs a ZoomControl.
	     * @param options The options for the control.
	     */
	    function ZoomControl(options) {
	        var _this = _super.call(this) || this;
	        _this.container = null;
	        _this.zoomInButton = null;
	        _this.zoomOutButton = null;
	        _this.zoomChanged = function (event) { return _this.updateZoomButtonsState(); };
	        _this.minZoomChanged = function (zoom) { return _this.updateZoomButtonsState(); };
	        _this.maxZoomChanged = function (zoom) { return _this.updateZoomButtonsState(); };
	        _this.options = new ZoomControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    ZoomControl.prototype.onAdd = function (map) {
	        this.container = this.buildContainer(map, this.options.style, "Zoom Control");
	        this.container.style.flexDirection = "column";
	        this.zoomInButton = this.constructZoomInButton(map);
	        this.zoomOutButton = this.constructZoomOutButton(map);
	        this.container.appendChild(this.zoomInButton);
	        this.container.appendChild(this.zoomOutButton);
	        map.events.add('zoom', this.zoomChanged);
	        map.events.add('minzoomchanged', this.minZoomChanged);
	        map.events.add('maxzoomchanged', this.maxZoomChanged);
	        this.map = map;
	        return this.container;
	    };
	    ZoomControl.prototype.onRemove = function () {
	        if (this.map) {
	            this.map.events.remove('zoom', this.zoomChanged);
	            this.map.events.remove('minzoomchanged', this.minZoomChanged);
	            this.map.events.remove('maxzoomchanged', this.maxZoomChanged);
	            this.map = null;
	        }
	        if (this.container) {
	            this.container.remove();
	            this.container = null;
	            this.zoomInButton = null;
	            this.zoomOutButton = null;
	        }
	    };
	    ZoomControl.prototype.updateZoomButtonsState = function () {
	        var zoomInDisabled = this.map.getCamera().zoom >= this.map._getMap().getMaxZoom();
	        // small values need special handling, since depending on the height of the map view 
	        // the actual zoom we can zoom out to can be above or below 0 when the entire map fits the height into the view
	        // use web mercator bounds to check if entire latitude range is visible
	        var reachedLatitudeBoundaries = BoundingBox.getSouth(this.map.getCamera().bounds) <= -ZoomControl.WEBMERCATOR_MAXLAT
	            && BoundingBox.getNorth(this.map.getCamera().bounds) >= ZoomControl.WEBMERCATOR_MAXLAT;
	        var zoomOutDisabled = this.map.getCamera().zoom <= this.map._getMap().getMinZoom() || reachedLatitudeBoundaries;
	        if (this.zoomInButton && this.zoomInButton.disabled != zoomInDisabled) {
	            this.zoomInButton.disabled = zoomInDisabled;
	        }
	        if (this.zoomOutButton && this.zoomOutButton.disabled != zoomOutDisabled) {
	            this.zoomOutButton.disabled = zoomOutDisabled;
	        }
	    };
	    ZoomControl.prototype.constructZoomInButton = function (map) {
	        var _this = this;
	        var zoomInButton = document.createElement("button");
	        zoomInButton.classList.add("azure-maps-control-button");
	        zoomInButton.classList.add("zoom-in");
	        zoomInButton.setAttribute("title", "Zoom In");
	        zoomInButton.setAttribute("alt", "Zoom In");
	        zoomInButton.setAttribute("type", "button");
	        zoomInButton.addEventListener("click", function () {
	            map.setCamera({
	                zoom: map.getCamera().zoom + _this.options.zoomDelta,
	                duration: ZoomControl.ZOOM_DURATION_MS,
	                type: "ease",
	            }, true);
	        });
	        return zoomInButton;
	    };
	    ZoomControl.prototype.constructZoomOutButton = function (map) {
	        var _this = this;
	        var zoomOutButton = document.createElement("button");
	        zoomOutButton.classList.add("azure-maps-control-button");
	        zoomOutButton.classList.add("zoom-out");
	        zoomOutButton.setAttribute("title", "Zoom Out");
	        zoomOutButton.setAttribute("alt", "Zoom Out");
	        zoomOutButton.setAttribute("type", "button");
	        zoomOutButton.addEventListener("click", function () {
	            map.setCamera({
	                zoom: map.getCamera().zoom - _this.options.zoomDelta,
	                duration: ZoomControl.ZOOM_DURATION_MS,
	                type: "ease",
	            }, true);
	        });
	        return zoomOutButton;
	    };
	    ZoomControl.WEBMERCATOR_MAXLAT = 85.0511;
	    ZoomControl.ZOOM_DURATION_MS = 200;
	    return ZoomControl;
	}(ControlBase));



	var index$3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ControlBase: ControlBase,
		PitchControl: PitchControl,
		CompassControl: CompassControl,
		ZoomControl: ZoomControl,
		StyleControl: StyleControl,
		TrafficControl: TrafficControl,
		TrafficLegendControl: TrafficLegendControl
	});

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$2 = 1,
	    CLONE_SYMBOLS_FLAG$2 = 4;

	/**
	 * This method is like `_.cloneWith` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @param {Function} [customizer] The function to customize cloning.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.cloneWith
	 * @example
	 *
	 * function customizer(value) {
	 *   if (_.isElement(value)) {
	 *     return value.cloneNode(true);
	 *   }
	 * }
	 *
	 * var el = _.cloneDeepWith(document.body, customizer);
	 *
	 * console.log(el === document.body);
	 * // => false
	 * console.log(el.nodeName);
	 * // => 'BODY'
	 * console.log(el.childNodes.length);
	 * // => 20
	 */
	function cloneDeepWith(value, customizer) {
	  customizer = typeof customizer == 'function' ? customizer : undefined;
	  return _baseClone(value, CLONE_DEEP_FLAG$2 | CLONE_SYMBOLS_FLAG$2, customizer);
	}

	var cloneDeepWith_1 = cloneDeepWith;

	/**
	 * A data source for managing shape data that will be displayed on the map.
	 * A data source must be added to a layer before it is visible on the map.
	 * Options for a `DataSourceOptions`.
	 * @module Object Definitions
	 */
	var DataSourceOptions = /** @class */ (function (_super) {
	    __extends(DataSourceOptions, _super);
	    function DataSourceOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /*
	         * The size of the buffer around each tile.
	         * A buffer value of 0 will provide better performance but will be more likely to generate artifacts when rendering.
	         * Larger buffers will produce left artifacts but will result in slower performance.
	         */
	        _this.buffer = 128;
	        /**
	         * Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels).
	         * default `18`
	         * @default 18
	         */
	        _this.maxZoom = 18;
	        /**
	         * A boolean indicating if Point features in the source should be clustered or not.
	         * If set to true, points will be clustered together into groups by radius.
	         * default `false`
	         * @default false
	         */
	        _this.cluster = false;
	        /**
	         * The radius of each cluster in pixels.
	         * default `50`
	         * @default 50
	         */
	        _this.clusterRadius = 50;
	        /**
	         * The maximum zoom level in which to cluster points.
	         * Defaults to one zoom less than `maxZoom` so that last zoom features are not clustered.
	         */
	        _this.clusterMaxZoom = undefined;
	        /**
	         * Defines custom properties that are calculated using expressions against all the points within each cluster and added to the properties of each cluster point.
	         */
	        _this.clusterProperties = undefined;
	        /**
	         * Specifies whether to calculate line distance metrics.
	         * This is required for line layers that specify `lineGradient` values.
	         * default `false`
	         * @default false
	         */
	        _this.lineMetrics = false;
	        /**
	         * The Douglas-Peucker simplification tolerance that is applied to the data when rendering (higher means simpler geometries and faster performance).
	         * default `0.375`
	         * @default 0.375
	         */
	        _this.tolerance = 0.375;
	        return _this;
	    }
	    return DataSourceOptions;
	}(Options));

	/**
	 * A base abstract class in which all other source objects extend.
	 * A source must be added to a layer before it is visible on the map.
	 */
	var Source = /** @class */ (function (_super) {
	    __extends(Source, _super);
	    function Source(id) {
	        var _this = _super.call(this) || this;
	        _this.id = id || uuidRandom();
	        return _this;
	    }
	    /**
	     * Gets the id of the data source
	     */
	    Source.prototype.getId = function () {
	        return this.id;
	    };
	    /**
	     * Get reference to Mapbox Map
	     * @internal
	     */
	    Source.prototype._setMap = function (map) {
	        if (map == null || map === undefined) {
	            var temp = this.map;
	            delete this.map;
	            this._invokeEvent("sourceremoved", this);
	            if (temp) {
	                temp.events.invoke("sourceremoved", this);
	            }
	        }
	        else {
	            this.map = map;
	            this._invokeEvent("sourceadded", this);
	            this.map.events.invoke("sourceadded", this);
	        }
	    };
	    return Source;
	}(EventEmitter));

	/**
	 * A data source class that makes it easy to manage shapes data that will be displayed on the map.
	 * A data source must be added to a layer before it is visible on the map.
	 * The DataSource class may be used with the SymbolLayer, LineLayer, PolygonLayer, BubbleLayer, and HeatMapLayer.
	 */
	var DataSource = /** @class */ (function (_super) {
	    __extends(DataSource, _super);
	    /**
	     * A data source class that makes it easy to manage shapes data that will be displayed on the map.
	     * A data source must be added to a layer before it is visible on the map.
	     * The `DataSource` class may be used with the `SymbolLayer`, `LineLayer`, `PolygonLayer`, `BubbleLayer`, and `HeatMapLayer`.
	     * @param id a unique id that the user assigns to the data source. If this is not specified, then the data source will automatically be assigned an id.
	     * @param options the options for the data source.
	     */
	    function DataSource(id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.requestId = undefined;
	        _this.options = new DataSourceOptions().merge(cloneDeep_1(options));
	        _this.shapes = [];
	        _this.shapesMap = new Dictionary();
	        return _this;
	    }
	    /**
	     * Adds shapes to the data source.
	     * GeoJSON objects will be wrapped within a Shape class to make them easier to manage.
	     * Optionally specify an index to insert the feature between other shapes/features in the layers.
	     * @param data
	     * @param index
	     */
	    DataSource.prototype.add = function (data, index) {
	        this._addNoUpdate(data, index);
	        this._updateSource();
	    };
	    /**
	     * Removes all data in the data source.
	     */
	    DataSource.prototype.clear = function () {
	        this._clearNoUpdate();
	        this._updateSource();
	    };
	    /**
	     * Cleans up any resources this object is consuming.
	     */
	    DataSource.prototype.dispose = function () {
	        this.options = null;
	        this.shapes = null;
	        this.shapesMap = null;
	        this.map = null;
	    };
	    /*
	     * (P3) Gets the bounding box the encloses all data in the data source.
	     * public getBounds() {}
	     */
	    /**
	     * Calculates a zoom level at which the cluster will start expanding or break apart.
	     * @param clusterId
	     */
	    DataSource.prototype.getClusterExpansionZoom = function (clusterId) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            if (!_this.map) {
	                reject("The DataSource hasn't been added to a map.");
	                return;
	            }
	            var mbSource = _this.map._getMap().getSource(_this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.getClusterExpansionZoom(clusterId, function (error, zoom) {
	                    if (error) {
	                        reject(error);
	                        return;
	                    }
	                    if (typeof zoom === "number") {
	                        resolve(zoom);
	                        return;
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Retrieves the children of the given cluster on the next zoom level. This may be a combination of shapes and sub-clusters.
	     * The sub-clusters will be features with properties matching ClusteredProperties.
	     * @param clusterId
	     */
	    DataSource.prototype.getClusterChildren = function (clusterId) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            if (!_this.map) {
	                reject("The DataSource hasn't been added to a map.");
	                return;
	            }
	            var mbSource = _this.map._getMap().getSource(_this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.getClusterChildren(clusterId, function (error, features) {
	                    if (error) {
	                        reject(error);
	                        return;
	                    }
	                    if (features) {
	                        resolve(_this.map.sources._mapFeaturesToShapes(features, false, _this));
	                        return;
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Retrieves shapes that are within the cluster.
	     * @param clusterId
	     * @param limit The maximum number of features to return. Set to Infinity to return all shapes.
	     * @param offset The number of shapes to skip. Allows you to page through the shapes in the cluster.
	     */
	    DataSource.prototype.getClusterLeaves = function (clusterId, limit, offset) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            if (!_this.map) {
	                reject("The DataSource hasn't been added to a map.");
	                return;
	            }
	            var mbSource = _this.map._getMap().getSource(_this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.getClusterLeaves(clusterId, limit, offset, function (error, features) {
	                    if (error) {
	                        reject(error);
	                        return;
	                    }
	                    if (features) {
	                        resolve(_this.map.sources._mapFeaturesToShapes(features, false, _this));
	                        return;
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Gets the options used by the data source.
	     */
	    DataSource.prototype.getOptions = function () {
	        return cloneDeep_1(this.options);
	    };
	    /**
	     * Returns all shapes that are in the DataSource.
	     */
	    DataSource.prototype.getShapes = function () {
	        return Array.from(this.shapes);
	    };
	    /**
	     * Downloads a GeoJSON document and imports its data into the data source.
	     * The GeoJSON document must be on the same domain or accessible using CORS.
	     * @param url
	     */
	    DataSource.prototype.importDataFromUrl = function (url) {
	        var _this = this;
	        return fetch(url, {
	            method: "GET",
	            mode: "cors"
	        }).then(function (response) {
	            if (response.ok) {
	                return response.json();
	            }
	            else {
	                throw new Error("HTTP " + response.status + ": " + response.statusText);
	            }
	        }).then(function (geoJson) {
	            _this.add(geoJson);
	        });
	    };
	    /**
	     * Retrieves a shape with the specified id.
	     * If no shape with the specified id is contained in the data source, null will be return.
	     * @param id The id of the shape to return.
	     */
	    DataSource.prototype.getShapeById = function (id) {
	        return this.shapes[this.shapesMap.get(id)] || null;
	    };
	    /**
	     * Removes one or more shapes from the data source.
	     * If a string is passed in, it is assumed to be an id.
	     * If a number is passed in, removes the shape at that index.
	     * @param shape The shape(s), shape id(s), or feature(s) to be removed
	     */
	    DataSource.prototype.remove = function (shape) {
	        var e_1, _a;
	        var shapes = Array.isArray(shape) ? shape : [shape];
	        try {
	            for (var shapes_1 = __values(shapes), shapes_1_1 = shapes_1.next(); !shapes_1_1.done; shapes_1_1 = shapes_1.next()) {
	                var s = shapes_1_1.value;
	                if (typeof s === "number") {
	                    this._removeByIndex(s);
	                }
	                else {
	                    this._removeById(s);
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (shapes_1_1 && !shapes_1_1.done && (_a = shapes_1.return)) _a.call(shapes_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        this._updateSource();
	    };
	    /**
	     * Removes one or more shapes from the datasource based on its id.
	     * @param shape shape id
	     */
	    DataSource.prototype.removeById = function (id) {
	        var e_2, _a;
	        var ids = Array.isArray(id) ? id : [id];
	        try {
	            for (var ids_1 = __values(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
	                var i = ids_1_1.value;
	                this._removeById(i);
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (ids_1_1 && !ids_1_1.done && (_a = ids_1.return)) _a.call(ids_1);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	        this._updateSource();
	    };
	    /**
	     * Sets the data source options.
	     * The data source will retain its current values for any option not specified in the supplied options.
	     * @param options the DataSourceOptions to be set
	     */
	    DataSource.prototype.setOptions = function (options) {
	        var newOptions = new DataSourceOptions().merge(this.options, cloneDeep_1(options));
	        // Only rebuild the map's style if a options has actually changed.
	        if (!isEqual_1(this.options, newOptions)) {
	            this._invokeEvent("datasourceupdated", this);
	            // Update the options before rebuilding.
	            this.options = newOptions;
	            if (this.map) {
	                this.map._rebuildStyle();
	            }
	        }
	    };
	    /**
	     * Overwrites all shapes in the data source with the new array of shapes.
	     * @param shape the new shapes to update
	     */
	    DataSource.prototype.setShapes = function (shape) {
	        this._clearNoUpdate();
	        this.add(shape);
	    };
	    /**
	     * Returns a GeoJSON FeatureCollection which contains all the shape data that is in the data source.
	     */
	    DataSource.prototype.toJson = function () {
	        return new FeatureCollection(this.shapes.map(function (shape) { return shape.toJson(); }));
	    };
	    /**
	     * Just like the toJson() function but will return a polygon feature
	     * for any circles as defined by the extended GeoJSON spec.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    DataSource.prototype._toJson = function () {
	        return new FeatureCollection(this.shapes.map(function (shape) { return shape._toJson(); }));
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._buildSource = function () {
	        var geoJsonSource = {
	            type: "geojson",
	            data: this._toJson(),
	            maxzoom: this.options.maxZoom,
	            cluster: this.options.cluster,
	            clusterRadius: this.options.clusterRadius,
	            tolerance: this.options.tolerance,
	            lineMetrics: this.options.lineMetrics,
	            clusterProperties: this.options.clusterProperties,
	            buffer: this.options.buffer
	        };
	        if (typeof this.options.clusterMaxZoom === "number") {
	            geoJsonSource.clusterMaxZoom = this.options.clusterMaxZoom;
	        }
	        return geoJsonSource;
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._addNoUpdate = function (data, index) {
	        var newShapes;
	        if (data instanceof Shape) {
	            this._addToSources(data, index);
	            newShapes = [data];
	        }
	        else if (Array.isArray(data)) {
	            newShapes = data.map(function (ele) { return ele instanceof Shape ? ele : new Shape(ele); });
	            this._addToSources(newShapes, index);
	        }
	        else if (data.type === "FeatureCollection") {
	            newShapes = data.features.map(function (ele) { return new Shape(ele); });
	            this._addToSources(newShapes, index);
	        }
	        else if (data.type === "GeometryCollection") {
	            newShapes = data.geometries.map(function (ele) { return new Shape(ele); });
	            this._addToSources(newShapes, index);
	        }
	        else {
	            // Either a Feature or Geometry.
	            // The Shape constructor can handle either.
	            var shape = new Shape(data);
	            this._addToSources(shape, index);
	            newShapes = [shape];
	        }
	        // Invoke the dataadded event once all the new features have been wrapped with shapes.
	        this._invokeEvent("dataadded", newShapes);
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._clearNoUpdate = function () {
	        var oldShapes = this.shapes;
	        this.shapes = [];
	        this.shapesMap = new Dictionary();
	        // If any shapes were removed fire the dataremoved event.
	        if (oldShapes && oldShapes.length > 0) {
	            this._invokeEvent("dataremoved", oldShapes);
	        }
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._updateSource = function () {
	        var _this = this;
	        // throttling logic that makes DataSource waits a small amount of time before rerendering the map, so the browser won't get frozen
	        // when there is too much data
	        if (this.requestId !== undefined) {
	            return;
	        }
	        else {
	            this.requestId = requestAnimationFrame(function () {
	                _this._updateMboxSource();
	                _this.requestId = undefined;
	            });
	        }
	    };
	    DataSource.prototype._addToSources = function (data, index) {
	        var e_3, _a, e_4, _b;
	        data = Array.isArray(data) ? data : [data];
	        if (typeof index !== "number") {
	            try {
	                for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
	                    var d = data_1_1.value;
	                    this.shapes.push(d);
	                    this.shapesMap.set(d.getId(), this.shapes.length - 1);
	                }
	            }
	            catch (e_3_1) { e_3 = { error: e_3_1 }; }
	            finally {
	                try {
	                    if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
	                }
	                finally { if (e_3) throw e_3.error; }
	            }
	        }
	        else {
	            for (var i = data.length - 1; i >= 0; i--) {
	                this.shapes.splice(index, 0, data[i]);
	                this._updateShapesMap(index);
	            }
	        }
	        try {
	            for (var data_2 = __values(data), data_2_1 = data_2.next(); !data_2_1.done; data_2_1 = data_2.next()) {
	                var d = data_2_1.value;
	                d._setDataSource(this);
	            }
	        }
	        catch (e_4_1) { e_4 = { error: e_4_1 }; }
	        finally {
	            try {
	                if (data_2_1 && !data_2_1.done && (_b = data_2.return)) _b.call(data_2);
	            }
	            finally { if (e_4) throw e_4.error; }
	        }
	    };
	    DataSource.prototype._removeById = function (shape) {
	        var oldShape;
	        var i = shape instanceof Shape ? shape.getId() : typeof shape === "string" || typeof shape === "number" ? shape : shape.id;
	        oldShape = this.shapes[this.shapesMap.get(i)];
	        if (oldShape) {
	            oldShape._setDataSource(null);
	            this.shapes.splice(this.shapesMap.get(i), 1);
	            this._updateShapesMap(this.shapesMap.get(i));
	            this.shapesMap.delete(i);
	            // Invoke the dataremoved event with the single shape removed.
	            this._invokeEvent("dataremoved", [oldShape]);
	        }
	    };
	    DataSource.prototype._removeByIndex = function (i) {
	        var oldShape;
	        if (i >= this.shapes.length) {
	            throw new Error("The specified remove index '" + i + "' " +
	                ("is greater than the maximum possible index '" + (this.shapes.length - 1) + "'"));
	        }
	        oldShape = this.shapes[i];
	        this.shapesMap.delete(oldShape.getId());
	        oldShape._setDataSource(null);
	        this.shapes.splice(i, 1);
	        this._updateShapesMap(i);
	        // Invoke the dataremoved event with the single shape removed.
	        this._invokeEvent("dataremoved", [oldShape]);
	    };
	    DataSource.prototype._updateShapesMap = function (index) {
	        for (var i = index; i < this.shapes.length; i++) {
	            this.shapesMap.set(this.shapes[i].getId(), i);
	        }
	    };
	    DataSource.prototype._updateMboxSource = function () {
	        if (this.map && this.map._getMap()) {
	            var mbSource = this.map._getMap().getSource(this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.setData(this._toJson());
	            }
	        }
	    };
	    return DataSource;
	}(Source));

	/**
	 * A data source for managing shape data that will be displayed on the map.
	 * A data source must be added to a layer before it is visible on the map.
	 * Options for a `VectorTileSource`.
	 * @module Object Definitions
	 */
	var VectorTileSourceOptions = /** @class */ (function (_super) {
	    __extends(VectorTileSourceOptions, _super);
	    function VectorTileSourceOptions() {
	        /*
	         * TODO:
	         * (P4) An attribute to display to the user when this data source is visible.
	         *
	         * public attribute?: string;
	         */
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A bounding box that specifies where tiles are available.
	         * When specified, no tiles outside of the bounding box will be requested.
	         */
	        _this.bounds = undefined;
	        /**
	         * An integer specifying the minimum zoom level to render the layer at.
	         * default `0`
	         * @default 0
	         */
	        _this.minZoom = 0;
	        /**
	         * An integer specifying the maximum zoom level to render the layer at.
	         * default `22`
	         * @default 22
	         */
	        _this.maxZoom = 22;
	        /**
	         * Specifies is the tile systems y coordinate uses the OSGeo Tile Map Services which reverses the Y coordinate axis.
	         * default `false`
	         * @default false
	         */
	        _this.isTMS = false;
	        /**
	         * An array of one or more tile source URLs. Supported URL parameters:
	         *  <ul>
	         *      <li>`{x}` - X position of tile. Tile URL usually also needs {y} and {z}.</li>
	         *      <li>`{y}` - Y position of tile. Tile URL usually also needs {x} and {z}.</li>
	         *      <li>`{z}` - Zoom level of tile. Tile URL usually also needs {x} and {y}.</li>
	         *      <li>`{quadkey}` - Tile quadkey id based on the Bing Maps tile system naming convention.</li>
	         *      <li>`{bbox-epsg-3857}` - A bounding box string with the format "{west},{south},{east},{north}" with coordinates in the EPSG 3857 Spatial Reference System also commonly known as WGS84 Web Mercator. This is useful when working with WMS imagery services.</li>
	         *  <ul>
	         */
	        _this.tiles = undefined;
	        /**
	         * A URL to a TileJSON resource.
	         * Supported protocols are `http:` and `https:`.
	         */
	        _this.url = undefined;
	        return _this;
	    }
	    return VectorTileSourceOptions;
	}(Options));

	/**
	 * A vector tile source describes how to access a vector tile layer.
	 * Vector tile sources can be used with; SymbolLayer, LineLayer, PolygonLayer, BubbleLayer, HeatmapLayer and VectorTileLayer.
	 */
	var VectorTileSource = /** @class */ (function (_super) {
	    __extends(VectorTileSource, _super);
	    function VectorTileSource(id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new VectorTileSourceOptions().merge(cloneDeep_1(options));
	        return _this;
	    }
	    /**
	     * Gets the options of the VectorTileSource.
	     */
	    VectorTileSource.prototype.getOptions = function () {
	        return cloneDeep_1(this.options);
	    };
	    /**
	     * Returns all GeoJSON features that are in the VectorTileSource and which satisfy the specified filter expression.
	     * @param sourceLayer Required if the source is a VectorTileSource. Specifies the layer within the VectorTileSource to query.
	     * @param filter A filter that will limit the query.
	     */
	    VectorTileSource.prototype.getShape = function (sourceLayer, filter) {
	        return this.map._getMap().querySourceFeatures(this.getId(), { sourceLayer: sourceLayer, filter: filter });
	    };
	    /**
	     * @internal
	     */
	    VectorTileSource.prototype._buildSource = function () {
	        var vectorSource = {
	            type: "vector",
	        };
	        if (this.options.bounds) {
	            vectorSource["bounds"] = this.options.bounds;
	        }
	        if (this.options.tiles) {
	            vectorSource["tiles"] = this.options.tiles;
	            vectorSource["minzoom"] = this.options.minZoom;
	            vectorSource["maxzoom"] = this.options.maxZoom;
	        }
	        else if (this.options.url) {
	            vectorSource["url"] = this.options.url;
	        }
	        if (this.options.isTMS) {
	            vectorSource["scheme"] = "tms";
	        }
	        return vectorSource;
	    };
	    return VectorTileSource;
	}(Source));



	var index$4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Source: Source,
		DataSource: DataSource,
		VectorTileSource: VectorTileSource
	});

	/**
	 * Abstract class for other layer classes to extend.
	 */
	var Layer = /** @class */ (function (_super) {
	    __extends(Layer, _super);
	    function Layer(id) {
	        var _this = 
	        // Assign an random id using a UUID if none was specified.
	        _super.call(this) || this;
	        _this.id = id || uuidRandom();
	        return _this;
	    }
	    /**
	     * Gets the id of the layer
	     */
	    Layer.prototype.getId = function () {
	        return this.id;
	    };
	    /**
	     * Gets the map that the layer is currently added to, or null.
	     */
	    Layer.prototype.getMap = function () {
	        return this.map || null;
	    };
	    /**
	     * Initialization method for the layer which is called when added to the map.
	     * @param map The map the layer has been added to.
	     */
	    Layer.prototype.onAdd = function (map) {
	        this.map = map;
	        this._invokeEvent("layeradded", this);
	        this.map.events.invoke("layeradded", this);
	    };
	    /**
	     * Method that is called when the layer is removed from the map.
	     * Should perform any necessary cleanup for the layer.
	     */
	    Layer.prototype.onRemove = function () {
	        var temp = this.map;
	        delete this.map;
	        this._invokeEvent("layerremoved", this);
	        if (temp) {
	            temp.events.invoke("layerremoved", this);
	        }
	    };
	    /**
	     * Returns if an event is one specified by Mapbox.
	     * False means we have defined that event.
	     * @internal
	     */
	    Layer._isMBoxEvent = function (eventType) {
	        return !this.LayerEvents.hasOwnProperty(eventType);
	    };
	    /**
	     * Updates the base layout and paint properties.
	     * Covers the follow properties: minZoom, maxZoom, filter, and visible.
	     * @param newOptions The new base layer options.
	     * @internal
	     */
	    Layer.prototype._updateBaseProperties = function (newOptions, oldOptions) {
	        this._updateFilter(newOptions.filter, oldOptions.filter);
	        this._updateZoomRange(newOptions.minZoom, oldOptions.minZoom, newOptions.maxZoom, oldOptions.maxZoom);
	        this._updateLayoutProperty("visibility", newOptions.visible, oldOptions.visible, newOptions.visible ? "visible" : "none");
	    };
	    /**
	     * Updates the filter for the layer in the maps its attached to.
	     * @param newFilter The new filter.
	     * @param oldFilter The old filter.
	     * Will be checked against newFilter to determine if an update is necessary.
	     * @param subFilter Optional filter to substitute for newFilter if updating is necessary.
	     * Useful when the option value doesn't exactly match the paint property.
	     * @internal
	     */
	    Layer.prototype._updateFilter = function (newFilter, oldFilter) {
	        if (!(isEqual_1(newFilter, oldFilter))) {
	            this.map._getMap().setFilter(this.id, newFilter);
	        }
	    };
	    Layer.prototype._updatePaintProperty = function (name, newValue, oldValue, subValue) {
	        // Only update if attached to a map and the values are changed.
	        if (!(isEqual_1(newValue, oldValue))) {
	            this.map._getMap().setPaintProperty(this.id, name, subValue || newValue);
	        }
	    };
	    Layer.prototype._updateLayoutProperty = function (name, newValue, oldValue, subValue) {
	        if (!(isEqual_1(newValue, oldValue))) {
	            this.map._getMap().setLayoutProperty(this.id, name, subValue || newValue);
	        }
	    };
	    /**
	     * Sets the zoom range for the layer in the attached map.
	     * @param minZoom The new minimum zoom value.
	     * @param maxZoom The new maximum zoom value.
	     * @internal
	     */
	    Layer.prototype._updateZoomRange = function (newMin, oldMin, newMax, oldMax) {
	        if ((newMin !== oldMin) || (oldMax !== newMax)) {
	            this.map._getMap().setLayerZoomRange(this.id, newMin, newMax);
	        }
	    };
	    // This object is accessible at runtime (unlike interfaces)
	    // and can be used to determine which events are ours vs Mapbox's.
	    Layer.LayerEvents = {
	        layeradded: undefined,
	        layerremoved: undefined
	    };
	    return Layer;
	}(EventEmitter));

	/**
	 * A base class which all other layer options inherit from.
	 */
	var LayerOptions = /** @class */ (function (_super) {
	    __extends(LayerOptions, _super);
	    function LayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * An expression specifying conditions on source features.
	         * Only features that match the filter are displayed.
	         */
	        _this.filter = undefined;
	        /**
	         * An integer specifying the minimum zoom level to render the layer at.
	         * This value is inclusive, i.e. the layer will be visible at `maxZoom > zoom >= minZoom`.
	         * Default `0`.
	         * @default 0
	         */
	        _this.minZoom = 0;
	        /**
	         * An integer specifying the maximum zoom level to render the layer at.
	         * This value is exclusive, i.e. the layer will be visible at `maxZoom > zoom >= minZoom`.
	         * Default `24`.
	         * @default 24
	         */
	        _this.maxZoom = 24;
	        /**
	         * Specifies if the layer is visible or not.
	         * Default `true`.
	         * @default true
	         */
	        _this.visible = true;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Source objects to pass through without cloning.
	     * Source objects are designed to be modifiable so a reference to the actual Source is fine for users to have.
	     * @param value The value being cloned.
	     * @internal
	     */
	    LayerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Source) {
	            return value;
	        }
	    };
	    return LayerOptions;
	}(Options));

	/**
	 * Options used when rendering Point objects in a BubbleLayer.
	 */
	var BubbleLayerOptions = /** @class */ (function (_super) {
	    __extends(BubbleLayerOptions, _super);
	    function BubbleLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * The color to fill the circle symbol with.
	         * Default `"#1A73AA"`.
	         * @default "#1A73AA"
	         */
	        _this.color = "#1A73AA";
	        /**
	         * The amount to blur the circles.
	         * A value of 1 blurs the circles such that only the center point if at full opacity.
	         * Default `0`.
	         * @default 0
	         */
	        _this.blur = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the circles will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        /**
	         * The color of the circles' outlines.
	         * Default `"#FFFFFF"`.
	         * @default "#FFFFFF"
	         */
	        _this.strokeColor = "#FFFFFF";
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the circles' outlines will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.strokeOpacity = 1;
	        /**
	         * The width of the circles' outlines in pixels.
	         * Default `2`.
	         * @default 2
	         */
	        _this.strokeWidth = 2;
	        /**
	         * Specifies the orientation of circle when map is pitched.
	         * <p>`"map"`: The circle is aligned to the plane of the map.</p>
	         * <p>`"viewport"`: The circle is aligned to the plane of the viewport.</p>
	         * Default: `"viewport"`
	         * @default "viewport"
	         */
	        _this.pitchAlignment = "viewport";
	        /**
	         * The radius of the circle symbols in pixels.
	         * Must be greater than or equal to 0.
	         * Default `8`.
	         * @default 8
	         */
	        _this.radius = 8;
	        return _this;
	    }
	    return BubbleLayerOptions;
	}(LayerOptions));

	/**
	 * Renders Point objects as scalable circles (bubbles).
	 */
	var BubbleLayer = /** @class */ (function (_super) {
	    __extends(BubbleLayer, _super);
	    /**
	     * Constructs a new BubbleLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the bubble layer.
	     */
	    function BubbleLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new BubbleLayerOptions().merge(cloneDeepWith_1(options, BubbleLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the bubble layer.
	     */
	    BubbleLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, BubbleLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    BubbleLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the bubble layer.
	     * @param newOptions The new options of the bubble layer.
	     */
	    BubbleLayer.prototype.setOptions = function (options) {
	        var newOptions = new BubbleLayerOptions().merge(this.options, cloneDeepWith_1(options, BubbleLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("circle-blur", newOptions.blur, this.options.blur);
	            this._updatePaintProperty("circle-color", newOptions.color, this.options.color);
	            this._updatePaintProperty("circle-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("circle-radius", newOptions.radius, this.options.radius);
	            this._updatePaintProperty("circle-stroke-color", newOptions.strokeColor, this.options.strokeColor);
	            this._updatePaintProperty("circle-stroke-opacity", newOptions.strokeOpacity, this.options.strokeOpacity);
	            this._updatePaintProperty("circle-stroke-width", newOptions.strokeWidth, this.options.strokeWidth);
	            this._updatePaintProperty("circle-pitch-alignment", newOptions.pitchAlignment, this.options.pitchAlignment);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    BubbleLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "circle",
	            source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source,
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "circle-color": this.options.color,
	                "circle-blur": this.options.blur,
	                "circle-opacity": this.options.opacity,
	                "circle-stroke-color": this.options.strokeColor,
	                "circle-stroke-opacity": this.options.strokeOpacity,
	                "circle-stroke-width": this.options.strokeWidth,
	                "circle-pitch-alignment": this.options.pitchAlignment,
	                "circle-radius": this.options.radius
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        if (this.options.sourceLayer) {
	            layer["source-layer"] = this.options.sourceLayer;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    BubbleLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    BubbleLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return BubbleLayer;
	}(Layer));

	/**
	 * Options used when rendering Point objects in a HeatMapLayer.
	 */
	var HeatMapLayerOptions = /** @class */ (function (_super) {
	    __extends(HeatMapLayerOptions, _super);
	    function HeatMapLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * Specifies the color gradient used to colorize the pixels in the heatmap.
	         * This is defined using an expression that uses `["heatmap-density"]` as input.
	         * Default `["interpolate",["linear"],["heatmap-density"],0,"rgba(0,0, 255,0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"]`
	         * @default `["interpolate",["linear"],["heatmap-density"],0,"rgba(0,0, 255,0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"]`
	         */
	        _this.color = ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0,0, 255,0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"];
	        /**
	         * Similar to `heatmap-weight` but specifies the global heatmap intensity.
	         * The higher this value is, the more ‘weight’ each point will contribute to the appearance.
	         * Default `1`
	         * @default 1
	         */
	        _this.intensity = 1;
	        /**
	         * The opacity at which the heatmap layer will be rendered defined as a number between 0 and 1.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        /**
	         * The radius in pixels used to render a data point on the heatmap.
	         * The radius must be a number greater or equal to 1.
	         * Default `30`.
	         * @default 30
	         */
	        _this.radius = 30;
	        /**
	         * Specifies how much an individual data point contributes to the heatmap.
	         * Must be a number greater than 0. A value of 5 would be equivalent to having 5 points of weight 1 in the same spot.
	         * This is useful when clustering points to allow heatmap rendering or large datasets.
	         * Default `1`
	         * @default 1
	         */
	        _this.weight = 1;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Source objects to pass through without cloning.
	     * Source objects are designed to be modifiable so a reference to the actual Source is fine for users to have.
	     * @param value The value being cloned.
	     * @internal
	     */
	    HeatMapLayerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Source) {
	            return value;
	        }
	    };
	    return HeatMapLayerOptions;
	}(LayerOptions));

	/**
	 * Represent the density of data using different colors (HeatMap).
	 */
	var HeatMapLayer = /** @class */ (function (_super) {
	    __extends(HeatMapLayer, _super);
	    /**
	     * Constructs a new HeatMapLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the heat map layer.
	     */
	    function HeatMapLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new HeatMapLayerOptions().merge(cloneDeepWith_1(options, HeatMapLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the heat map layer.
	     */
	    HeatMapLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, HeatMapLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    HeatMapLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the heat map layer.
	     * @param newOptions The new options of the heat map layer.
	     */
	    HeatMapLayer.prototype.setOptions = function (options) {
	        var newOptions = new HeatMapLayerOptions().merge(this.options, cloneDeepWith_1(options, HeatMapLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("heatmap-color", newOptions.color, this.options.color);
	            this._updatePaintProperty("heatmap-intensity", newOptions.intensity, this.options.intensity);
	            this._updatePaintProperty("heatmap-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("heatmap-radius", newOptions.radius, this.options.radius);
	            this._updatePaintProperty("heatmap-weight", newOptions.weight, this.options.weight);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    HeatMapLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "heatmap",
	            source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source,
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "heatmap-color": this.options.color,
	                "heatmap-intensity": this.options.intensity,
	                "heatmap-opacity": this.options.opacity,
	                "heatmap-radius": this.options.radius,
	                "heatmap-weight": this.options.weight,
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        if (this.options.sourceLayer) {
	            layer["source-layer"] = this.options.sourceLayer;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    HeatMapLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    HeatMapLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return HeatMapLayer;
	}(Layer));

	/**
	 * Options used when rendering canvas, image, raster tile, and video layers
	 */
	var MediaLayerOptions = /** @class */ (function (_super) {
	    __extends(MediaLayerOptions, _super);
	    function MediaLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A number between -1 and 1 that increases or decreases the contrast of the overlay.
	         * Default `0`.
	         * @default 0
	         */
	        _this.contrast = 0;
	        /**
	         * The duration in milliseconds of a fade transition when a new tile is added.
	         * Must be greater or equal to 0.
	         * Default `300`.
	         * @default 300
	         */
	        _this.fadeDuration = 300;
	        /**
	         * Rotates hues around the color wheel.
	         * A number in degrees.
	         * Default `0`.
	         * @default 0
	         */
	        _this.hueRotation = 0;
	        /**
	         * A number between 0 and 1 that increases or decreases the maximum brightness of the overlay.
	         * Default `1`.
	         * @default 1
	         */
	        _this.maxBrightness = 1;
	        /**
	         * A number between 0 and 1 that increases or decreases the minimum brightness of the overlay.
	         * Default `0`.
	         * @default 0
	         */
	        _this.minBrightness = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the overlay will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        /**
	         * A number between -1 and 1 that increases or decreases the saturation of the overlay.
	         * Default `0`.
	         * @default 0
	         */
	        _this.saturation = 0;
	        return _this;
	    }
	    return MediaLayerOptions;
	}(LayerOptions));

	/**
	 * Options used when rendering Point objects in a ImageLayer.
	 */
	var ImageLayerOptions = /** @class */ (function (_super) {
	    __extends(ImageLayerOptions, _super);
	    function ImageLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * URL to an image to overlay. Images hosted on other domains must have CORs enabled.
	         */
	        _this.url = undefined;
	        /**
	         * An array of positions for the corners of the image listed in clockwise order: [top left, top right, bottom right, bottom left].
	         */
	        _this.coordinates = undefined;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Source objects to pass through without cloning.
	     * Source objects are designed to be modifiable so a reference to the actual Source is fine for users to have.
	     * @param value The value being cloned.
	     * @internal
	     */
	    ImageLayerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Source) {
	            return value;
	        }
	    };
	    return ImageLayerOptions;
	}(MediaLayerOptions));

	/**
	 * Abstract class for other layer classes which have to build sources.
	 * @internal
	 */
	var SourceBuildingLayer = /** @class */ (function (_super) {
	    __extends(SourceBuildingLayer, _super);
	    function SourceBuildingLayer() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * @internal
	     */
	    SourceBuildingLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        ids.add(this._getSourceId());
	        return ids;
	    };
	    return SourceBuildingLayer;
	}(Layer));

	/**
	 * Overlays an image on the map with each corner anchored to a coordinate on the map. Also known as a ground or image overlay.
	 */
	var ImageLayer = /** @class */ (function (_super) {
	    __extends(ImageLayer, _super);
	    /**
	     * Constructs a new ImageLayer.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the image layer.
	     */
	    function ImageLayer(options, id) {
	        var _this = _super.call(this, id) || this;
	        _this.isLoading = false;
	        _this.options = new ImageLayerOptions().merge(cloneDeepWith_1(options, ImageLayerOptions._cloneCustomizer));
	        _this.img = new Image();
	        _this.reloadImage();
	        return _this;
	    }
	    /**
	     * Gets the options of the image layer.
	     */
	    ImageLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, ImageLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Sets the options of the image layer.
	     * @param newOptions The new options of the tile layer.
	     */
	    ImageLayer.prototype.setOptions = function (options) {
	        var newOptions = new ImageLayerOptions().merge(this.options, cloneDeepWith_1(options, ImageLayerOptions._cloneCustomizer));
	        var reloadImageTransform = (typeof options.url === "string" && options.url !== this.getOptions().url);
	        var coordChanged = (typeof options.coordinates !== "undefined" && options.coordinates !== this.getOptions().coordinates);
	        if (this.map) {
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("raster-contrast", newOptions.contrast, this.options.contrast);
	            this._updatePaintProperty("raster-fade-duration", newOptions.fadeDuration, this.options.fadeDuration);
	            this._updatePaintProperty("raster-hue-rotate", newOptions.hueRotation, this.options.hueRotation);
	            this._updatePaintProperty("raster-brightness-max", newOptions.maxBrightness, this.options.maxBrightness);
	            this._updatePaintProperty("raster-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("raster-saturation", newOptions.saturation, this.options.saturation);
	            // TODO: the mapbox typing file doesn't support mapboxgl.ImageSource.updateImage()
	            // update "as any" to "as mapboxgl.ImageSource" after the typing file is updated
	            var source = this.map._getMap().getSource(this._getSourceId());
	            if (source) {
	                source.updateImage(newOptions);
	            }
	        }
	        this.options = newOptions;
	        // Modified to update transform if image url or coordinates change
	        if (reloadImageTransform) {
	            this.reloadImage();
	        }
	        else if (coordChanged) {
	            this.updateTransform();
	        }
	    };
	    /**
	     * Calculates the approximate positions that align with the provided pixels from the source image.
	     * @param pixels the provided pixels from the source image used to calculate the positions
	     */
	    ImageLayer.prototype.getPositions = function (pixels) {
	        return this.transform.then(function (t) {
	            return t.toTarget(pixels);
	        });
	    };
	    /**
	     * Calculates the approximate pixels on the source image that align with the provided positions.
	     * @param positions the provided positions from the source image used to calculate the pixels
	     */
	    ImageLayer.prototype.getPixels = function (positions) {
	        return this.transform.then(function (t) {
	            return t.toSource(positions);
	        });
	    };
	    /**
	     * Calculates the approximate corner coordinates for an image based on the image width, height and by calculating an affine transform from a set of source pixels in the image and a set of target positions that are related.
	     * The same number of source and target values must be provided as reference points. It is recommended to provide atleast 3 reference points.
	     * @param imgWidth image width
	     * @param imgHeight image height
	     * @param source a set of source pixels
	     * @param target target positions
	     */
	    ImageLayer.getCoordinatesFromRefPoints = function (imgWidth, imgHeight, source, target) {
	        var transform = new AffineTransform(source, target);
	        return transform.toTarget([
	            [0, 0],
	            [imgWidth, 0],
	            [imgWidth, imgHeight],
	            [0, imgHeight]
	        ]);
	    };
	    /**
	     * Calculates coordinates for a rotated image layer when provided with the bounding box edges and rotation value.
	     * Note: If your rotation value is from a KML Ground Overlay it will need to be converted to a clockwise rotation using the following formula: `rotation = 360 – KmlRotation`
	     * @param north The north edge of the bounding box.
	     * @param south The south edge of the bounding box.
	     * @param east The east edge of the bounding box.
	     * @param west The west edge of the bounding box.
	     * @param rotation Clockwise rotation in degrees
	     */
	    ImageLayer.getCoordinatesFromEdges = function (north, south, east, west, rotation) {
	        if (typeof rotation !== "number") {
	            rotation = 0;
	        }
	        // [minLon, minLat, maxLon, maxLat]
	        var bounds = [
	            Math.min(west, east),
	            south,
	            Math.max(west, east),
	            north
	        ];
	        // Calculate the center of the bounding box and use that as the rotation origin.
	        var origin = BoundingBox.getCenter(bounds);
	        // Calculate the corner coordinates of the bounding box.
	        var topLeft = BoundingBox.getNorthWest(bounds);
	        var topRight = BoundingBox.getNorthEast(bounds);
	        var bottomRight = BoundingBox.getSouthEast(bounds);
	        var bottomLeft = BoundingBox.getSouthWest(bounds);
	        // Calcuate to rotated corners of the bounding box.
	        return rotatePositions([
	            topLeft,
	            topRight,
	            bottomRight,
	            bottomLeft
	        ], origin, rotation);
	    };
	    /**
	     * @internal
	     */
	    ImageLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "raster",
	            source: this._getSourceId(),
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "raster-opacity": this.options.opacity,
	                "raster-hue-rotate": this.options.hueRotation,
	                "raster-brightness-min": this.options.minBrightness,
	                "raster-brightness-max": this.options.maxBrightness,
	                "raster-saturation": this.options.saturation,
	                "raster-contrast": this.options.contrast,
	                "raster-fade-duration": this.options.fadeDuration
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    ImageLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * Builds the imge source to include with the layer.
	     * @internal
	     */
	    ImageLayer.prototype._buildSource = function () {
	        return {
	            type: "image",
	            url: this.options.url,
	            coordinates: this.options.coordinates
	        };
	    };
	    /**
	     * Gets the id of the source to be paired with this layer.
	     * @internal
	     */
	    ImageLayer.prototype._getSourceId = function () {
	        return this.getId() + "-ImageSource";
	    };
	    ImageLayer.prototype.reloadImage = function () {
	        var _this = this;
	        if (this.options.url) {
	            this.transform = new Promise(function (resolve, reject) {
	                _this.img.onload = function () {
	                    var corners = [[0, 0], [_this.img.width, 0], [_this.img.width, _this.img.height], [0, _this.img.height]];
	                    resolve(new AffineTransform(corners, _this.options.coordinates));
	                    _this.isLoading = false;
	                };
	                _this.img.onerror = _this.img.onabort = function () {
	                    reject("Failed to load image");
	                };
	                _this.isLoading = true;
	                _this.img.src = _this.options.url;
	            });
	        }
	    };
	    ImageLayer.prototype.updateTransform = function () {
	        if (!this.isLoading) {
	            var corners = [[0, 0], [this.img.width, 0], [this.img.width, this.img.height], [0, this.img.height]];
	            this.transform = Promise.resolve(new AffineTransform(corners, this.options.coordinates));
	        }
	    };
	    return ImageLayer;
	}(SourceBuildingLayer));

	/**
	 * Options used when rendering SimpleLine, SimplePolygon, CirclePolygon,
	 * LineString, MultiLineString, Polygon, and MultiPolygon objects in a line layer.
	 */
	var LineLayerOptions = /** @class */ (function (_super) {
	    __extends(LineLayerOptions, _super);
	    function LineLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * Specifies how the ends of the lines are rendered.
	         * <p>`"butt"`: A cap with a squared-off end which is drawn to the exact endpoint of the line.</p>
	         * <p>`"round"`: A cap with a rounded end which is drawn beyond the endpoint of the line
	         * at a radius of one-half of the lines width and centered on the endpoint of the line.</p>
	         * <p>`"square"`: A cap with a squared-off end which is drawn beyond the endpoint of the line
	         * at a distance of one-half of the line width.</p>
	         * Default `"round"`.
	         * @default "round"
	         */
	        _this.lineCap = "round";
	        /**
	         * Specifies how the joints in the lines are rendered.
	         * <p>`"bevel"`: A join with a squared-off end which is drawn beyond the endpoint of the line
	         * at a distance of one-half of the lines width.</p>
	         * <p>`"round"`: A join with a rounded end which is drawn beyond the endpoint of the line
	         * at a radius of one-half of the lines width and centered on the endpoint of the line.</p>
	         * <p>`"miter"`: A join with a sharp, angled corner which is drawn with the outer sides
	         * beyond the endpoint of the path until they meet.</p>
	         * Default `"round"`.
	         * @default "round"
	         */
	        _this.lineJoin = "round";
	        /**
	         * The amount of blur to apply to the line in pixels.
	         * Default `0`.
	         * @default 0
	         */
	        _this.blur = 0;
	        /**
	         * Specifies the color of the line.
	         * Default `"#1E90FF"`.
	         * @default "#1E90FF"
	         */
	        _this.strokeColor = "#1E90FF";
	        /**
	         * Specifies the lengths of the alternating dashes and gaps that form the dash pattern.
	         * Numbers must be equal or greater than 0. The lengths are scaled by the strokeWidth.
	         * To convert a dash length to pixels, multiply the length by the current stroke width.
	         */
	        _this.strokeDashArray = undefined;
	        /**
	         * Defines a gradient with which to color the lines.
	         * Requires the DataSource lineMetrics option to be set to true.
	         * Disabled if strokeDashArray is set.
	         */
	        _this.strokeGradient = undefined;
	        /**
	         * The line's offset.
	         * A positive value offsets the line to the right, relative to the direction of the line.
	         * A negative value offsets to the left.
	         * Default `0`.
	         * @default 0
	         */
	        _this.offset = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the line will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.strokeOpacity = 1;
	        /**
	         * The amount of offset in pixels to render the line relative to where it would render normally.
	         * Negative values indicate left and up.
	         * Default: `[0,0]`
	         * @default [0, 0]
	         */
	        _this.translate = new Pixel(0, 0);
	        /**
	         * Specifies the frame of reference for `translate`.
	         * <p>`"map"`: Lines are translated relative to the map.</p>
	         * <p>`"viewport"`: Lines are translated relative to the viewport</p>
	         * Default: `"map"`
	         * @default "map"
	         */
	        _this.translateAnchor = "map";
	        /**
	         * The width of the line in pixels. Must be a value greater or equal to 0.
	         * Default `2`.
	         * @default 2
	         */
	        _this.strokeWidth = 2;
	        return _this;
	    }
	    return LineLayerOptions;
	}(LayerOptions));

	/**
	 * Renders line data on the map. Can be used with SimpleLine, SimplePolygon,
	 * CirclePolygon, LineString, MultiLineString, Polygon, and MultiPolygon objects.
	 */
	var LineLayer = /** @class */ (function (_super) {
	    __extends(LineLayer, _super);
	    /**
	     * Constructs a new LineLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the line layer.
	     */
	    function LineLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new LineLayerOptions().merge(cloneDeepWith_1(options, LineLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the line layer.
	     */
	    LineLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, LineLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    LineLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the line layer.
	     * @param options The new options of the line layer.
	     */
	    LineLayer.prototype.setOptions = function (options) {
	        var newOptions = new LineLayerOptions().merge(this.options, cloneDeepWith_1(options, LineLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("line-blur", newOptions.blur, this.options.blur);
	            this._updateLayoutProperty("line-cap", newOptions.lineCap, this.options.lineCap);
	            this._updateLayoutProperty("line-join", newOptions.lineJoin, this.options.lineJoin);
	            this._updatePaintProperty("line-offset", newOptions.offset, this.options.offset);
	            this._updatePaintProperty("line-color", newOptions.strokeColor, this.options.strokeColor);
	            this._updatePaintProperty("line-dasharray", newOptions.strokeDashArray, this.options.strokeDashArray);
	            this._updatePaintProperty("line-gradient", newOptions.strokeGradient, this.options.strokeGradient);
	            this._updatePaintProperty("line-opacity", newOptions.strokeOpacity, this.options.strokeOpacity);
	            this._updatePaintProperty("line-width", newOptions.strokeWidth, this.options.strokeWidth);
	            this._updatePaintProperty("line-translate", newOptions.translate, this.options.translate);
	            this._updatePaintProperty("line-translate-anchor", newOptions.translateAnchor, this.options.translateAnchor);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    LineLayer.prototype._buildLayers = function () {
	        var layer = __assign(__assign(__assign(__assign({ id: this.id, type: "line" }, (this.options.sourceLayer && { "source-layer": this.options.sourceLayer })), { source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source, layout: {
	                visibility: this.options.visible ? "visible" : "none",
	                "line-cap": this.options.lineCap,
	                "line-join": this.options.lineJoin
	            }, paint: __assign(__assign(__assign({ "line-blur": this.options.blur, "line-color": this.options.strokeColor }, (this.options.strokeDashArray && { "line-dasharray": this.options.strokeDashArray })), (this.options.strokeGradient && { "line-gradient": this.options.strokeGradient })), { "line-offset": this.options.offset, "line-opacity": this.options.strokeOpacity, "line-translate": this.options.translate, "line-translate-anchor": this.options.translateAnchor, "line-width": this.options.strokeWidth }) }), (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    LineLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    LineLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return LineLayer;
	}(Layer));

	/**
	 * Options used when rendering `Polygon` and `MultiPolygon` objects in a `PolygonExtrusionLayer`.
	 */
	var PolygonExtrusionLayerOptions = /** @class */ (function (_super) {
	    __extends(PolygonExtrusionLayerOptions, _super);
	    function PolygonExtrusionLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * The height in meters to extrude the base of this layer.
	         * This height is relative to the ground.
	         * Must be greater or equal to 0 and less than or equal to `height`.
	         * Default `0`.
	         * @default 0
	         */
	        _this.base = 0;
	        /**
	         * The color to fill the polygons with.
	         * Ignored if `fillPattern` is set.
	         * Default `"#1E90FF"`.
	         * @default "#1E90FF"
	         */
	        _this.fillColor = "#1E90FF";
	        /**
	         * The height in meters to extrude this layer.
	         * This height is relative to the ground.
	         * Must be a number greater or equal to 0.
	         * Default `0`
	         * @default 0
	         */
	        _this.height = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the fill will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.fillOpacity = 1;
	        /**
	         * Name of image in sprite to use for drawing image fills.
	         * For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512).
	         */
	        _this.fillPattern = undefined;
	        /**
	         * The polygons' pixel offset.
	         * Values are [x, y] where negatives indicate left and up, respectively.
	         * Default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.translate = new Pixel(0, 0);
	        /**
	         * Specifies the frame of reference for `translate`.
	         * <p>`"map"`: Polygons are translated relative to the map.</p>
	         * <p>`"viewport"`: Polygons are translated relative to the viewport.</p>
	         * Default: `"map"`
	         * @default "map"
	         */
	        _this.translateAnchor = "map";
	        /**
	         * Specifies if the polygon should have a vertical gradient on the sides of the extrusion.
	         * Default: `true`
	         * @default true
	         */
	        _this.verticalGradient = true;
	        return _this;
	    }
	    return PolygonExtrusionLayerOptions;
	}(LayerOptions));

	/**
	 * Renders extruded filled `Polygon` and `MultiPolygon` objects on the map.
	 */
	var PolygonExtrusionLayer = /** @class */ (function (_super) {
	    __extends(PolygonExtrusionLayer, _super);
	    /**
	     * Constructs a new PolygonExtrusionLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the polygon extrusion layer.
	     */
	    function PolygonExtrusionLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new PolygonExtrusionLayerOptions().merge(cloneDeepWith_1(options, PolygonExtrusionLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the polygon layer.
	     */
	    PolygonExtrusionLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, PolygonExtrusionLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    PolygonExtrusionLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the polygon layer.
	     * @param newOptions The new options of the polygon layer.
	     */
	    PolygonExtrusionLayer.prototype.setOptions = function (options) {
	        var newOptions = new PolygonExtrusionLayerOptions().merge(this.options, cloneDeepWith_1(options, PolygonExtrusionLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("fill-extrusion-base", newOptions.base, this.options.base);
	            this._updatePaintProperty("fill-extrusion-color", newOptions.fillColor, this.options.fillColor);
	            this._updatePaintProperty("fill-extrusion-height", newOptions.height, this.options.height);
	            this._updatePaintProperty("fill-extrusion-opacity", newOptions.fillOpacity, this.options.fillOpacity);
	            this._updatePaintProperty("fill-extrusion-pattern", newOptions.fillPattern, this.options.fillPattern);
	            this._updatePaintProperty("fill-extrusion-translate", newOptions.translate, this.options.translate);
	            this._updatePaintProperty("fill-extrusion-translate-anchor", newOptions.translateAnchor, this.options.translateAnchor);
	            this._updatePaintProperty("fill-extrusion-vertical-gradient", newOptions.verticalGradient, this.options.verticalGradient);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    PolygonExtrusionLayer.prototype._buildLayers = function () {
	        var layer = __assign(__assign(__assign(__assign({ id: this.id, type: "fill-extrusion" }, (this.options.sourceLayer && { "source-layer": this.options.sourceLayer })), { source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source, layout: {
	                visibility: this.options.visible ? "visible" : "none",
	            }, paint: __assign(__assign({ "fill-extrusion-base": this.options.base, "fill-extrusion-height": this.options.height, "fill-extrusion-opacity": this.options.fillOpacity }, (this.options.fillPattern ?
	                { "fill-extrusion-pattern": this.options.fillPattern } :
	                { "fill-extrusion-color": this.options.fillColor })), { "fill-extrusion-translate": this.options.translate, "fill-extrusion-translate-anchor": this.options.translateAnchor, "fill-extrusion-vertical-gradient": this.options.verticalGradient }) }), (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    PolygonExtrusionLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    PolygonExtrusionLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return PolygonExtrusionLayer;
	}(Layer));

	/**
	 * Options used when rendering Polygon and MultiPolygon objects in a PolygonLayer.
	 */
	var PolygonLayerOptions = /** @class */ (function (_super) {
	    __extends(PolygonLayerOptions, _super);
	    function PolygonLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * The color to fill the polygons with.
	         * Default `"#1E90FF"`.
	         * @default "#1E90FF"
	         */
	        _this.fillColor = "#1E90FF";
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the fill will be drawn.
	         * Default `0.5`.
	         * @default 0.5
	         */
	        _this.fillOpacity = 0.5;
	        /**
	         * Name of image in sprite to use for drawing image fills. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512).
	         */
	        _this.fillPattern = undefined;
	        return _this;
	    }
	    /**
	     * Override the standard merge behavior to set fillPattern and fillColor to be mutually exclusive
	     * @internal
	     */
	    PolygonLayerOptions.prototype.merge = function () {
	        var e_1, _a;
	        var valueList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valueList[_i] = arguments[_i];
	        }
	        var isNewColorSet = false;
	        var isNewPatternSet = false;
	        try {
	            for (var valueList_1 = __values(valueList), valueList_1_1 = valueList_1.next(); !valueList_1_1.done; valueList_1_1 = valueList_1.next()) {
	                var value = valueList_1_1.value;
	                if (value) {
	                    if (value.hasOwnProperty("fillColor")) {
	                        isNewColorSet = true;
	                        isNewPatternSet = false;
	                    }
	                    else if (value.hasOwnProperty("fillPattern")) {
	                        isNewPatternSet = true;
	                        isNewColorSet = false;
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (valueList_1_1 && !valueList_1_1.done && (_a = valueList_1.return)) _a.call(valueList_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        // Then execute the standard merge behavior.
	        var merged = _super.prototype.merge.apply(this, __spread(valueList));
	        if (isNewColorSet) {
	            merged.fillPattern = undefined;
	        }
	        else if (isNewPatternSet) {
	            merged.fillColor = undefined;
	        }
	        return merged;
	    };
	    return PolygonLayerOptions;
	}(LayerOptions));

	/**
	 * Renders filled Polygon and MultiPolygon objects on the map.
	 */
	var PolygonLayer = /** @class */ (function (_super) {
	    __extends(PolygonLayer, _super);
	    /**
	     * Constructs a new PolygonLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the polygon layer.
	     */
	    function PolygonLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new PolygonLayerOptions().merge(cloneDeepWith_1(options, PolygonLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the polygon layer.
	     */
	    PolygonLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, PolygonLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    PolygonLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the polygon layer.
	     * @param newOptions The new options of the polygon layer.
	     */
	    PolygonLayer.prototype.setOptions = function (options) {
	        var newOptions = new PolygonLayerOptions().merge(this.options, cloneDeepWith_1(options, PolygonLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("fill-color", newOptions.fillColor, this.options.fillColor);
	            this._updatePaintProperty("fill-opacity", newOptions.fillOpacity, this.options.fillOpacity);
	            this._updatePaintProperty("fill-pattern", newOptions.fillPattern, this.options.fillPattern);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    PolygonLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "fill",
	            source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source,
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "fill-opacity": this.options.fillOpacity
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        if (this.options.sourceLayer) {
	            layer["source-layer"] = this.options.sourceLayer;
	        }
	        // The property fill-pattern should only be set if there is a value for fillPattern.
	        // The property fill-color should only be set if fill-pattern isn't.
	        if (this.options.fillPattern) {
	            layer.paint["fill-pattern"] = this.options.fillPattern;
	        }
	        else {
	            layer.paint["fill-color"] = this.options.fillColor;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    PolygonLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    PolygonLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return PolygonLayer;
	}(Layer));

	/**
	 * Options used to customize the icons in a SymbolLayer
	 */
	var IconOptions = /** @class */ (function (_super) {
	    __extends(IconOptions, _super);
	    function IconOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Specifies if the symbol icon can overlay other symbols on the map.
	         * If `true` the icon will be visible even if it collides with other previously drawn symbols.
	         * Tip: Set this to true if animating an symbol to ensure smooth rendering.
	         * Default `false`.
	         * @default false
	         */
	        _this.allowOverlap = false;
	        /**
	         * Specifies which part of the icon is placed closest to the icons anchor position on the map.
	         * <p>`"center"`: The center of the icon is placed closest to the anchor.</p>
	         * <p>`"left"`: The left side of the icon is placed closest to the anchor.</p>
	         * <p>`"right"`: The right side of the icon is placed closest to the anchor.</p>
	         * <p>`"top"`: The top of the icon is placed closest to the anchor.</p>
	         * <p>`"bottom"`: The bottom of the icon is placed closest to the anchor.</p>
	         * <p>`"top-left"`: The top left corner of the icon is placed closest to the anchor.</p>
	         * <p>`"top-right"`: The top right corner of the icon is placed closest to the anchor.</p>
	         * <p>`"bottom-left"`: The bottom left corner of the icon is placed closest to the anchor.</p>
	         * <p>`"bottom-right"`: The bottom right corner of the icon is placed closest to the anchor.</p>
	         * Default `"bottom"`.
	         * @default "bottom"
	         */
	        _this.anchor = "bottom";
	        /**
	         * Specifies if other symbols can overlap this symbol.
	         * If true, other symbols can be visible even if they collide with the icon.
	         * Default `false`.
	         * @default false
	         */
	        _this.ignorePlacement = false;
	        /**
	         * The name of the image in the map's image sprite to use for drawing the icon.
	         * Available built-in images are: `marker-black`, `marker-blue`, `marker-darkblue`,
	         * `marker-red`, `marker-yellow`, `pin-blue`, `pin-darkblue`, `pin-red`, `pin-round-blue`,
	         * `pin-round-darkblue`, `pin-round-red`.
	         * Default `"marker-blue"`.
	         * @default "marker-blue"
	         */
	        _this.image = "marker-blue";
	        /**
	         * Specifies an offset distance of the icon from its anchor in pixels.
	         * Positive values indicate right and down, while negative values indicate left and up.
	         * Each component is multiplied by the value of size to obtain the final offset in pixels.
	         * When combined with rotation the offset will be as if the rotated direction was up.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.offset = new Pixel(0, 0);
	        /**
	         * Specifies if a symbols icon can be hidden but its text displayed if it is overlapped with another symbol.
	         * If true, text will display without their corresponding icons
	         * when the icon collides with other symbols and the text does not.
	         * Default `false`.
	         * @default false
	         */
	        _this.optional = false;
	        /**
	         * Specifies the orientation of the icon when the map is pitched.
	         * <p>`"auto"`: Automatically matches the value of `rotationAlignment`.</p>
	         * <p>`"map"`: The icon is aligned to the plane of the map.</p>
	         * <p>`"viewport"`: The icon is aligned to the plane of the viewport</p>
	         * Default `"auto"`
	         * @default "auto"
	         */
	        _this.pitchAlignment = "auto";
	        /**
	         * The amount to rotate the icon clockwise in degrees
	         * Default `0`.
	         * @default 0
	         */
	        _this.rotation = 0;
	        /**
	         * In combination with the placement property of a SymbolLayerOptions
	         * this determines the rotation behavior of icons.
	         * <p>`"auto"`: When placement is "point" this is equivalent to "viewport".
	         * When placement is "line" this is equivalent to "map".</p>
	         * <p>`"map"`: When placement is "point" aligns icons east-west.
	         * When placement is "line" aligns the icons' x-axes with the line.</p>
	         * <p>`"viewport"`: Icons' x-axes will align with the x-axis of the viewport.</p>
	         * Default `"auto"`.
	         * @default "auto"
	         */
	        _this.rotationAlignment = "auto";
	        /**
	         * Scales the original size of the icon by the provided factor.
	         * Must be greater or equal to 0.
	         * Default `1`.
	         * @default 1
	         */
	        _this.size = 1;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the icon will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        return _this;
	    }
	    return IconOptions;
	}(Options));

	/**
	 * Options used to customize the text in a SymbolLayer
	 */
	var TextOptions = /** @class */ (function (_super) {
	    __extends(TextOptions, _super);
	    function TextOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Specifies if the text will be visible if it collides with other symbols.
	         * If true, the text will be visible even if it collides with other previously drawn symbols.
	         * Default `false`.
	         * @default false
	         */
	        _this.allowOverlap = false;
	        /**
	         * Specifies which part of the icon is placed closest to the icons anchor position on the map.
	         * <p>`"center"`: The center of the icon is placed closest to the anchor.</p>
	         * <p>`"left"`: The left side of the icon is placed closest to the anchor.</p>
	         * <p>`"right"`: The right side of the icon is placed closest to the anchor.</p>
	         * <p>`"top"`: The top of the icon is placed closest to the anchor.</p>
	         * <p>`"bottom"`: The bottom of the icon is placed closest to the anchor.</p>
	         * <p>`"top-left"`: The top left corner of the icon is placed closest to the anchor.</p>
	         * <p>`"top-right"`: The top right corner of the icon is placed closest to the anchor.</p>
	         * <p>`"bottom-left"`: The bottom left corner of the icon is placed closest to the anchor.</p>
	         * <p>`"bottom-right"`: The bottom right corner of the icon is placed closest to the anchor.</p>
	         * Default `"center"`.
	         * @default "center"
	         */
	        _this.anchor = "center";
	        /**
	         * Specifies the name of a property on the features to use for a text label.
	         */
	        _this.textField = undefined;
	        /**
	         * The font stack to use for displaying text.
	         * Possible values: `"SegoeFrutigerHelveticaMYingHei-Bold"`, `"SegoeFrutigerHelveticaMYingHei-Medium"`,
	         * `"SegoeFrutigerHelveticaMYingHei-Regular"`, `"SegoeUi-Bold"`, `"SegoeUi-Light"`, `"SegoeUi-Regular"`,
	         * `"SegoeUi-SemiBold"`, `"SegoeUi-SemiLight"`, `"SegoeUi-SymbolRegular"`, `"StandardCondensedSegoeUi-Black"`,
	         * `"StandardCondensedSegoeUi-Bold"`, `"StandardCondensedSegoeUi-Light"`, `"StandardCondensedSegoeUi-Regular"`,
	         * `"StandardFont-Black"`, `"StandardFont-Bold"`, `"StandardFont-Light"`, `"StandardFont-Regular"`,
	         * `"StandardFontCondensed-Black"`, `"StandardFontCondensed-Bold"`, `"StandardFontCondensed-Light"`,
	         * `"StandardFontCondensed-Regular"`.
	         * Default `["StandardFont-Regular"]`.
	         * @default ["StandardFont-Regular"]
	         */
	        _this.font = ["StandardFont-Regular"];
	        /**
	         * Specifies if the other symbols are allowed to collide with the text.
	         * If true, other symbols can be visible even if they collide with the text.
	         * Default `false`.
	         * @default false
	         */
	        _this.ignorePlacement = false;
	        /**
	         * Specifies an offset distance of the icon from its anchor in ems.
	         * Positive values indicate right and down, while negative values indicate left and up.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.offset = new Pixel(0, 0);
	        /**
	         * Specifies if the text can be hidden if it is overlapped by another symbol.
	         * If true, icons will display without their corresponding text
	         * when the text collides wit other symbols and the icon does not.
	         * Default `false`.
	         * @default false
	         */
	        _this.optional = false;
	        /**
	         * Specifies the orientation of the text when the map is pitched.
	         * <p>`"auto"`: Automatically matches the value of `rotationAlignment`.</p>
	         * <p>`"map"`: The text is aligned to the plane of the map.</p>
	         * <p>`"viewport"`: The text is aligned to the plane of the viewport.</p>
	         * Default: `"auto"`
	         * @default "auto"
	         */
	        _this.pitchAlignment = "auto";
	        /**
	         * The amount to rotate the text clockwise in degrees.
	         * Default `0`
	         * @default 0
	         */
	        _this.rotation = 0;
	        /**
	         * In combination with the `placement` property of the `SymbolLayerOptions`,
	         * specifies the rotation behavior of the individual glyphs forming the text.
	         * <p>`"auto"`: When the `placement` is set to `"point"`, this is equivalent to `"map"`.
	         * When the `placement` is set to `"line"` this is equivalent to `"map"`.</p>
	         * <p>`"map"`: When the `placement` is set to `"point"`, aligns text east-west.
	         * When the `placement` is set to `"line"`, aligns text x-axes with the line.</p>
	         * <p>`"viewport"`: Produces glyphs whose x-axes are aligned with the x-axis of the viewport,
	         * regardless of the value of `placement`.</p>
	         * Default: `"auto"`
	         * @default "auto"
	         */
	        _this.rotationAlignment = "auto";
	        /**
	         * The size of the font in pixels.
	         * Must be a number greater or equal to 0.
	         * Default `16`.
	         * @default 16
	         */
	        _this.size = 16;
	        /**
	         * The color of the text.
	         * Default `"#000000"`.
	         * @default "#000000"
	         */
	        _this.color = "#000000";
	        /**
	         * The halo's fadeout distance towards the outside in pixels.
	         * Must be a number greater or equal to 0.
	         * Default `0`.
	         * @default 0
	         */
	        _this.haloBlur = 0;
	        /**
	         * The color of the text's halo, which helps it stand out from backgrounds.
	         * Default `"rgba(0,0,0,0)"`.
	         * @default "rgba(0,0,0,0)"
	         */
	        _this.haloColor = "rgba(0,0,0,0)";
	        /**
	         * The distance of the halo to the font outline in pixels.
	         * Must be a number greater or equal to 0.
	         * The maximum text halo width is 1/4 of the font size.
	         * Default `0`.
	         * @default 0
	         */
	        _this.haloWidth = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the text will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        return _this;
	    }
	    return TextOptions;
	}(Options));

	/**
	 * Options used when rendering geometries in a SymbolLayer.
	 */
	var SymbolLayerOptions = /** @class */ (function (_super) {
	    __extends(SymbolLayerOptions, _super);
	    function SymbolLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * Options used to customize the icons of the symbols.
	         * @see IconOptions for defaults.
	         */
	        _this.iconOptions = new IconOptions();
	        /**
	         * Options used to customize the text of the symbols.
	         * @see TextOptions for defaults.
	         */
	        _this.textOptions = new TextOptions();
	        /**
	         * Specifies the label placement relative to its geometry.
	         * <p>`"point"`: The label is placed at the point where the geometry is located.</p>
	         * <p>`"line"`: The label is placed along the line of the geometry.
	         * Can only be used on LineString and Polygon geometries.</p>
	         * <p> `"line-center"`: The label is placed at the center of the line of the geometry.
	         * Can only be used on `LineString` and `Polygon` geometries </p>
	         * Default `"point"`.
	         * @default "point"
	         */
	        _this.placement = "point";
	        /**
	         * Distance in pixels between two symbol anchors along a line. Must be greater or equal to 1.
	         * Default `250`.
	         * @default 250
	         */
	        _this.lineSpacing = 250;
	        return _this;
	    }
	    return SymbolLayerOptions;
	}(LayerOptions));

	/**
	 * Renders point based data as symbols on the map using text and/or icons.
	 * Symbols can also be created for line and polygon data as well.
	 */
	var SymbolLayer = /** @class */ (function (_super) {
	    __extends(SymbolLayer, _super);
	    /**
	     * Constructs a new SymbolLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the polygon layer.
	     */
	    function SymbolLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new SymbolLayerOptions().merge(cloneDeepWith_1(options, SymbolLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the symbol layer.
	     */
	    SymbolLayer.prototype.getOptions = function () {
	        return cloneDeepWith_1(this.options, SymbolLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    SymbolLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the symbol layer.
	     * @param newOptions The new options of the polygon layer.
	     */
	    SymbolLayer.prototype.setOptions = function (options) {
	        var newOptions = new SymbolLayerOptions().merge(this.options, cloneDeepWith_1(options, SymbolLayerOptions._cloneCustomizer));
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            // Symbol options.
	            this._updateBaseProperties(newOptions, this.options);
	            this._updateLayoutProperty("symbol-spacing", newOptions.lineSpacing, this.options.lineSpacing);
	            this._updateLayoutProperty("symbol-placement", newOptions.placement, this.options.placement);
	            // Icon options.
	            this._updateLayoutProperty("icon-allow-overlap", newOptions.iconOptions.allowOverlap, this.options.iconOptions.allowOverlap);
	            this._updateLayoutProperty("icon-anchor", newOptions.iconOptions.anchor, this.options.iconOptions.anchor);
	            this._updateLayoutProperty("icon-ignore-placement", newOptions.iconOptions.ignorePlacement, this.options.iconOptions.ignorePlacement);
	            this._updateLayoutProperty("icon-image", newOptions.iconOptions.image, this.options.iconOptions.image);
	            this._updateLayoutProperty("icon-offset", newOptions.iconOptions.offset, this.options.iconOptions.offset);
	            this._updatePaintProperty("icon-opacity", newOptions.iconOptions.opacity, this.options.iconOptions.opacity);
	            this._updateLayoutProperty("icon-optional", newOptions.iconOptions.optional, this.options.iconOptions.optional);
	            this._updateLayoutProperty("icon-pitch-alignment", newOptions.iconOptions.pitchAlignment, this.options.iconOptions.pitchAlignment);
	            this._updateLayoutProperty("icon-rotate", newOptions.iconOptions.rotation, this.options.iconOptions.rotation);
	            this._updateLayoutProperty("icon-rotation-alignment", newOptions.iconOptions.rotationAlignment, this.options.iconOptions.rotationAlignment);
	            this._updateLayoutProperty("icon-size", newOptions.iconOptions.size, this.options.iconOptions.size);
	            // Text options.
	            this._updateLayoutProperty("text-allow-overlap", newOptions.textOptions.allowOverlap, this.options.textOptions.allowOverlap);
	            this._updateLayoutProperty("text-anchor", newOptions.textOptions.anchor, this.options.textOptions.anchor);
	            this._updatePaintProperty("text-color", newOptions.textOptions.color, this.options.textOptions.color);
	            this._updateLayoutProperty("text-font", newOptions.textOptions.font, this.options.textOptions.font);
	            this._updateLayoutProperty("text-ignore-placement", newOptions.textOptions.ignorePlacement, this.options.textOptions.ignorePlacement);
	            this._updatePaintProperty("text-halo-blur", newOptions.textOptions.haloBlur, this.options.textOptions.haloBlur);
	            this._updatePaintProperty("text-halo-color", newOptions.textOptions.haloColor, this.options.textOptions.haloColor);
	            this._updatePaintProperty("text-halo-width", newOptions.textOptions.haloWidth, this.options.textOptions.haloWidth);
	            this._updateLayoutProperty("text-offset", newOptions.textOptions.offset, this.options.textOptions.offset);
	            this._updatePaintProperty("text-opacity", newOptions.textOptions.opacity, this.options.textOptions.opacity);
	            this._updateLayoutProperty("text-optional", newOptions.textOptions.optional, this.options.textOptions.optional);
	            this._updateLayoutProperty("text-pitch-alignment", newOptions.textOptions.pitchAlignment, this.options.textOptions.pitchAlignment);
	            this._updateLayoutProperty("text-rotate", newOptions.textOptions.rotation, this.options.textOptions.rotation);
	            this._updateLayoutProperty("text-rotation-alignment", newOptions.textOptions.rotationAlignment, this.options.textOptions.rotationAlignment);
	            this._updateLayoutProperty("text-size", newOptions.textOptions.size, this.options.textOptions.size);
	            this._updateLayoutProperty("text-field", newOptions.textOptions.textField, this.options.textOptions.textField);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    SymbolLayer.prototype._buildLayers = function () {
	        var layer = __assign(__assign(__assign(__assign({ id: this.id, type: "symbol" }, (this.options.sourceLayer && { "source-layer": this.options.sourceLayer })), { source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source, layout: __assign(__assign({ visibility: this.options.visible ? "visible" : "none", "symbol-placement": this.options.placement, "symbol-spacing": this.options.lineSpacing, 
	                // Text options.
	                "text-allow-overlap": this.options.textOptions.allowOverlap, "text-anchor": this.options.textOptions.anchor }, (this.options.textOptions.textField && { "text-field": this.options.textOptions.textField })), { "text-font": this.options.textOptions.font, "text-ignore-placement": this.options.textOptions.ignorePlacement, "text-offset": this.options.textOptions.offset, "text-optional": this.options.textOptions.optional, "text-pitch-alignment": this.options.textOptions.pitchAlignment, "text-rotate": this.options.textOptions.rotation, "text-rotation-alignment": this.options.textOptions.rotationAlignment, "text-size": this.options.textOptions.size, 
	                // Icon options.
	                "icon-allow-overlap": this.options.iconOptions.allowOverlap, "icon-anchor": this.options.iconOptions.anchor, "icon-ignore-placement": this.options.iconOptions.ignorePlacement, "icon-image": this.options.iconOptions.image, "icon-offset": this.options.iconOptions.offset, "icon-optional": this.options.iconOptions.optional, "icon-pitch-alignment": this.options.iconOptions.pitchAlignment, "icon-rotate": this.options.iconOptions.rotation, "icon-rotation-alignment": this.options.iconOptions.rotationAlignment, "icon-size": this.options.iconOptions.size }), paint: {
	                // Text options.
	                "text-color": this.options.textOptions.color,
	                "text-halo-blur": this.options.textOptions.haloBlur,
	                "text-halo-color": this.options.textOptions.haloColor,
	                "text-halo-width": this.options.textOptions.haloWidth,
	                "text-opacity": this.options.textOptions.opacity,
	                // Icon options.
	                "icon-opacity": this.options.iconOptions.opacity,
	            } }), (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    SymbolLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    SymbolLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return SymbolLayer;
	}(Layer));

	/**
	 * Options used when rendering raster tiled images in a TileLayer.
	 */
	var TileLayerOptions = /** @class */ (function (_super) {
	    __extends(TileLayerOptions, _super);
	    function TileLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A bounding box that specifies where tiles are available.
	         * When specified, no tiles outside of the bounding box will be requested.
	         * Default `[-180, -85.0511, 180, 85.0511]`.
	         * @default [-180, -85.0511, 180, 85.0511]
	         */
	        _this.bounds = [-180, -85.0511, 180, 85.0511];
	        /**
	         * An integer specifying the minimum zoom level in which tiles are available from the tile source.
	         * Default `0`.
	         * @default 0
	         */
	        _this.minSourceZoom = 0;
	        /**
	         * An integer specifying the maximum zoom level in which tiles are available from the tile source.
	         * Default `22`.
	         * @default 22
	         */
	        _this.maxSourceZoom = 22;
	        /**
	         * An integer value that specifies the width and height dimensions of the map tiles.
	         * For a seamless experience, the tile size must be a multiplier of 2.
	         * Default `512`.
	         * @default 512
	         */
	        _this.tileSize = 512;
	        /**
	         * Specifies if the tile systems coordinates uses the Tile Map Services specification,
	         * which reverses the Y coordinate axis.
	         * Default `false`.
	         * @default false
	         */
	        _this.isTMS = false;
	        /**
	         * An array of subdomain values to apply to the tile URL.
	         */
	        _this.subdomains = undefined;
	        /**
	         * A http/https URL to a TileJSON resource or a tile URL template that uses the following parameters:
	         * <p>{x}: X position of the tile. Usually also needs {y} and {z}.</p>
	         * <p>{y}: Y position of the tile. Usually also needs {x} and {z}.</p>
	         * <p>{z}: Zoom level of the tile. Usually also needs {x} and {y}.</p>
	         * <p>{quadkey}: Tile quadKey id based on the Bing Maps tile system naming convention.</p>
	         * <p>{bbox-epsg-3857}: A bounding box string with the format {west},{south},{east},{north}
	         * in the EPSG 4325 Spacial Reference System.</p>
	         * <p>{subdomain}: A placeholder where the subdomain values if specified will be added.</p>
	         */
	        _this.tileUrl = undefined;
	        return _this;
	    }
	    return TileLayerOptions;
	}(MediaLayerOptions));

	/**
	 * Renders raster tiled images on top of the map tiles.
	 */
	var TileLayer = /** @class */ (function (_super) {
	    __extends(TileLayer, _super);
	    /**
	     * Constructs a new TileLayer.
	     * @param options The options for the tile layer.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     */
	    function TileLayer(options, id) {
	        var _this = _super.call(this, id) || this;
	        if (options) {
	            _this.setOptions(options);
	        }
	        return _this;
	    }
	    /**
	     * Gets the options of the tile layer.
	     */
	    TileLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, TileLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Sets the options of the tile layer.
	     * @param newOptions The new options of the tile layer.
	     */
	    TileLayer.prototype.setOptions = function (options) {
	        var newOptions = new TileLayerOptions().merge(this.options, cloneDeepWith_1(options, TileLayerOptions._cloneCustomizer));
	        if (this.map) {
	            // If the bounds, isTMS, max/minSourceZoom, subdomains, tileSize, or tileUrl
	            // options are changed the layer must be re-added to the map entirely.
	            if (!(isEqual_1(newOptions.bounds, this.options.bounds)) ||
	                newOptions.isTMS !== this.options.isTMS ||
	                newOptions.maxSourceZoom !== this.options.maxSourceZoom ||
	                newOptions.minSourceZoom !== this.options.minSourceZoom ||
	                !(isEqual_1(newOptions.subdomains, this.options.subdomains)) ||
	                newOptions.tileSize !== this.options.tileSize ||
	                newOptions.tileUrl !== this.options.tileUrl) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("raster-contrast", newOptions.contrast, this.options.contrast);
	            this._updatePaintProperty("raster-fade-duration", newOptions.fadeDuration, this.options.fadeDuration);
	            this._updatePaintProperty("raster-hue-rotate", newOptions.hueRotation, this.options.hueRotation);
	            this._updatePaintProperty("raster-brightness-max", newOptions.maxBrightness, this.options.maxBrightness);
	            this._updatePaintProperty("raster-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("raster-saturation", newOptions.saturation, this.options.saturation);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    TileLayer.prototype._setOptionsNoUpdate = function (options) {
	        this.options = new TileLayerOptions().merge(this.options, cloneDeepWith_1(options, TileLayerOptions._cloneCustomizer));
	    };
	    /**
	     * @internal
	     */
	    TileLayer.prototype._buildLayers = function () {
	        var layer = __assign(__assign({ id: this.id, type: "raster", source: this._getSourceId(), layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            }, paint: {
	                "raster-contrast": this.options.contrast,
	                "raster-fade-duration": this.options.fadeDuration,
	                "raster-hue-rotate": this.options.hueRotation,
	                "raster-brightness-max": this.options.maxBrightness,
	                "raster-brightness-min": this.options.minBrightness,
	                "raster-opacity": this.options.opacity,
	                "raster-saturation": this.options.saturation
	            } }, (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    TileLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * Builds the raster source to include with the layer.
	     * @internal
	     */
	    TileLayer.prototype._buildSource = function () {
	        var e_1, _a;
	        var tiles;
	        if (this.options.tileUrl) {
	            // If the tileUrl include { assume it is a formatted string and use tiles property.
	            if (this.options.tileUrl.indexOf("{") !== -1) {
	                // If the tileUrl include the subdomain placeholder
	                // we must manually assign an array of urls to the tiles property
	                // because mapbox does not support the subdomain placeholder.
	                if (this.options.tileUrl.indexOf("{subdomain}") !== -1) {
	                    // Throw an error if no subdomains were specified
	                    if (this.options.subdomains && this.options.subdomains.length > 0) {
	                        var urls = [];
	                        try {
	                            for (var _b = __values(this.options.subdomains), _c = _b.next(); !_c.done; _c = _b.next()) {
	                                var subdomain = _c.value;
	                                urls.push(this.options.tileUrl.replace(/{subdomain}/g, subdomain));
	                            }
	                        }
	                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                        finally {
	                            try {
	                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                            }
	                            finally { if (e_1) throw e_1.error; }
	                        }
	                        tiles = urls;
	                    }
	                    else {
	                        throw new Error("The {subdomain} placeholder was included in the tileUrl but no subdomains were specified");
	                    }
	                }
	                else {
	                    // Else just provide a single url.
	                    tiles = [this.options.tileUrl];
	                }
	            }
	            else {
	                // Else assume it is just a TileJSON url and use the url property.
	                // For a TileJSON url only the url needs to be specified.
	                return {
	                    type: "raster",
	                    url: this.options.tileUrl
	                };
	            }
	        }
	        return __assign({ type: "raster", bounds: this.options.bounds, maxzoom: this.options.maxSourceZoom, minzoom: this.options.minSourceZoom, scheme: this.options.isTMS ? "tms" : "xyz", tileSize: this.options.tileSize }, (tiles && { tiles: tiles }));
	    };
	    /**
	     * Gets the id of the source to be paired with this layer.
	     * @internal
	     */
	    TileLayer.prototype._getSourceId = function () {
	        return this.getId() + "-RasterSource";
	    };
	    return TileLayer;
	}(SourceBuildingLayer));



	var index$5 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BubbleLayer: BubbleLayer,
		Layer: Layer,
		LineLayer: LineLayer,
		PolygonExtrusionLayer: PolygonExtrusionLayer,
		PolygonLayer: PolygonLayer,
		SymbolLayer: SymbolLayer,
		TileLayer: TileLayer,
		HeatMapLayer: HeatMapLayer,
		ImageLayer: ImageLayer
	});

	var Html = /** @class */ (function () {
	    function Html() {
	    }
	    /**
	     * Converts the specified content into a div element.
	     * @param content A string to make the innerHTML of the div element.
	     * If a HTMLElement is provided it is returned unmodified.
	     */
	    Html.convertHtmlString = function (content) {
	        if (typeof content === "string") {
	            var htmlEle = document.createElement("div");
	            htmlEle.innerHTML = content;
	            return htmlEle;
	        }
	        else {
	            return content;
	        }
	    };
	    /**
	     * Parses the html string and filters out DOM nodes according to provided filter
	     * @param content A string containing valid html.
	     * @param filter A filter condition to check if the DOM node is allowed
	     * @param groupingElement An element that will be used as a root element if the content is a flat list of nodes
	     * If plain text is provided, the string will be returned
	     */
	    Html.parseWithFilter = function (content, filter, transformer, groupingElement) {
	        var _this = this;
	        if (filter === void 0) { filter = function (_) { return true; }; }
	        if (transformer === void 0) { transformer = function (elem) { return elem; }; }
	        if (groupingElement === void 0) { groupingElement = function () { return document.createElement('div'); }; }
	        var elem;
	        if (typeof content === 'string') {
	            var body = (new DOMParser()).parseFromString(content, 'text/html').body;
	            if (body.children.length == 0) {
	                return transformer(body.innerHTML);
	            }
	            else if (body.children.length == 1 && body.childNodes.length == 1) {
	                elem = body.children[0];
	            }
	            else {
	                var container_1 = groupingElement();
	                Array.from(body.childNodes).map(function (node) { return container_1.append(node); });
	                elem = container_1;
	            }
	        }
	        else {
	            elem = content;
	        }
	        Array.from(elem.children).forEach(function (elem) { return _this.parseWithFilter(elem, filter, transformer); });
	        if (!filter(elem)) {
	            if (elem.parentNode) {
	                elem.parentNode.removeChild(elem);
	            }
	            return null;
	        }
	        else {
	            return transformer(elem);
	        }
	    };
	    return Html;
	}());

	/** `Object#toString` result references. */
	var objectTag$4 = '[object Object]';

	/** Used for built-in method references. */
	var funcProto$2 = Function.prototype,
	    objectProto$f = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$2 = funcProto$2.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$c = objectProto$f.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString$2.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$4) {
	    return false;
	  }
	  var proto = _getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty$c.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString$2.call(Ctor) == objectCtorString;
	}

	var isPlainObject_1 = isPlainObject;

	/**
	 * Checks if `value` is likely a DOM element.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	 * @example
	 *
	 * _.isElement(document.body);
	 * // => true
	 *
	 * _.isElement('<body>');
	 * // => false
	 */
	function isElement(value) {
	  return isObjectLike_1(value) && value.nodeType === 1 && !isPlainObject_1(value);
	}

	var isElement_1 = isElement;

	/**
	 * The options for a popup.
	 */
	var PopupOptions = /** @class */ (function (_super) {
	    __extends(PopupOptions, _super);
	    function PopupOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Indicates the popup's location relative to its position on the map.
	         * Optional values: `"none"`, `"top"`, `"bottom"`, `"left"`, `"right"`,
	         * `"top-left"`, `"top-right"`, `"bottom-left"`, `"bottom-right"`.
	         * default `"none"`
	         * @default "none"
	         */
	        _this.anchor = "none";
	        /**
	         * Specifies if the popup can be dragged away from its position.
	         * default `false`
	         * @default false
	         */
	        _this.draggable = false;
	        /**
	         * Specifies if the close button should be displayed in the popup or not.
	         * default `true`
	         * @default true
	         */
	        _this.closeButton = true;
	        /**
	         * The content to display within the popup.
	         * default `span`
	         * @default span
	         */
	        _this.content = document.createElement("span");
	        /**
	         * Specifies the fill color of the popup.
	         * default `"#FFFFFF"`
	         * @default "#FFFFFF"
	         */
	        _this.fillColor = "#FFFFFF";
	        /**
	         * An array of [pixelsRight, pixelsDown] for how many pixels to the right and down the anchor of the popup should be
	         * offset. Negative numbers can be used to offset the popup left and up.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.pixelOffset = new Pixel(0, 0);
	        /**
	         * The position on the map where the popup should be anchored.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.position = new Position(0, 0);
	        /**
	         * Specifies if the pointer should be displayed in the popup or not.
	         * default `true`
	         * @default true
	         */
	        _this.showPointer = true;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows HTMLElements to pass through without cloning.
	     * @param value The value being cloned.
	     * @internal
	     */
	    PopupOptions._cloneCustomizer = function (value) {
	        if (isElement_1(value)) {
	            return value;
	        }
	    };
	    return PopupOptions;
	}(Options));

	/**
	 * An information window anchored at a specified position on a map.
	 */
	var Popup = /** @class */ (function (_super) {
	    __extends(Popup, _super);
	    /**
	     * Constructs a Popup object and initializes it with the specified options.
	     * @param options The options for the popup.
	     */
	    function Popup(options) {
	        var _this = _super.call(this) || this;
	        /**
	         * Attaches the popup to the HTML document in a hidden state.
	         * @param map The map.
	         */
	        _this.attach = function (map) {
	            // If attaching to a different map, remove popup on current map
	            if (_this.map !== map) {
	                // If map was defined the popup was attached to another map.
	                if (_this.map) {
	                    _this.remove();
	                }
	                // Create the marker before attaching the popup and it to the map.
	                _this.map = map;
	                _this.marker = _this._createMarker(_this.options);
	                // Attach the wrapped mapbox marker to the map.
	                // When the marker is attached to the map it will attach the containerHtml to a default container.
	                // Move the containerHtml to the popup collection container after attaching the marker.
	                _this.marker.addTo(_this.map._getMap());
	                _this.map.popups._getCollectionDiv().appendChild(_this.containerDiv);
	                _this.map.popups.add(_this);
	            }
	        };
	        /**
	         * Opens the popup.
	         * @param map The map to open the popup on.
	         * Optional if already attached to a map.
	         */
	        _this.open = function (map) {
	            if (!map && !_this.map) {
	                throw new Error("Must specify a map to open on or attach to a map in advance");
	            }
	            _this.attach(map || _this.map);
	            _this.containerDiv.classList.remove(Popup.Css.hidden);
	            _this.map.events.add("move", _this._onMove);
	            _this._onMove();
	            _this._invokeEvent("open", { target: _this, type: "open" });
	        };
	        /**
	         * Closes the popup on the map. The popup remains attached to the HTML document.
	         */
	        _this.close = function () {
	            if (_this.map) {
	                _this.map.events.remove("move", _this._onMove);
	            }
	            _this.containerDiv.classList.add(Popup.Css.hidden);
	            _this._invokeEvent("close", { target: _this, type: "close" });
	        };
	        /**
	         * Closes the popup on the map and removes it from the HTML document.
	         */
	        _this.remove = function () {
	            if (_this.map) {
	                _this.marker.remove();
	                _this.containerDiv.classList.remove(_this.autoAnchor || _this.options.anchor);
	                _this.map.events.remove("move", _this._onMove);
	                _this.map.popups.remove(_this);
	                delete _this.map;
	                delete _this.marker;
	                delete _this.autoAnchor;
	            }
	        };
	        /**
	         * Returns true if the popup is currently open, otherwise false.
	         */
	        _this.isOpen = function () {
	            return _this.map && !_this.containerDiv.classList.contains(Popup.Css.hidden);
	        };
	        /**
	         * Callback for the move listener used for auto anchoring.
	         */
	        _this._onMove = function () {
	            var newAutoAnchor = _this._getAutoAnchor(_this.map, _this.options);
	            if (newAutoAnchor !== _this.autoAnchor) {
	                // When we replace the marker it adds a new move listeners.
	                // We want our listener to fire after the marker's, so we add it again.
	                // Adding the listener again means it will fire after all other previously listeners.
	                _this._replaceMarker(_this.map, _this.options, newAutoAnchor);
	                _this.map.events.add("move", _this._onMove);
	            }
	        };
	        /**
	         * Called by a mouse down or touch start event.
	         */
	        _this._onDown = function (event) {
	            _this.map.popups._addDraggedPopup(_this);
	            var _a = __read(_this.map.positionsToPixels([_this.options.position]), 1), anchorPixel = _a[0];
	            if (event.type === "mousedown") {
	                event = event;
	                _this.dragOffset = [
	                    anchorPixel[0] - event.clientX,
	                    anchorPixel[1] - event.clientY
	                ];
	            }
	            else if (event.type === "touchstart") {
	                event = event;
	                _this.dragOffset = [
	                    anchorPixel[0] - event.touches[0].clientX,
	                    anchorPixel[1] - event.touches[0].clientY
	                ];
	            }
	        };
	        /**
	         * Called by the container's dragstart event.
	         * Used to call preventDefault as a fix for Edge dragging issues.
	         */
	        _this._onDragStart = function (event) {
	            event.preventDefault();
	        };
	        _this.options = new PopupOptions().merge(cloneDeepWith_1(options, PopupOptions._cloneCustomizer));
	        // Create full content container
	        _this.containerDiv = _this._createContainerDiv(_this.options);
	        // Create the container for the content specified in the options.
	        _this.contentDiv = _this._createContentDiv(_this.options);
	        _this.containerDiv.appendChild(_this.contentDiv);
	        // Create arrow tip if specified in the options.
	        if (_this.options.showPointer) {
	            _this.arrowDiv = _this._createArrowDiv();
	            _this.containerDiv.appendChild(_this.arrowDiv);
	        }
	        // Create close button if specified in the options.
	        if (_this.options.closeButton) {
	            _this.closeBtn = _this._createCloseButton();
	            _this.contentDiv.appendChild(_this.closeBtn);
	        }
	        return _this;
	    }
	    /**
	     * Sets the options for the popup.
	     * @param options The options for the popup.
	     * @deprecated Use setOptions(...) instead.
	     */
	    Popup.prototype.setPopupOptions = function (options) {
	        this.setOptions(options);
	    };
	    /**
	     * Sets the options for the popup.
	     * @param options The options for the popup.
	     */
	    Popup.prototype.setOptions = function (options) {
	        var newOptions = new PopupOptions().merge(this.options, cloneDeepWith_1(options, PopupOptions._cloneCustomizer));
	        if (newOptions.content !== this.options.content) {
	            // If the popup content is changed remove the old content and add the new stuff.
	            // Will also implicitly update draggability.
	            this.htmlContent.remove();
	            this.htmlContent = this._createHtmlContent(newOptions);
	            this.contentDiv.prepend(this.htmlContent);
	        }
	        else if (newOptions.draggable !== this.options.draggable) {
	            // If the content hasn't changed, check if draggable is changed.
	            this._setDraggable(this.htmlContent, newOptions.draggable);
	        }
	        // If a close button should be shown but the close button hasn't
	        // been initialized or is missing from the container add it.
	        if (newOptions.closeButton && !this.closeBtn) {
	            this.closeBtn = this._createCloseButton();
	            this.contentDiv.appendChild(this.closeBtn);
	        }
	        else if (!newOptions.closeButton && this.closeBtn) {
	            this.contentDiv.removeChild(this.closeBtn);
	            delete this.closeBtn;
	        }
	        // If a pointer should be shown but the close button hasn't
	        // been initialized or is missing from the container add it.
	        if (newOptions.showPointer && !this.arrowDiv) {
	            this.arrowDiv = this._createArrowDiv();
	            this.containerDiv.appendChild(this.arrowDiv);
	        }
	        else if (!newOptions.showPointer && this.arrowDiv) {
	            this.containerDiv.removeChild(this.arrowDiv);
	            delete this.arrowDiv;
	        }
	        // If the fill color is changed update the relavent elements.
	        if (newOptions.fillColor !== this.options.fillColor) {
	            this.containerDiv.style.borderColor = newOptions.fillColor;
	            this.contentDiv.style.backgroundColor = newOptions.fillColor;
	        }
	        if (this.marker) {
	            if (newOptions.anchor !== this.options.anchor) {
	                // If the anchor property has changed we need to build a new marker.
	                if (this.options.anchor === "none") {
	                    if (this.autoAnchor !== newOptions.anchor) {
	                        this._replaceMarker(this.map, newOptions);
	                    }
	                    this.map.events.remove("move", this._onMove);
	                    delete this.autoAnchor;
	                }
	                else {
	                    this._replaceMarker(this.map, newOptions);
	                    if (newOptions.anchor === "none") {
	                        this.map.events.add("move", this._onMove);
	                    }
	                }
	            }
	            else {
	                // Check if the position is changed.
	                if (!isEqual_1(newOptions.position, this.options.position)) {
	                    this.marker.setLngLat(newOptions.position);
	                }
	                // Check if the offset is changed.
	                if (!isEqual_1(newOptions.pixelOffset, this.options.pixelOffset)) {
	                    this.marker.setOffset(newOptions.pixelOffset);
	                }
	            }
	        }
	        this.options = newOptions;
	    };
	    /**
	     * Returns the options for the popup.
	     * @deprecated Use getOptions() instead.
	     */
	    Popup.prototype.getPopupOptions = function () {
	        return this.getOptions();
	    };
	    /**
	     * Returns the options for the popup.
	     */
	    Popup.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, PopupOptions._cloneCustomizer);
	    };
	    /**
	     * Drags the popup to the specified pixel.
	     * Accounts for the pixel offset when dragging started.
	     * @internal
	     */
	    Popup.prototype._dragToPixel = function (pixel) {
	        // Wait until the popup has been dragged the first time to fire th dragstart event.
	        if (!this.dragging) {
	            this.dragging = true;
	            this.contentDiv.style.pointerEvents = "none";
	            this._invokeEvent("dragstart", { type: "dragstart", target: this });
	        }
	        var anchorPixel = [
	            pixel[0] + this.dragOffset[0],
	            pixel[1] + this.dragOffset[1]
	        ];
	        var _a = __read(this.map.pixelsToPositions([anchorPixel]), 1), anchorPos = _a[0];
	        this.options.position = anchorPos;
	        this.marker.setLngLat(this.options.position);
	        this._invokeEvent("drag", { type: "drag", target: this });
	    };
	    /**
	     * Called by a mouse up or touch end event.
	     * @internal
	     */
	    Popup.prototype._onUp = function () {
	        // Only fire the dragend event if the popup was actually dragged.
	        if (this.dragging) {
	            this.contentDiv.style.pointerEvents = "";
	            this._invokeEvent("dragend", { type: "dragend", target: this });
	            if (this.options.anchor === "none") {
	                // If automatically anchoring the popup check if the anchor should change after done dragging.
	                this._onMove();
	            }
	        }
	        // Clear the drag state tracking variables.
	        delete this.dragOffset;
	        delete this.dragging;
	    };
	    /**
	     * Creates the overall container div.
	     */
	    Popup.prototype._createContainerDiv = function (options) {
	        var _this = this;
	        var ele = document.createElement("div");
	        ele.classList.add(Popup.Css.container);
	        ele.classList.add(Popup.Css.hidden);
	        ele.style.borderColor = options.fillColor;
	        ele.setAttribute("role", "dialog");
	        ele.setAttribute("aria-label", "Map Information Window");
	        // Track if a key which can change the focus has been pressed.
	        var focusKeyDown = false;
	        ele.addEventListener("keydown", function (e) {
	            if (e.key === "Tab" || e.key === "Escape" || e.key === "Esc") {
	                focusKeyDown = true;
	            }
	        });
	        // If the keyup event occurs before the focusout then don't close the popup.
	        ele.addEventListener("keyup", function (e) {
	            if (e.key === "Tab" || e.key === "Escape" || e.key === "Esc") {
	                focusKeyDown = false;
	            }
	        });
	        // If focus comes in without the popup being open go ahead and open it.
	        ele.addEventListener("focusin", function (e) {
	            if (_this.map && !_this.isOpen()) {
	                _this.open(_this.map);
	                // Focus on the element again because it may have been removed and added back to the DOM
	                if (e.target instanceof HTMLElement) {
	                    e.target.focus();
	                }
	            }
	        });
	        // If the focus is lost after a key was pressed close the popup.
	        ele.addEventListener("focusout", function (e) {
	            if (focusKeyDown && e.relatedTarget instanceof Node && !ele.contains(e.relatedTarget)) {
	                focusKeyDown = false;
	                if (_this.isOpen()) {
	                    _this.close();
	                }
	            }
	        });
	        return ele;
	    };
	    /**
	     * Creates the content container div.
	     */
	    Popup.prototype._createContentDiv = function (options) {
	        var ele = document.createElement("div");
	        ele.classList.add(Popup.Css.content);
	        ele.style.backgroundColor = options.fillColor;
	        ele.setAttribute("tabindex", "0");
	        this.htmlContent = this._createHtmlContent(options);
	        ele.appendChild(this.htmlContent);
	        return ele;
	    };
	    /**
	     * Creates an arrow element.
	     */
	    Popup.prototype._createArrowDiv = function () {
	        var ele = document.createElement("div");
	        ele.classList.add(Popup.Css.arrow);
	        return ele;
	    };
	    /**
	     * Creates a close button.
	     */
	    Popup.prototype._createCloseButton = function () {
	        var ele = document.createElement("button");
	        ele.addEventListener("click", this.close);
	        ele.classList.add(Popup.Css.close);
	        ele.setAttribute("aria-label", "close");
	        ele.setAttribute("title", "close");
	        ele.setAttribute("tabindex", "0");
	        ele.innerHTML = "&times;";
	        return ele;
	    };
	    /**
	     * Creates the user content element.
	     */
	    Popup.prototype._createHtmlContent = function (options) {
	        var ele = Html.convertHtmlString(options.content);
	        if (options.draggable) {
	            this._setDraggable(ele, options.draggable);
	        }
	        return ele;
	    };
	    /**
	     * Creates the marker which wraps the popup.
	     */
	    Popup.prototype._createMarker = function (options, autoAnchor) {
	        // If a marker already exists use it's LngLat value for the new marker's position
	        // This prevent the marker from jumping around if world copies are rendered.
	        var position = this.marker ?
	            this.marker.getLngLat() :
	            options.position;
	        // Create the mapbox marker that will hold the popup.
	        var marker;
	        if (options.anchor === "none") {
	            this.autoAnchor = autoAnchor || "bottom";
	            this.containerDiv.classList.add(this.autoAnchor);
	            marker = new azuremapsMaplibreGlUnminified_4({
	                anchor: this.autoAnchor,
	                element: this.containerDiv,
	                offset: options.pixelOffset,
	            }).setLngLat(position);
	        }
	        else {
	            this.containerDiv.classList.add(options.anchor);
	            marker = new azuremapsMaplibreGlUnminified_4({
	                anchor: options.anchor,
	                element: this.containerDiv,
	                offset: options.pixelOffset,
	            }).setLngLat(position);
	        }
	        return marker;
	    };
	    /**
	     * Calculates the auto anchor value for the current marker.
	     */
	    Popup.prototype._getAutoAnchor = function (map, options) {
	        var width = this.containerDiv.offsetWidth;
	        var height = this.containerDiv.offsetHeight;
	        var posX;
	        var posY;
	        if (this.marker) {
	            var pt = map._getMap().project(this.marker.getLngLat());
	            posX = pt.x;
	            posY = pt.y;
	        }
	        else {
	            var _a = __read(map.positionsToPixels([options.position]), 1), _b = __read(_a[0], 2), x = _b[0], y = _b[1];
	            posX = x;
	            posY = y;
	        }
	        var autoAnchor = [];
	        if (posY < height) {
	            autoAnchor.push("top");
	        }
	        else if (posY > map.getCanvas().offsetHeight - height) {
	            autoAnchor.push("bottom");
	        }
	        if (posX < width / 2) {
	            autoAnchor.push("left");
	        }
	        else if (posX > map.getCanvas().offsetWidth - width / 2) {
	            autoAnchor.push("right");
	        }
	        return autoAnchor.length > 0 ?
	            autoAnchor.join("-") :
	            "bottom";
	    };
	    /**
	     * Replaces the current marker with a new one using the specified options.
	     */
	    Popup.prototype._replaceMarker = function (map, options, autoAnchor) {
	        // Track the next sibling before the marker is removed.
	        var next = this.containerDiv.nextElementSibling;
	        this.marker.remove();
	        this.containerDiv.classList.remove(this.autoAnchor || this.options.anchor);
	        this.marker = this._createMarker(options, autoAnchor);
	        this.marker.addTo(map._getMap());
	        // If the popup was already to the DOM place it back in the original order
	        // This keeps the tab order consistent.
	        map.popups._getCollectionDiv().insertBefore(this.containerDiv, next || null);
	    };
	    /**
	     * Called to setup or remove draggability.
	     */
	    Popup.prototype._setDraggable = function (ele, draggable) {
	        if (draggable) {
	            ele.addEventListener("mousedown", this._onDown);
	            ele.addEventListener("touchstart", this._onDown);
	            ele.addEventListener("dragstart", this._onDragStart);
	        }
	        else {
	            ele.removeEventListener("mousedown", this._onDown);
	            ele.removeEventListener("touchstart", this._onDown);
	            ele.removeEventListener("dragstart", this._onDragStart);
	        }
	    };
	    // CSS class names.
	    Popup.Css = {
	        arrow: "popup-arrow",
	        close: "popup-close",
	        container: "popup-container",
	        content: "popup-content-container",
	        hidden: "hidden-accessible-element"
	    };
	    return Popup;
	}(EventEmitter));

	/**
	 * Options for rendering an HtmlMarker object
	 */
	var HtmlMarkerOptions = /** @class */ (function (_super) {
	    __extends(HtmlMarkerOptions, _super);
	    function HtmlMarkerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Indicates the marker's location relative to its position on the map.
	         * Optional values: `"center"`, `"top"`, `"bottom"`, `"left"`, `"right"`,
	         * `"top-left"`, `"top-right"`, `"bottom-left"`, `"bottom-right"`.
	         * Default `"bottom"`
	         * @default "bottom"
	         */
	        _this.anchor = "bottom";
	        /**
	         * A color value that replaces any {color} placeholder property that has been included in a string htmlContent.
	         * default `"#1A73AA"`
	         * @default "#1A73AA"
	         */
	        _this.color = "#1A73AA";
	        /**
	         * Indicates if the user can drag the position of the marker using the mouse or touch controls.
	         * default `false`
	         * @default false
	         */
	        _this.draggable = false;
	        /**
	         * The HTML content of the marker. Can be an HTMLElement or HTML string.
	         * Add {text} and {color} to HTML strings as placeholders to make it easy to update
	         * these values in your marker by using the setOptions function of the HtmlMarker class.
	         * This allows you to create a single HTML marker string that can be used as a template for multiple markers.
	         */
	        _this.htmlContent = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24.5 36.5\" id=\"marker_" + uuidRandom() + "\" width=\"24.5\" height=\"36.5\" display=\"block\"><path d=\"M12.25.25a12.2543,12.2543,0,0,0-12,12.4937c0,6.4436,6.4879,12.1093,11.059,22.5641.5493,1.2563,1.3327,1.2563,1.882,0C17.7621,24.8529,24.25,19.1857,24.25,12.7437A12.2543,12.2543,0,0,0,12.25.25Z\"   fill=\"{color}\" stroke=\"{secondaryColor}\" stroke-width=\"0.5\"/><text style=\"font-family: Arial, Helvetica, sans-serif; font-size: 14px; fill: white;\" text-anchor=\"middle\" x=\"12\" y=\"18\">{text}</text></svg>";
	        /**
	         * An offset in pixels to move the popup relative to the markers center.
	         * Negatives indicate left and up.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.pixelOffset = new Pixel(0, 0);
	        /**
	         * The position of the marker.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.position = new Position(0, 0);
	        /**
	         * A popup that is attached to the marker.
	         */
	        _this.popup = undefined;
	        /**
	         * A color value that replaces any {secondaryColor} placeholder property that has been included in a string htmlContent.
	         * default `"white"`
	         * @default "white"
	         */
	        _this.secondaryColor = "white";
	        /**
	         * A string of text that replaces any {text} placeholder property that has been included in a string htmlContent.
	         */
	        _this.text = undefined;
	        /**
	         * Specifies if the marker is visible or not.
	         * default `true`
	         * @default true
	         */
	        _this.visible = true;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Popups and HTMLElements to pass through without cloning.
	     * @param value The value being cloned.
	     * @internal
	     */
	    HtmlMarkerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Popup || isElement_1(value)) {
	            return value;
	        }
	    };
	    return HtmlMarkerOptions;
	}(Options));

	/**
	 * This class wraps an HTML element that can be displayed on the map.
	 */
	var HtmlMarker = /** @class */ (function (_super) {
	    __extends(HtmlMarker, _super);
	    /**
	     * Constructs a new HtmlMarker.
	     * @param options The options for the HtmlMarker.
	     */
	    function HtmlMarker(options) {
	        var _this = _super.call(this) || this;
	        /**
	         * Called by the drag event of the mapbox marker.
	         * @private
	         */
	        _this._onDrag = function () {
	            var lngLat = _this.marker.getLngLat().wrap();
	            _this.options.position = new Position(lngLat.lng, lngLat.lat);
	            _this._invokeEvent("drag", { type: "drag", target: _this });
	        };
	        /**
	         * Called by the dragstart event of the mapbox marker.
	         * @private
	         */
	        _this._onDragStart = function () {
	            _this._invokeEvent("dragstart", { type: "dragstart", target: _this });
	        };
	        /**
	         * Called by the dragend event of the mapbox marker.
	         * @private
	         */
	        _this._onDragEnd = function () {
	            _this._invokeEvent("dragend", { type: "dragend", target: _this });
	        };
	        /**
	         * Called by the events of the marker's element.
	         * @private
	         */
	        _this._bubbleElementEvent = function (event) {
	            _this._invokeEvent(event.type, { type: event.type, target: _this });
	        };
	        /**
	         * Called by the element's dragstart event.
	         * Used to call preventDefault so Edge doesn't break dragging.
	         * @private
	         */
	        _this._onEleDragStart = function (event) {
	            event.preventDefault();
	        };
	        _this.options = new HtmlMarkerOptions().merge(cloneDeepWith_1(options, HtmlMarkerOptions._cloneCustomizer));
	        _this._buildMarker(_this.options);
	        return _this;
	    }
	    /**
	     * Gets the HTML marker options.
	     */
	    HtmlMarker.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, HtmlMarkerOptions._cloneCustomizer);
	    };
	    /**
	     * Returns the underlying `Marker`'s HTML element.
	     */
	    HtmlMarker.prototype.getElement = function () {
	        return this.marker.getElement();
	    };
	    /**
	     * Sets the options of the marker.
	     * @param options The options for the marker.
	     */
	    HtmlMarker.prototype.setOptions = function (options) {
	        var newOptions = new HtmlMarkerOptions().merge(this.options, cloneDeepWith_1(options, HtmlMarkerOptions._cloneCustomizer));
	        if (!isEqual_1(newOptions.htmlContent, this.options.htmlContent) ||
	            newOptions.anchor !== this.options.anchor) {
	            // If the htmlContent is new the old marker must be removed and a new one created.
	            this.marker.remove();
	            this._buildMarker(newOptions);
	            // If this marker is attached to a map the new mapbox marker should be added to it.
	            if (this.map) {
	                this.marker.addTo(this.map._getMap());
	                this._getCollectionContainer().appendChild(this.element);
	            }
	        }
	        else {
	            // Check for which options have been updated.
	            // Not necessary if a new marker was created as it will have all the new properties.
	            if (typeof newOptions.htmlContent === "string" &&
	                (newOptions.color !== this.options.color ||
	                    newOptions.text !== this.options.text ||
	                    newOptions.secondaryColor !== this.options.secondaryColor)) {
	                this.element.innerHTML = this._getSubbedHtmlString(newOptions);
	            }
	            if (newOptions.draggable !== this.options.draggable) {
	                this._setDraggable(newOptions.draggable);
	                this.marker.setDraggable(newOptions.draggable);
	            }
	            if (!isEqual_1(newOptions.pixelOffset, this.options.pixelOffset)) {
	                this.marker.setOffset(newOptions.pixelOffset);
	            }
	            if (!isEqual_1(newOptions.position, this.options.position)) {
	                this.marker.setLngLat(newOptions.position);
	            }
	            if (newOptions.visible !== this.options.visible) {
	                if (newOptions.visible) {
	                    this.element.classList.remove(HtmlMarker.hiddenClass);
	                }
	                else {
	                    this.element.classList.add(HtmlMarker.hiddenClass);
	                }
	            }
	        }
	        this.options = newOptions;
	    };
	    /**
	     * Toggles the popup attached to the marker.
	     */
	    HtmlMarker.prototype.togglePopup = function () {
	        if (this.options.popup) {
	            if (this.options.popup.isOpen()) {
	                this.options.popup.close();
	            }
	            else if (this.map) {
	                // Set the popup position to match the marker's.
	                // Same as the mapbox behavior.
	                this.options.popup.setOptions({
	                    position: this.options.position,
	                });
	                this.options.popup.open(this.map);
	            }
	            else {
	                throw new Error("The marker must be added to a map before calling togglePopup().");
	            }
	        }
	    };
	    /**
	     * @internal
	     */
	    HtmlMarker.prototype._addToMap = function (map, position) {
	        // If already added to a different map remove it and add to the new one.
	        if (this.map && this.map !== map) {
	            this._removeFromMap();
	        }
	        if (position) {
	            this.options.position = cloneDeep_1(position);
	            this.marker.setLngLat(this.options.position);
	        }
	        // If the marker is being added to a map it already belongs to this isn't needed.
	        if (this.map !== map) {
	            this.map = map;
	            this.marker.addTo(map._getMap());
	            this._getCollectionContainer().appendChild(this.element);
	        }
	    };
	    /**
	     * @internal
	     */
	    HtmlMarker.prototype._removeFromMap = function () {
	        if (this.map) {
	            this.marker.remove();
	            delete this.map;
	        }
	    };
	    /**
	     * @internal
	     */
	    HtmlMarker.prototype._getId = function () {
	        if (this.element) {
	            if (typeof this.options.htmlContent === "string") {
	                return this.element.firstChild["id"];
	            }
	            else {
	                return this.element.id;
	            }
	        }
	        return undefined;
	    };
	    /**
	     * Builds the Mapbox marker that this HtmlMarker will wrap.
	     * @private
	     */
	    HtmlMarker.prototype._buildMarker = function (options) {
	        // Construct a mapbox marker that this class wraps.
	        // Must converts a HTML string to a HTMLElement (div with innerHTML == htmlContent).
	        // Must also handle the substitution of HTML string placeholders.
	        if (typeof options.htmlContent === "string") {
	            var subbedContent = this._getSubbedHtmlString(options);
	            this.element = Html.convertHtmlString(subbedContent);
	        }
	        else {
	            this.element = options.htmlContent;
	        }
	        this.element.classList.add(HtmlMarker.containerClass);
	        // If draggability is enabled some attributes need updated.
	        if (options.draggable) {
	            this._setDraggable(true);
	        }
	        // If visible is false the marker should still exist on the DOM so it is accessible.
	        if (!options.visible) {
	            this.element.classList.add(HtmlMarker.hiddenClass);
	        }
	        this.marker = new azuremapsMaplibreGlUnminified_4({
	            element: this.element,
	            offset: options.pixelOffset,
	            draggable: options.draggable,
	            anchor: options.anchor
	        }).setLngLat(options.position);
	        // Listen for marker specific events.
	        this.marker.on("drag", this._onDrag);
	        this.marker.on("dragstart", this._onDragStart);
	        this.marker.on("dragend", this._onDragEnd);
	        // Listen for HtmlElement specific events.
	        this.element.addEventListener("click", this._bubbleElementEvent);
	        this.element.addEventListener("dblclick", this._bubbleElementEvent);
	        this.element.addEventListener("contextmenu", this._bubbleElementEvent);
	        this.element.addEventListener("keydown", this._bubbleElementEvent);
	        this.element.addEventListener("keypress", this._bubbleElementEvent);
	        this.element.addEventListener("keyup", this._bubbleElementEvent);
	        this.element.addEventListener("mousedown", this._bubbleElementEvent);
	        this.element.addEventListener("mouseenter", this._bubbleElementEvent);
	        this.element.addEventListener("mouseleave", this._bubbleElementEvent);
	        this.element.addEventListener("mousemove", this._bubbleElementEvent);
	        this.element.addEventListener("mouseout", this._bubbleElementEvent);
	        this.element.addEventListener("mouseover", this._bubbleElementEvent);
	        this.element.addEventListener("mouseup", this._bubbleElementEvent);
	    };
	    /**
	     * Returns a HTML string with all place holders substituted for.
	     * @private
	     */
	    HtmlMarker.prototype._getSubbedHtmlString = function (options) {
	        if (typeof options.htmlContent === "string") {
	            return options.htmlContent
	                .replace(/{color}/ig, options.color || "")
	                .replace(/{secondaryColor}/ig, options.secondaryColor || "")
	                .replace(/{text}/ig, options.text || "");
	        }
	    };
	    /**
	     * Returns the element that should contain all the markers.
	     * Creates it if it doesn't already exist.
	     * @private
	     */
	    HtmlMarker.prototype._getCollectionContainer = function () {
	        var collectionContainer = this.map.getCanvasContainer()
	            .querySelector("." + HtmlMarker.collectionContainerClass);
	        if (!collectionContainer) {
	            collectionContainer = document.createElement("div");
	            collectionContainer.classList.add(HtmlMarker.collectionContainerClass);
	            this.map.getCanvasContainer().appendChild(collectionContainer);
	        }
	        return collectionContainer;
	    };
	    /**
	     * Called to set the element dragstart listener, needed for proper draggability on Edge.
	     */
	    HtmlMarker.prototype._setDraggable = function (draggable) {
	        if (draggable) {
	            this.element.addEventListener("dragstart", this._onEleDragStart);
	        }
	        else {
	            this.element.removeEventListener("dragstart", this._onEleDragStart);
	        }
	    };
	    HtmlMarker.collectionContainerClass = "marker-collection-container";
	    HtmlMarker.hiddenClass = "hidden-accessible-element";
	    HtmlMarker.containerClass = "marker-container";
	    return HtmlMarker;
	}(EventEmitter));

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq_1(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    _baseAssignValue(object, key, value);
	  }
	}

	var _assignMergeValue = assignMergeValue;

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	var _createBaseFor = createBaseFor;

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = _createBaseFor();

	var _baseFor = baseFor;

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike_1(value) && isArrayLike_1(value);
	}

	var isArrayLikeObject_1 = isArrayLikeObject;

	/**
	 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function safeGet(object, key) {
	  if (key === 'constructor' && typeof object[key] === 'function') {
	    return;
	  }

	  if (key == '__proto__') {
	    return;
	  }

	  return object[key];
	}

	var _safeGet = safeGet;

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return _copyObject(value, keysIn_1(value));
	}

	var toPlainObject_1 = toPlainObject;

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = _safeGet(object, key),
	      srcValue = _safeGet(source, key),
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    _assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    var isArr = isArray_1(srcValue),
	        isBuff = !isArr && isBuffer_1(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);

	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray_1(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject_1(objValue)) {
	        newValue = _copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = _cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = _cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
	      newValue = objValue;
	      if (isArguments_1(objValue)) {
	        newValue = toPlainObject_1(objValue);
	      }
	      else if (!isObject_1(objValue) || isFunction_1(objValue)) {
	        newValue = _initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  _assignMergeValue(object, key, newValue);
	}

	var _baseMergeDeep = baseMergeDeep;

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  _baseFor(source, function(srcValue, key) {
	    stack || (stack = new _Stack);
	    if (isObject_1(srcValue)) {
	      _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      _assignMergeValue(object, key, newValue);
	    }
	  }, keysIn_1);
	}

	var _baseMerge = baseMerge;

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	var identity_1 = identity;

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	var _apply = apply;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return _apply(func, this, otherArgs);
	  };
	}

	var _overRest = overRest;

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	var constant_1 = constant;

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !_defineProperty ? identity_1 : function(func, string) {
	  return _defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant_1(string),
	    'writable': true
	  });
	};

	var _baseSetToString = baseSetToString;

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	var _shortOut = shortOut;

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = _shortOut(_baseSetToString);

	var _setToString = setToString;

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return _setToString(_overRest(func, start, identity_1), func + '');
	}

	var _baseRest = baseRest;

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject_1(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike_1(object) && _isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq_1(object[index], value);
	  }
	  return false;
	}

	var _isIterateeCall = isIterateeCall;

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return _baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	var _createAssigner = createAssigner;

	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = _createAssigner(function(object, source, srcIndex) {
	  _baseMerge(object, source, srcIndex);
	});

	var merge_1 = merge;

	/**
	 * A helper class that will parses and splits a culture code into its language and region parts.
	 */
	var CultureCode = /** @class */ (function () {
	    function CultureCode() {
	    }
	    /**
	     * Parses and splits the specified culture code.
	     * Splits based on the last index of "-".
	     * If a split can not be made the specified code will be considered just the language leaving region undefined.
	     * All string properties will be in lowercase for simplified string matching.
	     * @param code The culture code.
	     */
	    CultureCode.parse = function (code) {
	        code = code.toLowerCase();
	        var index = code.lastIndexOf("-");
	        if (index !== -1) {
	            return {
	                code: code,
	                language: code.substring(0, index),
	                region: code.substring(index + 1)
	            };
	        }
	        return {
	            code: code,
	            language: code,
	        };
	    };
	    return CultureCode;
	}());

	/**
	 * A specific implementation of the LocaleIndex interface.
	 * Contains real information about the available/supported locales.
	 */
	var localeIndex = {
	    localizationsPath: "locs/mapcontrol/2019-3-12",
	    sensitiveUserRegions: ["il", "kr", "pk", "in", "cn", "ar", "bh", "eg", "jo", "sa", "kw", "om", "qa", "ma", "ae"],
	    locales: {
	        defaultLanguage: {
	            defaultRegion: {
	                code: "NGT",
	                strings: "en/resource.json"
	            }
	        },
	        ar: {
	            defaultRegion: {
	                code: "ar",
	                strings: "ar-sa/resource.json"
	            }
	        },
	        bg: {
	            defaultRegion: {
	                code: "bg-BG",
	                strings: "bg-bg/resource.json"
	            }
	        },
	        cs: {
	            defaultRegion: {
	                code: "cs-CZ",
	                strings: "cs-cz/resource.json"
	            }
	        },
	        da: {
	            defaultRegion: {
	                code: "da-DK",
	                strings: "da-dk/resource.json"
	            }
	        },
	        de: {
	            defaultRegion: {
	                code: "de-DE",
	                strings: "de-de/resource.json"
	            }
	        },
	        el: {
	            defaultRegion: {
	                code: "el-GR",
	                strings: "el-gr/resource.json"
	            }
	        },
	        en: {
	            defaultRegion: {
	                code: "en",
	                strings: "en/resource.json"
	            },
	            us: {
	                code: "en-US",
	                strings: "en/resource.json"
	            }
	        },
	        es: {
	            defaultRegion: {
	                code: "es-ES",
	                strings: "es-es/resource.json"
	            },
	            mx: {
	                code: "es-MX",
	                strings: "es-mx/resource.json"
	            }
	        },
	        fi: {
	            defaultRegion: {
	                code: "fi-FI",
	                strings: "fi-fi/resource.json"
	            }
	        },
	        fr: {
	            defaultRegion: {
	                code: "fr-FR",
	                strings: "fr-fr/resource.json"
	            }
	        },
	        hu: {
	            defaultRegion: {
	                code: "hu-HU",
	                strings: "hu-hu/resource.json"
	            }
	        },
	        id: {
	            defaultRegion: {
	                code: "id-ID",
	                strings: "id-id/resource.json"
	            }
	        },
	        it: {
	            defaultRegion: {
	                code: "it-IT",
	                strings: "it-it/resource.json"
	            }
	        },
	        ko: {
	            defaultRegion: {
	                code: "ko-KR",
	                strings: "ko-kr/resource.json"
	            }
	        },
	        lt: {
	            defaultRegion: {
	                code: "lt-LT",
	                strings: "lt-lt/resource.json"
	            }
	        },
	        ms: {
	            defaultRegion: {
	                code: "ms-MY",
	                strings: "ms-my/resource.json"
	            }
	        },
	        nb: {
	            defaultRegion: {
	                code: "nb-NO",
	                strings: "nb-no/resource.json"
	            }
	        },
	        nl: {
	            defaultRegion: {
	                code: "nl-NL",
	                strings: "nl-nl/resource.json"
	            }
	        },
	        pl: {
	            defaultRegion: {
	                code: "pl-PL",
	                strings: "pl-pl/resource.json"
	            }
	        },
	        pt: {
	            defaultRegion: {
	                code: "pt-PT",
	                strings: "pt-pt/resource.json"
	            },
	            br: {
	                code: "pt-BR",
	                strings: "pt-br/resource.json"
	            }
	        },
	        ru: {
	            defaultRegion: {
	                code: "ru-RU",
	                strings: "ru-ru/resource.json"
	            }
	        },
	        sk: {
	            defaultRegion: {
	                code: "sk-SK",
	                strings: "sk-sk/resource.json"
	            }
	        },
	        sl: {
	            defaultRegion: {
	                code: "sl-SL",
	                strings: "sl-sl/resource.json"
	            }
	        },
	        sv: {
	            defaultRegion: {
	                code: "sv-SE",
	                strings: "sv-se/resource.json"
	            }
	        },
	        th: {
	            defaultRegion: {
	                code: "th-TH",
	                strings: "th-th/resource.json"
	            }
	        },
	        tr: {
	            defaultRegion: {
	                code: "tr-TR",
	                strings: "tr-tr/resource.json"
	            }
	        },
	        zh: {
	            defaultRegion: {
	                code: "zh-Hant",
	                strings: "zh-tw/resource.json"
	            }
	        },
	        "zh-hant": {
	            defaultRegion: {
	                code: "zh-Hant",
	                strings: "zh-tw/resource.json"
	            }
	        }
	    }
	};

	/**
	 * An interface defining the contents of a specific localized strings json.
	 */
	var LocalizedStrings = /** @class */ (function () {
	    function LocalizedStrings() {
	        /**
	         * A localized version of `"Unknown"`.
	         */
	        this.Unknown = "Unknown";
	        /**
	         * A localized version of `"Accident"`.
	         */
	        this.Accident = "Accident";
	        /**
	         * A localized version of `"Fog"`.
	         */
	        this.Fog = "Fog";
	        /**
	         * A localized version of `"Danger"`.
	         */
	        this.Danger = "Danger";
	        /**
	         * A localized version of `"Rain"`.
	         */
	        this.Rain = "Rain";
	        /**
	         * A localized version of `"Ice"`.
	         */
	        this.Ice = "Ice";
	        /**
	         * A localized version of `"Jam"`.
	         */
	        this.Jam = "Jam";
	        /**
	         * A localized version of `"Lane Closed"`.
	         */
	        this.LaneClosed = "Lane Closed";
	        /**
	         * A localized version of `"Road Closed"`.
	         */
	        this.RoadClosed = "Road Closed";
	        /**
	         * A localized version of `"Road Works"`.
	         */
	        this.RoadWorks = "Road Works";
	        /**
	         * A localized version of `"Wind"`.
	         */
	        this.Wind = "Wind";
	        /**
	         * A localized version of `"Flood"`.
	         */
	        this.Flood = "Flood";
	        /**
	         * A localized version of `"Detour"`.
	         */
	        this.Detour = "Detour";
	    }
	    return LocalizedStrings;
	}());

	/**
	 * A static class used for fetching localized strings and validating supported language codes.
	 */
	var Localizer = /** @class */ (function () {
	    function Localizer() {
	    }
	    /**
	     * Returns a supported culture code that best fits the requested one.
	     * @param locale The requested culture code.
	     */
	    Localizer.getCode = function (locale) {
	        var code = CultureCode.parse(locale);
	        // If the requested culture code includes a sensitive region simply return the original code.
	        // This is to hopefully reduce the risk or providing bad content to users in a sensitive region.
	        return (localeIndex.sensitiveUserRegions.indexOf(code.region) === -1) ?
	            this.getLocaleData(code).code :
	            locale;
	    };
	    /**
	     * Returns a collection of localized strings that best fits the requested culture code.
	     * @param locale The requested culture code.
	     */
	    Localizer.getStrings = function (locale) {
	        var localeData = this.getLocaleData(locale);
	        // Start a GET request
	        var request = new Url({
	            domain: env.staticAssetsDomain,
	            path: localeIndex.localizationsPath + "/" + localeData.strings
	        }).get();
	        // Return the response as a LocalizedStrings object.
	        return request.then(function (response) {
	            return response;
	        }, function () {
	            // If the request for the localized strings json fails return a default localization in English.
	            return new LocalizedStrings();
	        });
	    };
	    /**
	     * Gets the best fit locale data based on the specified culture code.
	     * @param locale The requested culture code.
	     */
	    Localizer.getLocaleData = function (locale) {
	        // Convert the locale to a culture code if one wasn't already provided.
	        if (typeof locale === "string") {
	            locale = CultureCode.parse(locale);
	        }
	        // Check if the locale could be just the language.
	        // If so return the default locale data for that language.
	        if (localeIndex.locales[locale.code]) {
	            return localeIndex.locales[locale.code].defaultRegion;
	        }
	        // Check if the language is supported.
	        // If not use the default language.
	        var regionIndex;
	        if (localeIndex.locales[locale.language]) {
	            regionIndex = localeIndex.locales[locale.language];
	        }
	        else if (locale.language.indexOf("-") !== -1) {
	            // If the current language can't be matched but there is another "-"
	            // Try to use the language as if it is a full culture code.
	            return this.getLocaleData(locale.language);
	        }
	        else {
	            regionIndex = localeIndex.locales.defaultLanguage;
	        }
	        // Check if the region is supported for the chosen language.
	        // If not use the default region for the chosen language.
	        if (locale.region && regionIndex[locale.region]) {
	            return regionIndex[locale.region];
	        }
	        else {
	            return regionIndex.defaultRegion;
	        }
	    };
	    return Localizer;
	}());

	var UserAgent = /** @class */ (function () {
	    function UserAgent() {
	    }
	    /**
	     * Returns the Edge or IE browser version number.
	     * Edge will be version 12 or greater.
	     * IE will be version 11 or less.
	     * If the browser is not Edge or IE -1 will be returned.
	     */
	    UserAgent.getEdgeOrIEVersion = function () {
	        var ua = window.navigator.userAgent;
	        var msie = ua.indexOf("MSIE ");
	        if (msie > 0) {
	            // IE 10 or older
	            return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
	        }
	        var trident = ua.indexOf("Trident/");
	        if (trident > 0) {
	            // IE 11
	            var rv = ua.indexOf("rv:");
	            return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
	        }
	        var edge = ua.indexOf("Edge/");
	        if (edge > 0) {
	            // Edge (IE 12+)
	            return parseInt(ua.substring(edge + 5, ua.indexOf(".", edge)), 10);
	        }
	        // other browser
	        return -1;
	    };
	    /**
	     * Detects if the browser is IE or Edge.
	     */
	    UserAgent.isEdgeOrIE = function () {
	        var version = this.getEdgeOrIEVersion();
	        return version !== -1;
	    };
	    /**
	     * Detects if the browser is IE but not Edge.
	     */
	    UserAgent.isIE = function () {
	        var version = this.getEdgeOrIEVersion();
	        return version !== -1 && version <= 11;
	    };
	    return UserAgent;
	}());

	(function (AuthenticationType) {
	    /**
	     * The subscription key authentication mechanism.
	     * Literal value `"subscriptionKey"`
	     */
	    AuthenticationType["subscriptionKey"] = "subscriptionKey";
	    /**
	     * The AAD implicit grant mechanism. Recommended for pages protected by a sign-in.
	     * By default the page will be redirected to the AAD login when the map control initializes.
	     * Specify a logged-in `AuthenticationContext` in the `AuthenticationOptions`
	     * for greater control over when/how the users signs in.
	     * Literal value `"aad"`
	     */
	    AuthenticationType["aad"] = "aad";
	    /**
	     * The anonymous authentication mechanism. Recommended for public pages.
	     * Allows a callback responsible for acquiring an authentication token to be provided.
	     * Literal value `"anonymous"`
	     */
	    AuthenticationType["anonymous"] = "anonymous";
	})(exports.AuthenticationType || (exports.AuthenticationType = {}));
	/**
	 * Options for specifying how the map control should authenticate with the Azure Maps services.
	 */
	var AuthenticationOptions = /** @class */ (function (_super) {
	    __extends(AuthenticationOptions, _super);
	    function AuthenticationOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The authentication mechanism to be used.
	         */
	        _this.authType = undefined;
	        /**
	         * Subscription key from your Azure Maps account.
	         * Must be specified for subscription key authentication type.
	         */
	        _this.subscriptionKey = undefined;
	        /**
	         * The Azure Maps client ID, This is an unique identifier used to identify the maps account.
	         * Preferred to always be specified, but must be specified for AAD and anonymous authentication types.
	         */
	        _this.clientId = undefined;
	        /**
	         * The Azure AD registered app ID. This is the app ID of an app registered in your Azure AD tenant.
	         * Must be specified for AAD authentication type.
	         */
	        _this.aadAppId = undefined;
	        /**
	         * The AAD tenant that owns the registered app specified by `aadAppId`.
	         * Must be specified for AAD authentication type.
	         */
	        _this.aadTenant = undefined;
	        /**
	         * The AAD instance to use for logging in.
	         * Can be optionally specified when using the AAD authentication type.
	         * By default the `https://login.microsoftonline.com/` instance will be used.
	         */
	        _this.aadInstance = undefined;
	        /**
	         * A callback to use with the anonymous authentication mechanism.
	         * This callback will be responsible for resolving to a authentication token.
	         * E.g. fetching a CORS protected token from an endpoint.
	         */
	        _this.getToken = undefined;
	        /**
	         * Optionally provide an existing `AuthenticationContext` from the ADAL.js library.
	         * This authentication context will be used to acquire the AAD token.
	         * Only used with the AAD authentication type.
	         * This auth context must be configured to use the same AAD app ID as `this.aadAppId`.
	         * If this is not provided all map instances will share their own private auth context.
	         */
	        _this.authContext = undefined;
	        return _this;
	    }
	    /**
	     * Sets the required options to configure the subscription key authentication mechanism.
	     * @param subscriptionKey Subscription Key from your azure maps account
	     */
	    AuthenticationOptions.prototype.setSubscriptionKey = function (key) {
	        this.authType = exports.AuthenticationType.subscriptionKey;
	        this.subscriptionKey = key;
	    };
	    /**
	     * Sets the required authentication options to configure the AAD implicit grant mechanism.
	     * @param clientId Client ID from your azure maps account
	     * @param aadAppId Azure AD App ID
	     * @param aadTenant Azure AD Tenant Name
	     * @param aadInstance An optional Azure AD Instance
	     * @param authContext An optional `AuthenticationContext` from the ADAL.js library
	     */
	    AuthenticationOptions.prototype.setAadProperties = function (clientId, aadAppId, aadTenant, aadInstance, authContext) {
	        this.authType = exports.AuthenticationType.aad;
	        this.authContext = authContext || this.authContext;
	        this.aadInstance = aadInstance || this.aadInstance;
	        this.clientId = clientId;
	        this.aadAppId = aadAppId;
	        this.aadTenant = aadTenant;
	    };
	    /**
	     * Sets the required options to configure the anonymous authentication method.
	     * @param getTokenCallback Callback function responsible for resolving to an authentication token.
	     */
	    AuthenticationOptions.prototype.setTokenCallbackFunction = function (getTokenCallback) {
	        this.authType = exports.AuthenticationType.anonymous;
	        this.getToken = getTokenCallback;
	    };
	    /**
	     * Override the standard merge behavior to handle mutually exclusive options.
	     * @internal
	     */
	    AuthenticationOptions.prototype.merge = function () {
	        var valueList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valueList[_i] = arguments[_i];
	        }
	        var merged = _super.prototype.merge.apply(this, __spread(valueList));
	        if (merged.authType === exports.AuthenticationType.subscriptionKey) {
	            merged.authContext = merged.aadAppId = merged.getToken = undefined;
	        }
	        else if (merged.authType === exports.AuthenticationType.aad) {
	            merged.subscriptionKey = merged.getToken = undefined;
	        }
	        else if (merged.authType === exports.AuthenticationType.anonymous) {
	            merged.subscriptionKey = merged.authContext = merged.aadAppId = undefined;
	        }
	        return merged;
	    };
	    return AuthenticationOptions;
	}(Options));

	var defaultView;
	var defaultLanguage = "NGT";
	var defaultSessionId = uuidRandom();
	var defaultDomain = env.domain;
	var defaultStaticAssetsDomain = env.staticAssetsDomain;
	var defaultStyleDefinitionsPath = env.stylePath;
	var defaultStyleDefinitionsVersion = env.styleDefinitionsVersion;
	var defaultAuthOptions = new AuthenticationOptions();
	var hasSetView = false;
	var hasSetDomain = false;
	var hasSetStyleDefinitionsPath = false;
	var hasSetStyleDefinitionsVersion = false;
	var hasWorkerCount = false;
	var hasMaxParallelImageRequests = false;
	var hasSetLanguage = false;
	var hasSetSessionId = false;
	var hasSetAuthenticationOptions = false;
	/**
	 * Gets the default authentication options that were provided.
	 * If not previously set all properties will be undefined.
	 */
	function getAuthenticationOptions() {
	    return Object.assign({}, defaultAuthOptions);
	}
	/**
	 * Getrs the defawult static assets domain.
	 * @internal
	 */
	function getStaticAssetsDomain() {
	    return defaultStaticAssetsDomain;
	}
	/**
	 * Gets the default domain that was provided.
	 * If not previously set the default value is `"atlas.microsoft.com"`.
	 */
	function getDomain() {
	    return defaultDomain;
	}
	/**
	 * Gets the default styleDefinitionsPath that was provided.
	 * @internal
	 */
	function getStyleDefinitionsPath() {
	    return defaultStyleDefinitionsPath;
	}
	/**
	 * Gets the default styleDefinitionsVersion that was provided.
	 * @internal
	 */
	function getStyleDefinitionsVersion() {
	    return defaultStyleDefinitionsVersion;
	}
	/**
	 * Gets the worker count that will get created.
	 */
	function getWorkerCount() {
	    return azuremapsMaplibreGlUnminified.workerCount;
	}
	/**
	 * Gets the Maximum number of images (raster tiles, sprites, icons) to load in parallel
	 */
	function getMaxParallelImageRequests() {
	    return azuremapsMaplibreGlUnminified.maxParallelImageRequests;
	}
	/**
	 * Gets the default language that was provided.
	 * If not previously set the default value is `"NGT"`.
	 */
	function getLanguage() {
	    return defaultLanguage;
	}
	/**
	 * Gets the default session id that was provided.
	 * If not previously set the default value is a random UUID.
	 */
	function getSessionId() {
	    return defaultSessionId;
	}
	/**
	 * Gets the default Azure Maps subscription key that was provided.
	 */
	function getSubscriptionKey() {
	    return defaultAuthOptions.authType === exports.AuthenticationType.subscriptionKey ?
	        defaultAuthOptions.subscriptionKey : undefined;
	}
	/**
	 * @deprecated use atlas.getView() instead
	 */
	function getUserRegion() {
	    return defaultView;
	}
	/**
	 * Gets the default view setting of the map control.
	 * If not previously set the default value is `undefined`.
	 */
	function getView() {
	    return defaultView;
	}
	/**
	 * Current API version number based on build number.
	 */
	function getVersion() {
	    return Version.getFullVersion();
	}
	/**
	 * Checks to see if the user's browser is supported by the map control.
	 * @param failIfMajorPerformanceCaveat If true the function will return false
	 * if the performance of the map control would be dramatically worse than expected
	 * (e.g. a software WebGL renderer would be used).
	 */
	function isSupported(failIfMajorPerformanceCaveat) {
	    // Always return false for IE since we don't support it ourselves.
	    if (UserAgent.isIE()) {
	        return false;
	    }
	    return azuremapsMaplibreGlUnminified.supported({
	        failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat
	    });
	}
	/**
	 * Sets your authentication options as the default options in the atlas namespace
	 * which is used by the map control and any modules that make requests to the Azure maps services.
	 * If a Map is initialized with the authentication options explicitly defined and
	 * setAuthenticationOptions hasn't previously been called it will automatically be called by the Map constructor.
	 * @param options The new default authentication options.
	 */
	function setAuthenticationOptions(options) {
	    defaultAuthOptions = new AuthenticationOptions().merge(defaultAuthOptions, options);
	    hasSetAuthenticationOptions = true;
	}
	/**
	 * Sets the default domain used by the map and service modules unless the
	 * domain is explicitly specified when using those parts of the API.
	 * If a Map is initialized with the domain explicitly defined and
	 * setDomain hasn't previously been called it will automatically be called by the Map constructor.
	 * If the protocol is not specified `https` is assumed.
	 * @param domain The new default domain.
	 */
	function setDomain(domain) {
	    defaultDomain = domain;
	    hasSetDomain = true;
	}
	/**
	 * Sets the default styleDefinitionsPath to use for getting the map styles.
	 * If a Map is initialized with the styleDefinitionsPath explicitly defined and
	 * setStyleDefinitionsPath hasn't previously been called it will automatically be called by the Map constructor.
	 * @param styleDefinitionsPath The new default styleDefinitionsPath.
	 * @internal
	 */
	function setStyleDefinitionsPath(styleDefinitionsPath) {
	    defaultStyleDefinitionsPath = styleDefinitionsPath;
	    hasSetStyleDefinitionsPath = true;
	}
	/**
	 * Sets the default styleDefinitionsVersion to use when requesting style definitions
	 * from styleDefinitionsPath.  If a map is initialized with the with the styleDefinitionsVersion
	 * explicitly defined and setStyleDefinitionsVersion hasn't previously been called it will be
	 * automatically called by the Map constructor.
	 * @param styleDefinitionsVersion
	 */
	function setStyleDefinitionsVersion(styleDefinitionsVersion) {
	    defaultStyleDefinitionsVersion = styleDefinitionsVersion;
	    hasSetStyleDefinitionsVersion = true;
	}
	/**
	 * Sets number of web workers instantiated on a page.
	 * By default, it is set to half the number of CPU cores (capped at 6).
	 * @param workerCount worker count.
	 */
	function setWorkerCount(workerCount) {
	    if (workerCount > 0) {
	        azuremapsMaplibreGlUnminified.workerCount = workerCount;
	        hasWorkerCount = true;
	    }
	}
	/**
	 * Sets Maximum number of images (raster tiles, sprites, icons) to load in parallel,
	 * which affects performance in raster-heavy maps. 16 by default.
	 * @param maxParallelImageRequests Maximum number of images to load in parallel.
	 */
	function setMaxParallelImageRequests(maxParallelImageRequests) {
	    if (maxParallelImageRequests > 0) {
	        azuremapsMaplibreGlUnminified.maxParallelImageRequests = maxParallelImageRequests;
	        hasMaxParallelImageRequests = true;
	    }
	}
	/**
	 * Sets the default language used by the map and service modules unless the
	 * language is explicitly specified when using those parts of the API.
	 * If a Map is initialized with the language explicitly defined and
	 * setLanguage hasn't previously been called it will automatically be called by the Map constructor.
	 * @param language The new default language.
	 */
	function setLanguage(language) {
	    // Find the best fit supported language.
	    defaultLanguage = Localizer.getCode(language);
	    hasSetLanguage = true;
	}
	/**
	 * Sets the default session id used by the map and service modules unless the
	 * session id is explicitly specified when using those parts of the API.
	 * If a Map is initialized with the session ID explicitly defined and
	 * setSessionId hasn't previously been called it will automatically be called by the Map constructor.
	 * @param id The new default session id.
	 */
	function setSessionId(id) {
	    defaultSessionId = id;
	    hasSetSessionId = true;
	}
	/**
	 * Sets your Azure Maps subscription key as the default subscription key in the atlas namespace
	 * which is used by the map control and any modules that make requests to the Azure maps services.
	 * If a Map is initialized with the subscription key explicitly defined and
	 * setSubscriptionKey hasn't previously been called it will automatically be called by the Map constructor.
	 * @param key The new default subscription key.
	 */
	function setSubscriptionKey(key) {
	    defaultAuthOptions.setSubscriptionKey(key);
	    hasSetAuthenticationOptions = true;
	}
	/**
	 * @deprecated use atlas.setView(view: string) instead.
	 */
	function setUserRegion(userRegion) {
	    defaultView = userRegion;
	    hasSetView = true;
	}
	/**
	 * Specifies which set of geopolitically disputed borders and labels are displayed on the map. The View parameter (also referred to as “user region parameter”) is a 2-letter ISO-3166 Country Code that will show the correct maps for that country/region. Country/Regions that are not on the View list or if unspecified will default to the “Unified” View.
	 * Please see the supported [Views]{@link https://aka.ms/AzureMapsLocalizationViews }.
	 * It is your responsibility to determine the location of your users, and then set the View parameter correctly for that location. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the country where maps, images and other data and third party content that You are authorized to access via Azure Maps is made available.
	 * @param view The new default view
	 */
	function setView(view) {
	    defaultView = view;
	    hasSetView = true;
	}
	/**
	 * Adds an image template to the atlas namespace.
	 * @param templateName The name of the template.
	 * @param template The SVG template to add. Supports {color}, {secondaryColor}, {scale}, {text}.
	 * @param override Specifies if it should override existing templates if one with the same name already exists.
	 */
	function addImageTemplate(templateName, template, override) {
	    if (override || !imageTemplates[templateName.toLowerCase()]) {
	        imageTemplates[templateName.toLowerCase()] = template;
	    }
	}
	/**
	 * Retrieves an SVG template by name.
	 * @param templateName The name of the template to retrieve.
	 * @param scale Specifies how much to scale the template. For best results, scale the icon to the maximum size you want to display it on the map, then use the symbol layers icon size option to scale down if needed. This will reduce blurriness due to scaling. Default: 1
	 */
	function getImageTemplate(templateName, scale) {
	    scale = Math.abs(scale || 1);
	    if (typeof templateName === "string" && imageTemplates[templateName.toLowerCase()]) {
	        var template = imageTemplates[templateName.toLowerCase()];
	        // Firefox/Edge don't support calc for inline SVG's. Need to manually calculate this.
	        var pattern = /calc\(([0-9.]+)[px]*\s*\*\s*\{scale\}\)/gi;
	        var t = template;
	        var match = pattern.exec(template);
	        while (match) {
	            t = t.replace(match[0], parseFloat(match[1]) * scale + "");
	            match = pattern.exec(template);
	        }
	        // Just for good measure incase the pattern doesn't match.
	        t = t.replace("{scale}", scale + "");
	        return t;
	    }
	    else {
	        throw new Error("Invalid templateName.");
	    }
	}
	/**
	 * Retrieves an array of names for all image templates that are available in the atlas namespace.
	 */
	function getAllImageTemplateNames() {
	    return Object.keys(imageTemplates);
	}
	/**
	 * Initializes resources like WebWorkers that can be shared across maps to lower load
	 * times in some situations. `atlas.setWorkerCount`, if being
	 * used, must be set before `prewarm()` is called to have an effect.
	 *
	 * By default, the lifecycle of these resources is managed automatically, and they are
	 * lazily initialized when a Map is first created. By invoking `prewarm()`, these
	 * resources will be created ahead of time, and will not be cleared when the last Map
	 * is removed from the page. This allows them to be re-used by new Map instances that
	 * are created later. They can be manually cleared by calling
	 * `atlas.clearPrewarmedResources()`. This is only necessary if your web page remains
	 * active but stops using maps altogether.
	 *
	 * This is primarily useful when using GL-JS maps in a single page app, wherein a user
	 * would navigate between various views that can cause Map instances to constantly be
	 * created and destroyed.
	 */
	function prewarm() {
	    azuremapsMaplibreGlUnminified.prewarm();
	}
	/**
	 * Clears up resources that have previously been created by `atlas.prewarm()`.
	 * Note that this is typically not necessary. You should only call this function
	 * if you expect the user of your app to not return to a Map view at any point
	 * in your application.
	 */
	function clearPrewarmedResources() {
	    azuremapsMaplibreGlUnminified.clearPrewarmedResources();
	}
	/**
	 * Returns if authentication options are set.
	 * @internal
	 */
	function _hasSetAuthenticationOptions() {
	    return hasSetAuthenticationOptions;
	}
	/**
	 * Returns if the default domain has been set yet.
	 * @internal
	 */
	function _hasSetDomain() {
	    return hasSetDomain;
	}
	/**
	 * Returns if the default StyleDefinitionsPath has been set yet.
	 * @internal
	 */
	function _hasSetStyleDefinitionsPath() {
	    return hasSetStyleDefinitionsPath;
	}
	/**
	 * Returns if the default StyleDefinitionsVersion has been set yet.
	 * @internal
	 */
	function _hasSetStyleDefinitionsVersion() {
	    return hasSetStyleDefinitionsVersion;
	}
	/**
	 * Returns if the default workerCount has been set yet.
	 * @internal
	 */
	function _hasWorkerCount() {
	    return hasWorkerCount;
	}
	/**
	 * Returns if the default MaxParallelImageRequests has been set yet.
	 * @internal
	 */
	function _hasMaxParallelImageRequests() {
	    return hasMaxParallelImageRequests;
	}
	/**
	 * Returns is a default language has been set yet.
	 * @internal
	 */
	function _hasSetLanguage() {
	    return hasSetLanguage;
	}
	/**
	 * Returns is a default session id has been set yet.
	 * @internal
	 */
	function _hasSetSessionId() {
	    return hasSetSessionId;
	}
	/**
	 * Returns is a default language has been set yet.
	 * @internal
	 */
	function _hasSetView() {
	    return hasSetView;
	}
	/**
	 * Gets the base domain used for asset retrieval.
	 * @internal
	 */
	function _getAssetDomain() {
	    return env.domain;
	}
	/**
	 * Gets the base domain used for general map services.
	 * @internal
	 */
	// TODO Remove once all internal dependencies of this function are gone.
	function _getDomain() {
	    return getDomain();
	}
	var imageTemplates = {
	    /**********************
	     * Marker templates
	     **********************/
	    // Default built in marker. Supports {color} and {secondaryColor}
	    "marker": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 26 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:1"/><text x="12.5" y="17.5" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 27 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:2"/><text x="12.5" y="18.5" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-circle": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 27 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:1"/><circle cx="12.5" cy="12.5" r="9" fill="{secondaryColor}"/><text x="12" y="17.5" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    // Older pin style. (consider removing, although we could look at removing these icons from sprite and wrapping event that fires when missing icon is needed.)
	    "pin": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(24 * {scale})" height="calc(28 * {scale})" viewBox="0 0 24 28"><path d="m11.988 16.615a5.15 5.15 0 0 1-2.268-.525 4.909 4.909 0 0 1-2.805-4.442 5.019 5.019 0 0 1 5.072-4.936h.012a5.03 5.03 0 0 1 5.085 4.961 4.907 4.907 0 0 1-.549 2.224 5.114 5.114 0 0 1-4.548 2.718zm0-8.06a3.173 3.173 0 0 0-3.226 3.099 3.081 3.081 0 0 0 1.77 2.782 3.299 3.299 0 0 0 4.365-1.386 3.049 3.049 0 0 0 .342-1.381 3.184 3.184 0 0 0-3.239-3.114h-.012z" fill="{secondaryColor}"/><path d="m11.999.922a10.908 10.908 0 0 0-11.076 10.732 10.639 10.639 0 0 0 4.418 8.598l6.658 6.464 6.658-6.463a10.537 10.537 0 0 0 2.198-15.041 11.182 11.182 0 0 0-8.856-4.289zm1.873 14.341a4.221 4.221 0 0 1-5.589-1.789 3.945 3.945 0 0 1-.445-1.8 4.164 4.164 0 0 1 8.323-.037 4.028 4.028 0 0 1-2.289 3.626Z" fill="{color}"/><path d="m11.999 28-7.256-7.044a11.611 11.611 0 0 1-4.743-9.303 11.844 11.844 0 0 1 11.988-11.652.102 .102 0 0 1 .02 0 12.164 12.164 0 0 1 9.577 4.647 11.357 11.357 0 0 1 2.299 8.614 11.521 11.521 0 0 1-4.63 7.695zm-.01-26.157a9.997 9.997 0 0 0-10.143 9.812 9.769 9.769 0 0 0 4.04 7.853l.099.083 6.014 5.838 6.113-5.922a9.7 9.7 0 0 0 3.945-6.505 9.533 9.533 0 0 0-1.933-7.229 10.305 10.305 0 0 0-8.116-3.931h-.021zm.021 14.772a5.11 5.11 0 0 1-4.547-2.718 4.868 4.868 0 0 1 .932-5.743 5.118 5.118 0 0 1 3.58-1.46h.024a5.031 5.031 0 0 1 5.084 4.938 4.92 4.92 0 0 1-2.805 4.457h0a5.152 5.152 0 0 1-2.269.525zm-.011-8.079h-.015a3.277 3.277 0 0 0-2.295.933 3.029 3.029 0 0 0-.587 3.58 3.297 3.297 0 0 0 4.364 1.386h0a3.092 3.092 0 0 0 1.772-2.795 3.185 3.185 0 0 0-3.239-3.105z" fill="{secondaryColor}"/><text x="12" y="17" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    // Older pin-round style. (consider removing, although we could look at removing these icons from sprite and wrapping event that fires when missing icon is needed.)
	    "pin-round": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(25 * {scale})" height="calc(25 * {scale})" viewBox="0 0 25 25"><g transform="translate(0 1)"><circle cx="12.25" cy="11.5833" r="11" fill="{color}"/><path d="m12.25 23.583a12 12 0 1 1 12-12 12 12 0 0 1-12 12zm0-22a10 10 0 1 0 10 10 10 10 0 0 0-10-10z" fill="{secondaryColor}"/><circle cx="12.25" cy="11.5833" r="4.2386" fill="{secondaryColor}"/></g><text x="12.5" y="17" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "marker-flat": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(42.8 * {scale})"  viewBox="0 0 1600 2570"><g fill="{color}"><path d="M691 2419c-409-575-641-1086-683-1504-10-106-10-136 5-224 31-188 105-330 241-458 129-124 270-190 453-214 69-9 113-10 182-1 373 46 655 326 703 698 40 308-120 801-424 1309-134 224-348 535-369 535-4 0-53-63-108-141z"/></g><g fill="rgba(0,0,0,0.15)" style="transform:scale(-1,1);transform-origin:center"><path d="M691 2419c-407-571-639-1083-682-1498-14-139-3-249 37-371 69-208 254-402 459-481 68-27 217-59 271-59h24v160 180 940 635c0 349-2 635-5 635-2 0-49-63-104-141z"/></g><circle cx="800" cy="800" r="600" fill="{secondaryColor}"/><text x="800" y="1100" style="font-size:800px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "marker-arrow": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(25.47 * {scale})" height="calc(35.18 * {scale})" viewBox="0 0 4330 5980"><g fill="{color}"><path d="m2080 5969c-49-20-93-63-115-113-25-55-1928-5486-1953-5573-40-138 67-282 210-283 36 0 246 73 987 345 518 190 947 345 955 345 8 0 438-155 955-345 615-226 954-345 979-345 87 0 165 47 204 123 46 91 107-95-957 2942-537 1535-986 2805-997 2823-11 18-43 46-72 62-41 24-62 30-111 29-33 0-71-5-85-10z"/></g><g fill="{secondaryColor}"><path d="m2200 1600c-36 10-83 2-484-84-243-53-451-94-461-91-11 4-22 18-25 31-5 19 114 371 436 1292 244 697 448 1273 454 1281 19 24 50 30 71 12z"/><path d="m2200 1600c-36 10-83 2-484-84-243-53-451-94-461-91-11 4-22 18-25 31-5 19 114 371 436 1292 244 697 448 1273 454 1281 19 24 50 30 71 12z" style="transform:scale(-1,1);transform-origin:center"/></g><g fill="rgba(0,0,0,0.2)" ><path d="m2165 685c8 0 438-155 955-345 615-226 954-345 979-345 87 0 165 47 204 123 46 91 107-95-957 2942-537 1535-986 2805-997 2823-11 18-43 46-72 62-41 24-62 30-111 29z"/></g><text x="2165" y="3300" style="font-size:2500px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-ball-pin": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15.67 * {scale})" height="calc(33.33 * {scale})" viewBox="0 0 235 452"><g transform="translate(-135 10)"><path fill="{secondaryColor}" d="m256 442 0 0c-13 0-18-11-18-24l-6-323c0-13 11-24 24-24h0c13 0 24 11 24 24l-6 323c0 13-5 24-18 24z"/><circle style="fill:{color};stroke-width:10;stroke:{secondaryColor}" cx="256" cy="112" r="111"/><ellipse transform="matrix(0.834 0.5518 -0.5518 0.834 65.7916 -97.18)" fill="rgba(255,255,255,0.3)" cx="194.399" cy="60.749" rx="19.076" ry="32.428"/></g><text x="117.5" y="160" style="font-size:160px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(26.67 * {scale})" height="calc(32.27 * {scale})" viewBox="0 0 2000 2420"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="M845 2152c-22-37-58-95-80-129-22-35-62-99-90-143l-50-80-312 0-313 0 0-900 0-900 900 0 900 0 0 900 0 900-313 0-313 0-34 58c-19 31-38 59-42 60-5 2-8 8-8 12 0 9-69 123-88 145-5 6-11 15-13 21-16 39-77 123-89 124-8 0-33-31-55-68z"/></g><text x="1000" y="1300" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square-cluster": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(33.33 * {scale})" height="calc(38.8 * {scale})" viewBox="0 0 2500 2910"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="m866 2652c-17-31-37-68-46-82-9-14-32-54-51-90-19-36-50-92-70-125l-36-60-332-3-331-2 0-905 0-905 660 0 660 0 0-38c0-71 50-196 102-258 71-85 189-164 244-164 12 0 26-4 29-10 8-13 222-13 230 0 3 6 17 10 30 10 25 0 117 45 154 76 130 107 191 232 191 392 0 155-63 284-190 386-36 29-129 76-150 76-11 0-22 5-25 10-3 6-31 10-61 10l-54 0 0 660 0 660-332 2-332 3-29 50c-17 28-48 84-70 125-22 41-47 86-56 100-9 14-30 51-46 83-17 32-36 57-45 57-8 0-28-25-44-58z"/></g><text x="1650" y="900" style="font-size:1000px;fill:#fff">+</text><text x="1000" y="1800" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square-rounded": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(26.8 * {scale})" height="calc(32.27 * {scale})" viewBox="0 0 2010 2410"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="M856 2155c-20-30-36-59-36-65 0-5-4-10-10-10-5 0-10-5-10-11 0-5-18-37-40-69-22-32-40-64-40-69 0-6-4-11-10-11-5 0-10-5-10-10 0-6-15-33-32-60l-33-50-127 0c-74 0-129-4-133-10-3-5-17-10-30-10-25 0-116-45-155-76-87-69-142-151-178-265-15-46-17-1075-2-1084 5-3 10-17 10-30 0-13 5-27 10-30 6-3 10-13 10-22 0-22 83-135 122-168 57-46 62-50 112-75l50-25 585 0 586 0 63 34c84 46 169 133 212 218l35 68 0 565 0 565-28 59c-32 69-100 157-139 180-15 9-33 22-40 29-23 22-99 57-123 57-13 0-27 5-30 10-4 6-60 10-135 10l-128 0-128 205c-84 136-133 205-144 205-10 0-33-24-54-55z"/></g><text x="1000" y="1300" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square-rounded-cluster": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(33.33 * {scale})" height="calc(32.13 * {scale})" viewBox="0 0 2500 2900"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="m874 2669c-9-18-26-49-37-68-11-20-30-55-43-78-13-24-36-64-51-90-14-27-38-69-52-95l-26-48-142 0c-84 0-144-4-148-10-3-5-17-10-30-10-25 0-118-46-154-76-91-76-136-142-175-254-13-38-16-119-16-554 0-358 3-520 12-545 40-125 106-219 195-278 127-84 116-83 646-83l467 0 0-42c0-46 11-87 45-163 54-121 169-220 306-264 46-14 232-14 278 0 165 53 284 175 340 350 19 61 14 204-10 273-32 91-94 178-169 240-38 31-130 76-155 76-13 0-27 5-30 10-3 6-28 10-56 10l-49 0 0 462c0 446-1 464-21 522-32 91-94 178-169 240-38 31-130 76-155 76-13 0-27 5-30 10-4 6-65 10-149 10-138 0-143 1-154 23-12 23-62 114-112 202-16 28-44 79-63 115-42 77-67 88-93 39z"/></g><text x="1650" y="900" style="font-size:1000px;fill:#fff">+</text><text x="1000" y="1800" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "flag": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(23.5 * {scale})" height="calc(40 * {scale})" viewBox="34 28 198 308"><path style="stroke:{secondaryColor};stroke-width:15;stroke-linecap:round;" d="M42 327l0 -291"/><path style="fill:{color};stroke:{secondaryColor};stroke-width:10;stroke-linejoin:round;" d="M49 50c70 30 104 28 178 2-21 42-21 74 0 116-72 25-101 25-178 0l0-118z"/><text x="130" y="165" style="font-size:100px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "flag-triangle": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(35.33 * {scale})" viewBox="0 0 40.5 53"><g transform="translate(-31 -20)"><path fill="{secondaryColor}" d="M34.7,73.3V48.4l34.6-10.1c0.7-0.2,1.2-0.8,1.2-1.5s-0.4-1.4-1-1.7L33.7,20.5c-0.5-0.2-1.1-0.2-1.6,0.2 c-0.5,0.3-0.7,0.8-0.7,1.4v51.2H34.7z"/><polygon points="34.7,24.5 66,36.5 34.7,45 34.7,10" fill="{color}"/></g><text x="11" y="21" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "rounded-square": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(34 * {scale})" height="calc(34 * {scale})" viewBox="0 0 34 34"><g transform="translate(2 2)"><rect x="0" y="0" rx="8" ry="8" width="30" height="30" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17" y="22" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "rounded-square-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(38 * {scale})" height="calc(38 * {scale})" viewBox="0 0 38 38"><g transform="translate(4 4)"><rect x="0" y="0" rx="8" ry="8" width="30" height="30" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19" y="24" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(36 * {scale})" height="calc(36 * {scale})" viewBox="0 0 36 36"><g transform="translate(2 2)"><polygon points="16,0 32,32 0,32 16,0" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17.5" y="30" style="font-size:12px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 40 40"><g transform="translate(4 4)"><polygon points="16,0 32,32 0,32 16,0" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19.5" y="32" style="font-size:12px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(35 * {scale})" height="calc(40 * {scale})" viewBox="0 0 35 40"><g transform="translate(2 2)"><path d="M31 9 15.5 0 0 9 0 27 15.5 36 31 27 31 9Z" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17.5" y="25" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(39 * {scale})" height="calc(44 * {scale})" viewBox="0 0 39 44"><g transform="translate(4 4)"><path d="M31 9 15.5 0 0 9 0 27 15.5 36 31 27 31 9Z" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19.5" y="27" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon-rounded": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 1100 1100"><g transform="translate(50 50)"><path style="stroke:{secondaryColor};stroke-width:50;fill:{color}" d="M881 210 561 25c-33-19-88-19-121 0L119 210c-33 19-61 67-61 105v370c0 39 27 86 61 105l321 185c33 19 88 19 122 0l321-185c33-19 61-67 61-105V315C942 276 915 229 881 210z"/></g><text x="550" y="700" style="font-size:400px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon-rounded-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 1200 1200"><g transform="translate(100 100)"><path style="stroke:{secondaryColor};stroke-width:100;fill:{color}" d="M881 210 561 25c-33-19-88-19-121 0L119 210c-33 19-61 67-61 105v370c0 39 27 86 61 105l321 185c33 19 88 19 122 0l321-185c33-19 61-67 61-105V315C942 276 915 229 881 210z"/></g><text x="600" y="750" style="font-size:400px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle-arrow-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(28 * {scale})" viewBox="0 0 28 28"><g transform="translate(2 2)"><polygon points="12,0 0,24 12,17 24,24" stroke-width="2" stroke="{secondaryColor}" fill="{color}"/></g><text x="14" y="17" style="font-size:8px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle-arrow-left": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(28 * {scale})" viewBox="0 0 28 28"><g transform="translate(2 2)"><polygon points="24,12 0,0 7,12 0,24" stroke-width="2" stroke="{secondaryColor}" fill="{color}"/></g><text x="14" y="16.5" style="font-size:8px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "arrow-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(12.16 * {scale})" height="calc(30.1 * {scale})" viewBox="0 0 902 364"><g fill="{color}" transform="matrix(0,2.4,-2.4,0,897,-930)"><polygon points="902,222 233,222 233,364 0,182 233,0 233,141 902,141 902,222"/></g><text x="450" y="700" style="font-size:900px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "arrow-up-thin": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(33.33 * {scale})" viewBox="0 0 12 25"><g transform="translate(-136.91823 -751.91998)"><path fill="{color}" d="m148.271 760.71c-1.641-.547-3.186-1.47-4.633-2.769l0 18.07-1.675 0 0-18.07c-1.447 1.299-2.986 2.222-4.616 2.769l0-1.231c2.325-1.596 4.006-3.812 5.043-6.65l.838 0c1.037 2.838 2.718 5.055 5.043 6.65l0 1.231z"/></g><text x="6" y="20" style="font-size:10px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "car": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(21.93 * {scale})" height="calc(40.9 * {scale})" viewBox="0 0 6580 12270"><g transform="translate(0 12270) rotate(-90)"><path fill="{secondaryColor}" d="M7045 6566c-42-13-105-44-105-51 0-2 23-105 50-228 28-123 50-230 50-236 0-8-241-11-907-11-855 0-1145 6-1513 30-85 6-189 13-230 15-41 3-133 10-205 15-286 21-430 32-705 50-953 63-1459 18-2335-205-304-77-746-209-799-238-131-72-221-408-285-1062-34-345-42-532-48-1130-16-1557 108-2532 336-2649 32-17 469-149 676-205 409-110 819-191 1205-238 116-14 224-18 540-18 395 1 494 5 1140 50 1124 79 1224 82 2496 78l641-3-53-237c-29-131-52-238-51-239 1-1 31-14 66-29 56-23 76-26 142-23 67 3 83 7 120 33 23 17 50 41 61 55 10 14 51 117 91 230l73 205 674 3 675 2 90-39c98-43 198-72 315-93 122-21 829-18 990 5 321 45 626 143 849 270 293 168 516 378 704 662 266 402 416 893 467 1527 15 174 8 882-9 998-6 41-18 127-27 190-69 502-253 969-523 1325-79 105-262 284-381 374-189 142-355 229-574 300-336 110-526 139-952 148-457 9-685-23-887-124l-47-24-678-6-678-6-64 179c-79 224-92 253-121 284-67 70-177 97-274 66zm-2752-5073c-23-2-64-2-90 0-26 2-7 3 42 3 50 0 71-1 48-3zm395 0c-21-2-55-2-75 0-21 2-4 4 37 4 41 0 58-2 38-4z"/><path fill="{color}" d="M7043 6498c-13-6-23-19-23-28 0-9 23-117 50-240 28-123 50-230 50-237 0-22-2126-13-2465 10-132 10-400 28-595 42-661 47-824 55-1160 62-435 7-656-8-1040-73-415-70-865-183-1447-365-168-53-272-556-325-1569-16-319-16-1311 0-1630 45-872 129-1366 257-1518 22-26 51-39 172-77 557-177 1122-310 1563-369 271-36 351-40 690-40 361 1 463 6 1165 54 1122 78 1288 83 2337 79 460-2 840-7 843-11 4-4-17-117-47-252l-55-245 39-16c76-30 180-8 224 47 10 13 54 124 98 246l79 222 709 0 709 0 47-24c74-37 219-83 322-101 122-22 606-32 802-16 374 29 658 102 933 238 124 62 271 155 361 230l61 51 6 100c19 278 103 497 247 643 88 89 173 136 278 152l70 11 41 131c116 369 159 673 168 1170 10 584-38 984-167 1397l-40 126-70 12c-193 33-348 175-441 405-56 139-89 302-89 445 0 43-3 47-58 91-290 235-644 384-1068 450-191 29-796 39-974 16-135-18-263-54-368-102l-75-35-701 0-701 0-79 223c-82 232-102 267-163 293-38 16-138 17-170 2zm-2023-820c332-15 1155-12 1835 6 308 8 563 12 566 8 4-4 10-21 13-38 7-30 6-31-92-77-518-244-1197-396-2112-474-295-25-1282-25-1579 0-231 20-473 46-479 51-6 7 49 110 93 171 160 226 416 335 855 365 142 10 539 5 900-12zm3304-263c525-111 899-887 934-1935 19-557-37-1023-172-1435-186-563-521-900-896-899-81 0-158 14-525 92-426 91-431 92-540 146-195 96-287 207-306 368-12 104-11 2985 1 3078 22 170 135 291 365 389 49 21 191 55 480 115 226 47 419 87 430 89 45 10 164 6 229-8zm-5570-485c112-43 197-156 216-291 12-83 13-2623 1-2706-23-158-125-273-270-304-44-9-100-1-542 75-272 47-514 91-539 98-266 68-487 424-594 958-56 280-70 548-40 800 56 484 207 878 414 1081 115 114 122 116 702 218 277 49 524 90 550 90 26 1 72-8 102-19zm2111-3440c1023-44 1884-213 2462-486l113-53-7-33c-3-18-8-35-10-37-2-3-236 1-521 7-993 24-1271 26-1708 11-541-18-1128-18-1249-1-377 56-588 181-734 437-32 55-41 79-32 84 12 8 246 32 491 51 356 28 815 36 1195 20z"/></g><text x="3250" y="8250" style="font-size:3000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    /**********************
	     * Fill Patterns
	     **********************/
	    "checker": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(16 * {scale})" viewBox="0 0 16 16"><pattern id="p" x="0" y="0" width="16" height="16" patternUnits="userSpaceOnUse"><rect fill="{color}" x="0" width="8" height="8" y="0"/><rect fill="{color}" x="8" width="8" height="8" y="8"/></pattern><rect x="0" y="0" width="16" height="16" fill="{secondaryColor}"/><rect x="0" y="0" width="16" height="16" fill="url(#p)"/></svg>',
	    "checker-rotated": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(16 * {scale})" viewBox="0 0 60 60"><rect width="60" height="60" fill="{secondaryColor}"/><rect width="42.42" height="42.42" transform="translate(30 0) rotate(45)" fill="{color}"/></svg>',
	    "zig-zag": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15 * {scale})" height="calc(15 * {scale})" viewBox="0 0 120 120"><rect x="0" y="0" width="120" height="120" fill="{secondaryColor}"/><polygon fill="{color}" points="120 120 60 120 90 90 120 60 120 0 120 0 60 60 0 0 0 60 30 90 60 120 120 120"/></svg>',
	    "zig-zag-vertical": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15 * {scale})" height="calc(15 * {scale})" viewBox="0 0 120 120"><rect x="0" y="0" width="120" height="120" fill="{secondaryColor}"/><polygon fill="{color}" points="120 0 120 60 90 30 60 0 0 0 0 0 60 60 0 120 60 120 90 90 120 60 120 0"/></svg>',
	    "circles-spaced": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 20 20"><defs><pattern id="p" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="2" stroke="none" fill="{color}"/></pattern></defs><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><rect x="0" y="0" width="100" height="100" fill="url(#p)"/></svg>',
	    "circles": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(7 * {scale})" height="calc(7 * {scale})" viewBox="0 0 20 20"><defs><pattern id="p" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="6" stroke="none" fill="{color}"/></pattern></defs><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><rect x="0" y="0" width="100" height="100" fill="url(#p)"/></svg>',
	    "diagonal-lines-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "diagonal-lines-down": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(90 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "diagonal-stripes-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
	    "diagonal-stripes-down": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g transform="rotate(90 20 20)" fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
	    "grid-lines": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(14 * {scale})" height="calc(14 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(45 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g><g fill="{color}" transform="rotate(-45 3 3)"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "rotated-grid-lines": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(90 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g><g fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "rotated-grid-stripes": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g transform="rotate(90 20 20)" fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g><g fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
	    "x-fill": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="45.3" height="45.3" fill="{secondaryColor}"/><g fill="{color}"><path d="M0 38.59l2.83-2.83 1.41 1.41L1.41 40H0v-1.41zM0 1.4l2.83 2.83 1.41-1.41L1.41 0H0v1.41zM38.59 40l-2.83-2.83 1.41-1.41L40 38.59V40h-1.41zM40 1.41l-2.83 2.83-1.41-1.41L38.59 0H40v1.41zM20 18.6l2.83-2.83 1.41 1.41L21.41 20l2.83 2.83-1.41 1.41L20 21.41l-2.83 2.83-1.41-1.41L18.59 20l-2.83-2.83 1.41-1.41L20 18.59z"/></g></svg>',
	    "dots": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(13 * {scale})" height="calc(13 * {scale})" viewBox="0 0 20 20"><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><g fill="{color}"><circle cx="3" cy="3" r="3"/><circle cx="13" cy="13" r="3"/></g></svg>'
	};

	var Media = /** @class */ (function () {
	    function Media() {
	    }
	    /**
	     * Returns the current high contrast mode based on media queries.
	     * Can return the following values:
	     * - `"light"`: High contrast using black text on white backgrounds
	     * - `"dark"`: High contrast using white text on black backgrounds
	     * - `"invert"`: Inverting colors, often used for high contrast
	     * - `null`: Not in high contrast mode
	     */
	    Media.getHighContrastMode = function () {
	        if (matchMedia("(-ms-high-contrast: white-on-black)").matches) {
	            return "dark";
	        }
	        else if (matchMedia("(-ms-high-contrast: black-on-white)").matches) {
	            return "light";
	        }
	        else if (matchMedia("(-ms-high-contrast: active)").matches) {
	            return "dark"; // Default to dark if we can't detect a specific style
	        }
	        else if (matchMedia("(inverted-colors: inverted)").matches) {
	            return "invert"; // Inverted colors is specific to macOS
	        }
	        // If nothing matches assume high contrast isn't in use
	        return null;
	    };
	    return Media;
	}());

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	/**
	 * The EventsDiscardedReason enumeration contains a set of values that specify the reason for discarding an event.
	 */
	var EventsDiscardedReason = {
	    /**
	     * Unknown.
	     */
	    Unknown: 0,
	    /**
	     * Status set to non-retryable.
	     */
	    NonRetryableStatus: 1,
	    /**
	     * The event is invalid.
	     */
	    InvalidEvent: 2,
	    /**
	     * The size of the event is too large.
	     */
	    SizeLimitExceeded: 3,
	    /**
	     * The server is not accepting events from this instrumentation key.
	     */
	    KillSwitch: 4,
	    /**
	     * The event queue is full.
	     */
	    QueueFull: 5
	};

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	var strShimFunction = "function";
	var strShimObject = "object";
	var strShimUndefined = "undefined";
	var strShimPrototype = "prototype";
	var strShimHasOwnProperty = "hasOwnProperty";
	var ObjClass = Object;
	var ObjProto = ObjClass[strShimPrototype];
	var ObjAssign = ObjClass["assign"];
	var ObjCreate = ObjClass["create"];
	var ObjDefineProperty = ObjClass["defineProperty"];
	var ObjHasOwnProperty = ObjProto[strShimHasOwnProperty];

	// Copyright (c) Microsoft Corporation. All rights reserved.
	/**
	 * Returns the current global scope object, for a normal web page this will be the current
	 * window, for a Web Worker this will be current worker global scope via "self". The internal
	 * implementation returns the first available instance object in the following order
	 * - globalThis (New standard)
	 * - self (Will return the current window instance for supported browsers)
	 * - window (fallback for older browser implementations)
	 * - global (NodeJS standard)
	 * - <null> (When all else fails)
	 * While the return type is a Window for the normal case, not all environments will support all
	 * of the properties or functions.
	 */
	function getGlobal() {
	    if (typeof globalThis !== strShimUndefined && globalThis) {
	        return globalThis;
	    }
	    if (typeof self !== strShimUndefined && self) {
	        return self;
	    }
	    if (typeof window !== strShimUndefined && window) {
	        return window;
	    }
	    if (typeof global !== strShimUndefined && global) {
	        return global;
	    }
	    return null;
	}
	function throwTypeError(message) {
	    throw new TypeError(message);
	}
	/**
	 * Creates an object that has the specified prototype, and that optionally contains specified properties. This helper exists to avoid adding a polyfil
	 * for older browsers that do not define Object.create eg. ES3 only, IE8 just in case any page checks for presence/absence of the prototype implementation.
	 * Note: For consistency this will not use the Object.create implementation if it exists as this would cause a testing requirement to test with and without the implementations
	 * @param obj Object to use as a prototype. May be null
	 */
	function objCreateFn(obj) {
	    var func = ObjCreate;
	    // Use build in Object.create
	    if (func) {
	        // Use Object create method if it exists
	        return func(obj);
	    }
	    if (obj == null) {
	        return {};
	    }
	    var type = typeof obj;
	    if (type !== strShimObject && type !== strShimFunction) {
	        throwTypeError('Object prototype may only be an Object:' + obj);
	    }
	    function tmpFunc() { }
	    tmpFunc[strShimPrototype] = obj;
	    return new tmpFunc();
	}

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Most of these functions have been directly shamelessly "lifted" from the https://github.com/@microsoft/tslib and
	// modified to be ES3 compatible and applying several minification and tree-shaking techniques so that Application Insights
	// can successfully use TypeScript "importHelpers" which imports tslib during compilation but it will use these at runtime
	// Which is also why all of the functions have not been included as Application Insights currently doesn't use or require
	// them.
	var SymbolObj = (getGlobal() || {})["Symbol"];
	var ReflectObj = (getGlobal() || {})["Reflect"];
	var __objAssignFnImpl = function (t) {
	    // tslint:disable-next-line: ban-comma-operator
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) {
	            if (ObjProto[strShimHasOwnProperty].call(s, p)) {
	                t[p] = s[p];
	            }
	        }
	    }
	    return t;
	};
	var __assignFn = ObjAssign || __objAssignFnImpl;
	// tslint:disable-next-line: only-arrow-functions
	var extendStaticsFn = function (d, b) {
	    extendStaticsFn = ObjClass["setPrototypeOf"] ||
	        // tslint:disable-next-line: only-arrow-functions
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        // tslint:disable-next-line: only-arrow-functions
	        function (d, b) {
	            for (var p in b) {
	                if (b[strShimHasOwnProperty](p)) {
	                    d[p] = b[p];
	                }
	            }
	        };
	    return extendStaticsFn(d, b);
	};
	function __extendsFn(d, b) {
	    if (typeof b !== strShimFunction && b !== null) {
	        throwTypeError("Class extends value " + String(b) + " is not a constructor or null");
	    }
	    extendStaticsFn(d, b);
	    function __() { this.constructor = d; }
	    // tslint:disable-next-line: ban-comma-operator
	    d[strShimPrototype] = b === null ? objCreateFn(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
	}

	/*!
	 * Microsoft Dynamic Proto Utility, 1.1.4
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/**
	 * Constant string defined to support minimization
	 * @ignore
	 */
	var Constructor = 'constructor';
	/**
	 * Constant string defined to support minimization
	 * @ignore
	 */
	var Prototype = 'prototype';
	/**
	 * Constant string defined to support minimization
	 * @ignore
	 */
	var strFunction = 'function';
	/**
	 * Used to define the name of the instance function lookup table
	 * @ignore
	 */
	var DynInstFuncTable = '_dynInstFuncs';
	/**
	 * Name used to tag the dynamic prototype function
	 * @ignore
	 */
	var DynProxyTag = '_isDynProxy';
	/**
	 * Name added to a prototype to define the dynamic prototype "class" name used to lookup the function table
	 * @ignore
	 */
	var DynClassName = '_dynClass';
	/**
	 * Prefix added to the classname to avoid any name clashes with other instance level properties
	 * @ignore
	 */
	var DynClassNamePrefix = '_dynCls$';
	/**
	 * A tag which is used to check if we have already to attempted to set the instance function if one is not present
	 * @ignore
	 */
	var DynInstChkTag = '_dynInstChk';
	/**
	 * A tag which is used to check if we are allows to try and set an instance function is one is not present. Using the same
	 * tag name as the function level but a different const name for readability only.
	 */
	var DynAllowInstChkTag = DynInstChkTag;
	/**
	 * The global (imported) instances where the global performance options are stored
	 */
	var DynProtoDefaultOptions = '_dfOpts';
	/**
	 * Value used as the name of a class when it cannot be determined
	 * @ignore
	 */
	var UnknownValue = '_unknown_';
	/**
	 * Constant string defined to support minimization
	 * @ignore
	 */
	var str__Proto = "__proto__";
	/**
	 * Constant string defined to support minimization
	 * @ignore
	 */
	var strUseBaseInst = 'useBaseInst';
	/**
	 * Constant string defined to support minimization
	 * @ignore
	 */
	var strSetInstFuncs = 'setInstFuncs';
	var Obj = Object;
	/**
	 * Pre-lookup to check if we are running on a modern browser (i.e. not IE8)
	 * @ignore
	 */
	var _objGetPrototypeOf = Obj["getPrototypeOf"];
	/**
	 * Internal Global used to generate a unique dynamic class name, every new class will increase this value
	 * @ignore
	 */
	var _dynamicNames = 0;
	/**
	 * Helper to check if the object contains a property of the name
	 * @ignore
	 */
	function _hasOwnProperty(obj, prop) {
	    return obj && Obj[Prototype].hasOwnProperty.call(obj, prop);
	}
	/**
	 * Helper used to check whether the target is an Object prototype or Array prototype
	 * @ignore
	 */
	function _isObjectOrArrayPrototype(target) {
	    return target && (target === Obj[Prototype] || target === Array[Prototype]);
	}
	/**
	 * Helper used to check whether the target is an Object prototype, Array prototype or Function prototype
	 * @ignore
	 */
	function _isObjectArrayOrFunctionPrototype(target) {
	    return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
	}
	/**
	 * Helper used to get the prototype of the target object as getPrototypeOf is not available in an ES3 environment.
	 * @ignore
	 */
	function _getObjProto(target) {
	    if (target) {
	        // This method doesn't existing in older browsers (e.g. IE8)
	        if (_objGetPrototypeOf) {
	            return _objGetPrototypeOf(target);
	        }
	        // target[Constructor] May break if the constructor has been changed or removed
	        var newProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
	        if (newProto) {
	            return newProto;
	        }
	    }
	    return null;
	}
	/**
	 * Helper to get the properties of an object, including none enumerable ones as functions on a prototype in ES6
	 * are not enumerable.
	 * @param target
	 */
	function _forEachProp(target, func) {
	    var props = [];
	    var getOwnProps = Obj["getOwnPropertyNames"];
	    if (getOwnProps) {
	        props = getOwnProps(target);
	    }
	    else {
	        for (var name_1 in target) {
	            if (typeof name_1 === "string" && _hasOwnProperty(target, name_1)) {
	                props.push(name_1);
	            }
	        }
	    }
	    if (props && props.length > 0) {
	        for (var lp = 0; lp < props.length; lp++) {
	            func(props[lp]);
	        }
	    }
	}
	/**
	 * Helper function to check whether the provided function name is a potential candidate for dynamic
	 * callback and prototype generation.
	 * @param target The target object, may be a prototype or class object
	 * @param funcName The function name
	 * @param skipOwn Skips the check for own property
	 * @ignore
	 */
	function _isDynamicCandidate(target, funcName, skipOwn) {
	    return (funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || _hasOwnProperty(target, funcName)));
	}
	/**
	 * Helper to throw a TypeError exception
	 * @param message the message
	 * @ignore
	 */
	function _throwTypeError(message) {
	    throw new TypeError("DynamicProto: " + message);
	}
	/**
	 * Returns a collection of the instance functions that are defined directly on the thisTarget object, it does
	 * not return any inherited functions
	 * @param thisTarget The object to get the instance functions from
	 * @ignore
	 */
	function _getInstanceFuncs(thisTarget) {
	    // Get the base proto
	    var instFuncs = {};
	    // Save any existing instance functions
	    _forEachProp(thisTarget, function (name) {
	        // Don't include any dynamic prototype instances - as we only want the real functions
	        if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {
	            // Create an instance callback for passing the base function to the caller
	            instFuncs[name] = thisTarget[name];
	        }
	    });
	    return instFuncs;
	}
	/**
	 * Returns whether the value is included in the array
	 * @param values The array of values
	 * @param value  The value
	 */
	function _hasVisited(values, value) {
	    for (var lp = values.length - 1; lp >= 0; lp--) {
	        if (values[lp] === value) {
	            return true;
	        }
	    }
	    return false;
	}
	/**
	 * Returns an object that contains callback functions for all "base/super" functions, this is used to "save"
	 * enabling calling super.xxx() functions without requiring that the base "class" has defined a prototype references
	 * @param target The current instance
	 * @ignore
	 */
	function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
	    function _instFuncProxy(target, funcHost, funcName) {
	        var theFunc = funcHost[funcName];
	        if (theFunc[DynProxyTag] && useBaseInst) {
	            // grab and reuse the hosted looking function (if available) otherwise the original passed function
	            var instFuncTable = target[DynInstFuncTable] || {};
	            if (instFuncTable[DynAllowInstChkTag] !== false) {
	                theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;
	            }
	        }
	        return function () {
	            return theFunc.apply(target, arguments);
	        };
	    }
	    // Start creating a new baseFuncs by creating proxies for the instance functions (as they may get replaced)
	    var baseFuncs = {};
	    _forEachProp(instFuncs, function (name) {
	        // Create an instance callback for passing the base function to the caller
	        baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
	    });
	    // Get the base prototype functions
	    var baseProto = _getObjProto(classProto);
	    var visited = [];
	    // Don't include base object functions for Object, Array or Function
	    while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {
	        // look for prototype functions
	        _forEachProp(baseProto, function (name) {
	            // Don't include any dynamic prototype instances - as we only want the real functions
	            // For IE 7/8 the prototype lookup doesn't provide the full chain so we need to bypass the 
	            // hasOwnProperty check we get all of the methods, main difference is that IE7/8 doesn't return
	            // the Object prototype methods while bypassing the check
	            if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {
	                // Create an instance callback for passing the base function to the caller
	                baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);
	            }
	        });
	        // We need to find all possible functions that might be overloaded by walking the entire prototype chain
	        // This avoids the caller from needing to check whether it's direct base class implements the function or not
	        // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.
	        visited.push(baseProto);
	        baseProto = _getObjProto(baseProto);
	    }
	    return baseFuncs;
	}
	function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
	    var instFunc = null;
	    // We need to check whether the class name is defined directly on this prototype otherwise
	    // it will walk the proto chain and return any parent proto classname.
	    if (target && _hasOwnProperty(proto, DynClassName)) {
	        var instFuncTable = target[DynInstFuncTable] || {};
	        instFunc = (instFuncTable[proto[DynClassName]] || {})[funcName];
	        if (!instFunc) {
	            // Avoid stack overflow from recursive calling the same function
	            _throwTypeError("Missing [" + funcName + "] " + strFunction);
	        }
	        // We have the instance function, lets check it we can speed up further calls
	        // by adding the instance function back directly on the instance (avoiding the dynamic func lookup)
	        if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {
	            // If the instance already has an instance function we can't replace it
	            var canAddInst = !_hasOwnProperty(target, funcName);
	            // Get current prototype
	            var objProto = _getObjProto(target);
	            var visited = [];
	            // Lookup the function starting at the top (instance level prototype) and traverse down, if the first matching function
	            // if nothing is found or if the first hit is a dynamic proto instance then we can safely add an instance shortcut
	            while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {
	                var protoFunc = objProto[funcName];
	                if (protoFunc) {
	                    canAddInst = (protoFunc === currentDynProtoProxy);
	                    break;
	                }
	                // We need to find all possible initial functions to ensure that we don't bypass a valid override function
	                visited.push(objProto);
	                objProto = _getObjProto(objProto);
	            }
	            try {
	                if (canAddInst) {
	                    // This instance doesn't have an instance func and the class hierarchy does have a higher level prototype version
	                    // so it's safe to directly assign for any subsequent calls (for better performance)
	                    target[funcName] = instFunc;
	                }
	                // Block further attempts to set the instance function for any
	                instFunc[DynInstChkTag] = 1;
	            }
	            catch (e) {
	                // Don't crash if the object is readonly or the runtime doesn't allow changing this
	                // And set a flag so we don't try again for any function
	                instFuncTable[DynAllowInstChkTag] = false;
	            }
	        }
	    }
	    return instFunc;
	}
	function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
	    var protoFunc = proto[funcName];
	    // Check that the prototype function is not a self reference -- try to avoid stack overflow!
	    if (protoFunc === currentDynProtoProxy) {
	        // It is so lookup the base prototype
	        protoFunc = _getObjProto(proto)[funcName];
	    }
	    if (typeof protoFunc !== strFunction) {
	        _throwTypeError("[" + funcName + "] is not a " + strFunction);
	    }
	    return protoFunc;
	}
	/**
	 * Add the required dynamic prototype methods to the the class prototype
	 * @param proto - The class prototype
	 * @param className - The instance classname
	 * @param target - The target instance
	 * @param baseInstFuncs - The base instance functions
	 * @param setInstanceFunc - Flag to allow prototype function to reset the instance function if one does not exist
	 * @ignore
	 */
	function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
	    function _createDynamicPrototype(proto, funcName) {
	        var dynProtoProxy = function () {
	            // Use the instance or prototype function
	            var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);
	            return instFunc.apply(this, arguments);
	        };
	        // Tag this function as a proxy to support replacing dynamic proxy elements (primary use case is for unit testing
	        // via which can dynamically replace the prototype function reference)
	        dynProtoProxy[DynProxyTag] = 1;
	        return dynProtoProxy;
	    }
	    if (!_isObjectOrArrayPrototype(proto)) {
	        var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || {};
	        var instFuncs_1 = instFuncTable[className] = (instFuncTable[className] || {}); // fetch and assign if as it may not exist yet
	        // Set whether we are allow to lookup instances, if someone has set to false then do not re-enable
	        if (instFuncTable[DynAllowInstChkTag] !== false) {
	            instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;
	        }
	        _forEachProp(target, function (name) {
	            // Only add overridden functions
	            if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {
	                // Save the instance Function to the lookup table and remove it from the instance as it's not a dynamic proto function
	                instFuncs_1[name] = target[name];
	                delete target[name];
	                // Add a dynamic proto if one doesn't exist or if a prototype function exists and it's not a dynamic one
	                if (!_hasOwnProperty(proto, name) || (proto[name] && !proto[name][DynProxyTag])) {
	                    proto[name] = _createDynamicPrototype(proto, name);
	                }
	            }
	        });
	    }
	}
	/**
	 * Checks whether the passed prototype object appears to be correct by walking the prototype hierarchy of the instance
	 * @param classProto The class prototype instance
	 * @param thisTarget The current instance that will be checked whether the passed prototype instance is in the hierarchy
	 * @ignore
	 */
	function _checkPrototype(classProto, thisTarget) {
	    // This method doesn't existing in older browsers (e.g. IE8)
	    if (_objGetPrototypeOf) {
	        // As this is primarily a coding time check, don't bother checking if running in IE8 or lower
	        var visited = [];
	        var thisProto = _getObjProto(thisTarget);
	        while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {
	            if (thisProto === classProto) {
	                return true;
	            }
	            // This avoids the caller from needing to check whether it's direct base class implements the function or not
	            // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.
	            visited.push(thisProto);
	            thisProto = _getObjProto(thisProto);
	        }
	    }
	    return false;
	}
	/**
	 * Gets the current prototype name using the ES6 name if available otherwise falling back to a use unknown as the name.
	 * It's not critical for this to return a name, it's used to decorate the generated unique name for easier debugging only.
	 * @param target
	 * @param unknownValue
	 * @ignore
	 */
	function _getObjName(target, unknownValue) {
	    if (_hasOwnProperty(target, Prototype)) {
	        // Look like a prototype
	        return target.name || unknownValue || UnknownValue;
	    }
	    return (((target || {})[Constructor]) || {}).name || unknownValue || UnknownValue;
	}
	/**
	 * Helper function when creating dynamic (inline) functions for classes, this helper performs the following tasks :-
	 * - Saves references to all defined base class functions
	 * - Calls the delegateFunc with the current target (this) and a base object reference that can be used to call all "super" functions.
	 * - Will populate the class prototype for all overridden functions to support class extension that call the prototype instance.
	 * Callers should use this helper when declaring all function within the constructor of a class, as mentioned above the delegateFunc is
	 * passed both the target "this" and an object that can be used to call any base (super) functions, using this based object in place of
	 * super.XXX() (which gets expanded to _super.prototype.XXX()) provides a better minification outcome and also ensures the correct "this"
	 * context is maintained as TypeScript creates incorrect references using super.XXXX() for dynamically defined functions i.e. Functions
	 * defined in the constructor or some other function (rather than declared as complete typescript functions).
	 * ### Usage
	 * ```typescript
	 * import dynamicProto from "@microsoft/dynamicproto-js";
	 * class ExampleClass extends BaseClass {
	 *     constructor() {
	 *         dynamicProto(ExampleClass, this, (_self, base) => {
	 *             // This will define a function that will be converted to a prototype function
	 *             _self.newFunc = () => {
	 *                 // Access any "this" instance property
	 *                 if (_self.someProperty) {
	 *                     ...
	 *                 }
	 *             }
	 *             // This will define a function that will be converted to a prototype function
	 *             _self.myFunction = () => {
	 *                 // Access any "this" instance property
	 *                 if (_self.someProperty) {
	 *                     // Call the base version of the function that we are overriding
	 *                     base.myFunction();
	 *                 }
	 *                 ...
	 *             }
	 *             _self.initialize = () => {
	 *                 ...
	 *             }
	 *             // Warnings: While the following will work as _self is simply a reference to
	 *             // this, if anyone overrides myFunction() the overridden will be called first
	 *             // as the normal JavaScript method resolution will occur and the defined
	 *             // _self.initialize() function is actually gets removed from the instance and
	 *             // a proxy prototype version is created to reference the created method.
	 *             _self.initialize();
	 *         });
	 *     }
	 * }
	 * ```
	 * @typeparam DPType This is the generic type of the class, used to keep intellisense valid
	 * @typeparam DPCls The type that contains the prototype of the current class
	 * @param theClass - This is the current class instance which contains the prototype for the current class
	 * @param target - The current "this" (target) reference, when the class has been extended this.prototype will not be the 'theClass' value.
	 * @param delegateFunc - The callback function (closure) that will create the dynamic function
	 * @param options - Additional options to configure how the dynamic prototype operates
	 */
	function dynamicProto(theClass, target, delegateFunc, options) {
	    // Make sure that the passed theClass argument looks correct
	    if (!_hasOwnProperty(theClass, Prototype)) {
	        _throwTypeError("theClass is an invalid class definition.");
	    }
	    // Quick check to make sure that the passed theClass argument looks correct (this is a common copy/paste error)
	    var classProto = theClass[Prototype];
	    if (!_checkPrototype(classProto, target)) {
	        _throwTypeError("[" + _getObjName(theClass) + "] is not in class hierarchy of [" + _getObjName(target) + "]");
	    }
	    var className = null;
	    if (_hasOwnProperty(classProto, DynClassName)) {
	        // Only grab the class name if it's defined on this prototype (i.e. don't walk the prototype chain)
	        className = classProto[DynClassName];
	    }
	    else {
	        // As not all browser support name on the prototype creating a unique dynamic one if we have not already
	        // assigned one, so we can use a simple string as the lookup rather than an object for the dynamic instance
	        // function table lookup.
	        className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _dynamicNames;
	        _dynamicNames++;
	        classProto[DynClassName] = className;
	    }
	    var perfOptions = dynamicProto[DynProtoDefaultOptions];
	    var useBaseInst = !!perfOptions[strUseBaseInst];
	    if (useBaseInst && options && options[strUseBaseInst] !== undefined) {
	        useBaseInst = !!options[strUseBaseInst];
	    }
	    // Get the current instance functions
	    var instFuncs = _getInstanceFuncs(target);
	    // Get all of the functions for any base instance (before they are potentially overridden)
	    var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
	    // Execute the delegate passing in both the current target "this" and "base" function references
	    // Note casting the same type as we don't actually have the base class here and this will provide some intellisense support
	    delegateFunc(target, baseFuncs);
	    // Don't allow setting instance functions for older IE instances
	    var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
	    if (setInstanceFunc && options) {
	        setInstanceFunc = !!options[strSetInstFuncs];
	    }
	    // Populate the Prototype for any overridden instance functions
	    _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);
	}
	/**
	 * Exposes the default global options to allow global configuration, if the global values are disabled these will override
	 * any passed values. This is primarily exposed to support unit-testing without the need for individual classes to expose
	 * their internal usage of dynamic proto.
	 */
	var perfDefaults = {
	    setInstFuncs: true,
	    useBaseInst: true
	};
	// And expose for testing
	dynamicProto[DynProtoDefaultOptions] = perfDefaults;

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	var LoggingSeverity;
	(function (LoggingSeverity) {
	    /**
	     * Error will be sent as internal telemetry
	     */
	    LoggingSeverity[LoggingSeverity["CRITICAL"] = 1] = "CRITICAL";
	    /**
	     * Error will NOT be sent as internal telemetry, and will only be shown in browser console
	     */
	    LoggingSeverity[LoggingSeverity["WARNING"] = 2] = "WARNING";
	})(LoggingSeverity || (LoggingSeverity = {}));
	/**
	 * Internal message ID. Please create a new one for every conceptually different message. Please keep alphabetically ordered
	 */
	var _InternalMessageId = {
	    // Non user actionable
	    BrowserDoesNotSupportLocalStorage: 0,
	    BrowserCannotReadLocalStorage: 1,
	    BrowserCannotReadSessionStorage: 2,
	    BrowserCannotWriteLocalStorage: 3,
	    BrowserCannotWriteSessionStorage: 4,
	    BrowserFailedRemovalFromLocalStorage: 5,
	    BrowserFailedRemovalFromSessionStorage: 6,
	    CannotSendEmptyTelemetry: 7,
	    ClientPerformanceMathError: 8,
	    ErrorParsingAISessionCookie: 9,
	    ErrorPVCalc: 10,
	    ExceptionWhileLoggingError: 11,
	    FailedAddingTelemetryToBuffer: 12,
	    FailedMonitorAjaxAbort: 13,
	    FailedMonitorAjaxDur: 14,
	    FailedMonitorAjaxOpen: 15,
	    FailedMonitorAjaxRSC: 16,
	    FailedMonitorAjaxSend: 17,
	    FailedMonitorAjaxGetCorrelationHeader: 18,
	    FailedToAddHandlerForOnBeforeUnload: 19,
	    FailedToSendQueuedTelemetry: 20,
	    FailedToReportDataLoss: 21,
	    FlushFailed: 22,
	    MessageLimitPerPVExceeded: 23,
	    MissingRequiredFieldSpecification: 24,
	    NavigationTimingNotSupported: 25,
	    OnError: 26,
	    SessionRenewalDateIsZero: 27,
	    SenderNotInitialized: 28,
	    StartTrackEventFailed: 29,
	    StopTrackEventFailed: 30,
	    StartTrackFailed: 31,
	    StopTrackFailed: 32,
	    TelemetrySampledAndNotSent: 33,
	    TrackEventFailed: 34,
	    TrackExceptionFailed: 35,
	    TrackMetricFailed: 36,
	    TrackPVFailed: 37,
	    TrackPVFailedCalc: 38,
	    TrackTraceFailed: 39,
	    TransmissionFailed: 40,
	    FailedToSetStorageBuffer: 41,
	    FailedToRestoreStorageBuffer: 42,
	    InvalidBackendResponse: 43,
	    FailedToFixDepricatedValues: 44,
	    InvalidDurationValue: 45,
	    TelemetryEnvelopeInvalid: 46,
	    CreateEnvelopeError: 47,
	    // User actionable
	    CannotSerializeObject: 48,
	    CannotSerializeObjectNonSerializable: 49,
	    CircularReferenceDetected: 50,
	    ClearAuthContextFailed: 51,
	    ExceptionTruncated: 52,
	    IllegalCharsInName: 53,
	    ItemNotInArray: 54,
	    MaxAjaxPerPVExceeded: 55,
	    MessageTruncated: 56,
	    NameTooLong: 57,
	    SampleRateOutOfRange: 58,
	    SetAuthContextFailed: 59,
	    SetAuthContextFailedAccountName: 60,
	    StringValueTooLong: 61,
	    StartCalledMoreThanOnce: 62,
	    StopCalledWithoutStart: 63,
	    TelemetryInitializerFailed: 64,
	    TrackArgumentsNotSpecified: 65,
	    UrlTooLong: 66,
	    SessionStorageBufferFull: 67,
	    CannotAccessCookie: 68,
	    IdTooLong: 69,
	    InvalidEvent: 70,
	    FailedMonitorAjaxSetRequestHeader: 71,
	    SendBrowserInfoOnUserInit: 72,
	    PluginException: 73,
	    NotificationException: 74,
	    SnippetScriptLoadFailure: 99,
	    InvalidInstrumentationKey: 100,
	    CannotParseAiBlobValue: 101,
	    InvalidContentBlob: 102,
	    TrackPageActionEventFailed: 103
	};

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	// RESTRICT and AVOID circular dependencies you should not import other contained modules or export the contents of this file directly
	// Added to help with minfication
	var strOnPrefix = "on";
	var strAttachEvent = "attachEvent";
	var strAddEventHelper = "addEventListener";
	var strDetachEvent = "detachEvent";
	var strRemoveEventListener = "removeEventListener";
	var _objDefineProperty = ObjDefineProperty;
	function objToString(obj) {
	    return ObjProto.toString.call(obj);
	}
	function isUndefined(value) {
	    return value === undefined || typeof value === strShimUndefined;
	}
	function isNullOrUndefined(value) {
	    return (value === null || isUndefined(value));
	}
	function isNotNullOrUndefined(value) {
	    return !isNullOrUndefined(value);
	}
	function hasOwnProperty$d(obj, prop) {
	    return obj && ObjHasOwnProperty.call(obj, prop);
	}
	function isObject$1(value) {
	    // Changing to inline for performance
	    return typeof value === strShimObject;
	}
	function isFunction$1(value) {
	    // Changing to inline for performance
	    return typeof value === strShimFunction;
	}
	/**
	 * Binds the specified function to an event, so that the function gets called whenever the event fires on the object
	 * @param obj Object to add the event too.
	 * @param eventNameWithoutOn String that specifies any of the standard DHTML Events without "on" prefix
	 * @param handlerRef Pointer that specifies the function to call when event fires
	 * @param useCapture [Optional] Defaults to false
	 * @returns True if the function was bound successfully to the event, otherwise false
	 */
	function attachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
	    if (useCapture === void 0) { useCapture = false; }
	    var result = false;
	    if (!isNullOrUndefined(obj)) {
	        try {
	            if (!isNullOrUndefined(obj[strAddEventHelper])) {
	                // all browsers except IE before version 9
	                obj[strAddEventHelper](eventNameWithoutOn, handlerRef, useCapture);
	                result = true;
	            }
	            else if (!isNullOrUndefined(obj[strAttachEvent])) {
	                // IE before version 9                    
	                obj[strAttachEvent](strOnPrefix + eventNameWithoutOn, handlerRef);
	                result = true;
	            }
	        }
	        catch (e) {
	            // Just Ignore any error so that we don't break any execution path
	        }
	    }
	    return result;
	}
	/**
	 * Removes an event handler for the specified event
	 * @param Object to remove the event from
	 * @param eventNameWithoutOn {string} - The name of the event
	 * @param handlerRef {any} - The callback function that needs to be executed for the given event
	 * @param useCapture [Optional] Defaults to false
	 */
	function detachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
	    if (useCapture === void 0) { useCapture = false; }
	    if (!isNullOrUndefined(obj)) {
	        try {
	            if (!isNullOrUndefined(obj[strRemoveEventListener])) {
	                obj[strRemoveEventListener](eventNameWithoutOn, handlerRef, useCapture);
	            }
	            else if (!isNullOrUndefined(obj[strDetachEvent])) {
	                obj[strDetachEvent](strOnPrefix + eventNameWithoutOn, handlerRef);
	            }
	        }
	        catch (e) {
	            // Just Ignore any error so that we don't break any execution path
	        }
	    }
	}
	/**
	 * Validates that the string name conforms to the JS IdentifierName specification and if not
	 * normalizes the name so that it would. This method does not identify or change any keywords
	 * meaning that if you pass in a known keyword the same value will be returned.
	 * This is a simplified version
	 * @param name The name to validate
	 */
	function normalizeJsName(name) {
	    var value = name;
	    var match = /([^\w\d_$])/g;
	    if (match.test(name)) {
	        value = name.replace(match, "_");
	    }
	    return value;
	}
	/**
	 * This is a helper function for the equivalent of arForEach(objKeys(target), callbackFn), this is a
	 * performance optimization to avoid the creation of a new array for large objects
	 * @param target The target object to find and process the keys
	 * @param callbackfn The function to call with the details
	 */
	function objForEachKey(target, callbackfn) {
	    if (target) {
	        for (var prop in target) {
	            if (ObjHasOwnProperty.call(target, prop)) {
	                callbackfn.call(target, prop, target[prop]);
	            }
	        }
	    }
	}
	/**
	 * The strEndsWith() method determines whether a string ends with the characters of a specified string, returning true or false as appropriate.
	 * @param value - The value to check whether it ends with the search value.
	 * @param search - The characters to be searched for at the end of the value.
	 * @returns true if the given search value is found at the end of the string, otherwise false.
	 */
	function strEndsWith(value, search) {
	    if (value && search) {
	        var searchLen = search.length;
	        var valLen = value.length;
	        if (value === search) {
	            return true;
	        }
	        else if (valLen >= searchLen) {
	            var pos = valLen - 1;
	            for (var lp = searchLen - 1; lp >= 0; lp--) {
	                if (value[pos] != search[lp]) {
	                    return false;
	                }
	                pos--;
	            }
	            return true;
	        }
	    }
	    return false;
	}
	/**
	 * A simple wrapper (for minification support) to check if the value contains the search string.
	 * @param value - The string value to check for the existence of the search value
	 * @param search - The value search within the value
	 */
	function strContains(value, search) {
	    if (value && search) {
	        return value.indexOf(search) !== -1;
	    }
	    return false;
	}
	/**
	 * Check if an object is of type Date
	 */
	function isDate(obj) {
	    return objToString(obj) === "[object Date]";
	}
	/**
	 * Check if an object is of type Array
	 */
	function isArray$1(obj) {
	    return objToString(obj) === "[object Array]";
	}
	/**
	 * Check if an object is of type Error
	 */
	function isError(obj) {
	    return objToString(obj) === "[object Error]";
	}
	/**
	 * Checks if the type of value is a string.
	 * @param {any} value - Value to be checked.
	 * @return {boolean} True if the value is a string, false otherwise.
	 */
	function isString(value) {
	    // Changing to inline for performance
	    return typeof value === "string";
	}
	/**
	 * Checks if the type of value is a number.
	 * @param {any} value - Value to be checked.
	 * @return {boolean} True if the value is a number, false otherwise.
	 */
	function isNumber(value) {
	    // Changing to inline for performance
	    return typeof value === "number";
	}
	/**
	 * Convert a date to I.S.O. format in IE8
	 */
	function toISOString(date) {
	    if (isDate(date)) {
	        var pad = function (num) {
	            var r = String(num);
	            if (r.length === 1) {
	                r = "0" + r;
	            }
	            return r;
	        };
	        return date.getUTCFullYear()
	            + "-" + pad(date.getUTCMonth() + 1)
	            + "-" + pad(date.getUTCDate())
	            + "T" + pad(date.getUTCHours())
	            + ":" + pad(date.getUTCMinutes())
	            + ":" + pad(date.getUTCSeconds())
	            + "." + String((date.getUTCMilliseconds() / 1000).toFixed(3)).slice(2, 5)
	            + "Z";
	    }
	}
	/**
	 * Performs the specified action for each element in an array. This helper exists to avoid adding a polyfil for older browsers
	 * that do not define Array.prototype.xxxx (eg. ES3 only, IE8) just in case any page checks for presence/absence of the prototype
	 * implementation. Note: For consistency this will not use the Array.prototype.xxxx implementation if it exists as this would
	 * cause a testing requirement to test with and without the implementations
	 * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array. It can return -1 to break out of the loop
	 * @param thisArg  [Optional] An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
	 */
	function arrForEach(arr, callbackfn, thisArg) {
	    var len = arr.length;
	    for (var idx = 0; idx < len; idx++) {
	        if (idx in arr) {
	            if (callbackfn.call(thisArg || arr, arr[idx], idx, arr) === -1) {
	                break;
	            }
	        }
	    }
	}
	/**
	 * Returns the index of the first occurrence of a value in an array. This helper exists to avoid adding a polyfil for older browsers
	 * that do not define Array.prototype.xxxx (eg. ES3 only, IE8) just in case any page checks for presence/absence of the prototype
	 * implementation. Note: For consistency this will not use the Array.prototype.xxxx implementation if it exists as this would
	 * cause a testing requirement to test with and without the implementations
	 * @param searchElement The value to locate in the array.
	 * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
	 */
	function arrIndexOf(arr, searchElement, fromIndex) {
	    var len = arr.length;
	    var from = fromIndex || 0;
	    for (var lp = Math.max(from >= 0 ? from : len - Math.abs(from), 0); lp < len; lp++) {
	        if (lp in arr && arr[lp] === searchElement) {
	            return lp;
	        }
	    }
	    return -1;
	}
	/**
	 * Calls a defined callback function on each element of an array, and returns an array that contains the results. This helper exists
	 * to avoid adding a polyfil for older browsers that do not define Array.prototype.xxxx (eg. ES3 only, IE8) just in case any page
	 * checks for presence/absence of the prototype implementation. Note: For consistency this will not use the Array.prototype.xxxx
	 * implementation if it exists as this would cause a testing requirement to test with and without the implementations
	 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
	 * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
	 */
	function arrMap(arr, callbackfn, thisArg) {
	    var len = arr.length;
	    var _this = thisArg || arr;
	    var results = new Array(len);
	    for (var lp = 0; lp < len; lp++) {
	        if (lp in arr) {
	            results[lp] = callbackfn.call(_this, arr[lp], arr);
	        }
	    }
	    return results;
	}
	/**
	 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is
	 * provided as an argument in the next call to the callback function. This helper exists to avoid adding a polyfil for older browsers that do not define
	 * Array.prototype.xxxx (eg. ES3 only, IE8) just in case any page checks for presence/absence of the prototype implementation. Note: For consistency
	 * this will not use the Array.prototype.xxxx implementation if it exists as this would cause a testing requirement to test with and without the implementations
	 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
	 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
	 */
	function arrReduce(arr, callbackfn, initialValue) {
	    var len = arr.length;
	    var lp = 0;
	    var value;
	    // Specifically checking the number of passed arguments as the value could be anything
	    if (arguments.length >= 3) {
	        value = arguments[2];
	    }
	    else {
	        while (lp < len && !(lp in arr)) {
	            lp++;
	        }
	        value = arr[lp++];
	    }
	    while (lp < len) {
	        if (lp in arr) {
	            value = callbackfn(value, arr[lp], lp, arr);
	        }
	        lp++;
	    }
	    return value;
	}
	/**
	 * helper method to trim strings (IE8 does not implement String.prototype.trim)
	 */
	function strTrim(str) {
	    if (typeof str !== "string") {
	        return str;
	    }
	    return str.replace(/^\s+|\s+$/g, "");
	}
	var _objKeysHasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString');
	var _objKeysDontEnums = [
	    'toString',
	    'toLocaleString',
	    'valueOf',
	    'hasOwnProperty',
	    'isPrototypeOf',
	    'propertyIsEnumerable',
	    'constructor'
	];
	/**
	 * Returns the names of the enumerable string properties and methods of an object. This helper exists to avoid adding a polyfil for older browsers
	 * that do not define Object.keys eg. ES3 only, IE8 just in case any page checks for presence/absence of the prototype implementation.
	 * Note: For consistency this will not use the Object.keys implementation if it exists as this would cause a testing requirement to test with and without the implementations
	 * @param obj Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.
	 */
	function objKeys(obj) {
	    var objType = typeof obj;
	    if (objType !== strShimFunction && (objType !== strShimObject || obj === null)) {
	        throwTypeError('objKeys called on non-object');
	    }
	    var result = [];
	    for (var prop in obj) {
	        if (obj && ObjHasOwnProperty.call(obj, prop)) {
	            result.push(prop);
	        }
	    }
	    if (_objKeysHasDontEnumBug) {
	        var dontEnumsLength = _objKeysDontEnums.length;
	        for (var lp = 0; lp < dontEnumsLength; lp++) {
	            if (obj && ObjHasOwnProperty.call(obj, _objKeysDontEnums[lp])) {
	                result.push(_objKeysDontEnums[lp]);
	            }
	        }
	    }
	    return result;
	}
	/**
	 * Try to define get/set object property accessors for the target object/prototype, this will provide compatibility with
	 * existing API definition when run within an ES5+ container that supports accessors but still enable the code to be loaded
	 * and executed in an ES3 container, providing basic IE8 compatibility.
	 * @param target The object on which to define the property.
	 * @param prop The name of the property to be defined or modified.
	 * @param getProp The getter function to wire against the getter.
	 * @param setProp The setter function to wire against the setter.
	 * @returns True if it was able to create the accessors otherwise false
	 */
	function objDefineAccessors(target, prop, getProp, setProp) {
	    if (_objDefineProperty) {
	        try {
	            var descriptor = {
	                enumerable: true,
	                configurable: true
	            };
	            if (getProp) {
	                descriptor.get = getProp;
	            }
	            if (setProp) {
	                descriptor.set = setProp;
	            }
	            _objDefineProperty(target, prop, descriptor);
	            return true;
	        }
	        catch (e) {
	            // IE8 Defines a defineProperty on Object but it's only supported for DOM elements so it will throw
	            // We will just ignore this here.
	        }
	    }
	    return false;
	}
	/**
	 * Return the current time via the Date now() function (if available) and falls back to (new Date()).getTime() if now() is unavailable (IE8 or less)
	 * https://caniuse.com/#search=Date.now
	 */
	function dateNow() {
	    var dt = Date;
	    if (dt.now) {
	        return dt.now();
	    }
	    return new dt().getTime();
	}
	/**
	 * Returns the name of object if it's an Error. Otherwise, returns empty string.
	 */
	function getExceptionName(object) {
	    if (isError(object)) {
	        return object.name;
	    }
	    return "";
	}
	/**
	 * Sets the provided value on the target instance using the field name when the provided chk function returns true, the chk
	 * function will only be called if the new value is no equal to the original value.
	 * @param target - The target object
	 * @param field - The key of the target
	 * @param value - The value to set
	 * @param valChk - [Optional] Callback to check the value that if supplied will be called check if the new value can be set
	 * @param srcChk - [Optional] Callback to check to original value that if supplied will be called if the new value should be set (if allowed)
	 * @returns The existing or new value, depending what was set
	 */
	function setValue(target, field, value, valChk, srcChk) {
	    var theValue = value;
	    if (target) {
	        theValue = target[field];
	        if (theValue !== value && (!srcChk || srcChk(theValue)) && (!valChk || valChk(value))) {
	            theValue = value;
	            target[field] = theValue;
	        }
	    }
	    return theValue;
	}
	/**
	 * Returns the current value from the target object if not null or undefined otherwise sets the new value and returns it
	 * @param target - The target object to return or set the default value
	 * @param field - The key for the field to set on the target
	 * @param defValue - [Optional] The value to set if not already present, when not provided a empty object will be added
	 */
	function getSetValue(target, field, defValue) {
	    var theValue;
	    if (target) {
	        theValue = target[field];
	        if (!theValue && isNullOrUndefined(theValue)) {
	            // Supports having the default as null
	            theValue = !isUndefined(defValue) ? defValue : {};
	            target[field] = theValue;
	        }
	    }
	    else {
	        // Expanded for performance so we only check defValue if required
	        theValue = !isUndefined(defValue) ? defValue : {};
	    }
	    return theValue;
	}
	function isNotTruthy(value) {
	    return !value;
	}
	function isTruthy(value) {
	    return !!value;
	}
	function throwError(message) {
	    throw new Error(message);
	}
	/**
	 * Effectively assigns all enumerable properties (not just own properties) and functions (including inherited prototype) from
	 * the source object to the target, it attempts to use proxy getters / setters (if possible) and proxy functions to avoid potential
	 * implementation issues by assigning prototype functions as instance ones
	 *
	 * This method is the primary method used to "update" the snippet proxy with the ultimate implementations.
	 *
	 * Special ES3 Notes:
	 * Updates (setting) of direct property values on the target or indirectly on the source object WILL NOT WORK PROPERLY, updates to the
	 * properties of "referenced" object will work (target.context.newValue = 10 => will be reflected in the source.context as it's the
	 * same object). ES3 Failures: assigning target.myProp = 3 -> Won't change source.myProp = 3, likewise the reverse would also fail.
	 * @param target - The target object to be assigned with the source properties and functions
	 * @param source - The source object which will be assigned / called by setting / calling the targets proxies
	 * @param chkSet - An optional callback to determine whether a specific property/function should be proxied
	 * @memberof Initialization
	 */
	function proxyAssign(target, source, chkSet) {
	    if (target && source && target !== source && isObject$1(target) && isObject$1(source)) {
	        var _loop_1 = function (field) {
	            if (isString(field)) {
	                var value = source[field];
	                if (isFunction$1(value)) {
	                    if (!chkSet || chkSet(field, true, source, target)) {
	                        // Create a proxy function rather than just copying the (possible) prototype to the new object as an instance function
	                        target[field] = (function (funcName) {
	                            return function () {
	                                // Capture the original arguments passed to the method
	                                var originalArguments = arguments;
	                                return source[funcName].apply(source, originalArguments);
	                            };
	                        })(field);
	                    }
	                }
	                else if (!chkSet || chkSet(field, false, source, target)) {
	                    if (hasOwnProperty$d(target, field)) {
	                        // Remove any previous instance property
	                        delete target[field];
	                    }
	                    if (!objDefineAccessors(target, field, function () {
	                        return source[field];
	                    }, function (theValue) {
	                        source[field] = theValue;
	                    })) {
	                        // Unable to create an accessor, so just assign the values as a fallback
	                        // -- this will (mostly) work for objects
	                        // -- but will fail for accessing primitives (if the source changes it) and all types of "setters" as the source won't be modified
	                        target[field] = value;
	                    }
	                }
	            }
	        };
	        // effectively apply/proxy full source to the target instance
	        for (var field in source) {
	            _loop_1(field);
	        }
	    }
	    return target;
	}
	/**
	 * Simpler helper to create a dynamic class that implements the interface and populates the values with the defaults.
	 * Only instance properties (hasOwnProperty) values are copied from the defaults to the new instance
	 * @param defaults Simple helper
	 */
	function createClassFromInterface(defaults) {
	    return /** @class */ (function () {
	        function class_1() {
	            var _this = this;
	            if (defaults) {
	                objForEachKey(defaults, function (field, value) {
	                    _this[field] = value;
	                });
	            }
	        }
	        return class_1;
	    }());
	}
	/**
	 * A helper function to assist with JIT performance for objects that have properties added / removed dynamically
	 * this is primarily for chromium based browsers and has limited effects on Firefox and none of IE. Only call this
	 * function after you have finished "updating" the object, calling this within loops reduces or defeats the benefits.
	 * This helps when iterating using for..in, objKeys() and objForEach()
	 * @param theObject - The object to be optimized if possible
	 */
	function optimizeObject(theObject) {
	    // V8 Optimization to cause the JIT compiler to create a new optimized object for looking up the own properties
	    // primarily for object with <= 19 properties for >= 20 the effect is reduced or non-existent
	    if (theObject) {
	        theObject = ObjClass(ObjAssign ? ObjAssign({}, theObject) : theObject);
	    }
	    return theObject;
	}

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/**
	 * This file exists to hold environment utilities that are required to check and
	 * validate the current operating environment. Unless otherwise required, please
	 * only defined methods (functions) in this class so that users of these
	 * functions/properties only need to include those that are used within their own modules.
	 */
	var strWindow = "window";
	var strDocument = "document";
	var strNavigator = "navigator";
	var strHistory = "history";
	var strLocation = "location";
	var strConsole = "console";
	var strPerformance = "performance";
	var strJSON = "JSON";
	var strCrypto = "crypto";
	var strMsCrypto = "msCrypto";
	var strReactNative = "ReactNative";
	var strMsie = "msie";
	var strTrident = "trident/";
	var _isTrident = null;
	var _navUserAgentCheck = null;
	var _enableMocks = false;
	/**
	 * Return the named global object if available, will return null if the object is not available.
	 * @param name The globally named object
	 */
	function getGlobalInst(name) {
	    var gbl = getGlobal();
	    if (gbl && gbl[name]) {
	        return gbl[name];
	    }
	    // Test workaround, for environments where <global>.window (when global == window) doesn't return the base window
	    if (name === strWindow && hasWindow()) {
	        // tslint:disable-next-line: no-angle-bracket-type-assertion
	        return window;
	    }
	    return null;
	}
	/**
	 * Checks if window object is available, this is required as we support the API running without a
	 * window /document (eg. Node server, electron webworkers) and if we attempt to assign a window
	 * object to a local variable or pass as an argument an "Uncaught ReferenceError: window is not defined"
	 * exception will be thrown.
	 * Defined as a function to support lazy / late binding environments.
	 */
	function hasWindow() {
	    return Boolean(typeof window === strShimObject && window);
	}
	/**
	 * Returns the global window object if it is present otherwise null.
	 * This helper is used to access the window object without causing an exception
	 * "Uncaught ReferenceError: window is not defined"
	 */
	function getWindow() {
	    if (hasWindow()) {
	        return window;
	    }
	    // Return the global instance or null
	    return getGlobalInst(strWindow);
	}
	/**
	 * Checks if document object is available, this is required as we support the API running without a
	 * window /document (eg. Node server, electron webworkers) and if we attempt to assign a document
	 * object to a local variable or pass as an argument an "Uncaught ReferenceError: document is not defined"
	 * exception will be thrown.
	 * Defined as a function to support lazy / late binding environments.
	 */
	function hasDocument() {
	    return Boolean(typeof document === strShimObject && document);
	}
	/**
	 * Returns the global document object if it is present otherwise null.
	 * This helper is used to access the document object without causing an exception
	 * "Uncaught ReferenceError: document is not defined"
	 */
	function getDocument() {
	    if (hasDocument()) {
	        return document;
	    }
	    return getGlobalInst(strDocument);
	}
	/**
	 * Checks if navigator object is available, this is required as we support the API running without a
	 * window /document (eg. Node server, electron webworkers) and if we attempt to assign a navigator
	 * object to a local variable or pass as an argument an "Uncaught ReferenceError: navigator is not defined"
	 * exception will be thrown.
	 * Defined as a function to support lazy / late binding environments.
	 */
	function hasNavigator() {
	    return Boolean(typeof navigator === strShimObject && navigator);
	}
	/**
	 * Returns the global navigator object if it is present otherwise null.
	 * This helper is used to access the navigator object without causing an exception
	 * "Uncaught ReferenceError: navigator is not defined"
	 */
	function getNavigator() {
	    if (hasNavigator()) {
	        return navigator;
	    }
	    return getGlobalInst(strNavigator);
	}
	/**
	 * Checks if history object is available, this is required as we support the API running without a
	 * window /document (eg. Node server, electron webworkers) and if we attempt to assign a history
	 * object to a local variable or pass as an argument an "Uncaught ReferenceError: history is not defined"
	 * exception will be thrown.
	 * Defined as a function to support lazy / late binding environments.
	 */
	function hasHistory() {
	    return Boolean(typeof history === strShimObject && history);
	}
	/**
	 * Returns the global history object if it is present otherwise null.
	 * This helper is used to access the history object without causing an exception
	 * "Uncaught ReferenceError: history is not defined"
	 */
	function getHistory() {
	    if (hasHistory()) {
	        return history;
	    }
	    return getGlobalInst(strHistory);
	}
	/**
	 * Returns the global location object if it is present otherwise null.
	 * This helper is used to access the location object without causing an exception
	 * "Uncaught ReferenceError: location is not defined"
	 */
	function getLocation(checkForMock) {
	    if (checkForMock && _enableMocks) {
	        var mockLocation = getGlobalInst("__mockLocation");
	        if (mockLocation) {
	            return mockLocation;
	        }
	    }
	    if (typeof location === strShimObject && location) {
	        return location;
	    }
	    return getGlobalInst(strLocation);
	}
	/**
	 * Returns the global console object
	 */
	function getConsole() {
	    if (typeof console !== strShimUndefined) {
	        return console;
	    }
	    return getGlobalInst(strConsole);
	}
	/**
	 * Returns the performance object if it is present otherwise null.
	 * This helper is used to access the performance object from the current
	 * global instance which could be window or globalThis for a web worker
	 */
	function getPerformance() {
	    return getGlobalInst(strPerformance);
	}
	/**
	 * Checks if JSON object is available, this is required as we support the API running without a
	 * window /document (eg. Node server, electron webworkers) and if we attempt to assign a history
	 * object to a local variable or pass as an argument an "Uncaught ReferenceError: JSON is not defined"
	 * exception will be thrown.
	 * Defined as a function to support lazy / late binding environments.
	 */
	function hasJSON() {
	    return Boolean((typeof JSON === strShimObject && JSON) || getGlobalInst(strJSON) !== null);
	}
	/**
	 * Returns the global JSON object if it is present otherwise null.
	 * This helper is used to access the JSON object without causing an exception
	 * "Uncaught ReferenceError: JSON is not defined"
	 */
	function getJSON() {
	    if (hasJSON()) {
	        return JSON || getGlobalInst(strJSON);
	    }
	    return null;
	}
	/**
	 * Returns the crypto object if it is present otherwise null.
	 * This helper is used to access the crypto object from the current
	 * global instance which could be window or globalThis for a web worker
	 */
	function getCrypto() {
	    return getGlobalInst(strCrypto);
	}
	/**
	 * Returns the crypto object if it is present otherwise null.
	 * This helper is used to access the crypto object from the current
	 * global instance which could be window or globalThis for a web worker
	 */
	function getMsCrypto() {
	    return getGlobalInst(strMsCrypto);
	}
	/**
	 * Returns whether the environment is reporting that we are running in a React Native Environment
	 */
	function isReactNative() {
	    // If running in React Native, navigator.product will be populated
	    var nav = getNavigator();
	    if (nav && nav.product) {
	        return nav.product === strReactNative;
	    }
	    return false;
	}
	/**
	 * Identifies whether the current environment appears to be IE
	 */
	function isIE() {
	    var nav = getNavigator();
	    if (nav && (nav.userAgent !== _navUserAgentCheck || _isTrident === null)) {
	        // Added to support test mocking of the user agent
	        _navUserAgentCheck = nav.userAgent;
	        var userAgent = (_navUserAgentCheck || "").toLowerCase();
	        _isTrident = (strContains(userAgent, strMsie) || strContains(userAgent, strTrident));
	    }
	    return _isTrident;
	}
	/**
	 * Gets IE version returning the document emulation mode if we are running on IE, or null otherwise
	 */
	function getIEVersion(userAgentStr) {
	    if (userAgentStr === void 0) { userAgentStr = null; }
	    if (!userAgentStr) {
	        var navigator_1 = getNavigator() || {};
	        userAgentStr = navigator_1 ? (navigator_1.userAgent || "").toLowerCase() : "";
	    }
	    var ua = (userAgentStr || "").toLowerCase();
	    if (strContains(ua, strMsie)) {
	        return parseInt(ua.split(strMsie)[1]);
	    }
	    else if (strContains(ua, strTrident)) {
	        var tridentVer = parseInt(ua.split(strTrident)[1]);
	        if (tridentVer) {
	            return tridentVer + 4;
	        }
	    }
	    return null;
	}
	/**
	 * Returns string representation of an object suitable for diagnostics logging.
	 */
	function dumpObj(object) {
	    var objectTypeDump = Object[strShimPrototype].toString.call(object);
	    var propertyValueDump = "";
	    if (objectTypeDump === "[object Error]") {
	        propertyValueDump = "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object.name + "'";
	    }
	    else if (hasJSON()) {
	        propertyValueDump = getJSON().stringify(object);
	    }
	    return objectTypeDump + propertyValueDump;
	}

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/**
	 * For user non actionable traces use AI Internal prefix.
	 */
	var AiNonUserActionablePrefix = "AI (Internal): ";
	/**
	 * Prefix of the traces in portal.
	 */
	var AiUserActionablePrefix = "AI: ";
	/**
	 *  Session storage key for the prefix for the key indicating message type already logged
	 */
	var AIInternalMessagePrefix = "AITR_";
	function _sanitizeDiagnosticText(text) {
	    if (text) {
	        return "\"" + text.replace(/\"/g, "") + "\"";
	    }
	    return "";
	}
	var _InternalLogMessage = /** @class */ (function () {
	    function _InternalLogMessage(msgId, msg, isUserAct, properties) {
	        if (isUserAct === void 0) { isUserAct = false; }
	        var _self = this;
	        _self.messageId = msgId;
	        _self.message =
	            (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) +
	                msgId;
	        var strProps = "";
	        if (hasJSON()) {
	            strProps = getJSON().stringify(properties);
	        }
	        var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : "") +
	            (properties ? " props:" + _sanitizeDiagnosticText(strProps) : "");
	        _self.message += diagnosticText;
	    }
	    _InternalLogMessage.dataType = "MessageData";
	    return _InternalLogMessage;
	}());
	function safeGetLogger(core, config) {
	    return (core || {}).logger || new DiagnosticLogger(config);
	}
	var DiagnosticLogger = /** @class */ (function () {
	    function DiagnosticLogger(config) {
	        this.identifier = 'DiagnosticLogger';
	        /**
	         * The internal logging queue
	         */
	        this.queue = [];
	        /**
	         * Count of internal messages sent
	         */
	        var _messageCount = 0;
	        /**
	         * Holds information about what message types were already logged to console or sent to server.
	         */
	        var _messageLogged = {};
	        dynamicProto(DiagnosticLogger, this, function (_self) {
	            if (isNullOrUndefined(config)) {
	                config = {};
	            }
	            _self.consoleLoggingLevel = function () { return _getConfigValue('loggingLevelConsole', 0); };
	            _self.telemetryLoggingLevel = function () { return _getConfigValue('loggingLevelTelemetry', 1); };
	            _self.maxInternalMessageLimit = function () { return _getConfigValue('maxMessageLimit', 25); };
	            _self.enableDebugExceptions = function () { return _getConfigValue('enableDebugExceptions', false); };
	            /**
	             * This method will throw exceptions in debug mode or attempt to log the error as a console warning.
	             * @param severity {LoggingSeverity} - The severity of the log message
	             * @param message {_InternalLogMessage} - The log message.
	             */
	            _self.throwInternal = function (severity, msgId, msg, properties, isUserAct) {
	                if (isUserAct === void 0) { isUserAct = false; }
	                var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
	                if (_self.enableDebugExceptions()) {
	                    throw message;
	                }
	                else {
	                    if (!isUndefined(message.message)) {
	                        var logLevel = _self.consoleLoggingLevel();
	                        if (isUserAct) {
	                            // check if this message type was already logged to console for this page view and if so, don't log it again
	                            var messageKey = +message.messageId;
	                            if (!_messageLogged[messageKey] && logLevel >= LoggingSeverity.WARNING) {
	                                _self.warnToConsole(message.message);
	                                _messageLogged[messageKey] = true;
	                            }
	                        }
	                        else {
	                            // don't log internal AI traces in the console, unless the verbose logging is enabled
	                            if (logLevel >= LoggingSeverity.WARNING) {
	                                _self.warnToConsole(message.message);
	                            }
	                        }
	                        _self.logInternalMessage(severity, message);
	                    }
	                }
	            };
	            /**
	             * This will write a warning to the console if possible
	             * @param message {string} - The warning message
	             */
	            _self.warnToConsole = function (message) {
	                var theConsole = getConsole();
	                if (!!theConsole) {
	                    var logFunc = 'log';
	                    if (theConsole.warn) {
	                        logFunc = 'warn';
	                    }
	                    if (isFunction$1(theConsole[logFunc])) {
	                        theConsole[logFunc](message);
	                    }
	                }
	            };
	            /**
	             * Resets the internal message count
	             */
	            _self.resetInternalMessageCount = function () {
	                _messageCount = 0;
	                _messageLogged = {};
	            };
	            /**
	             * Logs a message to the internal queue.
	             * @param severity {LoggingSeverity} - The severity of the log message
	             * @param message {_InternalLogMessage} - The message to log.
	             */
	            _self.logInternalMessage = function (severity, message) {
	                if (_areInternalMessagesThrottled()) {
	                    return;
	                }
	                // check if this message type was already logged for this session and if so, don't log it again
	                var logMessage = true;
	                var messageKey = AIInternalMessagePrefix + message.messageId;
	                // if the session storage is not available, limit to only one message type per page view
	                if (_messageLogged[messageKey]) {
	                    logMessage = false;
	                }
	                else {
	                    _messageLogged[messageKey] = true;
	                }
	                if (logMessage) {
	                    // Push the event in the internal queue
	                    if (severity <= _self.telemetryLoggingLevel()) {
	                        _self.queue.push(message);
	                        _messageCount++;
	                    }
	                    // When throttle limit reached, send a special event
	                    if (_messageCount === _self.maxInternalMessageLimit()) {
	                        var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.";
	                        var throttleMessage = new _InternalLogMessage(_InternalMessageId.MessageLimitPerPVExceeded, throttleLimitMessage, false);
	                        _self.queue.push(throttleMessage);
	                        _self.warnToConsole(throttleLimitMessage);
	                    }
	                }
	            };
	            function _getConfigValue(name, defValue) {
	                var value = config[name];
	                if (!isNullOrUndefined(value)) {
	                    return value;
	                }
	                return defValue;
	            }
	            function _areInternalMessagesThrottled() {
	                return _messageCount >= _self.maxInternalMessageLimit();
	            }
	        });
	    }
	// Removed Stub for DiagnosticLogger.prototype.enableDebugExceptions.
	// Removed Stub for DiagnosticLogger.prototype.consoleLoggingLevel.
	// Removed Stub for DiagnosticLogger.prototype.telemetryLoggingLevel.
	// Removed Stub for DiagnosticLogger.prototype.maxInternalMessageLimit.
	// Removed Stub for DiagnosticLogger.prototype.throwInternal.
	// Removed Stub for DiagnosticLogger.prototype.warnToConsole.
	// Removed Stub for DiagnosticLogger.prototype.resetInternalMessageCount.
	// Removed Stub for DiagnosticLogger.prototype.logInternalMessage.
	    return DiagnosticLogger;
	}());

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var strExecutionContextKey = "ctx";
	var PerfEvent = /** @class */ (function () {
	    function PerfEvent(name, payloadDetails, isAsync) {
	        var _self = this;
	        var accessorDefined = false;
	        _self.start = dateNow();
	        _self.name = name;
	        _self.isAsync = isAsync;
	        _self.isChildEvt = function () { return false; };
	        if (isFunction$1(payloadDetails)) {
	            // Create an accessor to minimize the potential performance impact of executing the payloadDetails callback
	            var theDetails_1;
	            accessorDefined = objDefineAccessors(_self, 'payload', function () {
	                // Delay the execution of the payloadDetails until needed
	                if (!theDetails_1 && isFunction$1(payloadDetails)) {
	                    theDetails_1 = payloadDetails();
	                    // clear it out now so the referenced objects can be garbage collected
	                    payloadDetails = null;
	                }
	                return theDetails_1;
	            });
	        }
	        _self.getCtx = function (key) {
	            if (key) {
	                // The parent and child links are located directly on the object (for better viewing in the DebugPlugin)
	                if (key === PerfEvent.ParentContextKey || key === PerfEvent.ChildrenContextKey) {
	                    return _self[key];
	                }
	                return (_self[strExecutionContextKey] || {})[key];
	            }
	            return null;
	        };
	        _self.setCtx = function (key, value) {
	            if (key) {
	                // Put the parent and child links directly on the object (for better viewing in the DebugPlugin)
	                if (key === PerfEvent.ParentContextKey) {
	                    // Simple assumption, if we are setting a parent then we must be a child
	                    if (!_self[key]) {
	                        _self.isChildEvt = function () { return true; };
	                    }
	                    _self[key] = value;
	                }
	                else if (key === PerfEvent.ChildrenContextKey) {
	                    _self[key] = value;
	                }
	                else {
	                    var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
	                    ctx[key] = value;
	                }
	            }
	        };
	        _self.complete = function () {
	            var childTime = 0;
	            var childEvts = _self.getCtx(PerfEvent.ChildrenContextKey);
	            if (isArray$1(childEvts)) {
	                for (var lp = 0; lp < childEvts.length; lp++) {
	                    var childEvt = childEvts[lp];
	                    if (childEvt) {
	                        childTime += childEvt.time;
	                    }
	                }
	            }
	            _self.time = dateNow() - _self.start;
	            _self.exTime = _self.time - childTime;
	            _self.complete = function () { };
	            if (!accessorDefined && isFunction$1(payloadDetails)) {
	                // If we couldn't define the property set during complete -- to minimize the perf impact until after the time
	                _self.payload = payloadDetails();
	            }
	        };
	    }
	    PerfEvent.ParentContextKey = "parent";
	    PerfEvent.ChildrenContextKey = "childEvts";
	    return PerfEvent;
	}());
	var PerfManager = /** @class */ (function () {
	    function PerfManager(manager) {
	        /**
	         * General bucket used for execution context set and retrieved via setCtx() and getCtx.
	         * Defined as private so it can be visualized via the DebugPlugin
	         */
	        this.ctx = {};
	        dynamicProto(PerfManager, this, function (_self) {
	            _self.create = function (src, payloadDetails, isAsync) {
	                // TODO (@MSNev): at some point we will want to add additional configuration to "select" which events to instrument
	                // for now this is just a simple do everything.
	                return new PerfEvent(src, payloadDetails, isAsync);
	            };
	            _self.fire = function (perfEvent) {
	                if (perfEvent) {
	                    perfEvent.complete();
	                    if (manager) {
	                        manager.perfEvent(perfEvent);
	                    }
	                }
	            };
	            _self.setCtx = function (key, value) {
	                if (key) {
	                    var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
	                    ctx[key] = value;
	                }
	            };
	            _self.getCtx = function (key) {
	                return (_self[strExecutionContextKey] || {})[key];
	            };
	        });
	    }
	// Removed Stub for PerfManager.prototype.create.
	// Removed Stub for PerfManager.prototype.fire.
	// Removed Stub for PerfManager.prototype.setCtx.
	// Removed Stub for PerfManager.prototype.getCtx.
	    return PerfManager;
	}());
	var doPerfActiveKey = "CoreUtils.doPerf";
	/**
	 * Helper function to wrap a function with a perf event
	 * @param mgrSource - The Performance Manager or a Performance provider source (may be null)
	 * @param getSource - The callback to create the source name for the event (if perf monitoring is enabled)
	 * @param func - The function to call and measure
	 * @param details - A function to return the payload details
	 * @param isAsync - Is the event / function being call asynchronously or synchronously
	 */
	function doPerf(mgrSource, getSource, func, details, isAsync) {
	    if (mgrSource) {
	        var perfMgr = mgrSource;
	        if (isFunction$1(perfMgr["getPerfMgr"])) {
	            // Looks like a perf manager provider object
	            perfMgr = perfMgr["getPerfMgr"]();
	        }
	        if (perfMgr) {
	            var perfEvt = void 0;
	            var currentActive = perfMgr.getCtx(doPerfActiveKey);
	            try {
	                perfEvt = perfMgr.create(getSource(), details, isAsync);
	                if (perfEvt) {
	                    if (currentActive && perfEvt.setCtx) {
	                        perfEvt.setCtx(PerfEvent.ParentContextKey, currentActive);
	                        if (currentActive.getCtx && currentActive.setCtx) {
	                            var children = currentActive.getCtx(PerfEvent.ChildrenContextKey);
	                            if (!children) {
	                                children = [];
	                                currentActive.setCtx(PerfEvent.ChildrenContextKey, children);
	                            }
	                            children.push(perfEvt);
	                        }
	                    }
	                    // Set this event as the active event now
	                    perfMgr.setCtx(doPerfActiveKey, perfEvt);
	                    return func(perfEvt);
	                }
	            }
	            catch (ex) {
	                if (perfEvt && perfEvt.setCtx) {
	                    perfEvt.setCtx("exception", ex);
	                }
	            }
	            finally {
	                // fire the perf event
	                if (perfEvt) {
	                    perfMgr.fire(perfEvt);
	                }
	                // Reset the active event to the previous value
	                perfMgr.setCtx(doPerfActiveKey, currentActive);
	            }
	        }
	    }
	    return func();
	}

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var TelemetryPluginChain = /** @class */ (function () {
	    function TelemetryPluginChain(plugin, defItemCtx) {
	        var _self = this;
	        var _nextProxy = null;
	        var _hasProcessTelemetry = isFunction$1(plugin.processTelemetry);
	        var _hasSetNext = isFunction$1(plugin.setNextPlugin);
	        _self._hasRun = false;
	        _self.getPlugin = function () {
	            return plugin;
	        };
	        _self.getNext = function () {
	            return _nextProxy;
	        };
	        _self.setNext = function (nextPlugin) {
	            _nextProxy = nextPlugin;
	        };
	        _self.processTelemetry = function (env, itemCtx) {
	            if (!itemCtx) {
	                // Looks like a plugin didn't pass the (optional) context, so restore to the default
	                itemCtx = defItemCtx;
	            }
	            var identifier = plugin ? plugin.identifier : "TelemetryPluginChain";
	            doPerf(itemCtx ? itemCtx.core() : null, function () { return identifier + ":processTelemetry"; }, function () {
	                if (plugin && _hasProcessTelemetry) {
	                    _self._hasRun = true;
	                    try {
	                        // Ensure that we keep the context in sync (for processNext()), just in case a plugin
	                        // doesn't calls processTelemetry() instead of itemContext.processNext() or some 
	                        // other form of error occurred
	                        itemCtx.setNext(_nextProxy);
	                        if (_hasSetNext) {
	                            // Backward compatibility setting the next plugin on the instance
	                            plugin.setNextPlugin(_nextProxy);
	                        }
	                        // Set a flag on the next plugin so we know if it was attempted to be executed
	                        _nextProxy && (_nextProxy._hasRun = false);
	                        plugin.processTelemetry(env, itemCtx);
	                    }
	                    catch (error) {
	                        var hasRun = _nextProxy && _nextProxy._hasRun;
	                        if (!_nextProxy || !hasRun) {
	                            // Either we have no next plugin or the current one did not attempt to call the next plugin
	                            // Which means the current one is the root of the failure so log/report this failure
	                            itemCtx.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.PluginException, "Plugin [" + plugin.identifier + "] failed during processTelemetry - " + error);
	                        }
	                        if (_nextProxy && !hasRun) {
	                            // As part of the failure the current plugin did not attempt to call the next plugin in the cahin
	                            // So rather than leave the pipeline dead in the water we call the next plugin
	                            _nextProxy.processTelemetry(env, itemCtx);
	                        }
	                    }
	                }
	                else if (_nextProxy) {
	                    _self._hasRun = true;
	                    // The underlying plugin is either not defined or does not have a processTelemetry implementation
	                    // so we still want the next plugin to be executed.
	                    _nextProxy.processTelemetry(env, itemCtx);
	                }
	            }, function () { return ({ item: env }); }, !(env.sync));
	        };
	    }
	    return TelemetryPluginChain;
	}());

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/**
	 * Creates the instance execution chain for the plugins
	 */
	function _createProxyChain(plugins, itemCtx) {
	    var proxies = [];
	    if (plugins && plugins.length > 0) {
	        // Create the proxies and wire up the next plugin chain
	        var lastProxy = null;
	        for (var idx = 0; idx < plugins.length; idx++) {
	            var thePlugin = plugins[idx];
	            if (thePlugin && isFunction$1(thePlugin.processTelemetry)) {
	                // Only add plugins that are processors
	                var newProxy = new TelemetryPluginChain(thePlugin, itemCtx);
	                proxies.push(newProxy);
	                if (lastProxy) {
	                    // Set this new proxy as the next for the previous one
	                    lastProxy.setNext(newProxy);
	                }
	                lastProxy = newProxy;
	            }
	        }
	    }
	    return proxies.length > 0 ? proxies[0] : null;
	}
	function _copyProxyChain(proxy, itemCtx, startAt) {
	    var plugins = [];
	    var add = startAt ? false : true;
	    if (proxy) {
	        while (proxy) {
	            var thePlugin = proxy.getPlugin();
	            if (add || thePlugin === startAt) {
	                add = true;
	                plugins.push(thePlugin);
	            }
	            proxy = proxy.getNext();
	        }
	    }
	    if (!add) {
	        plugins.push(startAt);
	    }
	    return _createProxyChain(plugins, itemCtx);
	}
	function _copyPluginChain(srcPlugins, itemCtx, startAt) {
	    var plugins = srcPlugins;
	    var add = false;
	    if (startAt && srcPlugins) {
	        plugins = [];
	        arrForEach(srcPlugins, function (thePlugin) {
	            if (add || thePlugin === startAt) {
	                add = true;
	                plugins.push(thePlugin);
	            }
	        });
	    }
	    if (startAt && !add) {
	        if (!plugins) {
	            plugins = [];
	        }
	        plugins.push(startAt);
	    }
	    return _createProxyChain(plugins, itemCtx);
	}
	var ProcessTelemetryContext = /** @class */ (function () {
	    /**
	     * Creates a new Telemetry Item context with the current config, core and plugin execution chain
	     * @param plugins - The plugin instances that will be executed
	     * @param config - The current config
	     * @param core - The current core instance
	     */
	    function ProcessTelemetryContext(plugins, config, core, startAt) {
	        var _self = this;
	        var _nextProxy = null; // Null == No next plugin
	        // There is no next element (null) vs not defined (undefined)
	        if (startAt !== null) {
	            if (plugins && isFunction$1(plugins.getPlugin)) {
	                // We have a proxy chain object
	                _nextProxy = _copyProxyChain(plugins, _self, startAt || plugins.getPlugin());
	            }
	            else {
	                // We just have an array
	                if (startAt) {
	                    _nextProxy = _copyPluginChain(plugins, _self, startAt);
	                }
	                else if (isUndefined(startAt)) {
	                    // Undefined means copy the existing chain
	                    _nextProxy = _createProxyChain(plugins, _self);
	                }
	            }
	        }
	        _self.core = function () {
	            return core;
	        };
	        _self.diagLog = function () {
	            return safeGetLogger(core, config);
	        };
	        _self.getCfg = function () {
	            return config;
	        };
	        _self.getExtCfg = function (identifier, defaultValue) {
	            if (defaultValue === void 0) { defaultValue = {}; }
	            var theConfig;
	            if (config) {
	                var extConfig = config.extensionConfig;
	                if (extConfig && identifier) {
	                    theConfig = extConfig[identifier];
	                }
	            }
	            return (theConfig ? theConfig : defaultValue);
	        };
	        _self.getConfig = function (identifier, field, defaultValue) {
	            if (defaultValue === void 0) { defaultValue = false; }
	            var theValue;
	            var extConfig = _self.getExtCfg(identifier, null);
	            if (extConfig && !isNullOrUndefined(extConfig[field])) {
	                theValue = extConfig[field];
	            }
	            else if (config && !isNullOrUndefined(config[field])) {
	                theValue = config[field];
	            }
	            return !isNullOrUndefined(theValue) ? theValue : defaultValue;
	        };
	        _self.hasNext = function () {
	            return _nextProxy != null;
	        };
	        _self.getNext = function () {
	            return _nextProxy;
	        };
	        _self.setNext = function (nextPlugin) {
	            _nextProxy = nextPlugin;
	        };
	        _self.processNext = function (env) {
	            var nextPlugin = _nextProxy;
	            if (nextPlugin) {
	                // Automatically move to the next plugin
	                _nextProxy = nextPlugin.getNext();
	                nextPlugin.processTelemetry(env, _self);
	            }
	        };
	        _self.createNew = function (plugins, startAt) {
	            if (plugins === void 0) { plugins = null; }
	            return new ProcessTelemetryContext(plugins || _nextProxy, config, core, startAt);
	        };
	    }
	    return ProcessTelemetryContext;
	}());

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	var strIKey = "iKey";
	var strExtensionConfig = "extensionConfig";

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var strGetPlugin = "getPlugin";
	/**
	 * BaseTelemetryPlugin provides a basic implementation of the ITelemetryPlugin interface so that plugins
	 * can avoid implementation the same set of boiler plate code as well as provide a base
	 * implementation so that new default implementations can be added without breaking all plugins.
	 */
	var BaseTelemetryPlugin = /** @class */ (function () {
	    function BaseTelemetryPlugin() {
	        var _self = this;
	        var _isinitialized = false;
	        var _rootCtx = null; // Used as the root context, holding the current config and initialized core
	        var _nextPlugin = null; // Used for backward compatibility where plugins don't call the main pipeline
	        _self.core = null;
	        _self.diagLog = function (itemCtx) {
	            return _self._getTelCtx(itemCtx).diagLog();
	        };
	        _self.isInitialized = function () {
	            return _isinitialized;
	        };
	        _self.setInitialized = function (isInitialized) {
	            _isinitialized = isInitialized;
	        };
	        // _self.getNextPlugin = () => DO NOT IMPLEMENT
	        // Sub-classes of this base class *should* not be relying on this value and instead
	        // should use processNext() function. If you require access to the plugin use the
	        // IProcessTelemetryContext.getNext().getPlugin() while in the pipeline, Note getNext() may return null.
	        _self.setNextPlugin = function (next) {
	            _nextPlugin = next;
	        };
	        _self.processNext = function (env, itemCtx) {
	            if (itemCtx) {
	                // Normal core execution sequence
	                itemCtx.processNext(env);
	            }
	            else if (_nextPlugin && isFunction$1(_nextPlugin.processTelemetry)) {
	                // Looks like backward compatibility or out of band processing. And as it looks 
	                // like a ITelemetryPlugin or ITelemetryPluginChain, just call processTelemetry
	                _nextPlugin.processTelemetry(env, null);
	            }
	        };
	        _self._getTelCtx = function (currentCtx) {
	            if (currentCtx === void 0) { currentCtx = null; }
	            var itemCtx = currentCtx;
	            if (!itemCtx) {
	                var rootCtx = _rootCtx || new ProcessTelemetryContext(null, {}, _self.core);
	                // tslint:disable-next-line: prefer-conditional-expression
	                if (_nextPlugin && _nextPlugin[strGetPlugin]) {
	                    // Looks like a chain object
	                    itemCtx = rootCtx.createNew(null, _nextPlugin[strGetPlugin]);
	                }
	                else {
	                    itemCtx = rootCtx.createNew(null, _nextPlugin);
	                }
	            }
	            return itemCtx;
	        };
	        _self._baseTelInit = function (config, core, extensions, pluginChain) {
	            if (config) {
	                // Make sure the extensionConfig exists
	                setValue(config, strExtensionConfig, [], null, isNullOrUndefined);
	            }
	            if (!pluginChain && core) {
	                // Get the first plugin from the core
	                pluginChain = core.getProcessTelContext().getNext();
	            }
	            var nextPlugin = _nextPlugin;
	            if (_nextPlugin && _nextPlugin[strGetPlugin]) {
	                // If it looks like a proxy/chain then get the plugin
	                nextPlugin = _nextPlugin[strGetPlugin]();
	            }
	            // Support legacy plugins where core was defined as a property
	            _self.core = core;
	            _rootCtx = new ProcessTelemetryContext(pluginChain, config, core, nextPlugin);
	            _isinitialized = true;
	        };
	    }
	    BaseTelemetryPlugin.prototype.initialize = function (config, core, extensions, pluginChain) {
	        this._baseTelInit(config, core, extensions, pluginChain);
	    };
	    return BaseTelemetryPlugin;
	}());

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var processTelemetry = "processTelemetry";
	var priority = "priority";
	var setNextPlugin = "setNextPlugin";
	var isInitialized = "isInitialized";
	/**
	 * Initialize the queue of plugins
	 * @param plugins - The array of plugins to initialize and setting of the next plugin
	 * @param config The current config for the instance
	 * @param core THe current core instance
	 * @param extensions The extensions
	 */
	function initializePlugins(processContext, extensions) {
	    // Set the next plugin and identified the uninitialized plugins
	    var initPlugins = [];
	    var lastPlugin = null;
	    var proxy = processContext.getNext();
	    while (proxy) {
	        var thePlugin = proxy.getPlugin();
	        if (thePlugin) {
	            if (lastPlugin &&
	                isFunction$1(lastPlugin[setNextPlugin]) &&
	                isFunction$1(thePlugin[processTelemetry])) {
	                // Set this plugin as the next for the previous one
	                lastPlugin[setNextPlugin](thePlugin);
	            }
	            if (!isFunction$1(thePlugin[isInitialized]) || !thePlugin[isInitialized]()) {
	                initPlugins.push(thePlugin);
	            }
	            lastPlugin = thePlugin;
	            proxy = proxy.getNext();
	        }
	    }
	    // Now initiatilize the plugins
	    arrForEach(initPlugins, function (thePlugin) {
	        thePlugin.initialize(processContext.getCfg(), processContext.core(), extensions, processContext.getNext());
	    });
	}
	function sortPlugins(plugins) {
	    // Sort by priority
	    return plugins.sort(function (extA, extB) {
	        var result = 0;
	        var bHasProcess = isFunction$1(extB[processTelemetry]);
	        if (isFunction$1(extA[processTelemetry])) {
	            result = bHasProcess ? extA[priority] - extB[priority] : 1;
	        }
	        else if (bHasProcess) {
	            result = -1;
	        }
	        return result;
	    });
	    // sort complete    
	}

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var ChannelControllerPriority = 500;
	var ChannelValidationMessage = "Channel has invalid priority";
	var ChannelController = /** @class */ (function (_super) {
	    __extendsFn(ChannelController, _super);
	    function ChannelController() {
	        var _this = _super.call(this) || this;
	        _this.identifier = "ChannelControllerPlugin";
	        _this.priority = ChannelControllerPriority; // in reserved range 100 to 200
	        var _channelQueue;
	        dynamicProto(ChannelController, _this, function (_self, _base) {
	            _self.setNextPlugin = function (next) {
	                // The Channel controller is last in pipeline
	            };
	            _self.processTelemetry = function (item, itemCtx) {
	                if (_channelQueue) {
	                    arrForEach(_channelQueue, function (queues) {
	                        // pass on to first item in queue
	                        if (queues.length > 0) {
	                            // Copying the item context as we could have mutiple chains that are executing asynchronously
	                            // and calling _getDefTelCtx as it's possible that the caller doesn't pass any context
	                            var chainCtx = _this._getTelCtx(itemCtx).createNew(queues);
	                            chainCtx.processNext(item);
	                        }
	                    });
	                }
	            };
	            _self.getChannelControls = function () {
	                return _channelQueue;
	            };
	            _self.initialize = function (config, core, extensions) {
	                if (_self.isInitialized()) {
	                    // already initialized
	                    return;
	                }
	                _base.initialize(config, core, extensions);
	                _createChannelQueues((config || {}).channels, extensions);
	                // Initialize the Queues
	                arrForEach(_channelQueue, function (queue) { return initializePlugins(new ProcessTelemetryContext(queue, config, core), extensions); });
	            };
	        });
	        function _checkQueuePriority(queue) {
	            arrForEach(queue, function (queueItem) {
	                if (queueItem.priority < ChannelControllerPriority) {
	                    throwError(ChannelValidationMessage + queueItem.identifier);
	                }
	            });
	        }
	        function _addChannelQueue(queue) {
	            if (queue && queue.length > 0) {
	                queue = queue.sort(function (a, b) {
	                    return a.priority - b.priority;
	                });
	                _checkQueuePriority(queue);
	                _channelQueue.push(queue);
	            }
	        }
	        function _createChannelQueues(channels, extensions) {
	            _channelQueue = [];
	            if (channels) {
	                // Add and sort the configuration channel queues
	                arrForEach(channels, function (queue) { return _addChannelQueue(queue); });
	            }
	            if (extensions) {
	                // Create a new channel queue for any extensions with a priority > the ChannelControllerPriority
	                var extensionQueue_1 = [];
	                arrForEach(extensions, function (plugin) {
	                    if (plugin.priority > ChannelControllerPriority) {
	                        extensionQueue_1.push(plugin);
	                    }
	                });
	                _addChannelQueue(extensionQueue_1);
	            }
	        }
	        return _this;
	    }
	// Removed Stub for ChannelController.prototype.getChannelControls.
	// Removed Stub for ChannelController.prototype.initialize.
	    /**
	     * Static constructor, attempt to create accessors
	     */
	    // tslint:disable-next-line
	    ChannelController._staticInit = (function () {
	        var proto = ChannelController.prototype;
	        // Dynamically create get/set property accessors
	        objDefineAccessors(proto, "ChannelControls", proto.getChannelControls);
	        objDefineAccessors(proto, "channelQueue", proto.getChannelControls);
	    })();
	    return ChannelController;
	}(BaseTelemetryPlugin));

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var strToGMTString = "toGMTString";
	var strToUTCString = "toUTCString";
	var strCookie = "cookie";
	var strExpires = "expires";
	var strEnabled = "enabled";
	var strIsCookieUseDisabled = "isCookieUseDisabled";
	var strDisableCookiesUsage = "disableCookiesUsage";
	var strConfigCookieMgr = "_ckMgr";
	var strEmpty = "";
	var _supportsCookies = null;
	var _allowUaSameSite = null;
	var _parsedCookieValue = null;
	var _doc = getDocument();
	var _cookieCache = {};
	var _globalCookieConfig = {};
	/**
	 * @ignore
	 * DO NOT USE or export from the module, this is exposed as public to support backward compatibility of previous static utility methods only.
	 * If you want to manager cookies either use the ICookieMgr available from the core instance via getCookieMgr() or create
	 * your own instance of the CookieMgr and use that.
	 * Using this directly for enabling / disabling cookie handling will not only affect your usage but EVERY user of cookies.
	 * Example, if you are using a shared component that is also using Application Insights you will affect their cookie handling.
	 * @param logger - The DiagnosticLogger to use for reporting errors.
	 */
	function _gblCookieMgr(config, logger) {
	    // Stash the global instance against the BaseCookieMgr class
	    var inst = createCookieMgr[strConfigCookieMgr] || _globalCookieConfig[strConfigCookieMgr];
	    if (!inst) {
	        // Note: not using the getSetValue() helper as that would require always creating a temporary cookieMgr
	        // that ultimately is never used
	        inst = createCookieMgr[strConfigCookieMgr] = createCookieMgr(config, logger);
	        _globalCookieConfig[strConfigCookieMgr] = inst;
	    }
	    return inst;
	}
	function _isMgrEnabled(cookieMgr) {
	    if (cookieMgr) {
	        return cookieMgr.isEnabled();
	    }
	    return true;
	}
	function _createCookieMgrConfig(rootConfig) {
	    var cookieMgrCfg = rootConfig.cookieCfg = rootConfig.cookieCfg || {};
	    // Sets the values from the root config if not already present on the cookieMgrCfg
	    setValue(cookieMgrCfg, "domain", rootConfig.cookieDomain, isNotNullOrUndefined, isNullOrUndefined);
	    setValue(cookieMgrCfg, "path", rootConfig.cookiePath || "/", null, isNullOrUndefined);
	    if (isNullOrUndefined(cookieMgrCfg[strEnabled])) {
	        // Set the enabled from the provided setting or the legacy root values
	        var cookieEnabled = void 0;
	        if (!isUndefined(rootConfig[strIsCookieUseDisabled])) {
	            cookieEnabled = !rootConfig[strIsCookieUseDisabled];
	        }
	        if (!isUndefined(rootConfig[strDisableCookiesUsage])) {
	            cookieEnabled = !rootConfig[strDisableCookiesUsage];
	        }
	        cookieMgrCfg[strEnabled] = cookieEnabled;
	    }
	    return cookieMgrCfg;
	}
	/**
	 * Helper to return the ICookieMgr from the core (if not null/undefined) or a default implementation
	 * associated with the configuration or a legacy default.
	 * @param core
	 * @param config
	 * @returns
	 */
	function safeGetCookieMgr(core, config) {
	    var cookieMgr;
	    if (core) {
	        // Always returns an instance
	        cookieMgr = core.getCookieMgr();
	    }
	    else if (config) {
	        var cookieCfg = config.cookieCfg;
	        if (cookieCfg[strConfigCookieMgr]) {
	            cookieMgr = cookieCfg[strConfigCookieMgr];
	        }
	        else {
	            cookieMgr = createCookieMgr(config);
	        }
	    }
	    if (!cookieMgr) {
	        // Get or initialize the default global (legacy) cookie manager if we couldn't find one
	        cookieMgr = _gblCookieMgr(config, (core || {}).logger);
	    }
	    return cookieMgr;
	}
	function createCookieMgr(rootConfig, logger) {
	    var cookieMgrConfig = _createCookieMgrConfig(rootConfig || _globalCookieConfig);
	    var _path = cookieMgrConfig.path || "/";
	    var _domain = cookieMgrConfig.domain;
	    // Explicitly checking against false, so that setting to undefined will === true
	    var _enabled = cookieMgrConfig[strEnabled] !== false;
	    var cookieMgr = {
	        isEnabled: function () {
	            var enabled = _enabled && areCookiesSupported(logger);
	            // Using an indirect lookup for any global cookie manager to support tree shaking for SDK's
	            // that don't use the "applicationinsights-core" version of the default cookie function
	            var gblManager = _globalCookieConfig[strConfigCookieMgr];
	            if (enabled && gblManager && cookieMgr !== gblManager) {
	                // Make sure the GlobalCookie Manager instance (if not this instance) is also enabled.
	                // As the global (deprecated) functions may have been called (for backward compatibility)
	                enabled = _isMgrEnabled(gblManager);
	            }
	            return enabled;
	        },
	        setEnabled: function (value) {
	            // Explicitly checking against false, so that setting to undefined will === true
	            _enabled = value !== false;
	        },
	        set: function (name, value, maxAgeSec, domain, path) {
	            if (_isMgrEnabled(cookieMgr)) {
	                var values = {};
	                var theValue = strTrim(value || strEmpty);
	                var idx = theValue.indexOf(";");
	                if (idx !== -1) {
	                    theValue = strTrim(value.substring(0, idx));
	                    values = _extractParts(value.substring(idx + 1));
	                }
	                // Only update domain if not already present (isUndefined) and the value is truthy (not null, undefined or empty string)
	                setValue(values, "domain", domain || _domain, isTruthy, isUndefined);
	                if (!isNullOrUndefined(maxAgeSec)) {
	                    var _isIE = isIE();
	                    if (isUndefined(values[strExpires])) {
	                        var nowMs = dateNow();
	                        // Only add expires if not already present
	                        var expireMs = nowMs + (maxAgeSec * 1000);
	                        // Sanity check, if zero or -ve then ignore
	                        if (expireMs > 0) {
	                            var expiry = new Date();
	                            expiry.setTime(expireMs);
	                            setValue(values, strExpires, _formatDate(expiry, !_isIE ? strToUTCString : strToGMTString) || _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || strEmpty, isTruthy);
	                        }
	                    }
	                    if (!_isIE) {
	                        // Only replace if not already present
	                        setValue(values, "max-age", strEmpty + maxAgeSec, null, isUndefined);
	                    }
	                }
	                var location_1 = getLocation();
	                if (location_1 && location_1.protocol === "https:") {
	                    setValue(values, "secure", null, null, isUndefined);
	                    // Only set same site if not also secure
	                    if (_allowUaSameSite === null) {
	                        _allowUaSameSite = !uaDisallowsSameSiteNone((getNavigator() || {}).userAgent);
	                    }
	                    if (_allowUaSameSite) {
	                        setValue(values, "SameSite", "None", null, isUndefined);
	                    }
	                }
	                setValue(values, "path", path || _path, null, isUndefined);
	                var setCookieFn = cookieMgrConfig.setCookie || _setCookieValue;
	                setCookieFn(name, _formatCookieValue(theValue, values));
	            }
	        },
	        get: function (name) {
	            var value = strEmpty;
	            if (_isMgrEnabled(cookieMgr)) {
	                value = (cookieMgrConfig.getCookie || _getCookieValue)(name);
	            }
	            return value;
	        },
	        del: function (name, path) {
	            if (_isMgrEnabled(cookieMgr)) {
	                // Only remove the cookie if the manager and cookie support has not been disabled
	                cookieMgr.purge(name, path);
	            }
	        },
	        purge: function (name, path) {
	            if (areCookiesSupported(logger)) {
	                // Setting the expiration date in the past immediately removes the cookie
	                var values = (_a = {},
	                    _a["path"] = path ? path : "/",
	                    _a[strExpires] = "Thu, 01 Jan 1970 00:00:01 GMT",
	                    _a);
	                if (!isIE()) {
	                    // Set max age to expire now
	                    values["max-age"] = "0";
	                }
	                var delCookie = cookieMgrConfig.delCookie || _setCookieValue;
	                delCookie(name, _formatCookieValue(strEmpty, values));
	            }
	            var _a;
	        }
	    };
	    // Associated this cookie manager with the config
	    cookieMgr[strConfigCookieMgr] = cookieMgr;
	    return cookieMgr;
	}
	/*
	* Helper method to tell if document.cookie object is supported by the runtime
	*/
	function areCookiesSupported(logger) {
	    if (_supportsCookies === null) {
	        _supportsCookies = false;
	        try {
	            var doc = _doc || {};
	            _supportsCookies = doc[strCookie] !== undefined;
	        }
	        catch (e) {
	            logger && logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.CannotAccessCookie, "Cannot access document.cookie - " + getExceptionName(e), { exception: dumpObj(e) });
	        }
	    }
	    return _supportsCookies;
	}
	function _extractParts(theValue) {
	    var values = {};
	    if (theValue && theValue.length) {
	        var parts = strTrim(theValue).split(";");
	        arrForEach(parts, function (thePart) {
	            thePart = strTrim(thePart || strEmpty);
	            if (thePart) {
	                var idx = thePart.indexOf("=");
	                if (idx === -1) {
	                    values[thePart] = null;
	                }
	                else {
	                    values[strTrim(thePart.substring(0, idx))] = strTrim(thePart.substring(idx + 1));
	                }
	            }
	        });
	    }
	    return values;
	}
	function _formatDate(theDate, func) {
	    if (isFunction$1(theDate[func])) {
	        return theDate[func]();
	    }
	    return null;
	}
	function _formatCookieValue(value, values) {
	    var cookieValue = value || strEmpty;
	    objForEachKey(values, function (name, theValue) {
	        cookieValue += "; " + name + (!isNullOrUndefined(theValue) ? "=" + theValue : strEmpty);
	    });
	    return cookieValue;
	}
	function _getCookieValue(name) {
	    var cookieValue = strEmpty;
	    if (_doc) {
	        var theCookie = _doc[strCookie] || strEmpty;
	        if (_parsedCookieValue !== theCookie) {
	            _cookieCache = _extractParts(theCookie);
	            _parsedCookieValue = theCookie;
	        }
	        cookieValue = strTrim(_cookieCache[name] || strEmpty);
	    }
	    return cookieValue;
	}
	function _setCookieValue(name, cookieValue) {
	    if (_doc) {
	        _doc[strCookie] = name + "=" + cookieValue;
	    }
	}
	function uaDisallowsSameSiteNone(userAgent) {
	    if (!isString(userAgent)) {
	        return false;
	    }
	    // Cover all iOS based browsers here. This includes:
	    // - Safari on iOS 12 for iPhone, iPod Touch, iPad
	    // - WkWebview on iOS 12 for iPhone, iPod Touch, iPad
	    // - Chrome on iOS 12 for iPhone, iPod Touch, iPad
	    // All of which are broken by SameSite=None, because they use the iOS networking stack
	    if (strContains(userAgent, "CPU iPhone OS 12") || strContains(userAgent, "iPad; CPU OS 12")) {
	        return true;
	    }
	    // Cover Mac OS X based browsers that use the Mac OS networking stack. This includes:
	    // - Safari on Mac OS X
	    // This does not include:
	    // - Internal browser on Mac OS X
	    // - Chrome on Mac OS X
	    // - Chromium on Mac OS X
	    // Because they do not use the Mac OS networking stack.
	    if (strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strContains(userAgent, "Version/") && strContains(userAgent, "Safari")) {
	        return true;
	    }
	    // Cover Mac OS X internal browsers that use the Mac OS networking stack. This includes:
	    // - Internal browser on Mac OS X
	    // This does not include:
	    // - Safari on Mac OS X
	    // - Chrome on Mac OS X
	    // - Chromium on Mac OS X
	    // Because they do not use the Mac OS networking stack.
	    if (strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strEndsWith(userAgent, "AppleWebKit/605.1.15 (KHTML, like Gecko)")) {
	        return true;
	    }
	    // Cover Chrome 50-69, because some versions are broken by SameSite=None, and none in this range require it.
	    // Note: this covers some pre-Chromium Edge versions, but pre-Chromim Edge does not require SameSite=None, so this is fine.
	    // Note: this regex applies to Windows, Mac OS X, and Linux, deliberately.
	    if (strContains(userAgent, "Chrome/5") || strContains(userAgent, "Chrome/6")) {
	        return true;
	    }
	    // Unreal Engine runs Chromium 59, but does not advertise as Chrome until 4.23. Treat versions of Unreal
	    // that don't specify their Chrome version as lacking support for SameSite=None.
	    if (strContains(userAgent, "UnrealEngine") && !strContains(userAgent, "Chrome")) {
	        return true;
	    }
	    // UCBrowser < 12.13.2 ignores Set-Cookie headers with SameSite=None
	    // NB: this rule isn't complete - you need regex to make a complete rule.
	    // See: https://www.chromium.org/updates/same-site/incompatible-clients
	    if (strContains(userAgent, "UCBrowser/12") || strContains(userAgent, "UCBrowser/11")) {
	        return true;
	    }
	    return false;
	}

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var validationError = "Extensions must provide callback to initialize";
	var strNotificationManager = "_notificationManager";
	var BaseCore = /** @class */ (function () {
	    function BaseCore() {
	        var _isInitialized = false;
	        var _eventQueue;
	        var _channelController;
	        var _notificationManager;
	        var _perfManager;
	        var _cookieManager;
	        dynamicProto(BaseCore, this, function (_self) {
	            _self._extensions = new Array();
	            _channelController = new ChannelController();
	            _self.logger = objCreateFn({
	                throwInternal: function (severity, msgId, msg, properties, isUserAct) {
	                },
	                warnToConsole: function (message) { },
	                resetInternalMessageCount: function () { }
	            });
	            _eventQueue = [];
	            _self.isInitialized = function () { return _isInitialized; };
	            _self.initialize = function (config, extensions, logger, notificationManager) {
	                // Make sure core is only initialized once
	                if (_self.isInitialized()) {
	                    throwError("Core should not be initialized more than once");
	                }
	                if (!config || isNullOrUndefined(config.instrumentationKey)) {
	                    throwError("Please provide instrumentation key");
	                }
	                _notificationManager = notificationManager;
	                // For backward compatibility only
	                _self[strNotificationManager] = notificationManager;
	                _self.config = config || {};
	                config.extensions = isNullOrUndefined(config.extensions) ? [] : config.extensions;
	                // add notification to the extensions in the config so other plugins can access it
	                var extConfig = getSetValue(config, strExtensionConfig);
	                extConfig.NotificationManager = notificationManager;
	                if (logger) {
	                    _self.logger = logger;
	                }
	                // Concat all available extensions
	                var allExtensions = [];
	                allExtensions.push.apply(allExtensions, extensions.concat(config.extensions));
	                allExtensions = sortPlugins(allExtensions);
	                var coreExtensions = [];
	                // Check if any two extensions have the same priority, then warn to console
	                // And extract the local extensions from the 
	                var extPriorities = {};
	                // Extension validation
	                arrForEach(allExtensions, function (ext) {
	                    if (isNullOrUndefined(ext) || isNullOrUndefined(ext.initialize)) {
	                        throwError(validationError);
	                    }
	                    var extPriority = ext.priority;
	                    var identifier = ext.identifier;
	                    if (ext && extPriority) {
	                        if (!isNullOrUndefined(extPriorities[extPriority])) {
	                            logger.warnToConsole("Two extensions have same priority #" + extPriority + " - " + extPriorities[extPriority] + ", " + identifier);
	                        }
	                        else {
	                            // set a value
	                            extPriorities[extPriority] = identifier;
	                        }
	                    }
	                    // Split extensions to core and channelController
	                    if (!extPriority || extPriority < _channelController.priority) {
	                        // Add to core extension that will be managed by BaseCore
	                        coreExtensions.push(ext);
	                    }
	                });
	                // Validation complete
	                // Add the channelController to the complete extension collection and
	                // to the end of the core extensions
	                allExtensions.push(_channelController);
	                coreExtensions.push(_channelController);
	                // Sort the complete set of extensions by priority
	                allExtensions = sortPlugins(allExtensions);
	                _self._extensions = allExtensions;
	                // initialize channel controller first, this will initialize all channel plugins
	                initializePlugins(new ProcessTelemetryContext([_channelController], config, _self), allExtensions);
	                initializePlugins(new ProcessTelemetryContext(coreExtensions, config, _self), allExtensions);
	                // Now reset the extensions to just those being managed by Basecore
	                _self._extensions = coreExtensions;
	                if (_self.getTransmissionControls().length === 0) {
	                    throwError("No channels available");
	                }
	                _isInitialized = true;
	                _self.releaseQueue();
	            };
	            _self.getTransmissionControls = function () {
	                return _channelController.getChannelControls();
	            };
	            _self.track = function (telemetryItem) {
	                // setup default iKey if not passed in
	                setValue(telemetryItem, strIKey, _self.config.instrumentationKey, null, isNotTruthy);
	                // add default timestamp if not passed in
	                setValue(telemetryItem, "time", toISOString(new Date()), null, isNotTruthy);
	                // Common Schema 4.0
	                setValue(telemetryItem, "ver", "4.0", null, isNullOrUndefined);
	                if (_self.isInitialized()) {
	                    // Process the telemetry plugin chain
	                    _self.getProcessTelContext().processNext(telemetryItem);
	                }
	                else {
	                    // Queue events until all extensions are initialized
	                    _eventQueue.push(telemetryItem);
	                }
	            };
	            _self.getProcessTelContext = function () {
	                var extensions = _self._extensions;
	                var thePlugins = extensions;
	                // invoke any common telemetry processors before sending through pipeline
	                if (!extensions || extensions.length === 0) {
	                    // Pass to Channel controller so data is sent to correct channel queues
	                    thePlugins = [_channelController];
	                }
	                return new ProcessTelemetryContext(thePlugins, _self.config, _self);
	            };
	            _self.getNotifyMgr = function () {
	                if (!_notificationManager) {
	                    // Create Dummy notification manager
	                    _notificationManager = objCreateFn({
	                        addNotificationListener: function (listener) { },
	                        removeNotificationListener: function (listener) { },
	                        eventsSent: function (events) { },
	                        eventsDiscarded: function (events, reason) { },
	                        eventsSendRequest: function (sendReason, isAsync) { }
	                    });
	                    // For backward compatibility only
	                    _self[strNotificationManager] = _notificationManager;
	                }
	                return _notificationManager;
	            };
	            _self.getCookieMgr = function () {
	                if (!_cookieManager) {
	                    _cookieManager = createCookieMgr(_self.config, _self.logger);
	                }
	                return _cookieManager;
	            };
	            _self.setCookieMgr = function (cookieMgr) {
	                _cookieManager = cookieMgr;
	            };
	            _self.getPerfMgr = function () {
	                if (!_perfManager) {
	                    if (_self.config && _self.config.enablePerfMgr) {
	                        _perfManager = new PerfManager(_self.getNotifyMgr());
	                    }
	                }
	                return _perfManager;
	            };
	            _self.setPerfMgr = function (perfMgr) {
	                _perfManager = perfMgr;
	            };
	            _self.eventCnt = function () {
	                return _eventQueue.length;
	            };
	            _self.releaseQueue = function () {
	                if (_eventQueue.length > 0) {
	                    arrForEach(_eventQueue, function (event) {
	                        _self.getProcessTelContext().processNext(event);
	                    });
	                    _eventQueue = [];
	                }
	            };
	        });
	    }
	// Removed Stub for BaseCore.prototype.initialize.
	// Removed Stub for BaseCore.prototype.getTransmissionControls.
	// Removed Stub for BaseCore.prototype.track.
	// Removed Stub for BaseCore.prototype.getProcessTelContext.
	// Removed Stub for BaseCore.prototype.getNotifyMgr.
	// Removed Stub for BaseCore.prototype.getCookieMgr.
	// Removed Stub for BaseCore.prototype.setCookieMgr.
	// Removed Stub for BaseCore.prototype.getPerfMgr.
	// Removed Stub for BaseCore.prototype.setPerfMgr.
	// Removed Stub for BaseCore.prototype.eventCnt.
	// Removed Stub for BaseCore.prototype.releaseQueue.
	    return BaseCore;
	}());

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/**
	 * Class to manage sending notifications to all the listeners.
	 */
	var NotificationManager = /** @class */ (function () {
	    function NotificationManager(config) {
	        this.listeners = [];
	        var perfEvtsSendAll = !!(config || {}).perfEvtsSendAll;
	        dynamicProto(NotificationManager, this, function (_self) {
	            _self.addNotificationListener = function (listener) {
	                _self.listeners.push(listener);
	            };
	            /**
	             * Removes all instances of the listener.
	             * @param {INotificationListener} listener - AWTNotificationListener to remove.
	             */
	            _self.removeNotificationListener = function (listener) {
	                var index = arrIndexOf(_self.listeners, listener);
	                while (index > -1) {
	                    _self.listeners.splice(index, 1);
	                    index = arrIndexOf(_self.listeners, listener);
	                }
	            };
	            /**
	             * Notification for events sent.
	             * @param {ITelemetryItem[]} events - The array of events that have been sent.
	             */
	            _self.eventsSent = function (events) {
	                arrForEach(_self.listeners, function (listener) {
	                    if (listener && listener.eventsSent) {
	                        setTimeout(function () { return listener.eventsSent(events); }, 0);
	                    }
	                });
	            };
	            /**
	             * Notification for events being discarded.
	             * @param {ITelemetryItem[]} events - The array of events that have been discarded by the SDK.
	             * @param {number} reason           - The reason for which the SDK discarded the events. The EventsDiscardedReason
	             * constant should be used to check the different values.
	             */
	            _self.eventsDiscarded = function (events, reason) {
	                arrForEach(_self.listeners, function (listener) {
	                    if (listener && listener.eventsDiscarded) {
	                        setTimeout(function () { return listener.eventsDiscarded(events, reason); }, 0);
	                    }
	                });
	            };
	            /**
	             * [Optional] A function called when the events have been requested to be sent to the sever.
	             * @param {number} sendReason - The reason why the event batch is being sent.
	             * @param {boolean} isAsync   - A flag which identifies whether the requests are being sent in an async or sync manner.
	             */
	            _self.eventsSendRequest = function (sendReason, isAsync) {
	                arrForEach(_self.listeners, function (listener) {
	                    if (listener && listener.eventsSendRequest) {
	                        if (isAsync) {
	                            setTimeout(function () { return listener.eventsSendRequest(sendReason, isAsync); }, 0);
	                        }
	                        else {
	                            try {
	                                listener.eventsSendRequest(sendReason, isAsync);
	                            }
	                            catch (e) {
	                                // Catch errors to ensure we don't block sending the requests
	                            }
	                        }
	                    }
	                });
	            };
	            _self.perfEvent = function (perfEvent) {
	                if (perfEvent) {
	                    // Send all events or only parent events
	                    if (perfEvtsSendAll || !perfEvent.isChildEvt()) {
	                        arrForEach(_self.listeners, function (listener) {
	                            if (listener && listener.perfEvent) {
	                                if (perfEvent.isAsync) {
	                                    setTimeout(function () { return listener.perfEvent(perfEvent); }, 0);
	                                }
	                                else {
	                                    try {
	                                        listener.perfEvent(perfEvent);
	                                    }
	                                    catch (e) {
	                                        // Catch errors to ensure we don't block sending the requests
	                                    }
	                                }
	                            }
	                        });
	                    }
	                }
	            };
	        });
	    }
	// Removed Stub for NotificationManager.prototype.addNotificationListener.
	// Removed Stub for NotificationManager.prototype.removeNotificationListener.
	// Removed Stub for NotificationManager.prototype.eventsSent.
	// Removed Stub for NotificationManager.prototype.eventsDiscarded.
	// Removed Stub for NotificationManager.prototype.eventsSendRequest.
	    return NotificationManager;
	}());

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var AppInsightsCore = /** @class */ (function (_super) {
	    __extendsFn(AppInsightsCore, _super);
	    function AppInsightsCore() {
	        var _this = _super.call(this) || this;
	        dynamicProto(AppInsightsCore, _this, function (_self, _base) {
	            _self.initialize = function (config, extensions, logger, notificationManager) {
	                _base.initialize(config, extensions, logger || new DiagnosticLogger(config), notificationManager || new NotificationManager(config));
	            };
	            _self.track = function (telemetryItem) {
	                doPerf(_self.getPerfMgr(), function () { return "AppInsightsCore:track"; }, function () {
	                    if (telemetryItem === null) {
	                        _notifyInvalidEvent(telemetryItem);
	                        // throw error
	                        throwError("Invalid telemetry item");
	                    }
	                    // do basic validation before sending it through the pipeline
	                    _validateTelemetryItem(telemetryItem);
	                    _base.track(telemetryItem);
	                }, function () { return ({ item: telemetryItem }); }, !(telemetryItem.sync));
	            };
	            /**
	             * Adds a notification listener. The SDK calls methods on the listener when an appropriate notification is raised.
	             * The added plugins must raise notifications. If the plugins do not implement the notifications, then no methods will be
	             * called.
	             * @param {INotificationListener} listener - An INotificationListener object.
	             */
	            _self.addNotificationListener = function (listener) {
	                var manager = _self.getNotifyMgr();
	                if (manager) {
	                    manager.addNotificationListener(listener);
	                }
	            };
	            /**
	             * Removes all instances of the listener.
	             * @param {INotificationListener} listener - INotificationListener to remove.
	             */
	            _self.removeNotificationListener = function (listener) {
	                var manager = _self.getNotifyMgr();
	                if (manager) {
	                    manager.removeNotificationListener(listener);
	                }
	            };
	            /**
	             * Periodically check logger.queue for
	             */
	            _self.pollInternalLogs = function (eventName) {
	                var interval = _self.config.diagnosticLogInterval;
	                if (!interval || !(interval > 0)) {
	                    interval = 10000;
	                }
	                return setInterval(function () {
	                    var queue = _self.logger ? _self.logger.queue : [];
	                    arrForEach(queue, function (logMessage) {
	                        var item = {
	                            name: eventName ? eventName : "InternalMessageId: " + logMessage.messageId,
	                            iKey: _self.config.instrumentationKey,
	                            time: toISOString(new Date()),
	                            baseType: _InternalLogMessage.dataType,
	                            baseData: { message: logMessage.message }
	                        };
	                        _self.track(item);
	                    });
	                    queue.length = 0;
	                }, interval);
	            };
	            function _validateTelemetryItem(telemetryItem) {
	                if (isNullOrUndefined(telemetryItem.name)) {
	                    _notifyInvalidEvent(telemetryItem);
	                    throw Error("telemetry name required");
	                }
	            }
	            function _notifyInvalidEvent(telemetryItem) {
	                var manager = _self.getNotifyMgr();
	                if (manager) {
	                    manager.eventsDiscarded([telemetryItem], EventsDiscardedReason.InvalidEvent);
	                }
	            }
	        });
	        return _this;
	    }
	// Removed Stub for AppInsightsCore.prototype.initialize.
	// Removed Stub for AppInsightsCore.prototype.track.
	// Removed Stub for AppInsightsCore.prototype.addNotificationListener.
	// Removed Stub for AppInsightsCore.prototype.removeNotificationListener.
	// Removed Stub for AppInsightsCore.prototype.pollInternalLogs.
	    return AppInsightsCore;
	}(BaseCore));

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var UInt32Mask = 0x100000000;
	var MaxUInt32 = 0xffffffff;
	// MWC based Random generator (for IE)
	var _mwcSeeded = false;
	var _mwcW = 123456789;
	var _mwcZ = 987654321;
	// Takes any integer
	function _mwcSeed(seedValue) {
	    if (seedValue < 0) {
	        // Make sure we end up with a positive number and not -ve one.
	        seedValue >>>= 0;
	    }
	    _mwcW = (123456789 + seedValue) & MaxUInt32;
	    _mwcZ = (987654321 - seedValue) & MaxUInt32;
	    _mwcSeeded = true;
	}
	function _autoSeedMwc() {
	    // Simple initialization using default Math.random() - So we inherit any entropy from the browser
	    // and bitwise XOR with the current milliseconds
	    try {
	        var now = dateNow() & 0x7fffffff;
	        _mwcSeed(((Math.random() * UInt32Mask) ^ now) + now);
	    }
	    catch (e) {
	        // Don't crash if something goes wrong
	    }
	}
	/**
	 * generate a random 32-bit number (0x000000..0xFFFFFFFF) or (-0x80000000..0x7FFFFFFF), defaults un-unsigned.
	 * @param signed - True to return a signed 32-bit number (-0x80000000..0x7FFFFFFF) otherwise an unsigned one (0x000000..0xFFFFFFFF)
	 */
	function random32(signed) {
	    var value;
	    var c = getCrypto() || getMsCrypto();
	    if (c && c.getRandomValues) {
	        // Make sure the number is converted into the specified range (-0x80000000..0x7FFFFFFF)
	        value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32;
	    }
	    else if (isIE()) {
	        // For IE 6, 7, 8 (especially on XP) Math.random is not very random
	        if (!_mwcSeeded) {
	            // Set the seed for the Mwc algorithm
	            _autoSeedMwc();
	        }
	        // Don't use Math.random for IE
	        // Make sure the number is converted into the specified range (-0x80000000..0x7FFFFFFF)
	        value = mwcRandom32() & MaxUInt32;
	    }
	    else {
	        // Make sure the number is converted into the specified range (-0x80000000..0x7FFFFFFF)
	        value = Math.floor((UInt32Mask * Math.random()) | 0);
	    }
	    if (!signed) {
	        // Make sure we end up with a positive number and not -ve one.
	        value >>>= 0;
	    }
	    return value;
	}
	/**
	 * Generate a random 32-bit number between (0x000000..0xFFFFFFFF) or (-0x80000000..0x7FFFFFFF), using MWC (Multiply with carry)
	 * instead of Math.random() defaults to un-signed.
	 * Used as a replacement random generator for IE to avoid issues with older IE instances.
	 * @param signed - True to return a signed 32-bit number (-0x80000000..0x7FFFFFFF) otherwise an unsigned one (0x000000..0xFFFFFFFF)
	 */
	function mwcRandom32(signed) {
	    _mwcZ = (36969 * (_mwcZ & 0xFFFF) + (_mwcZ >> 16)) & MaxUInt32;
	    _mwcW = (18000 * (_mwcW & 0xFFFF) + (_mwcW >> 16)) & MaxUInt32;
	    var value = (((_mwcZ << 16) + (_mwcW & 0xFFFF)) >>> 0) & MaxUInt32 | 0;
	    if (!signed) {
	        // Make sure we end up with a positive number and not -ve one.
	        value >>>= 0;
	    }
	    return value;
	}

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/**
	 * Trys to add an event handler for the specified event to the window, body and document
	 * @param eventName {string} - The name of the event
	 * @param callback {any} - The callback function that needs to be executed for the given event
	 * @return {boolean} - true if the handler was successfully added
	 */
	function addEventHandler(eventName, callback) {
	    var result = false;
	    var w = getWindow();
	    if (w) {
	        result = attachEvent(w, eventName, callback);
	        result = attachEvent(w["body"], eventName, callback) || result;
	    }
	    var doc = getDocument();
	    if (doc) {
	        result = EventHelper.Attach(doc, eventName, callback) || result;
	    }
	    return result;
	}
	/**
	 * Generate random base64 id string.
	 * The default length is 22 which is 132-bits so almost the same as a GUID but as base64 (the previous default was 5)
	 * @param maxLength - Optional value to specify the length of the id to be generated, defaults to 22
	 */
	function newId(maxLength) {
	    if (maxLength === void 0) { maxLength = 22; }
	    var base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	    // Start with an initial random number, consuming the value in reverse byte order
	    var number = random32() >>> 0; // Make sure it's a +ve number
	    var chars = 0;
	    var result = "";
	    while (result.length < maxLength) {
	        chars++;
	        result += base64chars.charAt(number & 0x3F);
	        number >>>= 6; // Zero fill with right shift
	        if (chars === 5) {
	            // 5 base64 characters === 30 bits so we don't have enough bits for another base64 char
	            // So add on another 30 bits and make sure it's +ve
	            number = (((random32() << 2) & 0xFFFFFFFF) | (number & 0x03)) >>> 0;
	            chars = 0; // We need to reset the number every 5 chars (30 bits)
	        }
	    }
	    return result;
	}
	/**
	 * generate W3C trace id
	 */
	function generateW3CId() {
	    var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
	    // rfc4122 version 4 UUID without dashes and with lowercase letters
	    var oct = "", tmp;
	    for (var a = 0; a < 4; a++) {
	        tmp = random32();
	        oct +=
	            hexValues[tmp & 0xF] +
	                hexValues[tmp >> 4 & 0xF] +
	                hexValues[tmp >> 8 & 0xF] +
	                hexValues[tmp >> 12 & 0xF] +
	                hexValues[tmp >> 16 & 0xF] +
	                hexValues[tmp >> 20 & 0xF] +
	                hexValues[tmp >> 24 & 0xF] +
	                hexValues[tmp >> 28 & 0xF];
	    }
	    // "Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively"
	    var clockSequenceHi = hexValues[8 + (random32() & 0x03) | 0];
	    return oct.substr(0, 8) + oct.substr(9, 4) + "4" + oct.substr(13, 3) + clockSequenceHi + oct.substr(16, 3) + oct.substr(19, 12);
	}
	var EventHelper = {
	    Attach: attachEvent,
	    AttachEvent: attachEvent,
	    Detach: detachEvent,
	    DetachEvent: detachEvent
	};

	/*
	 * Application Insights JavaScript SDK - Core, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var aiInstrumentHooks = "_aiHooks";
	var cbNames = [
	    "req", "rsp", "hkErr", "fnErr"
	];
	/**
	 * Constant string defined to support minimization
	 * @ignore
	 */
	var str__Proto$1 = "__proto__";
	/**
	 * Constant string defined to support minimization
	 * @ignore
	 */
	var strConstructor = "constructor";
	/** @ignore */
	function _arrLoop(arr, fn) {
	    if (arr) {
	        for (var lp = 0; lp < arr.length; lp++) {
	            if (fn(arr[lp], lp)) {
	                break;
	            }
	        }
	    }
	}
	/** @ignore */
	function _doCallbacks(hooks, callDetails, cbArgs, hookCtx, type) {
	    if (type >= 0 /* Request */ && type <= 2 /* HookError */) {
	        _arrLoop(hooks, function (hook, idx) {
	            var cbks = hook.cbks;
	            var cb = cbks[cbNames[type]];
	            if (cb) {
	                // Set the specific hook context implementation using a lazy creation pattern
	                callDetails.ctx = function () {
	                    var ctx = hookCtx[idx] = (hookCtx[idx] || {});
	                    return ctx;
	                };
	                try {
	                    cb.apply(callDetails.inst, cbArgs);
	                }
	                catch (err) {
	                    var orgEx = callDetails.err;
	                    try {
	                        // Report Hook error via the callback
	                        var hookErrorCb = cbks[cbNames[2 /* HookError */]];
	                        if (hookErrorCb) {
	                            callDetails.err = err;
	                            hookErrorCb.apply(callDetails.inst, cbArgs);
	                        }
	                    }
	                    catch (e) {
	                        // Not much we can do here -- swallowing the exception to avoid crashing the hosting app
	                    }
	                    finally {
	                        // restore the original exception (if any)
	                        callDetails.err = orgEx;
	                    }
	                }
	            }
	        });
	    }
	}
	/** @ignore */
	function _createFunctionHook(aiHook) {
	    // Define a temporary method that queues-up a the real method call
	    return function () {
	        var funcThis = this;
	        // Capture the original arguments passed to the method
	        var orgArgs = arguments;
	        var hooks = aiHook.h;
	        var funcArgs = {
	            name: aiHook.n,
	            inst: funcThis,
	            ctx: null,
	            set: _replaceArg
	        };
	        var hookCtx = [];
	        var cbArgs = _createArgs([funcArgs], orgArgs);
	        function _createArgs(target, theArgs) {
	            _arrLoop(theArgs, function (arg) {
	                target.push(arg);
	            });
	            return target;
	        }
	        function _replaceArg(idx, value) {
	            orgArgs = _createArgs([], orgArgs);
	            orgArgs[idx] = value;
	            cbArgs = _createArgs([funcArgs], orgArgs);
	        }
	        // Call the pre-request hooks
	        _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, 0 /* Request */);
	        // Call the original function was called
	        var theFunc = aiHook.f;
	        try {
	            funcArgs.rslt = theFunc.apply(funcThis, orgArgs);
	        }
	        catch (err) {
	            // Report the request callback
	            funcArgs.err = err;
	            _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, 3 /* FunctionError */);
	            // rethrow the original exception so anyone listening for it can catch the exception
	            throw err;
	        }
	        // Call the post-request hooks
	        _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, 1 /* Response */);
	        return funcArgs.rslt;
	    };
	}
	/**
	 * Pre-lookup to check if we are running on a modern browser (i.e. not IE8)
	 * @ignore
	 */
	var _objGetPrototypeOf$1 = Object["getPrototypeOf"];
	/**
	 * Helper used to get the prototype of the target object as getPrototypeOf is not available in an ES3 environment.
	 * @ignore
	 */
	function _getObjProto$1(target) {
	    if (target) {
	        // This method doesn't existing in older browsers (e.g. IE8)
	        if (_objGetPrototypeOf$1) {
	            return _objGetPrototypeOf$1(target);
	        }
	        // target[Constructor] May break if the constructor has been changed or removed
	        var newProto = target[str__Proto$1] || target[strShimPrototype] || target[strConstructor];
	        if (newProto) {
	            return newProto;
	        }
	    }
	    return null;
	}
	/** @ignore */
	function _getOwner(target, name, checkPrototype) {
	    var owner = null;
	    if (target) {
	        if (hasOwnProperty$d(target, name)) {
	            owner = target;
	        }
	        else if (checkPrototype) {
	            owner = _getOwner(_getObjProto$1(target), name, false);
	        }
	    }
	    return owner;
	}
	/**
	 * Intercept the named prototype functions for the target class / object
	 * @param target - The target object
	 * @param funcName - The function name
	 * @param callbacks - The callbacks to configure and call whenever the function is called
	 */
	function InstrumentProto(target, funcName, callbacks) {
	    if (target) {
	        return InstrumentFunc(target[strShimPrototype], funcName, callbacks, false);
	    }
	    return null;
	}
	/**
	 * Intercept the named prototype functions for the target class / object
	 * @param target - The target object
	 * @param funcName - The function name
	 * @param callbacks - The callbacks to configure and call whenever the function is called
	 * @param checkPrototype - If the function doesn't exist on the target should it attempt to hook the prototype function
	 */
	function InstrumentFunc(target, funcName, callbacks, checkPrototype) {
	    if (checkPrototype === void 0) { checkPrototype = true; }
	    if (target && funcName && callbacks) {
	        var owner = _getOwner(target, funcName, checkPrototype);
	        if (owner) {
	            var fn = owner[funcName];
	            if (typeof fn === strShimFunction) {
	                var aiHook_1 = fn[aiInstrumentHooks];
	                if (!aiHook_1) {
	                    // Only hook the function once
	                    aiHook_1 = {
	                        i: 0,
	                        n: funcName,
	                        f: fn,
	                        h: []
	                    };
	                    // Override (hook) the original function
	                    var newFunc = _createFunctionHook(aiHook_1);
	                    newFunc[aiInstrumentHooks] = aiHook_1; // Tag and store the function hooks
	                    owner[funcName] = newFunc;
	                }
	                var theHook = {
	                    // tslint:disable:object-literal-shorthand
	                    id: aiHook_1.i,
	                    cbks: callbacks,
	                    rm: function () {
	                        // DO NOT Use () => { shorthand for the function as the this gets replaced
	                        // with the outer this and not the this for theHook instance.
	                        var id = this.id;
	                        _arrLoop(aiHook_1.h, function (hook, idx) {
	                            if (hook.id === id) {
	                                aiHook_1.h.splice(idx, 1);
	                                return 1;
	                            }
	                        });
	                    }
	                    // tslint:enable:object-literal-shorthand
	                };
	                aiHook_1.i++;
	                aiHook_1.h.push(theHook);
	                return theHook;
	            }
	        }
	    }
	    return null;
	}

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	var RequestHeaders = {
	    requestContextHeader: "Request-Context",
	    requestContextTargetKey: "appId",
	    requestContextAppIdFormat: "appId=cid-v1:",
	    requestIdHeader: "Request-Id",
	    traceParentHeader: "traceparent",
	    traceStateHeader: "tracestate",
	    sdkContextHeader: "Sdk-Context",
	    sdkContextHeaderAppIdRequest: "appId",
	    requestContextHeaderLowerCase: "request-context"
	};

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	function dataSanitizeKeyAndAddUniqueness(logger, key, map) {
	    var origLength = key.length;
	    var field = dataSanitizeKey(logger, key);
	    // validation truncated the length.  We need to add uniqueness
	    if (field.length !== origLength) {
	        var i = 0;
	        var uniqueField = field;
	        while (map[uniqueField] !== undefined) {
	            i++;
	            uniqueField = field.substring(0, 150 /* MAX_NAME_LENGTH */ - 3) + dsPadNumber(i);
	        }
	        field = uniqueField;
	    }
	    return field;
	}
	function dataSanitizeKey(logger, name) {
	    var nameTrunc;
	    if (name) {
	        // Remove any leading or trailing whitepace
	        name = strTrim(name.toString());
	        // truncate the string to 150 chars
	        if (name.length > 150 /* MAX_NAME_LENGTH */) {
	            nameTrunc = name.substring(0, 150 /* MAX_NAME_LENGTH */);
	            logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.NameTooLong, "name is too long.  It has been truncated to " + 150 /* MAX_NAME_LENGTH */ + " characters.", { name: name }, true);
	        }
	    }
	    return nameTrunc || name;
	}
	function dataSanitizeString(logger, value, maxLength) {
	    if (maxLength === void 0) { maxLength = 1024 /* MAX_STRING_LENGTH */; }
	    var valueTrunc;
	    if (value) {
	        maxLength = maxLength ? maxLength : 1024 /* MAX_STRING_LENGTH */; // in case default parameters dont work
	        value = strTrim(value);
	        if (value.toString().length > maxLength) {
	            valueTrunc = value.toString().substring(0, maxLength);
	            logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.StringValueTooLong, "string value is too long. It has been truncated to " + maxLength + " characters.", { value: value }, true);
	        }
	    }
	    return valueTrunc || value;
	}
	function dataSanitizeUrl(logger, url) {
	    return dataSanitizeInput(logger, url, 2048 /* MAX_URL_LENGTH */, _InternalMessageId.UrlTooLong);
	}
	function dataSanitizeMessage(logger, message) {
	    var messageTrunc;
	    if (message) {
	        if (message.length > 32768 /* MAX_MESSAGE_LENGTH */) {
	            messageTrunc = message.substring(0, 32768 /* MAX_MESSAGE_LENGTH */);
	            logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.MessageTruncated, "message is too long, it has been truncated to " + 32768 /* MAX_MESSAGE_LENGTH */ + " characters.", { message: message }, true);
	        }
	    }
	    return messageTrunc || message;
	}
	function dataSanitizeException(logger, exception) {
	    var exceptionTrunc;
	    if (exception) {
	        // Make surte its a string
	        var value = "" + exception;
	        if (value.length > 32768 /* MAX_EXCEPTION_LENGTH */) {
	            exceptionTrunc = value.substring(0, 32768 /* MAX_EXCEPTION_LENGTH */);
	            logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.ExceptionTruncated, "exception is too long, it has been truncated to " + 32768 /* MAX_EXCEPTION_LENGTH */ + " characters.", { exception: exception }, true);
	        }
	    }
	    return exceptionTrunc || exception;
	}
	function dataSanitizeProperties(logger, properties) {
	    if (properties) {
	        var tempProps_1 = {};
	        objForEachKey(properties, function (prop, value) {
	            if (isObject$1(value) && hasJSON()) {
	                // Stringify any part C properties
	                try {
	                    value = getJSON().stringify(value);
	                }
	                catch (e) {
	                    logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.CannotSerializeObjectNonSerializable, "custom property is not valid", { exception: e }, true);
	                }
	            }
	            value = dataSanitizeString(logger, value, 8192 /* MAX_PROPERTY_LENGTH */);
	            prop = dataSanitizeKeyAndAddUniqueness(logger, prop, tempProps_1);
	            tempProps_1[prop] = value;
	        });
	        properties = tempProps_1;
	    }
	    return properties;
	}
	function dataSanitizeMeasurements(logger, measurements) {
	    if (measurements) {
	        var tempMeasurements_1 = {};
	        objForEachKey(measurements, function (measure, value) {
	            measure = dataSanitizeKeyAndAddUniqueness(logger, measure, tempMeasurements_1);
	            tempMeasurements_1[measure] = value;
	        });
	        measurements = tempMeasurements_1;
	    }
	    return measurements;
	}
	function dataSanitizeId(logger, id) {
	    return id ? dataSanitizeInput(logger, id, 128 /* MAX_ID_LENGTH */, _InternalMessageId.IdTooLong).toString() : id;
	}
	function dataSanitizeInput(logger, input, maxLength, _msgId) {
	    var inputTrunc;
	    if (input) {
	        input = strTrim(input);
	        if (input.length > maxLength) {
	            inputTrunc = input.substring(0, maxLength);
	            logger.throwInternal(LoggingSeverity.WARNING, _msgId, "input is too long, it has been truncated to " + maxLength + " characters.", { data: input }, true);
	        }
	    }
	    return inputTrunc || input;
	}
	function dsPadNumber(num) {
	    var s = "00" + num;
	    return s.substr(s.length - 3);
	}

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	function createDomEvent(eventName) {
	    var event = null;
	    if (isFunction$1(Event)) {
	        event = new Event(eventName);
	    }
	    else {
	        var doc = getDocument();
	        if (doc && doc.createEvent) {
	            event = doc.createEvent("Event");
	            event.initEvent(eventName, true, true);
	        }
	    }
	    return event;
	}

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	function stringToBoolOrDefault(str, defaultValue) {
	    if (defaultValue === void 0) { defaultValue = false; }
	    if (str === undefined || str === null) {
	        return defaultValue;
	    }
	    return str.toString().toLowerCase() === "true";
	}
	/**
	 * Convert ms to c# time span format
	 */
	function msToTimeSpan(totalms) {
	    if (isNaN(totalms) || totalms < 0) {
	        totalms = 0;
	    }
	    totalms = Math.round(totalms);
	    var ms = "" + totalms % 1000;
	    var sec = "" + Math.floor(totalms / 1000) % 60;
	    var min = "" + Math.floor(totalms / (1000 * 60)) % 60;
	    var hour = "" + Math.floor(totalms / (1000 * 60 * 60)) % 24;
	    var days = Math.floor(totalms / (1000 * 60 * 60 * 24));
	    ms = ms.length === 1 ? "00" + ms : ms.length === 2 ? "0" + ms : ms;
	    sec = sec.length < 2 ? "0" + sec : sec;
	    min = min.length < 2 ? "0" + min : min;
	    hour = hour.length < 2 ? "0" + hour : hour;
	    return (days > 0 ? days + "." : "") + hour + ":" + min + ":" + sec + "." + ms;
	}
	function isBeaconApiSupported() {
	    var nav = getNavigator();
	    return ('sendBeacon' in nav && nav.sendBeacon);
	}
	function getExtensionByName(extensions, identifier) {
	    var extension = null;
	    arrForEach(extensions, function (value) {
	        if (value.identifier === identifier) {
	            extension = value;
	            return -1;
	        }
	    });
	    return extension;
	}
	function isCrossOriginError(message, url, lineNumber, columnNumber, error) {
	    return !error && isString(message) && (message === "Script error." || message === "Script error");
	}

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	/**
	 * This is an internal property used to cause internal (reporting) requests to be ignored from reporting
	 * additional telemetry, to handle polyfil implementations ALL urls used with a disabled request will
	 * also be ignored for future requests even when this property is not provided.
	 * Tagging as Ignore as this is an internal value and is not expected to be used outside of the SDK
	 * @ignore
	 */
	var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
	var SampleRate = "sampleRate";
	var ProcessLegacy = "ProcessLegacy";
	var HttpMethod = "http.method";
	var DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
	var strNotSpecified = "not_specified";

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	/**
	 * Type of storage to differentiate between local storage and session storage
	 */
	var StorageType;
	(function (StorageType) {
	    StorageType[StorageType["LocalStorage"] = 0] = "LocalStorage";
	    StorageType[StorageType["SessionStorage"] = 1] = "SessionStorage";
	})(StorageType || (StorageType = {}));
	var DistributedTracingModes;
	(function (DistributedTracingModes) {
	    /**
	     * (Default) Send Application Insights correlation headers
	     */
	    DistributedTracingModes[DistributedTracingModes["AI"] = 0] = "AI";
	    /**
	     * Send both W3C Trace Context headers and back-compatibility Application Insights headers
	     */
	    DistributedTracingModes[DistributedTracingModes["AI_AND_W3C"] = 1] = "AI_AND_W3C";
	    /**
	     * Send W3C Trace Context headers
	     */
	    DistributedTracingModes[DistributedTracingModes["W3C"] = 2] = "W3C";
	})(DistributedTracingModes || (DistributedTracingModes = {}));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var _canUseLocalStorage = undefined;
	var _canUseSessionStorage = undefined;
	/**
	 * Gets the localStorage object if available
	 * @return {Storage} - Returns the storage object if available else returns null
	 */
	function _getLocalStorageObject() {
	    if (utlCanUseLocalStorage()) {
	        return _getVerifiedStorageObject(StorageType.LocalStorage);
	    }
	    return null;
	}
	/**
	 * Tests storage object (localStorage or sessionStorage) to verify that it is usable
	 * More details here: https://mathiasbynens.be/notes/localstorage-pattern
	 * @param storageType Type of storage
	 * @return {Storage} Returns storage object verified that it is usable
	 */
	function _getVerifiedStorageObject(storageType) {
	    try {
	        if (isNullOrUndefined(getGlobal())) {
	            return null;
	        }
	        var uid = new Date;
	        var storage = getGlobalInst(storageType === StorageType.LocalStorage ? "localStorage" : "sessionStorage");
	        storage.setItem(uid.toString(), uid.toString());
	        var fail = storage.getItem(uid.toString()) !== uid.toString();
	        storage.removeItem(uid.toString());
	        if (!fail) {
	            return storage;
	        }
	    }
	    catch (exception) {
	        // eslint-disable-next-line no-empty
	    }
	    return null;
	}
	/**
	 * Gets the sessionStorage object if available
	 * @return {Storage} - Returns the storage object if available else returns null
	 */
	function _getSessionStorageObject() {
	    if (utlCanUseSessionStorage()) {
	        return _getVerifiedStorageObject(StorageType.SessionStorage);
	    }
	    return null;
	}
	function utlDisableStorage() {
	    _canUseLocalStorage = false;
	    _canUseSessionStorage = false;
	}
	function utlCanUseLocalStorage() {
	    if (_canUseLocalStorage === undefined) {
	        _canUseLocalStorage = !!_getVerifiedStorageObject(StorageType.LocalStorage);
	    }
	    return _canUseLocalStorage;
	}
	function utlGetLocalStorage(logger, name) {
	    var storage = _getLocalStorageObject();
	    if (storage !== null) {
	        try {
	            return storage.getItem(name);
	        }
	        catch (e) {
	            _canUseLocalStorage = false;
	            logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserCannotReadLocalStorage, "Browser failed read of local storage. " + getExceptionName(e), { exception: dumpObj(e) });
	        }
	    }
	    return null;
	}
	function utlSetLocalStorage(logger, name, data) {
	    var storage = _getLocalStorageObject();
	    if (storage !== null) {
	        try {
	            storage.setItem(name, data);
	            return true;
	        }
	        catch (e) {
	            _canUseLocalStorage = false;
	            logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserCannotWriteLocalStorage, "Browser failed write to local storage. " + getExceptionName(e), { exception: dumpObj(e) });
	        }
	    }
	    return false;
	}
	function utlRemoveStorage(logger, name) {
	    var storage = _getLocalStorageObject();
	    if (storage !== null) {
	        try {
	            storage.removeItem(name);
	            return true;
	        }
	        catch (e) {
	            _canUseLocalStorage = false;
	            logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserFailedRemovalFromLocalStorage, "Browser failed removal of local storage item. " + getExceptionName(e), { exception: dumpObj(e) });
	        }
	    }
	    return false;
	}
	function utlCanUseSessionStorage() {
	    if (_canUseSessionStorage === undefined) {
	        _canUseSessionStorage = !!_getVerifiedStorageObject(StorageType.SessionStorage);
	    }
	    return _canUseSessionStorage;
	}
	function utlGetSessionStorage(logger, name) {
	    var storage = _getSessionStorageObject();
	    if (storage !== null) {
	        try {
	            return storage.getItem(name);
	        }
	        catch (e) {
	            _canUseSessionStorage = false;
	            logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserCannotReadSessionStorage, "Browser failed read of session storage. " + getExceptionName(e), { exception: dumpObj(e) });
	        }
	    }
	    return null;
	}
	function utlSetSessionStorage(logger, name, data) {
	    var storage = _getSessionStorageObject();
	    if (storage !== null) {
	        try {
	            storage.setItem(name, data);
	            return true;
	        }
	        catch (e) {
	            _canUseSessionStorage = false;
	            logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserCannotWriteSessionStorage, "Browser failed write to session storage. " + getExceptionName(e), { exception: dumpObj(e) });
	        }
	    }
	    return false;
	}
	function utlRemoveSessionStorage(logger, name) {
	    var storage = _getSessionStorageObject();
	    if (storage !== null) {
	        try {
	            storage.removeItem(name);
	            return true;
	        }
	        catch (e) {
	            _canUseSessionStorage = false;
	            logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserFailedRemovalFromSessionStorage, "Browser failed removal of session storage item. " + getExceptionName(e), { exception: dumpObj(e) });
	        }
	    }
	    return false;
	}

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var _document = getDocument() || {};
	var _htmlAnchorIdx = 0;
	// Use an array of temporary values as it's possible for multiple calls to parseUrl() will be called with different URLs
	// Using a cache size of 5 for now as it current depth usage is at least 2, so adding a minor buffer to handle future updates
	var _htmlAnchorElement = [null, null, null, null, null];
	function urlParseUrl(url) {
	    var anchorIdx = _htmlAnchorIdx;
	    var anchorCache = _htmlAnchorElement;
	    var tempAnchor = anchorCache[anchorIdx];
	    if (!_document.createElement) {
	        // Always create the temp instance if createElement is not available
	        tempAnchor = { host: urlParseHost(url, true) };
	    }
	    else if (!anchorCache[anchorIdx]) {
	        // Create and cache the unattached anchor instance 
	        tempAnchor = anchorCache[anchorIdx] = _document.createElement('a');
	    }
	    tempAnchor.href = url;
	    // Move the cache index forward
	    anchorIdx++;
	    if (anchorIdx >= anchorCache.length) {
	        anchorIdx = 0;
	    }
	    _htmlAnchorIdx = anchorIdx;
	    return tempAnchor;
	}
	function urlGetAbsoluteUrl(url) {
	    var result;
	    var a = urlParseUrl(url);
	    if (a) {
	        result = a.href;
	    }
	    return result;
	}
	function urlGetCompleteUrl(method, absoluteUrl) {
	    if (method) {
	        return method.toUpperCase() + " " + absoluteUrl;
	    }
	    return absoluteUrl;
	}
	// Fallback method to grab host from url if document.createElement method is not available
	function urlParseHost(url, inclPort) {
	    var fullHost = urlParseFullHost(url, inclPort) || "";
	    if (fullHost) {
	        var match = fullHost.match(/(www[0-9]?\.)?(.[^/:]+)(\:[\d]+)?/i);
	        if (match != null && match.length > 3 && isString(match[2]) && match[2].length > 0) {
	            return match[2] + (match[3] || "");
	        }
	    }
	    return fullHost;
	}
	function urlParseFullHost(url, inclPort) {
	    var result = null;
	    if (url) {
	        var match = url.match(/(\w*):\/\/(.[^/:]+)(\:[\d]+)?/i);
	        if (match != null && match.length > 2 && isString(match[2]) && match[2].length > 0) {
	            result = match[2] || "";
	            if (inclPort && match.length > 2) {
	                var protocol = (match[1] || "").toLowerCase();
	                var port = match[3] || "";
	                // IE includes the standard port so pass it off if it's the same as the protocol
	                if (protocol === "http" && port === ":80") {
	                    port = "";
	                }
	                else if (protocol === "https" && port === ":443") {
	                    port = "";
	                }
	                result += port;
	            }
	        }
	    }
	    return result;
	}

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	// listing only non-geo specific locations
	var _internalEndpoints = [
	    "https://dc.services.visualstudio.com/v2/track",
	    "https://breeze.aimon.applicationinsights.io/v2/track",
	    "https://dc-int.services.visualstudio.com/v2/track"
	];
	function isInternalApplicationInsightsEndpoint(endpointUrl) {
	    return _internalEndpoints.indexOf(endpointUrl.toLowerCase()) !== -1;
	}
	var CorrelationIdHelper = {
	    correlationIdPrefix: "cid-v1:",
	    /**
	     * Checks if a request url is not on a excluded domain list and if it is safe to add correlation headers.
	     * Headers are always included if the current domain matches the request domain. If they do not match (CORS),
	     * they are regex-ed across correlationHeaderDomains and correlationHeaderExcludedDomains to determine if headers are included.
	     * Some environments don't give information on currentHost via window.location.host (e.g. Cordova). In these cases, the user must
	     * manually supply domains to include correlation headers on. Else, no headers will be included at all.
	     */
	    canIncludeCorrelationHeader: function (config, requestUrl, currentHost) {
	        if (!requestUrl || (config && config.disableCorrelationHeaders)) {
	            return false;
	        }
	        if (config && config.correlationHeaderExcludePatterns) {
	            for (var i = 0; i < config.correlationHeaderExcludePatterns.length; i++) {
	                if (config.correlationHeaderExcludePatterns[i].test(requestUrl)) {
	                    return false;
	                }
	            }
	        }
	        var requestHost = urlParseUrl(requestUrl).host.toLowerCase();
	        if (requestHost && (requestHost.indexOf(":443") !== -1 || requestHost.indexOf(":80") !== -1)) {
	            // [Bug #1260] IE can include the port even for http and https URLs so if present 
	            // try and parse it to remove if it matches the default protocol port
	            requestHost = (urlParseFullHost(requestUrl, true) || "").toLowerCase();
	        }
	        if ((!config || !config.enableCorsCorrelation) && (requestHost && requestHost !== currentHost)) {
	            return false;
	        }
	        var includedDomains = config && config.correlationHeaderDomains;
	        if (includedDomains) {
	            var matchExists_1;
	            arrForEach(includedDomains, function (domain) {
	                var regex = new RegExp(domain.toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
	                matchExists_1 = matchExists_1 || regex.test(requestHost);
	            });
	            if (!matchExists_1) {
	                return false;
	            }
	        }
	        var excludedDomains = config && config.correlationHeaderExcludedDomains;
	        if (!excludedDomains || excludedDomains.length === 0) {
	            return true;
	        }
	        for (var i = 0; i < excludedDomains.length; i++) {
	            var regex = new RegExp(excludedDomains[i].toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
	            if (regex.test(requestHost)) {
	                return false;
	            }
	        }
	        // if we don't know anything about the requestHost, require the user to use included/excludedDomains.
	        // Previously we always returned false for a falsy requestHost
	        return requestHost && requestHost.length > 0;
	    },
	    /**
	     * Combines target appId and target role name from response header.
	     */
	    getCorrelationContext: function (responseHeader) {
	        if (responseHeader) {
	            var correlationId = CorrelationIdHelper.getCorrelationContextValue(responseHeader, RequestHeaders.requestContextTargetKey);
	            if (correlationId && correlationId !== CorrelationIdHelper.correlationIdPrefix) {
	                return correlationId;
	            }
	        }
	    },
	    /**
	     * Gets key from correlation response header
	     */
	    getCorrelationContextValue: function (responseHeader, key) {
	        if (responseHeader) {
	            var keyValues = responseHeader.split(",");
	            for (var i = 0; i < keyValues.length; ++i) {
	                var keyValue = keyValues[i].split("=");
	                if (keyValue.length === 2 && keyValue[0] === key) {
	                    return keyValue[1];
	                }
	            }
	        }
	    }
	};
	function AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName) {
	    var target, name = commandName, data = commandName;
	    if (absoluteUrl && absoluteUrl.length > 0) {
	        var parsedUrl = urlParseUrl(absoluteUrl);
	        target = parsedUrl.host;
	        if (!name) {
	            if (parsedUrl.pathname != null) {
	                var pathName = (parsedUrl.pathname.length === 0) ? "/" : parsedUrl.pathname;
	                if (pathName.charAt(0) !== '/') {
	                    pathName = "/" + pathName;
	                }
	                data = parsedUrl.pathname;
	                name = dataSanitizeString(logger, method ? method + " " + pathName : pathName);
	            }
	            else {
	                name = dataSanitizeString(logger, absoluteUrl);
	            }
	        }
	    }
	    else {
	        target = commandName;
	        name = commandName;
	    }
	    return {
	        target: target,
	        name: name,
	        data: data
	    };
	}
	function dateTimeUtilsNow() {
	    // returns the window or webworker performance object
	    var perf = getPerformance();
	    if (perf && perf.now && perf.timing) {
	        var now = perf.now() + perf.timing.navigationStart;
	        // Known issue with IE where this calculation can be negative, so if it is then ignore and fallback
	        if (now > 0) {
	            return now;
	        }
	    }
	    return dateNow();
	}
	function dateTimeUtilsDuration(start, end) {
	    var result = null;
	    if (start !== 0 && end !== 0 && !isNullOrUndefined(start) && !isNullOrUndefined(end)) {
	        result = end - start;
	    }
	    return result;
	}

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var _FIELDS_SEPARATOR = ";";
	var _FIELD_KEY_VALUE_SEPARATOR = "=";
	function parseConnectionString(connectionString) {
	    if (!connectionString) {
	        return {};
	    }
	    var kvPairs = connectionString.split(_FIELDS_SEPARATOR);
	    var result = arrReduce(kvPairs, function (fields, kv) {
	        var kvParts = kv.split(_FIELD_KEY_VALUE_SEPARATOR);
	        if (kvParts.length === 2) {
	            var key = kvParts[0].toLowerCase();
	            var value = kvParts[1];
	            fields[key] = value;
	        }
	        return fields;
	    }, {});
	    if (objKeys(result).length > 0) {
	        // this is a valid connection string, so parse the results
	        if (result.endpointsuffix) {
	            // use endpoint suffix where overrides are not provided
	            var locationPrefix = result.location ? result.location + "." : "";
	            result.ingestionendpoint = result.ingestionendpoint || ("https://" + locationPrefix + "dc." + result.endpointsuffix);
	        }
	        // apply the default endpoints
	        result.ingestionendpoint = result.ingestionendpoint || DEFAULT_BREEZE_ENDPOINT;
	    }
	    return result;
	}

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	// THIS FILE WAS AUTOGENERATED
	/**
	 * Data struct to contain only C section with custom fields.
	 */
	var Base = /** @class */ (function () {
	    function Base() {
	    }
	    return Base;
	}());

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/**
	 * Data struct to contain both B and C sections.
	 */
	var Data = /** @class */ (function (_super) {
	    __extendsFn(Data, _super);
	    function Data() {
	        return _super.call(this) || this;
	    }
	    return Data;
	}(Base));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	/**
	 * System variables for a telemetry item.
	 */
	var Envelope = /** @class */ (function () {
	    function Envelope() {
	        /**
	         * Envelope version. For internal use only. By assigning this the default, it will not be serialized within the payload unless changed to a value other than #1.
	         */
	        this.ver = 1;
	        /**
	         * Sampling rate used in application. This telemetry item represents 1 / sampleRate actual telemetry items.
	         */
	        this.sampleRate = 100.0;
	        /**
	         * Key/value collection of context properties. See ContextTagKeys for information on available properties.
	         */
	        this.tags = {};
	    }
	    return Envelope;
	}());

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var Envelope$1 = /** @class */ (function (_super) {
	    __extendsFn(Envelope, _super);
	    /**
	     * Constructs a new instance of telemetry data.
	     */
	    function Envelope(logger, data, name) {
	        var _this = _super.call(this) || this;
	        _this.name = dataSanitizeString(logger, name) || strNotSpecified;
	        _this.data = data;
	        _this.time = toISOString(new Date());
	        _this.aiDataContract = {
	            time: 1 /* Required */,
	            iKey: 1 /* Required */,
	            name: 1 /* Required */,
	            sampleRate: function () {
	                return (_this.sampleRate === 100) ? 4 /* Hidden */ : 1 /* Required */;
	            },
	            tags: 1 /* Required */,
	            data: 1 /* Required */
	        };
	        return _this;
	    }
	    return Envelope;
	}(Envelope));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	/**
	 * Instances of Event represent structured event records that can be grouped and searched by their properties. Event data item also creates a metric of event count by name.
	 */
	var EventData = /** @class */ (function () {
	    function EventData() {
	        /**
	         * Schema version
	         */
	        this.ver = 2;
	        /**
	         * Collection of custom properties.
	         */
	        this.properties = {};
	        /**
	         * Collection of custom measurements.
	         */
	        this.measurements = {};
	    }
	    return EventData;
	}());

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var Event$1 = /** @class */ (function (_super) {
	    __extendsFn(Event, _super);
	    /**
	     * Constructs a new instance of the EventTelemetry object
	     */
	    function Event(logger, name, properties, measurements) {
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            ver: 1 /* Required */,
	            name: 1 /* Required */,
	            properties: 0 /* Default */,
	            measurements: 0 /* Default */
	        };
	        _this.name = dataSanitizeString(logger, name) || strNotSpecified;
	        _this.properties = dataSanitizeProperties(logger, properties);
	        _this.measurements = dataSanitizeMeasurements(logger, measurements);
	        return _this;
	    }
	    Event.envelopeType = "Microsoft.ApplicationInsights.{0}.Event";
	    Event.dataType = "EventData";
	    return Event;
	}(EventData));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	// THIS FILE WAS AUTOGENERATED
	/**
	 * Stack frame information.
	 */
	var StackFrame = /** @class */ (function () {
	    function StackFrame() {
	    }
	    return StackFrame;
	}());

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	/**
	 * An instance of Exception represents a handled or unhandled exception that occurred during execution of the monitored application.
	 */
	var ExceptionData = /** @class */ (function () {
	    function ExceptionData() {
	        /**
	         * Schema version
	         */
	        this.ver = 2;
	        /**
	         * Exception chain - list of inner exceptions.
	         */
	        this.exceptions = [];
	        /**
	         * Collection of custom properties.
	         */
	        this.properties = {};
	        /**
	         * Collection of custom measurements.
	         */
	        this.measurements = {};
	    }
	    return ExceptionData;
	}());

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	/**
	 * Exception details of the exception in a chain.
	 */
	var ExceptionDetails = /** @class */ (function () {
	    function ExceptionDetails() {
	        /**
	         * Indicates if full exception stack is provided in the exception. The stack may be trimmed, such as in the case of a StackOverflow exception.
	         */
	        this.hasFullStack = true;
	        /**
	         * List of stack frames. Either stack or parsedStack should have a value.
	         */
	        this.parsedStack = [];
	    }
	    return ExceptionDetails;
	}());

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var NoMethod = "<no_method>";
	var strError = "error";
	var strStack = "stack";
	var strStackDetails = "stackDetails";
	var strErrorSrc = "errorSrc";
	var strMessage = "message";
	var strDescription = "description";
	function _stringify(value, convertToString) {
	    var result = value;
	    if (result && !isString(result)) {
	        if (JSON && JSON.stringify) {
	            result = JSON.stringify(value);
	            if (convertToString && (!result || result === "{}")) {
	                if (isFunction$1(value.toString)) {
	                    result = value.toString();
	                }
	                else {
	                    result = "" + value;
	                }
	            }
	        }
	        else {
	            result = "" + value + " - (Missing JSON.stringify)";
	        }
	    }
	    return result || "";
	}
	function _formatMessage(theEvent, errorType) {
	    var evtMessage = theEvent;
	    if (theEvent) {
	        if (evtMessage && !isString(evtMessage)) {
	            evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage;
	        }
	        // Make sure the message is a string
	        if (evtMessage && !isString(evtMessage)) {
	            // tslint:disable-next-line: prefer-conditional-expression
	            evtMessage = _stringify(evtMessage, true);
	        }
	        if (theEvent["filename"]) {
	            // Looks like an event object with filename
	            evtMessage = evtMessage + " @" + (theEvent["filename"] || "") + ":" + (theEvent["lineno"] || "?") + ":" + (theEvent["colno"] || "?");
	        }
	    }
	    // Automatically add the error type to the message if it does already appear to be present
	    if (errorType && errorType !== "String" && errorType !== "Object" && errorType !== "Error" && (evtMessage || "").indexOf(errorType) === -1) {
	        evtMessage = errorType + ": " + evtMessage;
	    }
	    return evtMessage || "";
	}
	function _isExceptionDetailsInternal(value) {
	    if (isObject$1(value)) {
	        return "hasFullStack" in value && "typeName" in value;
	    }
	    return false;
	}
	function _isExceptionInternal(value) {
	    if (isObject$1(value)) {
	        return ("ver" in value && "exceptions" in value && "properties" in value);
	    }
	    return false;
	}
	function _isStackDetails(details) {
	    return details && details.src && isString(details.src) && details.obj && isArray$1(details.obj);
	}
	function _convertStackObj(errorStack) {
	    var src = errorStack || "";
	    if (!isString(src)) {
	        if (isString(src[strStack])) {
	            src = src[strStack];
	        }
	        else {
	            src = "" + src;
	        }
	    }
	    var items = src.split("\n");
	    return {
	        src: src,
	        obj: items
	    };
	}
	function _getOperaStack(errorMessage) {
	    var stack = [];
	    var lines = errorMessage.split("\n");
	    for (var lp = 0; lp < lines.length; lp++) {
	        var entry = lines[lp];
	        if (lines[lp + 1]) {
	            entry += "@" + lines[lp + 1];
	            lp++;
	        }
	        stack.push(entry);
	    }
	    return {
	        src: errorMessage,
	        obj: stack
	    };
	}
	function _getStackFromErrorObj(errorObj) {
	    var details = null;
	    if (errorObj) {
	        try {
	            /* Using bracket notation is support older browsers (IE 7/8 -- dont remember the version) that throw when using dot
	            notation for undefined objects and we don't want to loose the error from being reported */
	            if (errorObj[strStack]) {
	                // Chrome/Firefox
	                details = _convertStackObj(errorObj[strStack]);
	            }
	            else if (errorObj[strError] && errorObj[strError][strStack]) {
	                // Edge error event provides the stack and error object
	                details = _convertStackObj(errorObj[strError][strStack]);
	            }
	            else if (errorObj['exception'] && errorObj.exception[strStack]) {
	                details = _convertStackObj(errorObj.exception[strStack]);
	            }
	            else if (_isStackDetails(errorObj)) {
	                details = errorObj;
	            }
	            else if (_isStackDetails(errorObj[strStackDetails])) {
	                details = errorObj[strStackDetails];
	            }
	            else if (window['opera'] && errorObj[strMessage]) {
	                // Opera
	                details = _getOperaStack(errorObj.message);
	            }
	            else if (isString(errorObj)) {
	                details = _convertStackObj(errorObj);
	            }
	            else {
	                var evtMessage = errorObj[strMessage] || errorObj[strDescription] || "";
	                if (isString(errorObj[strErrorSrc])) {
	                    if (evtMessage) {
	                        evtMessage += "\n";
	                    }
	                    evtMessage += " from " + errorObj[strErrorSrc];
	                }
	                if (evtMessage) {
	                    details = _convertStackObj(evtMessage);
	                }
	            }
	        }
	        catch (e) {
	            // something unexpected happened so to avoid failing to report any error lets swallow the exception 
	            // and fallback to the callee/caller method
	            details = _convertStackObj(e);
	        }
	    }
	    return details || {
	        src: "",
	        obj: null
	    };
	}
	function _formatStackTrace(stackDetails) {
	    var stack = "";
	    if (stackDetails) {
	        if (stackDetails.obj) {
	            arrForEach(stackDetails.obj, function (entry) {
	                stack += entry + "\n";
	            });
	        }
	        else {
	            stack = stackDetails.src || "";
	        }
	    }
	    return stack;
	}
	function _parseStack(stack) {
	    var parsedStack;
	    var frames = stack.obj;
	    if (frames && frames.length > 0) {
	        parsedStack = [];
	        var level_1 = 0;
	        var totalSizeInBytes_1 = 0;
	        arrForEach(frames, function (frame) {
	            var theFrame = frame.toString();
	            if (_StackFrame.regex.test(theFrame)) {
	                var parsedFrame = new _StackFrame(theFrame, level_1++);
	                totalSizeInBytes_1 += parsedFrame.sizeInBytes;
	                parsedStack.push(parsedFrame);
	            }
	        });
	        // DP Constraint - exception parsed stack must be < 32KB
	        // remove frames from the middle to meet the threshold
	        var exceptionParsedStackThreshold = 32 * 1024;
	        if (totalSizeInBytes_1 > exceptionParsedStackThreshold) {
	            var left = 0;
	            var right = parsedStack.length - 1;
	            var size = 0;
	            var acceptedLeft = left;
	            var acceptedRight = right;
	            while (left < right) {
	                // check size
	                var lSize = parsedStack[left].sizeInBytes;
	                var rSize = parsedStack[right].sizeInBytes;
	                size += lSize + rSize;
	                if (size > exceptionParsedStackThreshold) {
	                    // remove extra frames from the middle
	                    var howMany = acceptedRight - acceptedLeft + 1;
	                    parsedStack.splice(acceptedLeft, howMany);
	                    break;
	                }
	                // update pointers
	                acceptedLeft = left;
	                acceptedRight = right;
	                left++;
	                right--;
	            }
	        }
	    }
	    return parsedStack;
	}
	function _getErrorType(errorType) {
	    // Gets the Error Type by passing the constructor (used to get the true type of native error object).
	    var typeName = "";
	    if (errorType) {
	        typeName = errorType.typeName || errorType.name || "";
	        if (!typeName) {
	            try {
	                var funcNameRegex = /function (.{1,200})\(/;
	                var results = (funcNameRegex).exec((errorType).constructor.toString());
	                typeName = (results && results.length > 1) ? results[1] : "";
	            }
	            catch (e) {
	                // eslint-disable-next-line no-empty -- Ignoring any failures as nothing we can do
	            }
	        }
	    }
	    return typeName;
	}
	/**
	 * Formats the provided errorObj for display and reporting, it may be a String, Object, integer or undefined depending on the browser.
	 * @param errorObj The supplied errorObj
	 */
	function _formatErrorCode(errorObj) {
	    if (errorObj) {
	        try {
	            if (!isString(errorObj)) {
	                var errorType = _getErrorType(errorObj);
	                var result = _stringify(errorObj, false);
	                if (!result || result === "{}") {
	                    if (errorObj[strError]) {
	                        // Looks like an MS Error Event
	                        errorObj = errorObj[strError];
	                        errorType = _getErrorType(errorObj);
	                    }
	                    result = _stringify(errorObj, true);
	                }
	                if (result.indexOf(errorType) !== 0 && errorType !== "String") {
	                    return errorType + ":" + result;
	                }
	                return result;
	            }
	        }
	        catch (e) {
	            // eslint-disable-next-line no-empty -- Ignoring any failures as nothing we can do
	        }
	    }
	    // Fallback to just letting the object format itself into a string
	    return "" + (errorObj || "");
	}
	var Exception = /** @class */ (function (_super) {
	    __extendsFn(Exception, _super);
	    /**
	     * Constructs a new instance of the ExceptionTelemetry object
	     */
	    function Exception(logger, exception, properties, measurements, severityLevel, id) {
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            ver: 1 /* Required */,
	            exceptions: 1 /* Required */,
	            severityLevel: 0 /* Default */,
	            properties: 0 /* Default */,
	            measurements: 0 /* Default */
	        };
	        if (!_isExceptionInternal(exception)) {
	            if (!properties) {
	                properties = {};
	            }
	            _this.exceptions = [new _ExceptionDetails(logger, exception, properties)];
	            _this.properties = dataSanitizeProperties(logger, properties);
	            _this.measurements = dataSanitizeMeasurements(logger, measurements);
	            if (severityLevel) {
	                _this.severityLevel = severityLevel;
	            }
	            if (id) {
	                _this.id = id;
	            }
	        }
	        else {
	            _this.exceptions = exception.exceptions;
	            _this.properties = exception.properties;
	            _this.measurements = exception.measurements;
	            if (exception.severityLevel) {
	                _this.severityLevel = exception.severityLevel;
	            }
	            if (exception.id) {
	                _this.id = exception.id;
	            }
	            if (exception.problemGroup) {
	                _this.problemGroup = exception.problemGroup;
	            }
	            // bool/int types, use isNullOrUndefined
	            _this.ver = 2; // TODO: handle the CS"4.0" ==> breeze 2 conversion in a better way
	            if (!isNullOrUndefined(exception.isManual)) {
	                _this.isManual = exception.isManual;
	            }
	        }
	        return _this;
	    }
	    Exception.CreateAutoException = function (message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {
	        var errorType = _getErrorType(error || evt || message);
	        return {
	            message: _formatMessage(message, errorType),
	            url: url,
	            lineNumber: lineNumber,
	            columnNumber: columnNumber,
	            error: _formatErrorCode(error || evt || message),
	            evt: _formatErrorCode(evt || message),
	            typeName: errorType,
	            stackDetails: _getStackFromErrorObj(stack || error || evt),
	            errorSrc: errorSrc
	        };
	    };
	    Exception.CreateFromInterface = function (logger, exception, properties, measurements) {
	        var exceptions = exception.exceptions
	            && arrMap(exception.exceptions, function (ex) { return _ExceptionDetails.CreateFromInterface(logger, ex); });
	        var exceptionData = new Exception(logger, __assignFn({}, exception, { exceptions: exceptions }), properties, measurements);
	        return exceptionData;
	    };
	    Exception.prototype.toInterface = function () {
	        var _a = this, exceptions = _a.exceptions, properties = _a.properties, measurements = _a.measurements, severityLevel = _a.severityLevel, ver = _a.ver, problemGroup = _a.problemGroup, id = _a.id, isManual = _a.isManual;
	        var exceptionDetailsInterface = exceptions instanceof Array
	            && arrMap(exceptions, function (exception) { return exception.toInterface(); })
	            || undefined;
	        return {
	            ver: "4.0",
	            exceptions: exceptionDetailsInterface,
	            severityLevel: severityLevel,
	            properties: properties,
	            measurements: measurements,
	            problemGroup: problemGroup,
	            id: id,
	            isManual: isManual
	        };
	    };
	    /**
	     * Creates a simple exception with 1 stack frame. Useful for manual constracting of exception.
	     */
	    Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {
	        return {
	            exceptions: [
	                {
	                    hasFullStack: true,
	                    message: message,
	                    stack: details,
	                    typeName: typeName
	                }
	            ]
	        };
	    };
	    Exception.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception";
	    Exception.dataType = "ExceptionData";
	    Exception.formatError = _formatErrorCode;
	    return Exception;
	}(ExceptionData));
	var _ExceptionDetails = /** @class */ (function (_super) {
	    __extendsFn(_ExceptionDetails, _super);
	    function _ExceptionDetails(logger, exception, properties) {
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            id: 0 /* Default */,
	            outerId: 0 /* Default */,
	            typeName: 1 /* Required */,
	            message: 1 /* Required */,
	            hasFullStack: 0 /* Default */,
	            stack: 0 /* Default */,
	            parsedStack: 2 /* Array */
	        };
	        if (!_isExceptionDetailsInternal(exception)) {
	            var error = exception;
	            var evt = error && error.evt;
	            if (!isError(error)) {
	                error = error[strError] || evt || error;
	            }
	            _this.typeName = dataSanitizeString(logger, _getErrorType(error)) || strNotSpecified;
	            _this.message = dataSanitizeMessage(logger, _formatMessage(exception || error, _this.typeName)) || strNotSpecified;
	            var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);
	            _this.parsedStack = _parseStack(stack);
	            _this[strStack] = dataSanitizeException(logger, _formatStackTrace(stack));
	            _this.hasFullStack = isArray$1(_this.parsedStack) && _this.parsedStack.length > 0;
	            if (properties) {
	                properties.typeName = properties.typeName || _this.typeName;
	            }
	        }
	        else {
	            _this.typeName = exception.typeName;
	            _this.message = exception.message;
	            _this[strStack] = exception[strStack];
	            _this.parsedStack = exception.parsedStack;
	            _this.hasFullStack = exception.hasFullStack;
	        }
	        return _this;
	    }
	    _ExceptionDetails.prototype.toInterface = function () {
	        var parsedStack = this.parsedStack instanceof Array
	            && arrMap(this.parsedStack, function (frame) { return frame.toInterface(); });
	        var exceptionDetailsInterface = {
	            id: this.id,
	            outerId: this.outerId,
	            typeName: this.typeName,
	            message: this.message,
	            hasFullStack: this.hasFullStack,
	            stack: this[strStack],
	            parsedStack: parsedStack || undefined
	        };
	        return exceptionDetailsInterface;
	    };
	    _ExceptionDetails.CreateFromInterface = function (logger, exception) {
	        var parsedStack = (exception.parsedStack instanceof Array
	            && arrMap(exception.parsedStack, function (frame) { return _StackFrame.CreateFromInterface(frame); }))
	            || exception.parsedStack;
	        var exceptionDetails = new _ExceptionDetails(logger, __assignFn({}, exception, { parsedStack: parsedStack }));
	        return exceptionDetails;
	    };
	    return _ExceptionDetails;
	}(ExceptionDetails));
	var _StackFrame = /** @class */ (function (_super) {
	    __extendsFn(_StackFrame, _super);
	    function _StackFrame(sourceFrame, level) {
	        var _this = _super.call(this) || this;
	        _this.sizeInBytes = 0;
	        _this.aiDataContract = {
	            level: 1 /* Required */,
	            method: 1 /* Required */,
	            assembly: 0 /* Default */,
	            fileName: 0 /* Default */,
	            line: 0 /* Default */
	        };
	        // Not converting this to isString() as typescript uses this logic to "understand" the different
	        // types for the 2 different code paths
	        if (typeof sourceFrame === "string") {
	            var frame = sourceFrame;
	            _this.level = level;
	            _this.method = NoMethod;
	            _this.assembly = strTrim(frame);
	            _this.fileName = "";
	            _this.line = 0;
	            var matches = frame.match(_StackFrame.regex);
	            if (matches && matches.length >= 5) {
	                _this.method = strTrim(matches[2]) || _this.method;
	                _this.fileName = strTrim(matches[4]);
	                _this.line = parseInt(matches[5]) || 0;
	            }
	        }
	        else {
	            _this.level = sourceFrame.level;
	            _this.method = sourceFrame.method;
	            _this.assembly = sourceFrame.assembly;
	            _this.fileName = sourceFrame.fileName;
	            _this.line = sourceFrame.line;
	            _this.sizeInBytes = 0;
	        }
	        _this.sizeInBytes += _this.method.length;
	        _this.sizeInBytes += _this.fileName.length;
	        _this.sizeInBytes += _this.assembly.length;
	        // todo: these might need to be removed depending on how the back-end settles on their size calculation
	        _this.sizeInBytes += _StackFrame.baseSize;
	        _this.sizeInBytes += _this.level.toString().length;
	        _this.sizeInBytes += _this.line.toString().length;
	        return _this;
	    }
	    _StackFrame.CreateFromInterface = function (frame) {
	        return new _StackFrame(frame, null /* level is available in frame interface */);
	    };
	    _StackFrame.prototype.toInterface = function () {
	        return {
	            level: this.level,
	            method: this.method,
	            assembly: this.assembly,
	            fileName: this.fileName,
	            line: this.line
	        };
	    };
	    // regex to match stack frames from ie/chrome/ff
	    // methodName=$2, fileName=$4, lineNo=$5, column=$6
	    _StackFrame.regex = /^([\s]+at)?[\s]{0,50}([^\@\()]+?)[\s]{0,50}(\@|\()([^\(\n]+):([0-9]+):([0-9]+)(\)?)$/;
	    _StackFrame.baseSize = 58; // '{"method":"","level":,"assembly":"","fileName":"","line":}'.length
	    return _StackFrame;
	}(StackFrame));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	/**
	 * An instance of the Metric item is a list of measurements (single data points) and/or aggregations.
	 */
	var MetricData = /** @class */ (function () {
	    function MetricData() {
	        /**
	         * Schema version
	         */
	        this.ver = 2;
	        /**
	         * List of metrics. Only one metric in the list is currently supported by Application Insights storage. If multiple data points were sent only the first one will be used.
	         */
	        this.metrics = [];
	        /**
	         * Collection of custom properties.
	         */
	        this.properties = {};
	        /**
	         * Collection of custom measurements.
	         */
	        this.measurements = {};
	    }
	    return MetricData;
	}());

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	// THIS FILE WAS AUTOGENERATED
	/**
	 * Type of the metric data measurement.
	 */
	var DataPointType;
	(function (DataPointType) {
	    DataPointType[DataPointType["Measurement"] = 0] = "Measurement";
	    DataPointType[DataPointType["Aggregation"] = 1] = "Aggregation";
	})(DataPointType || (DataPointType = {}));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/**
	 * Metric data single measurement.
	 */
	var DataPoint = /** @class */ (function () {
	    function DataPoint() {
	        /**
	         * Metric type. Single measurement or the aggregated value.
	         */
	        this.kind = DataPointType.Measurement;
	    }
	    return DataPoint;
	}());

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var DataPoint$1 = /** @class */ (function (_super) {
	    __extendsFn(DataPoint, _super);
	    function DataPoint() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The data contract for serializing this object.
	         */
	        _this.aiDataContract = {
	            name: 1 /* Required */,
	            kind: 0 /* Default */,
	            value: 1 /* Required */,
	            count: 0 /* Default */,
	            min: 0 /* Default */,
	            max: 0 /* Default */,
	            stdDev: 0 /* Default */
	        };
	        return _this;
	    }
	    return DataPoint;
	}(DataPoint));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var Metric = /** @class */ (function (_super) {
	    __extendsFn(Metric, _super);
	    /**
	     * Constructs a new instance of the MetricTelemetry object
	     */
	    function Metric(logger, name, value, count, min, max, properties, measurements) {
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            ver: 1 /* Required */,
	            metrics: 1 /* Required */,
	            properties: 0 /* Default */
	        };
	        var dataPoint = new DataPoint$1();
	        dataPoint.count = count > 0 ? count : undefined;
	        dataPoint.max = isNaN(max) || max === null ? undefined : max;
	        dataPoint.min = isNaN(min) || min === null ? undefined : min;
	        dataPoint.name = dataSanitizeString(logger, name) || strNotSpecified;
	        dataPoint.value = value;
	        _this.metrics = [dataPoint];
	        _this.properties = dataSanitizeProperties(logger, properties);
	        _this.measurements = dataSanitizeMeasurements(logger, measurements);
	        return _this;
	    }
	    Metric.envelopeType = "Microsoft.ApplicationInsights.{0}.Metric";
	    Metric.dataType = "MetricData";
	    return Metric;
	}(MetricData));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/**
	 * An instance of PageView represents a generic action on a page like a button click. It is also the base type for PageView.
	 */
	var PageViewData = /** @class */ (function (_super) {
	    __extendsFn(PageViewData, _super);
	    function PageViewData() {
	        var _this = _super.call(this) || this;
	        /**
	         * Schema version
	         */
	        _this.ver = 2;
	        /**
	         * Collection of custom properties.
	         */
	        _this.properties = {};
	        /**
	         * Collection of custom measurements.
	         */
	        _this.measurements = {};
	        return _this;
	    }
	    return PageViewData;
	}(EventData));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var PageView = /** @class */ (function (_super) {
	    __extendsFn(PageView, _super);
	    /**
	     * Constructs a new instance of the PageEventTelemetry object
	     */
	    function PageView(logger, name, url, durationMs, properties, measurements, id) {
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            ver: 1 /* Required */,
	            name: 0 /* Default */,
	            url: 0 /* Default */,
	            duration: 0 /* Default */,
	            properties: 0 /* Default */,
	            measurements: 0 /* Default */,
	            id: 0 /* Default */
	        };
	        _this.id = dataSanitizeId(logger, id);
	        _this.url = dataSanitizeUrl(logger, url);
	        _this.name = dataSanitizeString(logger, name) || strNotSpecified;
	        if (!isNaN(durationMs)) {
	            _this.duration = msToTimeSpan(durationMs);
	        }
	        _this.properties = dataSanitizeProperties(logger, properties);
	        _this.measurements = dataSanitizeMeasurements(logger, measurements);
	        return _this;
	    }
	    PageView.envelopeType = "Microsoft.ApplicationInsights.{0}.Pageview";
	    PageView.dataType = "PageviewData";
	    return PageView;
	}(PageViewData));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	/**
	 * An instance of Remote Dependency represents an interaction of the monitored component with a remote component/service like SQL or an HTTP endpoint.
	 */
	var RemoteDependencyData = /** @class */ (function () {
	    function RemoteDependencyData() {
	        /**
	         * Schema version
	         */
	        this.ver = 2;
	        /**
	         * Indication of successful or unsuccessful call.
	         */
	        this.success = true;
	        /**
	         * Collection of custom properties.
	         */
	        this.properties = {};
	        /**
	         * Collection of custom measurements.
	         */
	        this.measurements = {};
	    }
	    return RemoteDependencyData;
	}());

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var RemoteDependencyData$1 = /** @class */ (function (_super) {
	    __extendsFn(RemoteDependencyData, _super);
	    /**
	     * Constructs a new instance of the RemoteDependencyData object
	     */
	    function RemoteDependencyData(logger, id, absoluteUrl, commandName, value, success, resultCode, method, requestAPI, correlationContext, properties, measurements) {
	        if (requestAPI === void 0) { requestAPI = "Ajax"; }
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            id: 1 /* Required */,
	            ver: 1 /* Required */,
	            name: 0 /* Default */,
	            resultCode: 0 /* Default */,
	            duration: 0 /* Default */,
	            success: 0 /* Default */,
	            data: 0 /* Default */,
	            target: 0 /* Default */,
	            type: 0 /* Default */,
	            properties: 0 /* Default */,
	            measurements: 0 /* Default */,
	            kind: 0 /* Default */,
	            value: 0 /* Default */,
	            count: 0 /* Default */,
	            min: 0 /* Default */,
	            max: 0 /* Default */,
	            stdDev: 0 /* Default */,
	            dependencyKind: 0 /* Default */,
	            dependencySource: 0 /* Default */,
	            commandName: 0 /* Default */,
	            dependencyTypeName: 0 /* Default */
	        };
	        _this.id = id;
	        _this.duration = msToTimeSpan(value);
	        _this.success = success;
	        _this.resultCode = resultCode + "";
	        _this.type = dataSanitizeString(logger, requestAPI);
	        var dependencyFields = AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName);
	        _this.data = dataSanitizeUrl(logger, commandName) || dependencyFields.data; // get a value from hosturl if commandName not available
	        _this.target = dataSanitizeString(logger, dependencyFields.target);
	        if (correlationContext) {
	            _this.target = _this.target + " | " + correlationContext;
	        }
	        _this.name = dataSanitizeString(logger, dependencyFields.name);
	        _this.properties = dataSanitizeProperties(logger, properties);
	        _this.measurements = dataSanitizeMeasurements(logger, measurements);
	        return _this;
	    }
	    RemoteDependencyData.envelopeType = "Microsoft.ApplicationInsights.{0}.RemoteDependency";
	    RemoteDependencyData.dataType = "RemoteDependencyData";
	    return RemoteDependencyData;
	}(RemoteDependencyData));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	/**
	 * Instances of Message represent printf-like trace statements that are text-searched. Log4Net, NLog and other text-based log file entries are translated into intances of this type. The message does not have measurements.
	 */
	var MessageData = /** @class */ (function () {
	    function MessageData() {
	        /**
	         * Schema version
	         */
	        this.ver = 2;
	        /**
	         * Collection of custom properties.
	         */
	        this.properties = {};
	        /**
	         * Collection of custom measurements.
	         */
	        this.measurements = {};
	    }
	    return MessageData;
	}());

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var Trace = /** @class */ (function (_super) {
	    __extendsFn(Trace, _super);
	    /**
	     * Constructs a new instance of the TraceTelemetry object
	     */
	    function Trace(logger, message, severityLevel, properties, measurements) {
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            ver: 1 /* Required */,
	            message: 1 /* Required */,
	            severityLevel: 0 /* Default */,
	            properties: 0 /* Default */
	        };
	        message = message || strNotSpecified;
	        _this.message = dataSanitizeMessage(logger, message);
	        _this.properties = dataSanitizeProperties(logger, properties);
	        _this.measurements = dataSanitizeMeasurements(logger, measurements);
	        if (severityLevel) {
	            _this.severityLevel = severityLevel;
	        }
	        return _this;
	    }
	    Trace.envelopeType = "Microsoft.ApplicationInsights.{0}.Message";
	    Trace.dataType = "MessageData";
	    return Trace;
	}(MessageData));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/**
	 * An instance of PageViewPerf represents: a page view with no performance data, a page view with performance data, or just the performance data of an earlier page request.
	 */
	var PageViewPerfData = /** @class */ (function (_super) {
	    __extendsFn(PageViewPerfData, _super);
	    function PageViewPerfData() {
	        var _this = _super.call(this) || this;
	        /**
	         * Schema version
	         */
	        _this.ver = 2;
	        /**
	         * Collection of custom properties.
	         */
	        _this.properties = {};
	        /**
	         * Collection of custom measurements.
	         */
	        _this.measurements = {};
	        return _this;
	    }
	    return PageViewPerfData;
	}(PageViewData));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var PageViewPerformance = /** @class */ (function (_super) {
	    __extendsFn(PageViewPerformance, _super);
	    /**
	     * Constructs a new instance of the PageEventTelemetry object
	     */
	    function PageViewPerformance(logger, name, url, unused, properties, measurements, cs4BaseData) {
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            ver: 1 /* Required */,
	            name: 0 /* Default */,
	            url: 0 /* Default */,
	            duration: 0 /* Default */,
	            perfTotal: 0 /* Default */,
	            networkConnect: 0 /* Default */,
	            sentRequest: 0 /* Default */,
	            receivedResponse: 0 /* Default */,
	            domProcessing: 0 /* Default */,
	            properties: 0 /* Default */,
	            measurements: 0 /* Default */
	        };
	        _this.url = dataSanitizeUrl(logger, url);
	        _this.name = dataSanitizeString(logger, name) || strNotSpecified;
	        _this.properties = dataSanitizeProperties(logger, properties);
	        _this.measurements = dataSanitizeMeasurements(logger, measurements);
	        if (cs4BaseData) {
	            _this.domProcessing = cs4BaseData.domProcessing;
	            _this.duration = cs4BaseData.duration;
	            _this.networkConnect = cs4BaseData.networkConnect;
	            _this.perfTotal = cs4BaseData.perfTotal;
	            _this.receivedResponse = cs4BaseData.receivedResponse;
	            _this.sentRequest = cs4BaseData.sentRequest;
	        }
	        return _this;
	    }
	    PageViewPerformance.envelopeType = "Microsoft.ApplicationInsights.{0}.PageviewPerformance";
	    PageViewPerformance.dataType = "PageviewPerformanceData";
	    return PageViewPerformance;
	}(PageViewPerfData));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var Data$1 = /** @class */ (function (_super) {
	    __extendsFn(Data, _super);
	    /**
	     * Constructs a new instance of telemetry data.
	     */
	    function Data(baseType, data) {
	        var _this = _super.call(this) || this;
	        /**
	         * The data contract for serializing this object.
	         */
	        _this.aiDataContract = {
	            baseType: 1 /* Required */,
	            baseData: 1 /* Required */
	        };
	        _this.baseType = baseType;
	        _this.baseData = data;
	        return _this;
	    }
	    return Data;
	}(Data));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	// THIS FILE WAS AUTOGENERATED
	/**
	 * Defines the level of severity for the event.
	 */
	var SeverityLevel;
	(function (SeverityLevel) {
	    SeverityLevel[SeverityLevel["Verbose"] = 0] = "Verbose";
	    SeverityLevel[SeverityLevel["Information"] = 1] = "Information";
	    SeverityLevel[SeverityLevel["Warning"] = 2] = "Warning";
	    SeverityLevel[SeverityLevel["Error"] = 3] = "Error";
	    SeverityLevel[SeverityLevel["Critical"] = 4] = "Critical";
	})(SeverityLevel || (SeverityLevel = {}));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	function _aiNameFunc(baseName) {
	    var aiName = "ai." + baseName + ".";
	    return function (name) {
	        return aiName + name;
	    };
	}
	var _aiApplication = _aiNameFunc("application");
	var _aiDevice = _aiNameFunc("device");
	var _aiLocation = _aiNameFunc("location");
	var _aiOperation = _aiNameFunc("operation");
	var _aiSession = _aiNameFunc("session");
	var _aiUser = _aiNameFunc("user");
	var _aiCloud = _aiNameFunc("cloud");
	var _aiInternal = _aiNameFunc("internal");
	var ContextTagKeys = /** @class */ (function (_super) {
	    __extendsFn(ContextTagKeys, _super);
	    function ContextTagKeys() {
	        return _super.call(this) || this;
	    }
	    return ContextTagKeys;
	}(createClassFromInterface({
	    applicationVersion: _aiApplication("ver"),
	    applicationBuild: _aiApplication("build"),
	    applicationTypeId: _aiApplication("typeId"),
	    applicationId: _aiApplication("applicationId"),
	    applicationLayer: _aiApplication("layer"),
	    deviceId: _aiDevice("id"),
	    deviceIp: _aiDevice("ip"),
	    deviceLanguage: _aiDevice("language"),
	    deviceLocale: _aiDevice("locale"),
	    deviceModel: _aiDevice("model"),
	    deviceFriendlyName: _aiDevice("friendlyName"),
	    deviceNetwork: _aiDevice("network"),
	    deviceNetworkName: _aiDevice("networkName"),
	    deviceOEMName: _aiDevice("oemName"),
	    deviceOS: _aiDevice("os"),
	    deviceOSVersion: _aiDevice("osVersion"),
	    deviceRoleInstance: _aiDevice("roleInstance"),
	    deviceRoleName: _aiDevice("roleName"),
	    deviceScreenResolution: _aiDevice("screenResolution"),
	    deviceType: _aiDevice("type"),
	    deviceMachineName: _aiDevice("machineName"),
	    deviceVMName: _aiDevice("vmName"),
	    deviceBrowser: _aiDevice("browser"),
	    deviceBrowserVersion: _aiDevice("browserVersion"),
	    locationIp: _aiLocation("ip"),
	    locationCountry: _aiLocation("country"),
	    locationProvince: _aiLocation("province"),
	    locationCity: _aiLocation("city"),
	    operationId: _aiOperation("id"),
	    operationName: _aiOperation("name"),
	    operationParentId: _aiOperation("parentId"),
	    operationRootId: _aiOperation("rootId"),
	    operationSyntheticSource: _aiOperation("syntheticSource"),
	    operationCorrelationVector: _aiOperation("correlationVector"),
	    sessionId: _aiSession("id"),
	    sessionIsFirst: _aiSession("isFirst"),
	    sessionIsNew: _aiSession("isNew"),
	    userAccountAcquisitionDate: _aiUser("accountAcquisitionDate"),
	    userAccountId: _aiUser("accountId"),
	    userAgent: _aiUser("userAgent"),
	    userId: _aiUser("id"),
	    userStoreRegion: _aiUser("storeRegion"),
	    userAuthUserId: _aiUser("authUserId"),
	    userAnonymousUserAcquisitionDate: _aiUser("anonUserAcquisitionDate"),
	    userAuthenticatedUserAcquisitionDate: _aiUser("authUserAcquisitionDate"),
	    cloudName: _aiCloud("name"),
	    cloudRole: _aiCloud("role"),
	    cloudRoleVer: _aiCloud("roleVer"),
	    cloudRoleInstance: _aiCloud("roleInstance"),
	    cloudEnvironment: _aiCloud("environment"),
	    cloudLocation: _aiCloud("location"),
	    cloudDeploymentUnit: _aiCloud("deploymentUnit"),
	    internalNodeName: _aiInternal("nodeName"),
	    internalSdkVersion: _aiInternal("sdkVersion"),
	    internalAgentVersion: _aiInternal("agentVersion"),
	    internalSnippet: _aiInternal("snippet"),
	    internalSdkSrc: _aiInternal("sdkSrc")
	})));

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var TelemetryItemCreator = /** @class */ (function () {
	    function TelemetryItemCreator() {
	    }
	    /**
	     * Create a telemetry item that the 1DS channel understands
	     * @param item domain specific properties; part B
	     * @param baseType telemetry item type. ie PageViewData
	     * @param envelopeName name of the envelope. ie Microsoft.ApplicationInsights.<instrumentation key>.PageView
	     * @param customProperties user defined custom properties; part C
	     * @param systemProperties system properties that are added to the context; part A
	     * @returns ITelemetryItem that is sent to channel
	     */
	    TelemetryItemCreator.create = function (item, baseType, envelopeName, logger, customProperties, systemProperties) {
	        envelopeName = dataSanitizeString(logger, envelopeName) || strNotSpecified;
	        if (isNullOrUndefined(item) ||
	            isNullOrUndefined(baseType) ||
	            isNullOrUndefined(envelopeName)) {
	            throw Error("Input doesn't contain all required fields");
	        }
	        var telemetryItem = {
	            name: envelopeName,
	            time: toISOString(new Date()),
	            iKey: "",
	            ext: systemProperties ? systemProperties : {},
	            tags: [],
	            data: {},
	            baseType: baseType,
	            baseData: item // Part B
	        };
	        // Part C
	        if (!isNullOrUndefined(customProperties)) {
	            objForEachKey(customProperties, function (prop, value) {
	                telemetryItem.data[prop] = value;
	            });
	        }
	        return telemetryItem;
	    };
	    return TelemetryItemCreator;
	}());

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var Extensions = {
	    UserExt: "user",
	    DeviceExt: "device",
	    TraceExt: "trace",
	    WebExt: "web",
	    AppExt: "app",
	    OSExt: "os",
	    SessionExt: "ses",
	    SDKExt: "sdk"
	};
	var CtxTagKeys = new ContextTagKeys();

	/*
	 * Application Insights JavaScript SDK - Common, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var PropertiesPluginIdentifier = "AppInsightsPropertiesPlugin";
	var BreezeChannelIdentifier = "AppInsightsChannelPlugin";
	var AnalyticsPluginIdentifier = "ApplicationInsightsAnalytics";

	/*
	 * Application Insights JavaScript SDK - Web Analytics, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/**
	 * Class encapsulates sending page views and page view performance telemetry.
	 */
	var PageViewManager = /** @class */ (function () {
	    function PageViewManager(appInsights, overridePageViewDuration, core, pageViewPerformanceManager) {
	        dynamicProto(PageViewManager, this, function (_self) {
	            var intervalHandle = null;
	            var itemQueue = [];
	            var pageViewPerformanceSent = false;
	            var _logger;
	            if (core) {
	                _logger = core.logger;
	            }
	            function _flushChannels() {
	                if (core) {
	                    arrForEach(core.getTransmissionControls(), function (queues) {
	                        arrForEach(queues, function (q) { return q.flush(true); });
	                    });
	                }
	            }
	            function _addQueue(cb) {
	                itemQueue.push(cb);
	                if (!intervalHandle) {
	                    intervalHandle = setInterval((function () {
	                        var allItems = itemQueue.slice(0);
	                        var doFlush = false;
	                        itemQueue = [];
	                        arrForEach(allItems, function (item) {
	                            if (!item()) {
	                                // Not processed so rescheduled
	                                itemQueue.push(item);
	                            }
	                            else {
	                                doFlush = true;
	                            }
	                        });
	                        if (itemQueue.length === 0) {
	                            clearInterval(intervalHandle);
	                            intervalHandle = null;
	                        }
	                        if (doFlush) {
	                            // We process at least one item so flush the queue
	                            _flushChannels();
	                        }
	                    }), 100);
	                }
	            }
	            _self.trackPageView = function (pageView, customProperties) {
	                var name = pageView.name;
	                if (isNullOrUndefined(name) || typeof name !== "string") {
	                    var doc = getDocument();
	                    name = pageView.name = doc && doc.title || "";
	                }
	                var uri = pageView.uri;
	                if (isNullOrUndefined(uri) || typeof uri !== "string") {
	                    var location_1 = getLocation();
	                    uri = pageView.uri = location_1 && location_1.href || "";
	                }
	                // case 1a. if performance timing is not supported by the browser, send the page view telemetry with the duration provided by the user. If the user
	                // do not provide the duration, set duration to undefined
	                // Also this is case 4
	                if (!pageViewPerformanceManager.isPerformanceTimingSupported()) {
	                    appInsights.sendPageViewInternal(pageView, customProperties);
	                    _flushChannels();
	                    // no navigation timing (IE 8, iOS Safari 8.4, Opera Mini 8 - see http://caniuse.com/#feat=nav-timing)
	                    _logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.NavigationTimingNotSupported, "trackPageView: navigation timing API used for calculation of page duration is not supported in this browser. This page view will be collected without duration and timing info.");
	                    return;
	                }
	                var pageViewSent = false;
	                var customDuration;
	                // if the performance timing is supported by the browser, calculate the custom duration
	                var start = pageViewPerformanceManager.getPerformanceTiming().navigationStart;
	                if (start > 0) {
	                    customDuration = dateTimeUtilsDuration(start, +new Date);
	                    if (!pageViewPerformanceManager.shouldCollectDuration(customDuration)) {
	                        customDuration = undefined;
	                    }
	                }
	                // if the user has provided duration, send a page view telemetry with the provided duration. Otherwise, if
	                // overridePageViewDuration is set to true, send a page view telemetry with the custom duration calculated earlier
	                var duration;
	                if (!isNullOrUndefined(customProperties) &&
	                    !isNullOrUndefined(customProperties.duration)) {
	                    duration = customProperties.duration;
	                }
	                if (overridePageViewDuration || !isNaN(duration)) {
	                    if (isNaN(duration)) {
	                        // case 3
	                        if (!customProperties) {
	                            customProperties = {};
	                        }
	                        customProperties["duration"] = customDuration;
	                    }
	                    // case 2
	                    appInsights.sendPageViewInternal(pageView, customProperties);
	                    _flushChannels();
	                    pageViewSent = true;
	                }
	                // now try to send the page view performance telemetry
	                var maxDurationLimit = 60000;
	                if (!customProperties) {
	                    customProperties = {};
	                }
	                // Queue the event for processing
	                _addQueue(function () {
	                    var processed = false;
	                    try {
	                        if (pageViewPerformanceManager.isPerformanceTimingDataReady()) {
	                            processed = true;
	                            var pageViewPerformance = {
	                                name: name,
	                                uri: uri
	                            };
	                            pageViewPerformanceManager.populatePageViewPerformanceEvent(pageViewPerformance);
	                            if (!pageViewPerformance.isValid && !pageViewSent) {
	                                // If navigation timing gives invalid numbers, then go back to "override page view duration" mode.
	                                // That's the best value we can get that makes sense.
	                                customProperties["duration"] = customDuration;
	                                appInsights.sendPageViewInternal(pageView, customProperties);
	                            }
	                            else {
	                                if (!pageViewSent) {
	                                    customProperties["duration"] = pageViewPerformance.durationMs;
	                                    appInsights.sendPageViewInternal(pageView, customProperties);
	                                }
	                                if (!pageViewPerformanceSent) {
	                                    appInsights.sendPageViewPerformanceInternal(pageViewPerformance, customProperties);
	                                    pageViewPerformanceSent = true;
	                                }
	                            }
	                        }
	                        else if (start > 0 && dateTimeUtilsDuration(start, +new Date) > maxDurationLimit) {
	                            // if performance timings are not ready but we exceeded the maximum duration limit, just log a page view telemetry
	                            // with the maximum duration limit. Otherwise, keep waiting until performance timings are ready
	                            processed = true;
	                            if (!pageViewSent) {
	                                customProperties["duration"] = maxDurationLimit;
	                                appInsights.sendPageViewInternal(pageView, customProperties);
	                            }
	                        }
	                    }
	                    catch (e) {
	                        _logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TrackPVFailedCalc, "trackPageView failed on page load calculation: " + getExceptionName(e), { exception: dumpObj(e) });
	                    }
	                    return processed;
	                });
	            };
	        });
	    }
	// Removed Stub for PageViewManager.prototype.trackPageView.
	    return PageViewManager;
	}());

	/*
	 * Application Insights JavaScript SDK - Web Analytics, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/**
	 * Used to track page visit durations
	 */
	var PageVisitTimeManager = /** @class */ (function () {
	    /**
	     * Creates a new instance of PageVisitTimeManager
	     * @param pageVisitTimeTrackingHandler Delegate that will be called to send telemetry data to AI (when trackPreviousPageVisit is called)
	     * @returns {}
	     */
	    function PageVisitTimeManager(logger, pageVisitTimeTrackingHandler) {
	        this.prevPageVisitDataKeyName = "prevPageVisitData";
	        this.pageVisitTimeTrackingHandler = pageVisitTimeTrackingHandler;
	        this._logger = logger;
	    }
	    /**
	     * Tracks the previous page visit time telemetry (if exists) and starts timing of new page visit time
	     * @param currentPageName Name of page to begin timing for visit duration
	     * @param currentPageUrl Url of page to begin timing for visit duration
	     */
	    PageVisitTimeManager.prototype.trackPreviousPageVisit = function (currentPageName, currentPageUrl) {
	        try {
	            // Restart timer for new page view
	            var prevPageVisitTimeData = this.restartPageVisitTimer(currentPageName, currentPageUrl);
	            // If there was a page already being timed, track the visit time for it now.
	            if (prevPageVisitTimeData) {
	                this.pageVisitTimeTrackingHandler(prevPageVisitTimeData.pageName, prevPageVisitTimeData.pageUrl, prevPageVisitTimeData.pageVisitTime);
	            }
	        }
	        catch (e) {
	            this._logger.warnToConsole("Auto track page visit time failed, metric will not be collected: " + dumpObj(e));
	        }
	    };
	    /**
	     * Stops timing of current page (if exists) and starts timing for duration of visit to pageName
	     * @param pageName Name of page to begin timing visit duration
	     * @returns {PageVisitData} Page visit data (including duration) of pageName from last call to start or restart, if exists. Null if not.
	     */
	    PageVisitTimeManager.prototype.restartPageVisitTimer = function (pageName, pageUrl) {
	        try {
	            var prevPageVisitData = this.stopPageVisitTimer();
	            this.startPageVisitTimer(pageName, pageUrl);
	            return prevPageVisitData;
	        }
	        catch (e) {
	            this._logger.warnToConsole("Call to restart failed: " + dumpObj(e));
	            return null;
	        }
	    };
	    /**
	     * Starts timing visit duration of pageName
	     * @param pageName
	     * @returns {}
	     */
	    PageVisitTimeManager.prototype.startPageVisitTimer = function (pageName, pageUrl) {
	        try {
	            if (utlCanUseSessionStorage()) {
	                if (utlGetSessionStorage(this._logger, this.prevPageVisitDataKeyName) != null) {
	                    throwError("Cannot call startPageVisit consecutively without first calling stopPageVisit");
	                }
	                var currPageVisitData = new PageVisitData(pageName, pageUrl);
	                var currPageVisitDataStr = getJSON().stringify(currPageVisitData);
	                utlSetSessionStorage(this._logger, this.prevPageVisitDataKeyName, currPageVisitDataStr);
	            }
	        }
	        catch (e) {
	            // TODO: Remove this catch in next phase, since if start is called twice in a row the exception needs to be propagated out
	            this._logger.warnToConsole("Call to start failed: " + dumpObj(e));
	        }
	    };
	    /**
	     * Stops timing of current page, if exists.
	     * @returns {PageVisitData} Page visit data (including duration) of pageName from call to start, if exists. Null if not.
	     */
	    PageVisitTimeManager.prototype.stopPageVisitTimer = function () {
	        try {
	            if (utlCanUseSessionStorage()) {
	                // Define end time of page's visit
	                var pageVisitEndTime = dateNow();
	                // Try to retrieve  page name and start time from session storage
	                var pageVisitDataJsonStr = utlGetSessionStorage(this._logger, this.prevPageVisitDataKeyName);
	                if (pageVisitDataJsonStr && hasJSON()) {
	                    // if previous page data exists, set end time of visit
	                    var prevPageVisitData = getJSON().parse(pageVisitDataJsonStr);
	                    prevPageVisitData.pageVisitTime = pageVisitEndTime - prevPageVisitData.pageVisitStartTime;
	                    // Remove data from storage since we already used it
	                    utlRemoveSessionStorage(this._logger, this.prevPageVisitDataKeyName);
	                    // Return page visit data
	                    return prevPageVisitData;
	                }
	                else {
	                    return null;
	                }
	            }
	            return null;
	        }
	        catch (e) {
	            this._logger.warnToConsole("Stop page visit timer failed: " + dumpObj(e));
	            return null;
	        }
	    };
	    return PageVisitTimeManager;
	}());
	var PageVisitData = /** @class */ (function () {
	    function PageVisitData(pageName, pageUrl) {
	        this.pageVisitStartTime = dateNow();
	        this.pageName = pageName;
	        this.pageUrl = pageUrl;
	    }
	    return PageVisitData;
	}());

	/*
	 * Application Insights JavaScript SDK - Web Analytics, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/**
	 * Class encapsulates sending page view performance telemetry.
	 */
	var PageViewPerformanceManager = /** @class */ (function () {
	    function PageViewPerformanceManager(core) {
	        this.MAX_DURATION_ALLOWED = 3600000; // 1h
	        if (core) {
	            this._logger = core.logger;
	        }
	    }
	    PageViewPerformanceManager.prototype.populatePageViewPerformanceEvent = function (pageViewPerformance) {
	        pageViewPerformance.isValid = false;
	        /*
	         * http://www.w3.org/TR/navigation-timing/#processing-model
	         *  |-navigationStart
	         *  |             |-connectEnd
	         *  |             ||-requestStart
	         *  |             ||             |-responseStart
	         *  |             ||             |              |-responseEnd
	         *  |             ||             |              |
	         *  |             ||             |              |         |-loadEventEnd
	         *  |---network---||---request---|---response---|---dom---|
	         *  |--------------------------total----------------------|
	         *
	         *  total = The difference between the load event of the current document is completed and the first recorded timestamp of the performance entry : https://developer.mozilla.org/en-US/docs/Web/Performance/Navigation_and_resource_timings#duration
	         *  network = Redirect time + App Cache + DNS lookup time + TCP connection time
	         *  request = Request time : https://developer.mozilla.org/en-US/docs/Web/Performance/Navigation_and_resource_timings#request_time
	         *  response = Response time
	         *  dom = Document load time : https://html.spec.whatwg.org/multipage/dom.html#document-load-timing-info
	         *      = Document processing time : https://developers.google.com/web/fundamentals/performance/navigation-and-resource-timing/#document_processing
	         *      + Loading time : https://developers.google.com/web/fundamentals/performance/navigation-and-resource-timing/#loading
	         */
	        var navigationTiming = this.getPerformanceNavigationTiming();
	        var timing = this.getPerformanceTiming();
	        var total = 0;
	        var network = 0;
	        var request = 0;
	        var response = 0;
	        var dom = 0;
	        if (navigationTiming || timing) {
	            if (navigationTiming) {
	                total = navigationTiming.duration;
	                /**
	                 * support both cases:
	                 * - startTime is always zero: https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming
	                 * - for older browsers where the startTime is not zero
	                 */
	                network = navigationTiming.startTime === 0 ? navigationTiming.connectEnd : dateTimeUtilsDuration(navigationTiming.startTime, navigationTiming.connectEnd);
	                request = dateTimeUtilsDuration(navigationTiming.requestStart, navigationTiming.responseStart);
	                response = dateTimeUtilsDuration(navigationTiming.responseStart, navigationTiming.responseEnd);
	                dom = dateTimeUtilsDuration(navigationTiming.responseEnd, navigationTiming.loadEventEnd);
	            }
	            else {
	                total = dateTimeUtilsDuration(timing.navigationStart, timing.loadEventEnd);
	                network = dateTimeUtilsDuration(timing.navigationStart, timing.connectEnd);
	                request = dateTimeUtilsDuration(timing.requestStart, timing.responseStart);
	                response = dateTimeUtilsDuration(timing.responseStart, timing.responseEnd);
	                dom = dateTimeUtilsDuration(timing.responseEnd, timing.loadEventEnd);
	            }
	            if (total === 0) {
	                this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.ErrorPVCalc, "error calculating page view performance.", { total: total, network: network, request: request, response: response, dom: dom });
	            }
	            else if (!this.shouldCollectDuration(total, network, request, response, dom)) {
	                this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.InvalidDurationValue, "Invalid page load duration value. Browser perf data won't be sent.", { total: total, network: network, request: request, response: response, dom: dom });
	            }
	            else if (total < Math.floor(network) + Math.floor(request) + Math.floor(response) + Math.floor(dom)) {
	                // some browsers may report individual components incorrectly so that the sum of the parts will be bigger than total PLT
	                // in this case, don't report client performance from this page
	                this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.ClientPerformanceMathError, "client performance math error.", { total: total, network: network, request: request, response: response, dom: dom });
	            }
	            else {
	                pageViewPerformance.durationMs = total;
	                // // convert to timespans
	                pageViewPerformance.perfTotal = pageViewPerformance.duration = msToTimeSpan(total);
	                pageViewPerformance.networkConnect = msToTimeSpan(network);
	                pageViewPerformance.sentRequest = msToTimeSpan(request);
	                pageViewPerformance.receivedResponse = msToTimeSpan(response);
	                pageViewPerformance.domProcessing = msToTimeSpan(dom);
	                pageViewPerformance.isValid = true;
	            }
	        }
	    };
	    PageViewPerformanceManager.prototype.getPerformanceTiming = function () {
	        if (this.isPerformanceTimingSupported()) {
	            return getPerformance().timing;
	        }
	        return null;
	    };
	    PageViewPerformanceManager.prototype.getPerformanceNavigationTiming = function () {
	        if (this.isPerformanceNavigationTimingSupported()) {
	            return getPerformance().getEntriesByType("navigation")[0];
	        }
	        return null;
	    };
	    /**
	     * Returns true is window PerformanceNavigationTiming API is supported, false otherwise.
	     */
	    PageViewPerformanceManager.prototype.isPerformanceNavigationTimingSupported = function () {
	        var perf = getPerformance();
	        return perf && perf.getEntriesByType && perf.getEntriesByType("navigation").length > 0;
	    };
	    /**
	     * Returns true is window performance timing API is supported, false otherwise.
	     */
	    PageViewPerformanceManager.prototype.isPerformanceTimingSupported = function () {
	        var perf = getPerformance();
	        return perf && perf.timing;
	    };
	    /**
	     * As page loads different parts of performance timing numbers get set. When all of them are set we can report it.
	     * Returns true if ready, false otherwise.
	     */
	    PageViewPerformanceManager.prototype.isPerformanceTimingDataReady = function () {
	        var perf = getPerformance();
	        var timing = perf ? perf.timing : 0;
	        return timing
	            && timing.domainLookupStart > 0
	            && timing.navigationStart > 0
	            && timing.responseStart > 0
	            && timing.requestStart > 0
	            && timing.loadEventEnd > 0
	            && timing.responseEnd > 0
	            && timing.connectEnd > 0
	            && timing.domLoading > 0;
	    };
	    /**
	     * This method tells if given durations should be excluded from collection.
	     */
	    PageViewPerformanceManager.prototype.shouldCollectDuration = function () {
	        var durations = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            durations[_i] = arguments[_i];
	        }
	        var _navigator = getNavigator() || {};
	        // a full list of Google crawlers user agent strings - https://support.google.com/webmasters/answer/1061943?hl=en
	        var botAgentNames = ['googlebot', 'adsbot-google', 'apis-google', 'mediapartners-google'];
	        var userAgent = _navigator.userAgent;
	        var isGoogleBot = false;
	        if (userAgent) {
	            for (var i = 0; i < botAgentNames.length; i++) {
	                isGoogleBot = isGoogleBot || userAgent.toLowerCase().indexOf(botAgentNames[i]) !== -1;
	            }
	        }
	        if (isGoogleBot) {
	            // Don't report durations for GoogleBot, it is returning invalid values in performance.timing API.
	            return false;
	        }
	        else {
	            // for other page views, don't report if it's outside of a reasonable range
	            for (var i = 0; i < durations.length; i++) {
	                if (durations[i] < 0 || durations[i] >= this.MAX_DURATION_ALLOWED) {
	                    return false;
	                }
	            }
	        }
	        return true;
	    };
	    return PageViewPerformanceManager;
	}());

	/*
	 * Application Insights JavaScript SDK - Web Analytics, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var durationProperty = "duration";
	var strEvent = "event";
	function _dispatchEvent(target, evnt) {
	    if (target && target.dispatchEvent && evnt) {
	        target.dispatchEvent(evnt);
	    }
	}
	function _getReason(error) {
	    if (error && error.reason) {
	        var reason = error.reason;
	        if (!isString(reason) && isFunction$1(reason.toString)) {
	            return reason.toString();
	        }
	        return dumpObj(reason);
	    }
	    // Pass the original object down which will eventually get evaluated for any message or description
	    return error || "";
	}
	var ApplicationInsights = /** @class */ (function (_super) {
	    __extendsFn(ApplicationInsights, _super);
	    function ApplicationInsights() {
	        var _this = _super.call(this) || this;
	        _this.identifier = AnalyticsPluginIdentifier; // do not change name or priority
	        _this.priority = 180; // take from reserved priority range 100- 200
	        _this.autoRoutePVDelay = 500; // ms; Time to wait after a route change before triggering a pageview to allow DOM changes to take place
	        var _eventTracking;
	        var _pageTracking;
	        var _properties;
	        // array with max length of 2 that store current url and previous url for SPA page route change trackPageview use.
	        var _prevUri; // Assigned in the constructor
	        var _currUri;
	        dynamicProto(ApplicationInsights, _this, function (_self, _base) {
	            var location = getLocation(true);
	            _prevUri = location && location.href || "";
	            _self.getCookieMgr = function () {
	                return safeGetCookieMgr(_self.core);
	            };
	            _self.processTelemetry = function (env, itemCtx) {
	                doPerf(_self.core, function () { return _self.identifier + ":processTelemetry"; }, function () {
	                    var doNotSendItem = false;
	                    var telemetryInitializersCount = _self._telemetryInitializers.length;
	                    itemCtx = _self._getTelCtx(itemCtx);
	                    for (var i = 0; i < telemetryInitializersCount; ++i) {
	                        var telemetryInitializer = _self._telemetryInitializers[i];
	                        if (telemetryInitializer) {
	                            try {
	                                if (telemetryInitializer.apply(null, [env]) === false) {
	                                    doNotSendItem = true;
	                                    break;
	                                }
	                            }
	                            catch (e) {
	                                // log error but dont stop executing rest of the telemetry initializers
	                                // doNotSendItem = true;
	                                itemCtx.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TelemetryInitializerFailed, "One of telemetry initializers failed, telemetry item will not be sent: " + getExceptionName(e), { exception: dumpObj(e) }, true);
	                            }
	                        }
	                    }
	                    if (!doNotSendItem) {
	                        _self.processNext(env, itemCtx);
	                    }
	                }, function () { return ({ item: env }); }, !(env.sync));
	            };
	            _self.trackEvent = function (event, customProperties) {
	                try {
	                    var telemetryItem = TelemetryItemCreator.create(event, Event$1.dataType, Event$1.envelopeType, _self.diagLog(), customProperties);
	                    _self.core.track(telemetryItem);
	                }
	                catch (e) {
	                    _self.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TrackTraceFailed, "trackTrace failed, trace will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
	                }
	            };
	            /**
	             * Start timing an extended event. Call `stopTrackEvent` to log the event when it ends.
	             * @param   name    A string that identifies this event uniquely within the document.
	             */
	            _self.startTrackEvent = function (name) {
	                try {
	                    _eventTracking.start(name);
	                }
	                catch (e) {
	                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.StartTrackEventFailed, "startTrackEvent failed, event will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
	                }
	            };
	            /**
	             * Log an extended event that you started timing with `startTrackEvent`.
	             * @param   name    The string you used to identify this event in `startTrackEvent`.
	             * @param   properties  map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.
	             * @param   measurements    map[string, number] - metrics associated with this event, displayed in Metrics Explorer on the portal. Defaults to empty.
	             */
	            _self.stopTrackEvent = function (name, properties, measurements) {
	                try {
	                    _eventTracking.stop(name, undefined, properties); // Todo: Fix to pass measurements once type is updated
	                }
	                catch (e) {
	                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.StopTrackEventFailed, "stopTrackEvent failed, event will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
	                }
	            };
	            /**
	             * @description Log a diagnostic message
	             * @param {ITraceTelemetry} trace
	             * @param ICustomProperties.
	             * @memberof ApplicationInsights
	             */
	            _self.trackTrace = function (trace, customProperties) {
	                try {
	                    var telemetryItem = TelemetryItemCreator.create(trace, Trace.dataType, Trace.envelopeType, _self.diagLog(), customProperties);
	                    _self.core.track(telemetryItem);
	                }
	                catch (e) {
	                    _self.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TrackTraceFailed, "trackTrace failed, trace will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
	                }
	            };
	            /**
	             * @description Log a numeric value that is not associated with a specific event. Typically
	             * used to send regular reports of performance indicators. To send single measurement, just
	             * use the name and average fields of {@link IMetricTelemetry}. If you take measurements
	             * frequently, you can reduce the telemetry bandwidth by aggregating multiple measurements
	             * and sending the resulting average at intervals
	             * @param {IMetricTelemetry} metric input object argument. Only name and average are mandatory.
	             * @param {{[key: string]: any}} customProperties additional data used to filter metrics in the
	             * portal. Defaults to empty.
	             * @memberof ApplicationInsights
	             */
	            _self.trackMetric = function (metric, customProperties) {
	                try {
	                    var telemetryItem = TelemetryItemCreator.create(metric, Metric.dataType, Metric.envelopeType, _self.diagLog(), customProperties);
	                    _self.core.track(telemetryItem);
	                }
	                catch (e) {
	                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TrackMetricFailed, "trackMetric failed, metric will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
	                }
	            };
	            /**
	             * Logs that a page or other item was viewed.
	             * @param IPageViewTelemetry The string you used as the name in startTrackPage. Defaults to the document title.
	             * @param customProperties Additional data used to filter events and metrics. Defaults to empty.
	             * If a user wants to provide duration for pageLoad, it'll have to be in pageView.properties.duration
	             */
	            _self.trackPageView = function (pageView, customProperties) {
	                try {
	                    var inPv = pageView || {};
	                    _self._pageViewManager.trackPageView(inPv, __assignFn({}, inPv.properties, inPv.measurements, customProperties));
	                    if (_self.config.autoTrackPageVisitTime) {
	                        _self._pageVisitTimeManager.trackPreviousPageVisit(inPv.name, inPv.uri);
	                    }
	                }
	                catch (e) {
	                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TrackPVFailed, "trackPageView failed, page view will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
	                }
	            };
	            /**
	             * Create a page view telemetry item and send it to the SDK pipeline through the core.track API
	             * @param pageView Page view item to be sent
	             * @param properties Custom properties (Part C) that a user can add to the telemetry item
	             * @param systemProperties System level properties (Part A) that a user can add to the telemetry item
	             */
	            _self.sendPageViewInternal = function (pageView, properties, systemProperties) {
	                var doc = getDocument();
	                if (doc) {
	                    pageView.refUri = pageView.refUri === undefined ? doc.referrer : pageView.refUri;
	                }
	                var telemetryItem = TelemetryItemCreator.create(pageView, PageView.dataType, PageView.envelopeType, _self.diagLog(), properties, systemProperties);
	                _self.core.track(telemetryItem);
	            };
	            /**
	             * @ignore INTERNAL ONLY
	             * @param pageViewPerformance
	             * @param properties
	             */
	            _self.sendPageViewPerformanceInternal = function (pageViewPerformance, properties, systemProperties) {
	                var telemetryItem = TelemetryItemCreator.create(pageViewPerformance, PageViewPerformance.dataType, PageViewPerformance.envelopeType, _self.diagLog(), properties, systemProperties);
	                _self.core.track(telemetryItem);
	            };
	            /**
	             * Send browser performance metrics.
	             * @param pageViewPerformance
	             * @param customProperties
	             */
	            _self.trackPageViewPerformance = function (pageViewPerformance, customProperties) {
	                try {
	                    _self._pageViewPerformanceManager.populatePageViewPerformanceEvent(pageViewPerformance);
	                    _self.sendPageViewPerformanceInternal(pageViewPerformance, customProperties);
	                }
	                catch (e) {
	                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TrackPVFailed, "trackPageViewPerformance failed, page view will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
	                }
	            };
	            /**
	             * Starts the timer for tracking a page load time. Use this instead of `trackPageView` if you want to control when the page view timer starts and stops,
	             * but don't want to calculate the duration yourself. This method doesn't send any telemetry. Call `stopTrackPage` to log the end of the page view
	             * and send the event.
	             * @param name A string that idenfities this item, unique within this HTML document. Defaults to the document title.
	             */
	            _self.startTrackPage = function (name) {
	                try {
	                    if (typeof name !== "string") {
	                        var doc = getDocument();
	                        name = doc && doc.title || "";
	                    }
	                    _pageTracking.start(name);
	                }
	                catch (e) {
	                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.StartTrackFailed, "startTrackPage failed, page view may not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
	                }
	            };
	            /**
	             * Stops the timer that was started by calling `startTrackPage` and sends the pageview load time telemetry with the specified properties and measurements.
	             * The duration of the page view will be the time between calling `startTrackPage` and `stopTrackPage`.
	             * @param   name  The string you used as the name in startTrackPage. Defaults to the document title.
	             * @param   url   String - a relative or absolute URL that identifies the page or other item. Defaults to the window location.
	             * @param   properties  map[string, string] - additional data used to filter pages and metrics in the portal. Defaults to empty.
	             * @param   measurements    map[string, number] - metrics associated with this page, displayed in Metrics Explorer on the portal. Defaults to empty.
	             */
	            _self.stopTrackPage = function (name, url, properties, measurement) {
	                try {
	                    if (typeof name !== "string") {
	                        var doc = getDocument();
	                        name = doc && doc.title || "";
	                    }
	                    if (typeof url !== "string") {
	                        var loc = getLocation();
	                        url = loc && loc.href || "";
	                    }
	                    _pageTracking.stop(name, url, properties, measurement);
	                    if (_self.config.autoTrackPageVisitTime) {
	                        _self._pageVisitTimeManager.trackPreviousPageVisit(name, url);
	                    }
	                }
	                catch (e) {
	                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.StopTrackFailed, "stopTrackPage failed, page view will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
	                }
	            };
	            /**
	             * @ignore INTERNAL ONLY
	             * @param exception
	             * @param properties
	             * @param systemProperties
	             */
	            _self.sendExceptionInternal = function (exception, customProperties, systemProperties) {
	                var theError = exception.exception || exception.error || new Error(strNotSpecified);
	                var exceptionPartB = new Exception(_self.diagLog(), theError, exception.properties || customProperties, exception.measurements, exception.severityLevel, exception.id).toInterface();
	                var telemetryItem = TelemetryItemCreator.create(exceptionPartB, Exception.dataType, Exception.envelopeType, _self.diagLog(), customProperties, systemProperties);
	                _self.core.track(telemetryItem);
	            };
	            /**
	             * Log an exception you have caught.
	             *
	             * @param {IExceptionTelemetry} exception   Object which contains exception to be sent
	             * @param {{[key: string]: any}} customProperties   Additional data used to filter pages and metrics in the portal. Defaults to empty.
	             *
	             * Any property of type double will be considered a measurement, and will be treated by Application Insights as a metric.
	             * @memberof ApplicationInsights
	             */
	            _self.trackException = function (exception, customProperties) {
	                try {
	                    _self.sendExceptionInternal(exception, customProperties);
	                }
	                catch (e) {
	                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TrackExceptionFailed, "trackException failed, exception will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
	                }
	            };
	            /**
	             * @description Custom error handler for Application Insights Analytics
	             * @param {IAutoExceptionTelemetry} exception
	             * @memberof ApplicationInsights
	             */
	            _self._onerror = function (exception) {
	                var error = exception && exception.error;
	                var evt = exception && exception.evt;
	                try {
	                    if (!evt) {
	                        var _window = getWindow();
	                        if (_window) {
	                            evt = _window[strEvent];
	                        }
	                    }
	                    var url = (exception && exception.url) || (getDocument() || {}).URL;
	                    // If no error source is provided assume the default window.onerror handler
	                    var errorSrc = exception.errorSrc || "window.onerror@" + url + ":" + (exception.lineNumber || 0) + ":" + (exception.columnNumber || 0);
	                    var properties = {
	                        errorSrc: errorSrc,
	                        url: url,
	                        lineNumber: exception.lineNumber || 0,
	                        columnNumber: exception.columnNumber || 0,
	                        message: exception.message
	                    };
	                    if (isCrossOriginError(exception.message, exception.url, exception.lineNumber, exception.columnNumber, exception.error)) {
	                        _sendCORSException(Exception.CreateAutoException("Script error: The browser's same-origin policy prevents us from getting the details of this exception. Consider using the 'crossorigin' attribute.", url, exception.lineNumber || 0, exception.columnNumber || 0, error, evt, null, errorSrc), properties);
	                    }
	                    else {
	                        if (!exception.errorSrc) {
	                            exception.errorSrc = errorSrc;
	                        }
	                        _self.trackException({ exception: exception, severityLevel: SeverityLevel.Error }, properties);
	                    }
	                }
	                catch (e) {
	                    var errorString = error ? (error.name + ", " + error.message) : "null";
	                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.ExceptionWhileLoggingError, "_onError threw exception while logging error, error will not be collected: "
	                        + getExceptionName(e), { exception: dumpObj(e), errorString: errorString });
	                }
	            };
	            _self.addTelemetryInitializer = function (telemetryInitializer) {
	                _self._telemetryInitializers.push(telemetryInitializer);
	            };
	            _self.initialize = function (config, core, extensions, pluginChain) {
	                if (_self.isInitialized()) {
	                    return;
	                }
	                if (isNullOrUndefined(core)) {
	                    throw Error("Error initializing");
	                }
	                _base.initialize(config, core, extensions, pluginChain);
	                _self.setInitialized(false); // resetting the initialized state, just in case the following fails
	                var ctx = _self._getTelCtx();
	                var identifier = _self.identifier;
	                _self.config = ctx.getExtCfg(identifier);
	                // load default values if specified
	                var defaults = ApplicationInsights.getDefaultConfig(config);
	                if (defaults !== undefined) {
	                    objForEachKey(defaults, function (field, value) {
	                        // for each unspecified field, set the default value
	                        _self.config[field] = ctx.getConfig(identifier, field, value);
	                        if (_self.config[field] === undefined) {
	                            _self.config[field] = value;
	                        }
	                    });
	                }
	                // Todo: move this out of static state
	                if (_self.config.isStorageUseDisabled) {
	                    utlDisableStorage();
	                }
	                var configGetters = {
	                    instrumentationKey: function () { return config.instrumentationKey; },
	                    accountId: function () { return _self.config.accountId || config.accountId; },
	                    sessionRenewalMs: function () { return _self.config.sessionRenewalMs || config.sessionRenewalMs; },
	                    sessionExpirationMs: function () { return _self.config.sessionExpirationMs || config.sessionExpirationMs; },
	                    sampleRate: function () { return _self.config.samplingPercentage || config.samplingPercentage; },
	                    sdkExtension: function () { return _self.config.sdkExtension || config.sdkExtension; },
	                    isBrowserLinkTrackingEnabled: function () { return _self.config.isBrowserLinkTrackingEnabled || config.isBrowserLinkTrackingEnabled; },
	                    appId: function () { return _self.config.appId || config.appId; }
	                };
	                _self._pageViewPerformanceManager = new PageViewPerformanceManager(_self.core);
	                _self._pageViewManager = new PageViewManager(_this, _self.config.overridePageViewDuration, _self.core, _self._pageViewPerformanceManager);
	                _self._pageVisitTimeManager = new PageVisitTimeManager(_self.diagLog(), function (pageName, pageUrl, pageVisitTime) { return trackPageVisitTime(pageName, pageUrl, pageVisitTime); });
	                _self._telemetryInitializers = _self._telemetryInitializers || [];
	                _addDefaultTelemetryInitializers(configGetters);
	                _eventTracking = new Timing(_self.diagLog(), "trackEvent");
	                _eventTracking.action =
	                    function (name, url, duration, properties) {
	                        if (!properties) {
	                            properties = {};
	                        }
	                        properties[durationProperty] = duration.toString();
	                        _self.trackEvent({ name: name, properties: properties });
	                    };
	                // initialize page view timing
	                _pageTracking = new Timing(_self.diagLog(), "trackPageView");
	                _pageTracking.action = function (name, url, duration, properties, measurements) {
	                    // duration must be a custom property in order for the collector to extract it
	                    if (isNullOrUndefined(properties)) {
	                        properties = {};
	                    }
	                    properties[durationProperty] = duration.toString();
	                    var pageViewItem = {
	                        name: name,
	                        uri: url,
	                        properties: properties,
	                        measurements: measurements
	                    };
	                    _self.sendPageViewInternal(pageViewItem, properties);
	                };
	                var _window = getWindow();
	                var _history = getHistory();
	                var _location = getLocation(true);
	                var instance = _this;
	                if (_self.config.disableExceptionTracking === false &&
	                    !_self.config.autoExceptionInstrumented && _window) {
	                    // We want to enable exception auto collection and it has not been done so yet
	                    var onerror_1 = "onerror";
	                    var originalOnError_1 = _window[onerror_1];
	                    _window.onerror = function (message, url, lineNumber, columnNumber, error) {
	                        var evt = _window[strEvent];
	                        var handled = originalOnError_1 && originalOnError_1(message, url, lineNumber, columnNumber, error);
	                        if (handled !== true) {
	                            instance._onerror(Exception.CreateAutoException(message, url, lineNumber, columnNumber, error, evt));
	                        }
	                        return handled;
	                    };
	                    _self.config.autoExceptionInstrumented = true;
	                }
	                if (_self.config.disableExceptionTracking === false &&
	                    _self.config.enableUnhandledPromiseRejectionTracking === true &&
	                    !_self.config.autoUnhandledPromiseInstrumented && _window) {
	                    // We want to enable exception auto collection and it has not been done so yet
	                    var onunhandledrejection = "onunhandledrejection";
	                    var originalOnUnhandledRejection_1 = _window[onunhandledrejection];
	                    _window[onunhandledrejection] = function (error) {
	                        var evt = _window[strEvent];
	                        var handled = originalOnUnhandledRejection_1 && originalOnUnhandledRejection_1.call(_window, error);
	                        if (handled !== true) {
	                            instance._onerror(Exception.CreateAutoException(_getReason(error), _location ? _location.href : "", 0, 0, error, evt));
	                        }
	                        return handled;
	                    };
	                    _self.config.autoUnhandledPromiseInstrumented = true;
	                }
	                /**
	                 * Create a custom "locationchange" event which is triggered each time the history object is changed
	                 */
	                if (_self.config.enableAutoRouteTracking === true
	                    && _history && isFunction$1(_history.pushState) && isFunction$1(_history.replaceState)
	                    && _window
	                    && typeof Event !== "undefined") {
	                    var _self_1 = _this;
	                    // Find the properties plugin
	                    arrForEach(extensions, function (extension) {
	                        if (extension.identifier === PropertiesPluginIdentifier) {
	                            _properties = extension;
	                        }
	                    });
	                    _history.pushState = (function (f) { return function pushState() {
	                        var ret = f.apply(this, arguments);
	                        _dispatchEvent(_window, createDomEvent(_self_1.config.namePrefix + "pushState"));
	                        _dispatchEvent(_window, createDomEvent(_self_1.config.namePrefix + "locationchange"));
	                        return ret;
	                    }; })(_history.pushState);
	                    _history.replaceState = (function (f) { return function replaceState() {
	                        var ret = f.apply(this, arguments);
	                        _dispatchEvent(_window, createDomEvent(_self_1.config.namePrefix + "replaceState"));
	                        _dispatchEvent(_window, createDomEvent(_self_1.config.namePrefix + "locationchange"));
	                        return ret;
	                    }; })(_history.replaceState);
	                    if (_window.addEventListener) {
	                        _window.addEventListener(_self_1.config.namePrefix + "popstate", function () {
	                            _dispatchEvent(_window, createDomEvent(_self_1.config.namePrefix + "locationchange"));
	                        });
	                        _window.addEventListener(_self_1.config.namePrefix + "locationchange", function () {
	                            if (_properties && _properties.context && _properties.context.telemetryTrace) {
	                                _properties.context.telemetryTrace.traceID = generateW3CId();
	                                var traceLocationName = "_unknown_";
	                                if (_location && _location.pathname) {
	                                    traceLocationName = _location.pathname + (_location.hash || "");
	                                }
	                                _properties.context.telemetryTrace.name = traceLocationName;
	                            }
	                            if (_currUri) {
	                                _prevUri = _currUri;
	                                _currUri = _location && _location.href || "";
	                            }
	                            else {
	                                _currUri = _location && _location.href || "";
	                            }
	                            setTimeout((function (uri) {
	                                // todo: override start time so that it is not affected by autoRoutePVDelay
	                                _self_1.trackPageView({ refUri: uri, properties: { duration: 0 } }); // SPA route change loading durations are undefined, so send 0
	                            }).bind(_this, _prevUri), _self_1.autoRoutePVDelay);
	                        });
	                    }
	                }
	                _self.setInitialized(true);
	            };
	            /**
	             * Log a page visit time
	             * @param    pageName    Name of page
	             * @param    pageVisitDuration Duration of visit to the page in milleseconds
	             */
	            function trackPageVisitTime(pageName, pageUrl, pageVisitTime) {
	                var properties = { PageName: pageName, PageUrl: pageUrl };
	                _self.trackMetric({
	                    name: "PageVisitTime",
	                    average: pageVisitTime,
	                    max: pageVisitTime,
	                    min: pageVisitTime,
	                    sampleCount: 1
	                }, properties);
	            }
	            function _addDefaultTelemetryInitializers(configGetters) {
	                if (!configGetters.isBrowserLinkTrackingEnabled()) {
	                    var browserLinkPaths_1 = ['/browserLinkSignalR/', '/__browserLink/'];
	                    var dropBrowserLinkRequests = function (envelope) {
	                        if (envelope.baseType === RemoteDependencyData$1.dataType) {
	                            var remoteData = envelope.baseData;
	                            if (remoteData) {
	                                for (var i = 0; i < browserLinkPaths_1.length; i++) {
	                                    if (remoteData.target && remoteData.target.indexOf(browserLinkPaths_1[i]) >= 0) {
	                                        return false;
	                                    }
	                                }
	                            }
	                        }
	                        return true;
	                    };
	                    _addTelemetryInitializer(dropBrowserLinkRequests);
	                }
	            }
	            function _addTelemetryInitializer(telemetryInitializer) {
	                _self._telemetryInitializers.push(telemetryInitializer);
	            }
	            function _sendCORSException(exception, properties) {
	                var telemetryItem = TelemetryItemCreator.create(exception, Exception.dataType, Exception.envelopeType, _self.diagLog(), properties);
	                _self.core.track(telemetryItem);
	            }
	        });
	        return _this;
	    }
	    ApplicationInsights.getDefaultConfig = function (config) {
	        if (!config) {
	            config = {};
	        }
	        // set default values
	        config.sessionRenewalMs = 30 * 60 * 1000;
	        config.sessionExpirationMs = 24 * 60 * 60 * 1000;
	        config.disableExceptionTracking = stringToBoolOrDefault(config.disableExceptionTracking);
	        config.autoTrackPageVisitTime = stringToBoolOrDefault(config.autoTrackPageVisitTime);
	        config.overridePageViewDuration = stringToBoolOrDefault(config.overridePageViewDuration);
	        config.enableUnhandledPromiseRejectionTracking = stringToBoolOrDefault(config.enableUnhandledPromiseRejectionTracking);
	        if (isNaN(config.samplingPercentage) || config.samplingPercentage <= 0 || config.samplingPercentage >= 100) {
	            config.samplingPercentage = 100;
	        }
	        config.isStorageUseDisabled = stringToBoolOrDefault(config.isStorageUseDisabled);
	        config.isBrowserLinkTrackingEnabled = stringToBoolOrDefault(config.isBrowserLinkTrackingEnabled);
	        config.enableAutoRouteTracking = stringToBoolOrDefault(config.enableAutoRouteTracking);
	        config.namePrefix = config.namePrefix || "";
	        config.enableDebug = stringToBoolOrDefault(config.enableDebug);
	        config.disableFlushOnBeforeUnload = stringToBoolOrDefault(config.disableFlushOnBeforeUnload);
	        config.disableFlushOnUnload = stringToBoolOrDefault(config.disableFlushOnUnload, config.disableFlushOnBeforeUnload);
	        return config;
	    };
	// Removed Stub for ApplicationInsights.prototype.getCookieMgr.
	// Removed Stub for ApplicationInsights.prototype.processTelemetry.
	// Removed Stub for ApplicationInsights.prototype.trackEvent.
	// Removed Stub for ApplicationInsights.prototype.startTrackEvent.
	// Removed Stub for ApplicationInsights.prototype.stopTrackEvent.
	// Removed Stub for ApplicationInsights.prototype.trackTrace.
	// Removed Stub for ApplicationInsights.prototype.trackMetric.
	// Removed Stub for ApplicationInsights.prototype.trackPageView.
	// Removed Stub for ApplicationInsights.prototype.sendPageViewInternal.
	// Removed Stub for ApplicationInsights.prototype.sendPageViewPerformanceInternal.
	// Removed Stub for ApplicationInsights.prototype.trackPageViewPerformance.
	// Removed Stub for ApplicationInsights.prototype.startTrackPage.
	// Removed Stub for ApplicationInsights.prototype.stopTrackPage.
	// Removed Stub for ApplicationInsights.prototype.sendExceptionInternal.
	// Removed Stub for ApplicationInsights.prototype.trackException.
	// Removed Stub for ApplicationInsights.prototype._onerror.
	// Removed Stub for ApplicationInsights.prototype.addTelemetryInitializer.
	// Removed Stub for ApplicationInsights.prototype.initialize.
	    ApplicationInsights.Version = "2.6.5"; // Not currently used anywhere
	    return ApplicationInsights;
	}(BaseTelemetryPlugin));
	/**
	 * Used to record timed events and page views.
	 */
	var Timing = /** @class */ (function () {
	    function Timing(logger, name) {
	        var _self = this;
	        var _events = {};
	        _self.start = function (name) {
	            if (typeof _events[name] !== "undefined") {
	                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.StartCalledMoreThanOnce, "start was called more than once for this event without calling stop.", { name: name, key: name }, true);
	            }
	            _events[name] = +new Date;
	        };
	        _self.stop = function (name, url, properties, measurements) {
	            var start = _events[name];
	            if (isNaN(start)) {
	                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.StopCalledWithoutStart, "stop was called without a corresponding start.", { name: name, key: name }, true);
	            }
	            else {
	                var end = +new Date;
	                var duration = dateTimeUtilsDuration(start, end);
	                _self.action(name, url, duration, properties, measurements);
	            }
	            delete _events[name];
	            _events[name] = undefined;
	        };
	    }
	    return Timing;
	}());

	/*
	 * Application Insights JavaScript SDK - Channel, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/*
	 * An array based send buffer.
	 */
	var ArraySendBuffer = /** @class */ (function () {
	    function ArraySendBuffer(config) {
	        var _buffer = [];
	        dynamicProto(ArraySendBuffer, this, function (_self) {
	            _self.enqueue = function (payload) {
	                _buffer.push(payload);
	            };
	            _self.count = function () {
	                return _buffer.length;
	            };
	            _self.clear = function () {
	                _buffer.length = 0;
	            };
	            _self.getItems = function () {
	                return _buffer.slice(0);
	            };
	            _self.batchPayloads = function (payload) {
	                if (payload && payload.length > 0) {
	                    var batch = config.emitLineDelimitedJson() ?
	                        payload.join("\n") :
	                        "[" + payload.join(",") + "]";
	                    return batch;
	                }
	                return null;
	            };
	            _self.markAsSent = function (payload) {
	                _self.clear();
	            };
	            _self.clearSent = function (payload) {
	                // not supported
	            };
	        });
	    }
	// Removed Stub for ArraySendBuffer.prototype.enqueue.
	// Removed Stub for ArraySendBuffer.prototype.count.
	// Removed Stub for ArraySendBuffer.prototype.clear.
	// Removed Stub for ArraySendBuffer.prototype.getItems.
	// Removed Stub for ArraySendBuffer.prototype.batchPayloads.
	// Removed Stub for ArraySendBuffer.prototype.markAsSent.
	// Removed Stub for ArraySendBuffer.prototype.clearSent.
	    return ArraySendBuffer;
	}());
	/*
	 * Session storage buffer holds a copy of all unsent items in the browser session storage.
	 */
	var SessionStorageSendBuffer = /** @class */ (function () {
	    function SessionStorageSendBuffer(logger, config) {
	        var _bufferFullMessageSent = false;
	        // An in-memory copy of the buffer. A copy is saved to the session storage on enqueue() and clear().
	        // The buffer is restored in a constructor and contains unsent events from a previous page.
	        var _buffer;
	        dynamicProto(SessionStorageSendBuffer, this, function (_self) {
	            var bufferItems = _getBuffer(SessionStorageSendBuffer.BUFFER_KEY);
	            var notDeliveredItems = _getBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY);
	            _buffer = bufferItems.concat(notDeliveredItems);
	            // If the buffer has too many items, drop items from the end.
	            if (_buffer.length > SessionStorageSendBuffer.MAX_BUFFER_SIZE) {
	                _buffer.length = SessionStorageSendBuffer.MAX_BUFFER_SIZE;
	            }
	            _setBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY, []);
	            _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _buffer);
	            _self.enqueue = function (payload) {
	                if (_buffer.length >= SessionStorageSendBuffer.MAX_BUFFER_SIZE) {
	                    // sent internal log only once per page view
	                    if (!_bufferFullMessageSent) {
	                        logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.SessionStorageBufferFull, "Maximum buffer size reached: " + _buffer.length, true);
	                        _bufferFullMessageSent = true;
	                    }
	                    return;
	                }
	                _buffer.push(payload);
	                _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _buffer);
	            };
	            _self.count = function () {
	                return _buffer.length;
	            };
	            _self.clear = function () {
	                _buffer = [];
	                _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, []);
	                _setBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY, []);
	                _bufferFullMessageSent = false;
	            };
	            _self.getItems = function () {
	                return _buffer.slice(0);
	            };
	            _self.batchPayloads = function (payload) {
	                if (payload && payload.length > 0) {
	                    var batch = config.emitLineDelimitedJson() ?
	                        payload.join("\n") :
	                        "[" + payload.join(",") + "]";
	                    return batch;
	                }
	                return null;
	            };
	            _self.markAsSent = function (payload) {
	                _buffer = _removePayloadsFromBuffer(payload, _buffer);
	                _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _buffer);
	                var sentElements = _getBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY);
	                if (sentElements instanceof Array && payload instanceof Array) {
	                    sentElements = sentElements.concat(payload);
	                    if (sentElements.length > SessionStorageSendBuffer.MAX_BUFFER_SIZE) {
	                        // We send telemetry normally. If the SENT_BUFFER is too big we don't add new elements
	                        // until we receive a response from the backend and the buffer has free space again (see clearSent method)
	                        logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.SessionStorageBufferFull, "Sent buffer reached its maximum size: " + sentElements.length, true);
	                        sentElements.length = SessionStorageSendBuffer.MAX_BUFFER_SIZE;
	                    }
	                    _setBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY, sentElements);
	                }
	            };
	            _self.clearSent = function (payload) {
	                var sentElements = _getBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY);
	                sentElements = _removePayloadsFromBuffer(payload, sentElements);
	                _setBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY, sentElements);
	            };
	            function _removePayloadsFromBuffer(payloads, buffer) {
	                var remaining = [];
	                arrForEach(buffer, function (value) {
	                    if (!isFunction$1(value) && arrIndexOf(payloads, value) === -1) {
	                        remaining.push(value);
	                    }
	                });
	                return remaining;
	            }
	            function _getBuffer(key) {
	                var prefixedKey = key;
	                try {
	                    prefixedKey = config.namePrefix && config.namePrefix() ? config.namePrefix() + "_" + prefixedKey : prefixedKey;
	                    var bufferJson = utlGetSessionStorage(logger, prefixedKey);
	                    if (bufferJson) {
	                        var buffer = getJSON().parse(bufferJson);
	                        if (isString(buffer)) {
	                            // When using some version prototype.js the stringify / parse cycle does not decode array's correctly
	                            buffer = getJSON().parse(buffer);
	                        }
	                        if (buffer && isArray$1(buffer)) {
	                            return buffer;
	                        }
	                    }
	                }
	                catch (e) {
	                    logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedToRestoreStorageBuffer, " storage key: " + prefixedKey + ", " + getExceptionName(e), { exception: dumpObj(e) });
	                }
	                return [];
	            }
	            function _setBuffer(key, buffer) {
	                var prefixedKey = key;
	                try {
	                    prefixedKey = config.namePrefix && config.namePrefix() ? config.namePrefix() + "_" + prefixedKey : prefixedKey;
	                    var bufferJson = JSON.stringify(buffer);
	                    utlSetSessionStorage(logger, prefixedKey, bufferJson);
	                }
	                catch (e) {
	                    // if there was an error, clear the buffer
	                    // telemetry is stored in the _buffer array so we won't loose any items
	                    utlSetSessionStorage(logger, prefixedKey, JSON.stringify([]));
	                    logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedToSetStorageBuffer, " storage key: " + prefixedKey + ", " + getExceptionName(e) + ". Buffer cleared", { exception: dumpObj(e) });
	                }
	            }
	        });
	    }
	// Removed Stub for SessionStorageSendBuffer.prototype.enqueue.
	// Removed Stub for SessionStorageSendBuffer.prototype.count.
	// Removed Stub for SessionStorageSendBuffer.prototype.clear.
	// Removed Stub for SessionStorageSendBuffer.prototype.getItems.
	// Removed Stub for SessionStorageSendBuffer.prototype.batchPayloads.
	// Removed Stub for SessionStorageSendBuffer.prototype.markAsSent.
	// Removed Stub for SessionStorageSendBuffer.prototype.clearSent.
	    SessionStorageSendBuffer.BUFFER_KEY = "AI_buffer";
	    SessionStorageSendBuffer.SENT_BUFFER_KEY = "AI_sentBuffer";
	    // Maximum number of payloads stored in the buffer. If the buffer is full, new elements will be dropped.
	    SessionStorageSendBuffer.MAX_BUFFER_SIZE = 2000;
	    return SessionStorageSendBuffer;
	}());

	/*
	 * Application Insights JavaScript SDK - Channel, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	// these two constants are used to filter out properties not needed when trying to extract custom properties and measurements from the incoming payload
	var strBaseType = 'baseType';
	var strBaseData = 'baseData';
	var strProperties = 'properties';
	var strTrue = 'true';
	function _setValueIf(target, field, value) {
	    return setValue(target, field, value, isTruthy);
	}
	var EnvelopeCreator = /** @class */ (function () {
	    function EnvelopeCreator() {
	    }
	    EnvelopeCreator.extractPropsAndMeasurements = function (data, properties, measurements) {
	        if (!isNullOrUndefined(data)) {
	            objForEachKey(data, function (key, value) {
	                if (isNumber(value)) {
	                    measurements[key] = value;
	                }
	                else if (isString(value)) {
	                    properties[key] = value;
	                }
	                else if (hasJSON()) {
	                    properties[key] = getJSON().stringify(value);
	                }
	            });
	        }
	    };
	    // TODO: Do we want this to take logger as arg or use this._logger as nonstatic?
	    EnvelopeCreator.createEnvelope = function (logger, envelopeType, telemetryItem, data) {
	        var envelope = new Envelope$1(logger, data, envelopeType);
	        _setValueIf(envelope, 'sampleRate', telemetryItem[SampleRate]);
	        if ((telemetryItem[strBaseData] || {}).startTime) {
	            envelope.time = toISOString(telemetryItem[strBaseData].startTime);
	        }
	        envelope.iKey = telemetryItem.iKey;
	        var iKeyNoDashes = telemetryItem.iKey.replace(/-/g, "");
	        envelope.name = envelope.name.replace("{0}", iKeyNoDashes);
	        // extract all extensions from ctx
	        EnvelopeCreator.extractPartAExtensions(telemetryItem, envelope);
	        // loop through the envelope tags (extension of Part A) and pick out the ones that should go in outgoing envelope tags
	        telemetryItem.tags = telemetryItem.tags || [];
	        return optimizeObject(envelope);
	    };
	    /*
	     * Maps Part A data from CS 4.0
	     */
	    EnvelopeCreator.extractPartAExtensions = function (item, env) {
	        // todo: switch to keys from common in this method
	        var envTags = env.tags = env.tags || {};
	        var itmExt = item.ext = item.ext || {};
	        var itmTags = item.tags = item.tags || [];
	        var extUser = itmExt.user;
	        if (extUser) {
	            _setValueIf(envTags, CtxTagKeys.userAuthUserId, extUser.authId);
	            _setValueIf(envTags, CtxTagKeys.userId, extUser.id || extUser.localId);
	        }
	        var extApp = itmExt.app;
	        if (extApp) {
	            _setValueIf(envTags, CtxTagKeys.sessionId, extApp.sesId);
	        }
	        var extDevice = itmExt.device;
	        if (extDevice) {
	            _setValueIf(envTags, CtxTagKeys.deviceId, extDevice.id || extDevice.localId);
	            _setValueIf(envTags, CtxTagKeys.deviceType, extDevice.deviceClass);
	            _setValueIf(envTags, CtxTagKeys.deviceIp, extDevice.ip);
	            _setValueIf(envTags, CtxTagKeys.deviceModel, extDevice.model);
	            _setValueIf(envTags, CtxTagKeys.deviceType, extDevice.deviceType);
	        }
	        var web = item.ext.web;
	        if (web) {
	            _setValueIf(envTags, CtxTagKeys.deviceLanguage, web.browserLang);
	            _setValueIf(envTags, CtxTagKeys.deviceBrowserVersion, web.browserVer);
	            _setValueIf(envTags, CtxTagKeys.deviceBrowser, web.browser);
	            var envData = env.data = env.data || {};
	            var envBaseData = envData[strBaseData] = envData[strBaseData] || {};
	            var envProps = envBaseData[strProperties] = envBaseData[strProperties] || {};
	            _setValueIf(envProps, 'domain', web.domain);
	            _setValueIf(envProps, 'isManual', web.isManual ? strTrue : null);
	            _setValueIf(envProps, 'screenRes', web.screenRes);
	            _setValueIf(envProps, 'userConsent', web.userConsent ? strTrue : null);
	        }
	        var extOs = itmExt.os;
	        if (extOs) {
	            _setValueIf(envTags, CtxTagKeys.deviceOS, extOs.name);
	        }
	        // No support for mapping Trace.traceState to 2.0 as it is currently empty
	        var extTrace = itmExt.trace;
	        if (extTrace) {
	            _setValueIf(envTags, CtxTagKeys.operationParentId, extTrace.parentID);
	            _setValueIf(envTags, CtxTagKeys.operationName, extTrace.name);
	            _setValueIf(envTags, CtxTagKeys.operationId, extTrace.traceID);
	        }
	        // Sample 4.0 schema
	        //  {
	        //     "time" : "2018-09-05T22:51:22.4936Z",
	        //     "name" : "MetricWithNamespace",
	        //     "iKey" : "ABC-5a4cbd20-e601-4ef5-a3c6-5d6577e4398e",
	        //     "ext": {  "cloud": {
	        //          "role": "WATSON3",
	        //          "roleInstance": "CO4AEAP00000260"
	        //      },
	        //      "device": {}, "correlation": {} },
	        //      "tags": [
	        //        { "amazon.region" : "east2" },
	        //        { "os.expid" : "wp:02df239" }
	        //     ]
	        //   }
	        var tgs = {};
	        // deals with tags.push({object})
	        for (var i = itmTags.length - 1; i >= 0; i--) {
	            var tg = itmTags[i];
	            objForEachKey(tg, function (key, value) {
	                tgs[key] = value;
	            });
	            itmTags.splice(i, 1);
	        }
	        // deals with tags[key]=value (and handles hasOwnProperty)
	        objForEachKey(itmTags, function (tg, value) {
	            tgs[tg] = value;
	        });
	        var theTags = __assignFn({}, envTags, tgs);
	        if (!theTags[CtxTagKeys.internalSdkVersion]) {
	            // Append a version in case it is not already set
	            theTags[CtxTagKeys.internalSdkVersion] = "javascript:" + EnvelopeCreator.Version;
	        }
	        env.tags = optimizeObject(theTags);
	    };
	    EnvelopeCreator.prototype.Init = function (logger, telemetryItem) {
	        this._logger = logger;
	        if (isNullOrUndefined(telemetryItem[strBaseData])) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TelemetryEnvelopeInvalid, "telemetryItem.baseData cannot be null.");
	        }
	    };
	    EnvelopeCreator.Version = "2.6.5";
	    return EnvelopeCreator;
	}());
	var DependencyEnvelopeCreator = /** @class */ (function (_super) {
	    __extendsFn(DependencyEnvelopeCreator, _super);
	    function DependencyEnvelopeCreator() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    DependencyEnvelopeCreator.prototype.Create = function (logger, telemetryItem) {
	        _super.prototype.Init.call(this, logger, telemetryItem);
	        var customMeasurements = telemetryItem[strBaseData].measurements || {};
	        var customProperties = telemetryItem[strBaseData][strProperties] || {};
	        EnvelopeCreator.extractPropsAndMeasurements(telemetryItem.data, customProperties, customMeasurements);
	        var bd = telemetryItem[strBaseData];
	        if (isNullOrUndefined(bd)) {
	            logger.warnToConsole("Invalid input for dependency data");
	            return null;
	        }
	        var method = bd[strProperties] && bd[strProperties][HttpMethod] ? bd[strProperties][HttpMethod] : "GET";
	        var remoteDepData = new RemoteDependencyData$1(logger, bd.id, bd.target, bd.name, bd.duration, bd.success, bd.responseCode, method, bd.type, bd.correlationContext, customProperties, customMeasurements);
	        var data = new Data$1(RemoteDependencyData$1.dataType, remoteDepData);
	        return EnvelopeCreator.createEnvelope(logger, RemoteDependencyData$1.envelopeType, telemetryItem, data);
	    };
	    DependencyEnvelopeCreator.DependencyEnvelopeCreator = new DependencyEnvelopeCreator();
	    return DependencyEnvelopeCreator;
	}(EnvelopeCreator));
	var EventEnvelopeCreator = /** @class */ (function (_super) {
	    __extendsFn(EventEnvelopeCreator, _super);
	    function EventEnvelopeCreator() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    EventEnvelopeCreator.prototype.Create = function (logger, telemetryItem) {
	        _super.prototype.Init.call(this, logger, telemetryItem);
	        var customProperties = {};
	        var customMeasurements = {};
	        if (telemetryItem[strBaseType] !== Event$1.dataType) {
	            customProperties['baseTypeSource'] = telemetryItem[strBaseType]; // save the passed in base type as a property
	        }
	        if (telemetryItem[strBaseType] === Event$1.dataType) {
	            customProperties = telemetryItem[strBaseData][strProperties] || {};
	            customMeasurements = telemetryItem[strBaseData].measurements || {};
	        }
	        else {
	            if (telemetryItem[strBaseData]) {
	                EnvelopeCreator.extractPropsAndMeasurements(telemetryItem[strBaseData], customProperties, customMeasurements);
	            }
	        }
	        // Extract root level properties from part C telemetryItem.data
	        EnvelopeCreator.extractPropsAndMeasurements(telemetryItem.data, customProperties, customMeasurements);
	        var eventName = telemetryItem[strBaseData].name;
	        var eventData = new Event$1(logger, eventName, customProperties, customMeasurements);
	        var data = new Data$1(Event$1.dataType, eventData);
	        return EnvelopeCreator.createEnvelope(logger, Event$1.envelopeType, telemetryItem, data);
	    };
	    EventEnvelopeCreator.EventEnvelopeCreator = new EventEnvelopeCreator();
	    return EventEnvelopeCreator;
	}(EnvelopeCreator));
	var ExceptionEnvelopeCreator = /** @class */ (function (_super) {
	    __extendsFn(ExceptionEnvelopeCreator, _super);
	    function ExceptionEnvelopeCreator() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ExceptionEnvelopeCreator.prototype.Create = function (logger, telemetryItem) {
	        _super.prototype.Init.call(this, logger, telemetryItem);
	        // Extract root level properties from part C telemetryItem.data
	        var customMeasurements = telemetryItem[strBaseData].measurements || {};
	        var customProperties = telemetryItem[strBaseData][strProperties] || {};
	        EnvelopeCreator.extractPropsAndMeasurements(telemetryItem.data, customProperties, customMeasurements);
	        var bd = telemetryItem[strBaseData];
	        var exData = Exception.CreateFromInterface(logger, bd, customProperties, customMeasurements);
	        var data = new Data$1(Exception.dataType, exData);
	        return EnvelopeCreator.createEnvelope(logger, Exception.envelopeType, telemetryItem, data);
	    };
	    ExceptionEnvelopeCreator.ExceptionEnvelopeCreator = new ExceptionEnvelopeCreator();
	    return ExceptionEnvelopeCreator;
	}(EnvelopeCreator));
	var MetricEnvelopeCreator = /** @class */ (function (_super) {
	    __extendsFn(MetricEnvelopeCreator, _super);
	    function MetricEnvelopeCreator() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    MetricEnvelopeCreator.prototype.Create = function (logger, telemetryItem) {
	        _super.prototype.Init.call(this, logger, telemetryItem);
	        var baseData = telemetryItem[strBaseData];
	        var props = baseData[strProperties] || {};
	        var measurements = baseData.measurements || {};
	        EnvelopeCreator.extractPropsAndMeasurements(telemetryItem.data, props, measurements);
	        var baseMetricData = new Metric(logger, baseData.name, baseData.average, baseData.sampleCount, baseData.min, baseData.max, props, measurements);
	        var data = new Data$1(Metric.dataType, baseMetricData);
	        return EnvelopeCreator.createEnvelope(logger, Metric.envelopeType, telemetryItem, data);
	    };
	    MetricEnvelopeCreator.MetricEnvelopeCreator = new MetricEnvelopeCreator();
	    return MetricEnvelopeCreator;
	}(EnvelopeCreator));
	var PageViewEnvelopeCreator = /** @class */ (function (_super) {
	    __extendsFn(PageViewEnvelopeCreator, _super);
	    function PageViewEnvelopeCreator() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    PageViewEnvelopeCreator.prototype.Create = function (logger, telemetryItem) {
	        _super.prototype.Init.call(this, logger, telemetryItem);
	        // Since duration is not part of the domain properties in Common Schema, extract it from part C
	        var strDuration = "duration";
	        var duration;
	        var baseData = telemetryItem[strBaseData];
	        if (!isNullOrUndefined(baseData) &&
	            !isNullOrUndefined(baseData[strProperties]) &&
	            !isNullOrUndefined(baseData[strProperties][strDuration])) {
	            duration = baseData[strProperties][strDuration];
	            delete baseData[strProperties][strDuration];
	        }
	        else if (!isNullOrUndefined(telemetryItem.data) &&
	            !isNullOrUndefined(telemetryItem.data[strDuration])) {
	            duration = telemetryItem.data[strDuration];
	            delete telemetryItem.data[strDuration];
	        }
	        var bd = telemetryItem[strBaseData];
	        // special case: pageview.id is grabbed from current operation id. Analytics plugin is decoupled from properties plugin, so this is done here instead. This can be made a default telemetry intializer instead if needed to be decoupled from channel
	        var currentContextId;
	        if (((telemetryItem.ext || {}).trace || {}).traceID) {
	            currentContextId = telemetryItem.ext.trace.traceID;
	        }
	        var id = bd.id || currentContextId;
	        var name = bd.name;
	        var url = bd.uri;
	        var properties = bd[strProperties] || {};
	        var measurements = bd.measurements || {};
	        // refUri is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
	        if (!isNullOrUndefined(bd.refUri)) {
	            properties["refUri"] = bd.refUri;
	        }
	        // pageType is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
	        if (!isNullOrUndefined(bd.pageType)) {
	            properties["pageType"] = bd.pageType;
	        }
	        // isLoggedIn is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
	        if (!isNullOrUndefined(bd.isLoggedIn)) {
	            properties["isLoggedIn"] = bd.isLoggedIn.toString();
	        }
	        // pageTags is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
	        if (!isNullOrUndefined(bd[strProperties])) {
	            var pageTags = bd[strProperties];
	            objForEachKey(pageTags, function (key, value) {
	                properties[key] = value;
	            });
	        }
	        EnvelopeCreator.extractPropsAndMeasurements(telemetryItem.data, properties, measurements);
	        var pageViewData = new PageView(logger, name, url, duration, properties, measurements, id);
	        var data = new Data$1(PageView.dataType, pageViewData);
	        return EnvelopeCreator.createEnvelope(logger, PageView.envelopeType, telemetryItem, data);
	    };
	    PageViewEnvelopeCreator.PageViewEnvelopeCreator = new PageViewEnvelopeCreator();
	    return PageViewEnvelopeCreator;
	}(EnvelopeCreator));
	var PageViewPerformanceEnvelopeCreator = /** @class */ (function (_super) {
	    __extendsFn(PageViewPerformanceEnvelopeCreator, _super);
	    function PageViewPerformanceEnvelopeCreator() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    PageViewPerformanceEnvelopeCreator.prototype.Create = function (logger, telemetryItem) {
	        _super.prototype.Init.call(this, logger, telemetryItem);
	        var bd = telemetryItem[strBaseData];
	        var name = bd.name;
	        var url = bd.uri || bd.url;
	        var properties = bd[strProperties] || {};
	        var measurements = bd.measurements || {};
	        EnvelopeCreator.extractPropsAndMeasurements(telemetryItem.data, properties, measurements);
	        var baseData = new PageViewPerformance(logger, name, url, undefined, properties, measurements, bd);
	        var data = new Data$1(PageViewPerformance.dataType, baseData);
	        return EnvelopeCreator.createEnvelope(logger, PageViewPerformance.envelopeType, telemetryItem, data);
	    };
	    PageViewPerformanceEnvelopeCreator.PageViewPerformanceEnvelopeCreator = new PageViewPerformanceEnvelopeCreator();
	    return PageViewPerformanceEnvelopeCreator;
	}(EnvelopeCreator));
	var TraceEnvelopeCreator = /** @class */ (function (_super) {
	    __extendsFn(TraceEnvelopeCreator, _super);
	    function TraceEnvelopeCreator() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    TraceEnvelopeCreator.prototype.Create = function (logger, telemetryItem) {
	        _super.prototype.Init.call(this, logger, telemetryItem);
	        var message = telemetryItem[strBaseData].message;
	        var severityLevel = telemetryItem[strBaseData].severityLevel;
	        var props = telemetryItem[strBaseData][strProperties] || {};
	        var measurements = telemetryItem[strBaseData].measurements || {};
	        EnvelopeCreator.extractPropsAndMeasurements(telemetryItem.data, props, measurements);
	        var baseData = new Trace(logger, message, severityLevel, props, measurements);
	        var data = new Data$1(Trace.dataType, baseData);
	        return EnvelopeCreator.createEnvelope(logger, Trace.envelopeType, telemetryItem, data);
	    };
	    TraceEnvelopeCreator.TraceEnvelopeCreator = new TraceEnvelopeCreator();
	    return TraceEnvelopeCreator;
	}(EnvelopeCreator));

	/*
	 * Application Insights JavaScript SDK - Channel, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var Serializer = /** @class */ (function () {
	    function Serializer(logger) {
	        dynamicProto(Serializer, this, function (_self) {
	            /**
	             * Serializes the current object to a JSON string.
	             */
	            _self.serialize = function (input) {
	                var output = _serializeObject(input, "root");
	                try {
	                    return getJSON().stringify(output);
	                }
	                catch (e) {
	                    // if serialization fails return an empty string
	                    logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.CannotSerializeObject, (e && isFunction$1(e.toString)) ? e.toString() : "Error serializing object", null, true);
	                }
	            };
	            function _serializeObject(source, name) {
	                var circularReferenceCheck = "__aiCircularRefCheck";
	                var output = {};
	                if (!source) {
	                    logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.CannotSerializeObject, "cannot serialize object because it is null or undefined", { name: name }, true);
	                    return output;
	                }
	                if (source[circularReferenceCheck]) {
	                    logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.CircularReferenceDetected, "Circular reference detected while serializing object", { name: name }, true);
	                    return output;
	                }
	                if (!source.aiDataContract) {
	                    // special case for measurements/properties/tags
	                    if (name === "measurements") {
	                        output = _serializeStringMap(source, "number", name);
	                    }
	                    else if (name === "properties") {
	                        output = _serializeStringMap(source, "string", name);
	                    }
	                    else if (name === "tags") {
	                        output = _serializeStringMap(source, "string", name);
	                    }
	                    else if (isArray$1(source)) {
	                        output = _serializeArray(source, name);
	                    }
	                    else {
	                        logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.CannotSerializeObjectNonSerializable, "Attempting to serialize an object which does not implement ISerializable", { name: name }, true);
	                        try {
	                            // verify that the object can be stringified
	                            getJSON().stringify(source);
	                            output = source;
	                        }
	                        catch (e) {
	                            // if serialization fails return an empty string
	                            logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.CannotSerializeObject, (e && isFunction$1(e.toString)) ? e.toString() : "Error serializing object", null, true);
	                        }
	                    }
	                    return output;
	                }
	                source[circularReferenceCheck] = true;
	                objForEachKey(source.aiDataContract, function (field, contract) {
	                    var isRequired = (isFunction$1(contract)) ? (contract() & 1 /* Required */) : (contract & 1 /* Required */);
	                    var isHidden = (isFunction$1(contract)) ? (contract() & 4 /* Hidden */) : (contract & 4 /* Hidden */);
	                    var isArray = contract & 2 /* Array */;
	                    var isPresent = source[field] !== undefined;
	                    var isObj = isObject$1(source[field]) && source[field] !== null;
	                    if (isRequired && !isPresent && !isArray) {
	                        logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.MissingRequiredFieldSpecification, "Missing required field specification. The field is required but not present on source", { field: field, name: name });
	                        // If not in debug mode, continue and hope the error is permissible
	                    }
	                    else if (!isHidden) {
	                        var value = void 0;
	                        if (isObj) {
	                            if (isArray) {
	                                // special case; recurse on each object in the source array
	                                value = _serializeArray(source[field], field);
	                            }
	                            else {
	                                // recurse on the source object in this field
	                                value = _serializeObject(source[field], field);
	                            }
	                        }
	                        else {
	                            // assign the source field to the output even if undefined or required
	                            value = source[field];
	                        }
	                        // only emit this field if the value is defined
	                        if (value !== undefined) {
	                            output[field] = value;
	                        }
	                    }
	                });
	                delete source[circularReferenceCheck];
	                return output;
	            }
	            function _serializeArray(sources, name) {
	                var output;
	                if (!!sources) {
	                    if (!isArray$1(sources)) {
	                        logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.ItemNotInArray, "This field was specified as an array in the contract but the item is not an array.\r\n", { name: name }, true);
	                    }
	                    else {
	                        output = [];
	                        for (var i = 0; i < sources.length; i++) {
	                            var source = sources[i];
	                            var item = _serializeObject(source, name + "[" + i + "]");
	                            output.push(item);
	                        }
	                    }
	                }
	                return output;
	            }
	            function _serializeStringMap(map, expectedType, name) {
	                var output;
	                if (map) {
	                    output = {};
	                    objForEachKey(map, function (field, value) {
	                        if (expectedType === "string") {
	                            if (value === undefined) {
	                                output[field] = "undefined";
	                            }
	                            else if (value === null) {
	                                output[field] = "null";
	                            }
	                            else if (!value.toString) {
	                                output[field] = "invalid field: toString() is not defined.";
	                            }
	                            else {
	                                output[field] = value.toString();
	                            }
	                        }
	                        else if (expectedType === "number") {
	                            if (value === undefined) {
	                                output[field] = "undefined";
	                            }
	                            else if (value === null) {
	                                output[field] = "null";
	                            }
	                            else {
	                                var num = parseFloat(value);
	                                if (isNaN(num)) {
	                                    output[field] = "NaN";
	                                }
	                                else {
	                                    output[field] = num;
	                                }
	                            }
	                        }
	                        else {
	                            output[field] = "invalid field: " + name + " is of unknown type.";
	                            logger.throwInternal(LoggingSeverity.CRITICAL, output[field], null, true);
	                        }
	                    });
	                }
	                return output;
	            }
	        });
	    }
	// Removed Stub for Serializer.prototype.serialize.
	    return Serializer;
	}());

	/*
	 * Application Insights JavaScript SDK - Channel, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	/**
	 * @description Monitors browser for offline events
	 * @export default - Offline: Static instance of OfflineListener
	 * @class OfflineListener
	 */
	var OfflineListener = /** @class */ (function () {
	    function OfflineListener() {
	        var _window = getWindow();
	        var _document = getDocument();
	        var isListening = false;
	        var _onlineStatus = true;
	        dynamicProto(OfflineListener, this, function (_self) {
	            try {
	                if (_window) {
	                    if (EventHelper.Attach(_window, 'online', _setOnline)) {
	                        EventHelper.Attach(_window, 'offline', _setOffline);
	                        isListening = true;
	                    }
	                }
	                if (_document) {
	                    // Also attach to the document.body or document
	                    var target = _document.body || _document;
	                    if (!isUndefined(target.ononline)) {
	                        target.ononline = _setOnline;
	                        target.onoffline = _setOffline;
	                        isListening = true;
	                    }
	                }
	                if (isListening) {
	                    // We are listening to events so lets set the current status rather than assuming we are online #1538
	                    var _navigator = getNavigator(); // Gets the window.navigator or workerNavigator depending on the global
	                    if (_navigator && !isNullOrUndefined(_navigator.onLine)) {
	                        _onlineStatus = _navigator.onLine;
	                    }
	                }
	            }
	            catch (e) {
	                // this makes react-native less angry
	                isListening = false;
	            }
	            _self.isListening = isListening;
	            _self.isOnline = function () {
	                var result = true;
	                var _navigator = getNavigator();
	                if (isListening) {
	                    result = _onlineStatus;
	                }
	                else if (_navigator && !isNullOrUndefined(_navigator.onLine)) {
	                    result = _navigator.onLine;
	                }
	                return result;
	            };
	            _self.isOffline = function () {
	                return !_self.isOnline();
	            };
	            function _setOnline() {
	                _onlineStatus = true;
	            }
	            function _setOffline() {
	                _onlineStatus = false;
	            }
	        });
	    }
	// Removed Stub for OfflineListener.prototype.isOnline.
	// Removed Stub for OfflineListener.prototype.isOffline.
	    OfflineListener.Offline = new OfflineListener;
	    return OfflineListener;
	}());
	var Offline = OfflineListener.Offline;

	/*
	 * Application Insights JavaScript SDK - Channel, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	var HashCodeScoreGenerator = /** @class */ (function () {
	    function HashCodeScoreGenerator() {
	    }
	    HashCodeScoreGenerator.prototype.getHashCodeScore = function (key) {
	        var score = this.getHashCode(key) / HashCodeScoreGenerator.INT_MAX_VALUE;
	        return score * 100;
	    };
	    HashCodeScoreGenerator.prototype.getHashCode = function (input) {
	        if (input === "") {
	            return 0;
	        }
	        while (input.length < HashCodeScoreGenerator.MIN_INPUT_LENGTH) {
	            input = input.concat(input);
	        }
	        // 5381 is a magic number: http://stackoverflow.com/questions/10696223/reason-for-5381-number-in-djb-hash-function
	        var hash = 5381;
	        for (var i = 0; i < input.length; ++i) {
	            hash = ((hash << 5) + hash) + input.charCodeAt(i);
	            // 'hash' is of number type which means 53 bit integer (http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types-number-type)
	            // 'hash & hash' will keep it 32 bit integer - just to make it clearer what the result is.
	            hash = hash & hash;
	        }
	        return Math.abs(hash);
	    };
	    // We're using 32 bit math, hence max value is (2^31 - 1)
	    HashCodeScoreGenerator.INT_MAX_VALUE = 2147483647;
	    // (Magic number) DJB algorithm can't work on shorter strings (results in poor distribution
	    HashCodeScoreGenerator.MIN_INPUT_LENGTH = 8;
	    return HashCodeScoreGenerator;
	}());

	/*
	 * Application Insights JavaScript SDK - Channel, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var SamplingScoreGenerator = /** @class */ (function () {
	    function SamplingScoreGenerator() {
	        this.hashCodeGeneragor = new HashCodeScoreGenerator();
	        this.keys = new ContextTagKeys();
	    }
	    SamplingScoreGenerator.prototype.getSamplingScore = function (item) {
	        var score = 0;
	        if (item.tags && item.tags[this.keys.userId]) {
	            score = this.hashCodeGeneragor.getHashCodeScore(item.tags[this.keys.userId]);
	        }
	        else if (item.ext && item.ext.user && item.ext.user.id) {
	            score = this.hashCodeGeneragor.getHashCodeScore(item.ext.user.id);
	        }
	        else if (item.tags && item.tags[this.keys.operationId]) {
	            score = this.hashCodeGeneragor.getHashCodeScore(item.tags[this.keys.operationId]);
	        }
	        else if (item.ext && item.ext.telemetryTrace && item.ext.telemetryTrace.traceID) {
	            score = this.hashCodeGeneragor.getHashCodeScore(item.ext.telemetryTrace.traceID);
	        }
	        else {
	            // tslint:disable-next-line:insecure-random
	            score = (Math.random() * 100);
	        }
	        return score;
	    };
	    return SamplingScoreGenerator;
	}());

	/*
	 * Application Insights JavaScript SDK - Channel, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var Sample = /** @class */ (function () {
	    function Sample(sampleRate, logger) {
	        // We're using 32 bit math, hence max value is (2^31 - 1)
	        this.INT_MAX_VALUE = 2147483647;
	        this._logger = logger || safeGetLogger(null);
	        if (sampleRate > 100 || sampleRate < 0) {
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.SampleRateOutOfRange, "Sampling rate is out of range (0..100). Sampling will be disabled, you may be sending too much data which may affect your AI service level.", { samplingRate: sampleRate }, true);
	            sampleRate = 100;
	        }
	        this.sampleRate = sampleRate;
	        this.samplingScoreGenerator = new SamplingScoreGenerator();
	    }
	    /**
	     * Determines if an envelope is sampled in (i.e. will be sent) or not (i.e. will be dropped).
	     */
	    Sample.prototype.isSampledIn = function (envelope) {
	        var samplingPercentage = this.sampleRate; // 0 - 100
	        var isSampledIn = false;
	        if (samplingPercentage === null || samplingPercentage === undefined || samplingPercentage >= 100) {
	            return true;
	        }
	        else if (envelope.baseType === Metric.dataType) {
	            // exclude MetricData telemetry from sampling
	            return true;
	        }
	        isSampledIn = this.samplingScoreGenerator.getSamplingScore(envelope) < samplingPercentage;
	        return isSampledIn;
	    };
	    return Sample;
	}());

	/*
	 * Application Insights JavaScript SDK - Channel, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	function _getResponseText(xhr) {
	    try {
	        return xhr.responseText;
	    }
	    catch (e) {
	        // Best effort, as XHR may throw while XDR wont so just ignore
	    }
	    return null;
	}
	var Sender = /** @class */ (function (_super) {
	    __extendsFn(Sender, _super);
	    function Sender() {
	        var _this = _super.call(this) || this;
	        _this.priority = 1001;
	        _this.identifier = BreezeChannelIdentifier;
	        /**
	         * Whether XMLHttpRequest object is supported. Older version of IE (8,9) do not support it.
	         */
	        _this._XMLHttpRequestSupported = false;
	        /**
	         * How many times in a row a retryable error condition has occurred.
	         */
	        var _consecutiveErrors;
	        /**
	         * The time to retry at in milliseconds from 1970/01/01 (this makes the timer calculation easy).
	         */
	        var _retryAt;
	        /**
	         * Handle to the timer for delayed sending of batches of data.
	         */
	        var _timeoutHandle;
	        var _serializer;
	        var _stamp_specific_redirects;
	        var _headers = {};
	        dynamicProto(Sender, _this, function (_self, _base) {
	            function _notImplemented() {
	                throwError("Method not implemented.");
	            }
	            _self.pause = _notImplemented;
	            _self.resume = _notImplemented;
	            _self.flush = function () {
	                try {
	                    _self.triggerSend(true, null, 1 /* ManualFlush */);
	                }
	                catch (e) {
	                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FlushFailed, "flush failed, telemetry will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
	                }
	            };
	            _self.onunloadFlush = function () {
	                if ((_self._senderConfig.onunloadDisableBeacon() === false || _self._senderConfig.isBeaconApiDisabled() === false) && isBeaconApiSupported()) {
	                    try {
	                        _self.triggerSend(true, _beaconSender, 2 /* Unload */);
	                    }
	                    catch (e) {
	                        _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedToSendQueuedTelemetry, "failed to flush with beacon sender on page unload, telemetry will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
	                    }
	                }
	                else {
	                    _self.flush();
	                }
	            };
	            _self.teardown = _notImplemented;
	            _self.addHeader = function (name, value) {
	                _headers[name] = value;
	            };
	            _self.initialize = function (config, core, extensions, pluginChain) {
	                _base.initialize(config, core, extensions, pluginChain);
	                var ctx = _self._getTelCtx();
	                var identifier = _self.identifier;
	                _serializer = new Serializer(core.logger);
	                _consecutiveErrors = 0;
	                _retryAt = null;
	                _self._sender = null;
	                _stamp_specific_redirects = 0;
	                var defaultConfig = Sender._getDefaultAppInsightsChannelConfig();
	                _self._senderConfig = Sender._getEmptyAppInsightsChannelConfig();
	                objForEachKey(defaultConfig, function (field, value) {
	                    _self._senderConfig[field] = function () { return ctx.getConfig(identifier, field, value()); };
	                });
	                _self._buffer = (_self._senderConfig.enableSessionStorageBuffer() && utlCanUseSessionStorage())
	                    ? new SessionStorageSendBuffer(_self.diagLog(), _self._senderConfig) : new ArraySendBuffer(_self._senderConfig);
	                _self._sample = new Sample(_self._senderConfig.samplingPercentage(), _self.diagLog());
	                if (!_validateInstrumentationKey(config)) {
	                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.InvalidInstrumentationKey, "Invalid Instrumentation key " + config.instrumentationKey);
	                }
	                if (!isInternalApplicationInsightsEndpoint(_self._senderConfig.endpointUrl()) && _self._senderConfig.customHeaders() && _self._senderConfig.customHeaders().length > 0) {
	                    arrForEach(_self._senderConfig.customHeaders(), function (customHeader) {
	                        _this.addHeader(customHeader.header, customHeader.value);
	                    });
	                }
	                if (!_self._senderConfig.isBeaconApiDisabled() && isBeaconApiSupported()) {
	                    _self._sender = _beaconSender;
	                }
	                else {
	                    var xhr = getGlobalInst("XMLHttpRequest");
	                    if (xhr) {
	                        var testXhr = new xhr();
	                        if ("withCredentials" in testXhr) {
	                            _self._sender = _xhrSender;
	                            _self._XMLHttpRequestSupported = true;
	                        }
	                        else if (typeof XDomainRequest !== strShimUndefined) {
	                            _self._sender = _xdrSender; // IE 8 and 9
	                        }
	                    }
	                    else {
	                        var fetch_1 = getGlobalInst("fetch");
	                        if (fetch_1) {
	                            _self._sender = _fetchSender;
	                        }
	                    }
	                }
	            };
	            _self.processTelemetry = function (telemetryItem, itemCtx) {
	                itemCtx = _self._getTelCtx(itemCtx);
	                try {
	                    // if master off switch is set, don't send any data
	                    if (_self._senderConfig.disableTelemetry()) {
	                        // Do not send/save data
	                        return;
	                    }
	                    // validate input
	                    if (!telemetryItem) {
	                        itemCtx.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.CannotSendEmptyTelemetry, "Cannot send empty telemetry");
	                        return;
	                    }
	                    // validate event
	                    if (telemetryItem.baseData && !telemetryItem.baseType) {
	                        itemCtx.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.InvalidEvent, "Cannot send telemetry without baseData and baseType");
	                        return;
	                    }
	                    if (!telemetryItem.baseType) {
	                        // Default
	                        telemetryItem.baseType = "EventData";
	                    }
	                    // ensure a sender was constructed
	                    if (!_self._sender) {
	                        itemCtx.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.SenderNotInitialized, "Sender was not initialized");
	                        return;
	                    }
	                    // check if this item should be sampled in, else add sampleRate tag
	                    if (!_isSampledIn(telemetryItem)) {
	                        // Item is sampled out, do not send it
	                        itemCtx.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TelemetrySampledAndNotSent, "Telemetry item was sampled out and not sent", { SampleRate: _self._sample.sampleRate });
	                        return;
	                    }
	                    else {
	                        telemetryItem[SampleRate] = _self._sample.sampleRate;
	                    }
	                    // construct an envelope that Application Insights endpoint can understand
	                    var aiEnvelope_1 = Sender.constructEnvelope(telemetryItem, _self._senderConfig.instrumentationKey(), itemCtx.diagLog());
	                    if (!aiEnvelope_1) {
	                        itemCtx.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.CreateEnvelopeError, "Unable to create an AppInsights envelope");
	                        return;
	                    }
	                    var doNotSendItem_1 = false;
	                    // this is for running in legacy mode, where customer may already have a custom initializer present
	                    if (telemetryItem.tags && telemetryItem.tags[ProcessLegacy]) {
	                        arrForEach(telemetryItem.tags[ProcessLegacy], function (callBack) {
	                            try {
	                                if (callBack && callBack(aiEnvelope_1) === false) {
	                                    doNotSendItem_1 = true;
	                                    itemCtx.diagLog().warnToConsole("Telemetry processor check returns false");
	                                }
	                            }
	                            catch (e) {
	                                // log error but dont stop executing rest of the telemetry initializers
	                                // doNotSendItem = true;
	                                itemCtx.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TelemetryInitializerFailed, "One of telemetry initializers failed, telemetry item will not be sent: " + getExceptionName(e), { exception: dumpObj(e) }, true);
	                            }
	                        });
	                        delete telemetryItem.tags[ProcessLegacy];
	                    }
	                    if (doNotSendItem_1) {
	                        return; // do not send, no need to execute next plugin
	                    }
	                    // check if the incoming payload is too large, truncate if necessary
	                    var payload = _serializer.serialize(aiEnvelope_1);
	                    // flush if we would exceed the max-size limit by adding this item
	                    var bufferPayload = _self._buffer.getItems();
	                    var batch = _self._buffer.batchPayloads(bufferPayload);
	                    if (batch && (batch.length + payload.length > _self._senderConfig.maxBatchSizeInBytes())) {
	                        _self.triggerSend(true, null, 10 /* MaxBatchSize */);
	                    }
	                    // enqueue the payload
	                    _self._buffer.enqueue(payload);
	                    // ensure an invocation timeout is set
	                    _setupTimer();
	                }
	                catch (e) {
	                    itemCtx.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedAddingTelemetryToBuffer, "Failed adding telemetry to the sender's buffer, some telemetry will be lost: " + getExceptionName(e), { exception: dumpObj(e) });
	                }
	                // hand off the telemetry item to the next plugin
	                _self.processNext(telemetryItem, itemCtx);
	            };
	            /**
	             * xhr state changes
	             */
	            _self._xhrReadyStateChange = function (xhr, payload, countOfItemsInPayload) {
	                if (xhr.readyState === 4) {
	                    _checkResponsStatus(xhr.status, payload, xhr.responseURL, countOfItemsInPayload, _formatErrorMessageXhr(xhr), _getResponseText(xhr) || xhr.response);
	                }
	            };
	            /**
	             * Immediately send buffered data
	             * @param async {boolean} - Indicates if the events should be sent asynchronously
	             * @param forcedSender {SenderFunction} - Indicates the forcedSender, undefined if not passed
	             */
	            _self.triggerSend = function (async, forcedSender, sendReason) {
	                if (async === void 0) { async = true; }
	                try {
	                    // Send data only if disableTelemetry is false
	                    if (!_self._senderConfig.disableTelemetry()) {
	                        if (_self._buffer.count() > 0) {
	                            var payload = _self._buffer.getItems();
	                            _notifySendRequest(sendReason || 0 /* Undefined */, async);
	                            // invoke send
	                            if (forcedSender) {
	                                forcedSender.call(_this, payload, async);
	                            }
	                            else {
	                                _self._sender(payload, async);
	                            }
	                        }
	                    }
	                    else {
	                        _self._buffer.clear();
	                    }
	                    clearTimeout(_timeoutHandle);
	                    _timeoutHandle = null;
	                    _retryAt = null;
	                }
	                catch (e) {
	                    /* Ignore this error for IE under v10 */
	                    var ieVer = getIEVersion();
	                    if (!ieVer || ieVer > 9) {
	                        _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TransmissionFailed, "Telemetry transmission failed, some telemetry will be lost: " + getExceptionName(e), { exception: dumpObj(e) });
	                    }
	                }
	            };
	            /**
	             * error handler
	             */
	            _self._onError = function (payload, message, event) {
	                _self.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.OnError, "Failed to send telemetry.", { message: message });
	                _self._buffer.clearSent(payload);
	            };
	            /**
	             * partial success handler
	             */
	            _self._onPartialSuccess = function (payload, results) {
	                var failed = [];
	                var retry = [];
	                // Iterate through the reversed array of errors so that splicing doesn't have invalid indexes after the first item.
	                var errors = results.errors.reverse();
	                for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
	                    var error = errors_1[_i];
	                    var extracted = payload.splice(error.index, 1)[0];
	                    if (_isRetriable(error.statusCode)) {
	                        retry.push(extracted);
	                    }
	                    else {
	                        // All other errors, including: 402 (Monthly quota exceeded) and 439 (Too many requests and refresh cache).
	                        failed.push(extracted);
	                    }
	                }
	                if (payload.length > 0) {
	                    _self._onSuccess(payload, results.itemsAccepted);
	                }
	                if (failed.length > 0) {
	                    _self._onError(failed, _formatErrorMessageXhr(null, ['partial success', results.itemsAccepted, 'of', results.itemsReceived].join(' ')));
	                }
	                if (retry.length > 0) {
	                    _resendPayload(retry);
	                    _self.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, "Partial success. " +
	                        "Delivered: " + payload.length + ", Failed: " + failed.length +
	                        ". Will retry to send " + retry.length + " our of " + results.itemsReceived + " items");
	                }
	            };
	            /**
	             * success handler
	             */
	            _self._onSuccess = function (payload, countOfItemsInPayload) {
	                _self._buffer.clearSent(payload);
	            };
	            /**
	             * xdr state changes
	             */
	            _self._xdrOnLoad = function (xdr, payload) {
	                var responseText = _getResponseText(xdr);
	                if (xdr && (responseText + "" === "200" || responseText === "")) {
	                    _consecutiveErrors = 0;
	                    _self._onSuccess(payload, 0);
	                }
	                else {
	                    var results = _parseResponse(responseText);
	                    if (results && results.itemsReceived && results.itemsReceived > results.itemsAccepted
	                        && !_self._senderConfig.isRetryDisabled()) {
	                        _self._onPartialSuccess(payload, results);
	                    }
	                    else {
	                        _self._onError(payload, _formatErrorMessageXdr(xdr));
	                    }
	                }
	            };
	            function _isSampledIn(envelope) {
	                return _self._sample.isSampledIn(envelope);
	            }
	            function _checkResponsStatus(status, payload, responseUrl, countOfItemsInPayload, errorMessage, res) {
	                var response = null;
	                if (!_self._appId) {
	                    response = _parseResponse(res);
	                    if (response && response.appId) {
	                        _self._appId = response.appId;
	                    }
	                }
	                if ((status < 200 || status >= 300) && status !== 0) {
	                    // Update End Point url if permanent redirect or moved permanently
	                    // Updates the end point url before retry
	                    if (status === 301 || status === 307 || status === 308) {
	                        if (!_checkAndUpdateEndPointUrl(responseUrl)) {
	                            _self._onError(payload, errorMessage);
	                            return;
	                        }
	                    }
	                    if (!_self._senderConfig.isRetryDisabled() && _isRetriable(status)) {
	                        _resendPayload(payload);
	                        _self.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, ". " +
	                            "Response code " + status + ". Will retry to send " + payload.length + " items.");
	                    }
	                    else {
	                        _self._onError(payload, errorMessage);
	                    }
	                }
	                else if (Offline.isOffline()) {
	                    // Note: Don't check for status == 0, since adblock gives this code
	                    if (!_self._senderConfig.isRetryDisabled()) {
	                        var offlineBackOffMultiplier = 10; // arbritrary number
	                        _resendPayload(payload, offlineBackOffMultiplier);
	                        _self.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, ". Offline - Response Code: " + status + ". Offline status: " + Offline.isOffline() + ". Will retry to send " + payload.length + " items.");
	                    }
	                }
	                else {
	                    // check if the xhr's responseURL or fetch's response.url is same as endpoint url
	                    // TODO after 10 redirects force send telemetry with 'redirect=false' as query parameter.
	                    _checkAndUpdateEndPointUrl(responseUrl);
	                    if (status === 206) {
	                        if (!response) {
	                            response = _parseResponse(res);
	                        }
	                        if (response && !_self._senderConfig.isRetryDisabled()) {
	                            _self._onPartialSuccess(payload, response);
	                        }
	                        else {
	                            _self._onError(payload, errorMessage);
	                        }
	                    }
	                    else {
	                        _consecutiveErrors = 0;
	                        _self._onSuccess(payload, countOfItemsInPayload);
	                    }
	                }
	            }
	            function _checkAndUpdateEndPointUrl(responseUrl) {
	                // Maximum stamp specific redirects allowed(uncomment this when breeze is ready with not allowing redirects feature)
	                if (_stamp_specific_redirects >= 10) {
	                    //  _self._senderConfig.endpointUrl = () => Sender._getDefaultAppInsightsChannelConfig().endpointUrl()+"/?redirect=false";
	                    //  _stamp_specific_redirects = 0;
	                    return false;
	                }
	                if (!isNullOrUndefined(responseUrl) && responseUrl !== '') {
	                    if (responseUrl !== _self._senderConfig.endpointUrl()) {
	                        _self._senderConfig.endpointUrl = function () { return responseUrl; };
	                        ++_stamp_specific_redirects;
	                        return true;
	                    }
	                }
	                return false;
	            }
	            /**
	             * Send Beacon API request
	             * @param payload {string} - The data payload to be sent.
	             * @param isAsync {boolean} - not used
	             * Note: Beacon API does not support custom headers and we are not able to get
	             * appId from the backend for the correct correlation.
	             */
	            function _beaconSender(payload, isAsync) {
	                var url = _self._senderConfig.endpointUrl();
	                var batch = _self._buffer.batchPayloads(payload);
	                // Chrome only allows CORS-safelisted values for the sendBeacon data argument
	                // see: https://bugs.chromium.org/p/chromium/issues/detail?id=720283
	                var plainTextBatch = new Blob([batch], { type: 'text/plain;charset=UTF-8' });
	                // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.
	                var queued = getNavigator().sendBeacon(url, plainTextBatch);
	                if (queued) {
	                    _self._buffer.markAsSent(payload);
	                    // no response from beaconSender, clear buffer
	                    _self._onSuccess(payload, payload.length);
	                }
	                else {
	                    _xhrSender(payload, true);
	                    _self.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, ". " + "Failed to send telemetry with Beacon API, retried with xhrSender.");
	                }
	            }
	            /**
	             * Send XMLHttpRequest
	             * @param payload {string} - The data payload to be sent.
	             * @param isAsync {boolean} - Indicates if the request should be sent asynchronously
	             */
	            function _xhrSender(payload, isAsync) {
	                var xhr = new XMLHttpRequest();
	                var endPointUrl = _self._senderConfig.endpointUrl();
	                try {
	                    xhr[DisabledPropertyName] = true;
	                }
	                catch (e) {
	                    // If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would
	                    // cause the request to fail and we no telemetry would be sent
	                }
	                xhr.open("POST", endPointUrl, isAsync);
	                xhr.setRequestHeader("Content-type", "application/json");
	                // append Sdk-Context request header only in case of breeze endpoint
	                if (isInternalApplicationInsightsEndpoint(endPointUrl)) {
	                    xhr.setRequestHeader(RequestHeaders.sdkContextHeader, RequestHeaders.sdkContextHeaderAppIdRequest);
	                }
	                arrForEach(objKeys(_headers), function (headerName) {
	                    xhr.setRequestHeader(headerName, _headers[headerName]);
	                });
	                xhr.onreadystatechange = function () { return _self._xhrReadyStateChange(xhr, payload, payload.length); };
	                xhr.onerror = function (event) { return _self._onError(payload, _formatErrorMessageXhr(xhr), event); };
	                // compose an array of payloads
	                var batch = _self._buffer.batchPayloads(payload);
	                xhr.send(batch);
	                _self._buffer.markAsSent(payload);
	            }
	            /**
	             * Send fetch API request
	             * @param payload {string} - The data payload to be sent.
	             * @param isAsync {boolean} - not used
	             */
	            function _fetchSender(payload, isAsync) {
	                var endPointUrl = _self._senderConfig.endpointUrl();
	                var batch = _self._buffer.batchPayloads(payload);
	                var plainTextBatch = new Blob([batch], { type: 'text/plain;charset=UTF-8' });
	                var requestHeaders = new Headers();
	                // append Sdk-Context request header only in case of breeze endpoint
	                if (isInternalApplicationInsightsEndpoint(endPointUrl)) {
	                    requestHeaders.append(RequestHeaders.sdkContextHeader, RequestHeaders.sdkContextHeaderAppIdRequest);
	                }
	                arrForEach(objKeys(_headers), function (headerName) {
	                    requestHeaders.append(headerName, _headers[headerName]);
	                });
	                var init = {
	                    method: "POST",
	                    headers: requestHeaders,
	                    body: plainTextBatch
	                };
	                var request = new Request(endPointUrl, init);
	                fetch(request).then(function (response) {
	                    /**
	                     * The Promise returned from fetch() won’t reject on HTTP error status even if the response is an HTTP 404 or 500.
	                     * Instead, it will resolve normally (with ok status set to false), and it will only reject on network failure
	                     * or if anything prevented the request from completing.
	                     */
	                    if (!response.ok) {
	                        throw Error(response.statusText);
	                    }
	                    else {
	                        response.text().then(function (text) {
	                            _checkResponsStatus(response.status, payload, response.url, payload.length, response.statusText, text);
	                        });
	                        _self._buffer.markAsSent(payload);
	                    }
	                })["catch"](function (error) {
	                    _self._onError(payload, error.message);
	                });
	            }
	            /**
	             * Parses the response from the backend.
	             * @param response - XMLHttpRequest or XDomainRequest response
	             */
	            function _parseResponse(response) {
	                try {
	                    if (response && response !== "") {
	                        var result = getJSON().parse(response);
	                        if (result && result.itemsReceived && result.itemsReceived >= result.itemsAccepted &&
	                            result.itemsReceived - result.itemsAccepted === result.errors.length) {
	                            return result;
	                        }
	                    }
	                }
	                catch (e) {
	                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.InvalidBackendResponse, "Cannot parse the response. " + getExceptionName(e), {
	                        response: response
	                    });
	                }
	                return null;
	            }
	            /**
	             * Resend payload. Adds payload back to the send buffer and setup a send timer (with exponential backoff).
	             * @param payload
	             */
	            function _resendPayload(payload, linearFactor) {
	                if (linearFactor === void 0) { linearFactor = 1; }
	                if (!payload || payload.length === 0) {
	                    return;
	                }
	                _self._buffer.clearSent(payload);
	                _consecutiveErrors++;
	                for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {
	                    var item = payload_1[_i];
	                    _self._buffer.enqueue(item);
	                }
	                // setup timer
	                _setRetryTime(linearFactor);
	                _setupTimer();
	            }
	            /**
	             * Calculates the time to wait before retrying in case of an error based on
	             * http://en.wikipedia.org/wiki/Exponential_backoff
	             */
	            function _setRetryTime(linearFactor) {
	                var SlotDelayInSeconds = 10;
	                var delayInSeconds;
	                if (_consecutiveErrors <= 1) {
	                    delayInSeconds = SlotDelayInSeconds;
	                }
	                else {
	                    var backOffSlot = (Math.pow(2, _consecutiveErrors) - 1) / 2;
	                    // tslint:disable-next-line:insecure-random
	                    var backOffDelay = Math.floor(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;
	                    backOffDelay = linearFactor * backOffDelay;
	                    delayInSeconds = Math.max(Math.min(backOffDelay, 3600), SlotDelayInSeconds);
	                }
	                // TODO: Log the backoff time like the C# version does.
	                var retryAfterTimeSpan = dateNow() + (delayInSeconds * 1000);
	                // TODO: Log the retry at time like the C# version does.
	                _retryAt = retryAfterTimeSpan;
	            }
	            /**
	             * Sets up the timer which triggers actually sending the data.
	             */
	            function _setupTimer() {
	                if (!_timeoutHandle) {
	                    var retryInterval = _retryAt ? Math.max(0, _retryAt - dateNow()) : 0;
	                    var timerValue = Math.max(_self._senderConfig.maxBatchInterval(), retryInterval);
	                    _timeoutHandle = setTimeout(function () {
	                        _self.triggerSend(true, null, 1 /* NormalSchedule */);
	                    }, timerValue);
	                }
	            }
	            /**
	             * Checks if the SDK should resend the payload after receiving this status code from the backend.
	             * @param statusCode
	             */
	            function _isRetriable(statusCode) {
	                return statusCode === 408 // Timeout
	                    || statusCode === 429 // Too many requests.
	                    || statusCode === 500 // Internal server error.
	                    || statusCode === 503; // Service unavailable.
	            }
	            function _formatErrorMessageXhr(xhr, message) {
	                if (xhr) {
	                    return "XMLHttpRequest,Status:" + xhr.status + ",Response:" + _getResponseText(xhr) || xhr.response || "";
	                }
	                return message;
	            }
	            /**
	             * Send XDomainRequest
	             * @param payload {string} - The data payload to be sent.
	             * @param isAsync {boolean} - Indicates if the request should be sent asynchronously
	             *
	             * Note: XDomainRequest does not support sync requests. This 'isAsync' parameter is added
	             * to maintain consistency with the xhrSender's contract
	             * Note: XDomainRequest does not support custom headers and we are not able to get
	             * appId from the backend for the correct correlation.
	             */
	            function _xdrSender(payload, isAsync) {
	                var _window = getWindow();
	                var xdr = new XDomainRequest();
	                xdr.onload = function () { return _self._xdrOnLoad(xdr, payload); };
	                xdr.onerror = function (event) { return _self._onError(payload, _formatErrorMessageXdr(xdr), event); };
	                // XDomainRequest requires the same protocol as the hosting page.
	                // If the protocol doesn't match, we can't send the telemetry :(.
	                var hostingProtocol = _window && _window.location && _window.location.protocol || "";
	                if (_self._senderConfig.endpointUrl().lastIndexOf(hostingProtocol, 0) !== 0) {
	                    _self.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, ". " +
	                        "Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.");
	                    _self._buffer.clear();
	                    return;
	                }
	                var endpointUrl = _self._senderConfig.endpointUrl().replace(/^(https?:)/, "");
	                xdr.open('POST', endpointUrl);
	                // compose an array of payloads
	                var batch = _self._buffer.batchPayloads(payload);
	                xdr.send(batch);
	                _self._buffer.markAsSent(payload);
	            }
	            function _formatErrorMessageXdr(xdr, message) {
	                if (xdr) {
	                    return "XDomainRequest,Response:" + _getResponseText(xdr) || "";
	                }
	                return message;
	            }
	            // Using function lookups for backward compatibility as the getNotifyMgr() did not exist until after v2.5.6
	            function _getNotifyMgr() {
	                var func = 'getNotifyMgr';
	                if (_self.core[func]) {
	                    return _self.core[func]();
	                }
	                // using _self.core['_notificationManager'] for backward compatibility
	                return _self.core['_notificationManager'];
	            }
	            function _notifySendRequest(sendRequest, isAsync) {
	                var manager = _getNotifyMgr();
	                if (manager && manager.eventsSendRequest) {
	                    try {
	                        manager.eventsSendRequest(sendRequest, isAsync);
	                    }
	                    catch (e) {
	                        _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.NotificationException, "send request notification failed: " + getExceptionName(e), { exception: dumpObj(e) });
	                    }
	                }
	            }
	            /**
	             * Validate UUID Format
	             * Specs taken from https://tools.ietf.org/html/rfc4122 and breeze repo
	             */
	            function _validateInstrumentationKey(config) {
	                var disableIKeyValidationFlag = isNullOrUndefined(config.disableInstrumentationKeyValidation) ? false : config.disableInstrumentationKeyValidation;
	                if (disableIKeyValidationFlag) {
	                    return true;
	                }
	                var UUID_Regex = '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$';
	                var regexp = new RegExp(UUID_Regex);
	                return regexp.test(config.instrumentationKey);
	            }
	        });
	        return _this;
	    }
	    Sender.constructEnvelope = function (orig, iKey, logger) {
	        var envelope;
	        if (iKey !== orig.iKey && !isNullOrUndefined(iKey)) {
	            envelope = __assignFn({}, orig, { iKey: iKey });
	        }
	        else {
	            envelope = orig;
	        }
	        switch (envelope.baseType) {
	            case Event$1.dataType:
	                return EventEnvelopeCreator.EventEnvelopeCreator.Create(logger, envelope);
	            case Trace.dataType:
	                return TraceEnvelopeCreator.TraceEnvelopeCreator.Create(logger, envelope);
	            case PageView.dataType:
	                return PageViewEnvelopeCreator.PageViewEnvelopeCreator.Create(logger, envelope);
	            case PageViewPerformance.dataType:
	                return PageViewPerformanceEnvelopeCreator.PageViewPerformanceEnvelopeCreator.Create(logger, envelope);
	            case Exception.dataType:
	                return ExceptionEnvelopeCreator.ExceptionEnvelopeCreator.Create(logger, envelope);
	            case Metric.dataType:
	                return MetricEnvelopeCreator.MetricEnvelopeCreator.Create(logger, envelope);
	            case RemoteDependencyData$1.dataType:
	                return DependencyEnvelopeCreator.DependencyEnvelopeCreator.Create(logger, envelope);
	            default:
	                return EventEnvelopeCreator.EventEnvelopeCreator.Create(logger, envelope);
	        }
	    };
	    Sender._getDefaultAppInsightsChannelConfig = function () {
	        // set default values
	        return {
	            endpointUrl: function () { return "https://dc.services.visualstudio.com/v2/track"; },
	            emitLineDelimitedJson: function () { return false; },
	            maxBatchInterval: function () { return 15000; },
	            maxBatchSizeInBytes: function () { return 102400; },
	            disableTelemetry: function () { return false; },
	            enableSessionStorageBuffer: function () { return true; },
	            isRetryDisabled: function () { return false; },
	            isBeaconApiDisabled: function () { return true; },
	            onunloadDisableBeacon: function () { return false; },
	            instrumentationKey: function () { return undefined; },
	            namePrefix: function () { return undefined; },
	            samplingPercentage: function () { return 100; },
	            customHeaders: function () { return undefined; }
	        };
	    };
	    Sender._getEmptyAppInsightsChannelConfig = function () {
	        return {
	            endpointUrl: undefined,
	            emitLineDelimitedJson: undefined,
	            maxBatchInterval: undefined,
	            maxBatchSizeInBytes: undefined,
	            disableTelemetry: undefined,
	            enableSessionStorageBuffer: undefined,
	            isRetryDisabled: undefined,
	            isBeaconApiDisabled: undefined,
	            onunloadDisableBeacon: undefined,
	            instrumentationKey: undefined,
	            namePrefix: undefined,
	            samplingPercentage: undefined,
	            customHeaders: undefined
	        };
	    };
	// Removed Stub for Sender.prototype.pause.
	// Removed Stub for Sender.prototype.resume.
	// Removed Stub for Sender.prototype.flush.
	// Removed Stub for Sender.prototype.onunloadFlush.
	// Removed Stub for Sender.prototype.teardown.
	// Removed Stub for Sender.prototype.initialize.
	// Removed Stub for Sender.prototype.processTelemetry.
	// Removed Stub for Sender.prototype._xhrReadyStateChange.
	// Removed Stub for Sender.prototype.triggerSend.
	// Removed Stub for Sender.prototype._onError.
	// Removed Stub for Sender.prototype._onPartialSuccess.
	// Removed Stub for Sender.prototype._onSuccess.
	// Removed Stub for Sender.prototype._xdrOnLoad.
	// Removed Stub for Sender.prototype.addHeader.
	    return Sender;
	}(BaseTelemetryPlugin));

	/*
	 * Application Insights JavaScript SDK - Properties Plugin, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var cookieNameConst = 'ai_session';
	var Session = /** @class */ (function () {
	    function Session() {
	    }
	    return Session;
	}());
	var _SessionManager = /** @class */ (function () {
	    function _SessionManager(config, core) {
	        var self = this;
	        var _storageNamePrefix;
	        var _cookieUpdatedTimestamp;
	        var _logger = safeGetLogger(core);
	        var _cookieManager = safeGetCookieMgr(core);
	        dynamicProto(_SessionManager, self, function (_self) {
	            if (!config) {
	                config = {};
	            }
	            if (!isFunction$1(config.sessionExpirationMs)) {
	                config.sessionExpirationMs = function () { return _SessionManager.acquisitionSpan; };
	            }
	            if (!isFunction$1(config.sessionRenewalMs)) {
	                config.sessionRenewalMs = function () { return _SessionManager.renewalSpan; };
	            }
	            _self.config = config;
	            // sessionCookiePostfix takes the preference if it is configured, otherwise takes namePrefix if configured.
	            var sessionCookiePostfix = (_self.config.sessionCookiePostfix && _self.config.sessionCookiePostfix()) ?
	                _self.config.sessionCookiePostfix() :
	                ((_self.config.namePrefix && _self.config.namePrefix()) ? _self.config.namePrefix() : "");
	            _storageNamePrefix = function () { return cookieNameConst + sessionCookiePostfix; };
	            _self.automaticSession = new Session();
	            _self.update = function () {
	                // Always using Date getTime() as there is a bug in older IE instances that causes the performance timings to have the hi-bit set eg 0x800000000 causing
	                // the number to be incorrect.
	                var nowMs = dateNow();
	                var isExpired = false;
	                var session = _self.automaticSession;
	                if (!session.id) {
	                    isExpired = !_initializeAutomaticSession(session);
	                }
	                var sessionExpirationMs = _self.config.sessionExpirationMs();
	                if (!isExpired && sessionExpirationMs > 0) {
	                    var sessionRenewalMs = _self.config.sessionRenewalMs();
	                    var timeSinceAcqMs = nowMs - session.acquisitionDate;
	                    var timeSinceRenewalMs = nowMs - session.renewalDate;
	                    isExpired = timeSinceAcqMs < 0 || timeSinceRenewalMs < 0; // expired if the acquisition or last renewal are in the future
	                    isExpired = isExpired || timeSinceAcqMs > sessionExpirationMs; // expired if the time since acquisition is more than session Expiration
	                    isExpired = isExpired || timeSinceRenewalMs > sessionRenewalMs; // expired if the time since last renewal is more than renewal period
	                }
	                // renew if acquisitionSpan or renewalSpan has elapsed
	                if (isExpired) {
	                    // update automaticSession so session state has correct id
	                    _renew(nowMs);
	                }
	                else {
	                    // do not update the cookie more often than cookieUpdateInterval
	                    if (!_cookieUpdatedTimestamp || nowMs - _cookieUpdatedTimestamp > _SessionManager.cookieUpdateInterval) {
	                        _setCookie(session, nowMs);
	                    }
	                }
	            };
	            /**
	             *  Record the current state of the automatic session and store it in our cookie string format
	             *  into the browser's local storage. This is used to restore the session data when the cookie
	             *  expires.
	             */
	            _self.backup = function () {
	                var session = _self.automaticSession;
	                _setStorage(session.id, session.acquisitionDate, session.renewalDate);
	            };
	            /**
	             * Use config.namePrefix + ai_session cookie data or local storage data (when the cookie is unavailable) to
	             * initialize the automatic session.
	             * @returns true if values set otherwise false
	             */
	            function _initializeAutomaticSession(session, now) {
	                var isValid = false;
	                var cookieValue = _cookieManager.get(_storageNamePrefix());
	                if (cookieValue && isFunction$1(cookieValue.split)) {
	                    isValid = _initializeAutomaticSessionWithData(session, cookieValue);
	                }
	                else {
	                    // There's no cookie, but we might have session data in local storage
	                    // This can happen if the session expired or the user actively deleted the cookie
	                    // We only want to recover data if the cookie is missing from expiry. We should respect the user's wishes if the cookie was deleted actively.
	                    // The User class handles this for us and deletes our local storage object if the persistent user cookie was removed.
	                    var storageValue = utlGetLocalStorage(_logger, _storageNamePrefix());
	                    if (storageValue) {
	                        isValid = _initializeAutomaticSessionWithData(session, storageValue);
	                    }
	                }
	                return isValid || !!session.id;
	            }
	            /**
	             * Extract id, acquisitionDate, and renewalDate from an ai_session payload string and
	             * use this data to initialize automaticSession.
	             *
	             * @param {string} sessionData - The string stored in an ai_session cookie or local storage backup
	             * @returns true if values set otherwise false
	             */
	            function _initializeAutomaticSessionWithData(session, sessionData) {
	                var isValid = false;
	                var sessionReset = ", session will be reset";
	                var tokens = sessionData.split("|");
	                if (tokens.length >= 2) {
	                    try {
	                        var acqMs = +tokens[1] || 0;
	                        var renewalMs = +tokens[2] || 0;
	                        if (isNaN(acqMs) || acqMs <= 0) {
	                            _logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.SessionRenewalDateIsZero, "AI session acquisition date is 0" + sessionReset);
	                        }
	                        else if (isNaN(renewalMs) || renewalMs <= 0) {
	                            _logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.SessionRenewalDateIsZero, "AI session renewal date is 0" + sessionReset);
	                        }
	                        else if (tokens[0]) {
	                            // Everything looks valid so set the values
	                            session.id = tokens[0];
	                            session.acquisitionDate = acqMs;
	                            session.renewalDate = renewalMs;
	                            isValid = true;
	                        }
	                    }
	                    catch (e) {
	                        _logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.ErrorParsingAISessionCookie, "Error parsing ai_session value [" + (sessionData || "") + "]" + sessionReset + " - " + getExceptionName(e), { exception: dumpObj(e) });
	                    }
	                }
	                return isValid;
	            }
	            function _renew(nowMs) {
	                var theConfig = (_self.config || {});
	                var getNewId = (theConfig.getNewId ? theConfig.getNewId() : null) || newId;
	                _self.automaticSession.id = getNewId(theConfig.idLength ? theConfig.idLength() : 22);
	                _self.automaticSession.acquisitionDate = nowMs;
	                _setCookie(_self.automaticSession, nowMs);
	                // If this browser does not support local storage, fire an internal log to keep track of it at this point
	                if (!utlCanUseLocalStorage()) {
	                    _logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserDoesNotSupportLocalStorage, "Browser does not support local storage. Session durations will be inaccurate.");
	                }
	            }
	            function _setCookie(session, nowMs) {
	                var acq = session.acquisitionDate;
	                session.renewalDate = nowMs;
	                var config = _self.config;
	                var renewalPeriodMs = config.sessionRenewalMs();
	                // Set cookie to expire after the session expiry time passes or the session renewal deadline, whichever is sooner
	                // Expiring the cookie will cause the session to expire even if the user isn't on the page
	                var acqTimeLeftMs = (acq + config.sessionExpirationMs()) - nowMs;
	                var cookie = [session.id, acq, nowMs];
	                var maxAgeSec = 0;
	                if (acqTimeLeftMs < renewalPeriodMs) {
	                    maxAgeSec = acqTimeLeftMs / 1000;
	                }
	                else {
	                    maxAgeSec = renewalPeriodMs / 1000;
	                }
	                var cookieDomain = config.cookieDomain ? config.cookieDomain() : null;
	                // if sessionExpirationMs is set to 0, it means the expiry is set to 0 for this session cookie
	                // A cookie with 0 expiry in the session cookie will never expire for that browser session.  If the browser is closed the cookie expires.  
	                // Depending on the browser, another instance does not inherit this cookie, however, another tab will
	                _cookieManager.set(_storageNamePrefix(), cookie.join('|'), config.sessionExpirationMs() > 0 ? maxAgeSec : null, cookieDomain);
	                _cookieUpdatedTimestamp = nowMs;
	            }
	            function _setStorage(guid, acq, renewal) {
	                // Keep data in local storage to retain the last session id, allowing us to cleanly end the session when it expires
	                // Browsers that don't support local storage won't be able to end sessions cleanly from the client
	                // The server will notice this and end the sessions itself, with loss of accurate session duration
	                utlSetLocalStorage(_logger, _storageNamePrefix(), [guid, acq, renewal].join('|'));
	            }
	        });
	    }
	// Removed Stub for _SessionManager.prototype.update.
	// Removed Stub for _SessionManager.prototype.backup.
	    _SessionManager.acquisitionSpan = 86400000; // 24 hours in ms
	    _SessionManager.renewalSpan = 1800000; // 30 minutes in ms
	    _SessionManager.cookieUpdateInterval = 60000; // 1 minute in ms
	    return _SessionManager;
	}());

	/*
	 * Application Insights JavaScript SDK - Properties Plugin, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	var Application = /** @class */ (function () {
	    function Application() {
	    }
	    return Application;
	}());

	/*
	 * Application Insights JavaScript SDK - Properties Plugin, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	var Device = /** @class */ (function () {
	    /**
	     * Constructs a new instance of the Device class
	     */
	    function Device() {
	        // don't attempt to fingerprint browsers
	        this.id = "browser";
	        // Device type is a dimension in our data platform
	        // Setting it to 'Browser' allows to separate client and server dependencies/exceptions
	        this.deviceClass = "Browser";
	    }
	    return Device;
	}());

	/*
	 * Application Insights JavaScript SDK - Properties Plugin, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	var Version$1 = "2.6.5";
	var Internal = /** @class */ (function () {
	    /**
	     * Constructs a new instance of the internal telemetry data class.
	     */
	    function Internal(config) {
	        this.sdkVersion = (config.sdkExtension && config.sdkExtension() ? config.sdkExtension() + "_" : "") + "javascript:" + Version$1;
	    }
	    return Internal;
	}());

	/*
	 * Application Insights JavaScript SDK - Properties Plugin, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	function _validateUserInput(id) {
	    // Validate:
	    // 1. Id is a non-empty string.
	    // 2. It does not contain special characters for cookies.
	    if (typeof id !== 'string' ||
	        !id ||
	        id.match(/,|;|=| |\|/)) {
	        return false;
	    }
	    return true;
	}
	var User = /** @class */ (function () {
	    function User(config, core) {
	        this.isNewUser = false;
	        var _logger = safeGetLogger(core);
	        var _cookieManager = safeGetCookieMgr(core);
	        var _storageNamePrefix;
	        dynamicProto(User, this, function (_self) {
	            _self.config = config;
	            var userCookiePostfix = (_self.config.userCookiePostfix && _self.config.userCookiePostfix()) ? _self.config.userCookiePostfix() : "";
	            _storageNamePrefix = function () { return User.userCookieName + userCookiePostfix; };
	            // get userId or create new one if none exists
	            var cookie = _cookieManager.get(_storageNamePrefix());
	            if (cookie) {
	                _self.isNewUser = false;
	                var params = cookie.split(User.cookieSeparator);
	                if (params.length > 0) {
	                    _self.id = params[0];
	                }
	            }
	            if (!_self.id) {
	                var theConfig = (config || {});
	                var getNewId = (theConfig.getNewId ? theConfig.getNewId() : null) || newId;
	                _self.id = getNewId(theConfig.idLength ? config.idLength() : 22);
	                // without expiration, cookies expire at the end of the session
	                // set it to 365 days from now
	                // 365 * 24 * 60 * 60 = 31536000 
	                var oneYear = 31536000;
	                var acqStr = toISOString(new Date());
	                _self.accountAcquisitionDate = acqStr;
	                _self.isNewUser = true;
	                var newCookie = [_self.id, acqStr];
	                _cookieManager.set(_storageNamePrefix(), newCookie.join(User.cookieSeparator), oneYear);
	                // If we have an config.namePrefix() + ai_session in local storage this means the user actively removed our cookies.
	                // We should respect their wishes and clear ourselves from local storage
	                var name_1 = config.namePrefix && config.namePrefix() ? config.namePrefix() + 'ai_session' : 'ai_session';
	                utlRemoveStorage(_logger, name_1);
	            }
	            // We still take the account id from the ctor param for backward compatibility. 
	            // But if the the customer set the accountId through the newer setAuthenticatedUserContext API, we will override it.
	            _self.accountId = config.accountId ? config.accountId() : undefined;
	            // Get the auth user id and account id from the cookie if exists
	            // Cookie is in the pattern: <authenticatedId>|<accountId>
	            var authCookie = _cookieManager.get(User.authUserCookieName);
	            if (authCookie) {
	                authCookie = decodeURI(authCookie);
	                var authCookieString = authCookie.split(User.cookieSeparator);
	                if (authCookieString[0]) {
	                    _self.authenticatedId = authCookieString[0];
	                }
	                if (authCookieString.length > 1 && authCookieString[1]) {
	                    _self.accountId = authCookieString[1];
	                }
	            }
	            _self.setAuthenticatedUserContext = function (authenticatedUserId, accountId, storeInCookie) {
	                if (storeInCookie === void 0) { storeInCookie = false; }
	                // Validate inputs to ensure no cookie control characters.
	                var isInvalidInput = !_validateUserInput(authenticatedUserId) || (accountId && !_validateUserInput(accountId));
	                if (isInvalidInput) {
	                    _logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.SetAuthContextFailedAccountName, "Setting auth user context failed. " +
	                        "User auth/account id should be of type string, and not contain commas, semi-colons, equal signs, spaces, or vertical-bars.", true);
	                    return;
	                }
	                // Create cookie string.
	                _self.authenticatedId = authenticatedUserId;
	                var authCookie = _self.authenticatedId;
	                if (accountId) {
	                    _self.accountId = accountId;
	                    authCookie = [_self.authenticatedId, _self.accountId].join(User.cookieSeparator);
	                }
	                if (storeInCookie) {
	                    // Set the cookie. No expiration date because this is a session cookie (expires when browser closed).
	                    // Encoding the cookie to handle unexpected unicode characters.
	                    _cookieManager.set(User.authUserCookieName, encodeURI(authCookie));
	                }
	            };
	            /**
	             * Clears the authenticated user id and the account id from the user context.
	             * @returns {}
	             */
	            _self.clearAuthenticatedUserContext = function () {
	                _self.authenticatedId = null;
	                _self.accountId = null;
	                _cookieManager.del(User.authUserCookieName);
	            };
	        });
	    }
	// Removed Stub for User.prototype.setAuthenticatedUserContext.
	// Removed Stub for User.prototype.clearAuthenticatedUserContext.
	    User.cookieSeparator = '|';
	    User.userCookieName = 'ai_user';
	    User.authUserCookieName = 'ai_authUser';
	    return User;
	}());

	/*
	 * Application Insights JavaScript SDK - Properties Plugin, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */


	var Location = /** @class */ (function () {
	    function Location() {
	    }
	    return Location;
	}());

	/*
	 * Application Insights JavaScript SDK - Properties Plugin, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var TelemetryTrace = /** @class */ (function () {
	    function TelemetryTrace(id, parentId, name, logger) {
	        var _self = this;
	        _self.traceID = id || generateW3CId();
	        _self.parentID = parentId;
	        _self.name = name;
	        var location = getLocation();
	        if (!name && location && location.pathname) {
	            _self.name = location.pathname;
	        }
	        _self.name = dataSanitizeString(logger, _self.name);
	    }
	    return TelemetryTrace;
	}());

	/*
	 * Application Insights JavaScript SDK - Properties Plugin, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var strExt = "ext";
	var strTags = "tags";
	function _removeEmpty(target, name) {
	    if (target && target[name] && objKeys(target[name]).length === 0) {
	        delete target[name];
	    }
	}
	var TelemetryContext = /** @class */ (function () {
	    function TelemetryContext(core, defaultConfig) {
	        var _this = this;
	        var logger = core.logger;
	        this.appId = function () { return null; };
	        dynamicProto(TelemetryContext, this, function (_self) {
	            _self.application = new Application();
	            _self.internal = new Internal(defaultConfig);
	            if (hasWindow()) {
	                _self.sessionManager = new _SessionManager(defaultConfig, core);
	                _self.device = new Device();
	                _self.location = new Location();
	                _self.user = new User(defaultConfig, core);
	                _self.telemetryTrace = new TelemetryTrace(undefined, undefined, undefined, logger);
	                _self.session = new Session();
	            }
	            _self.applySessionContext = function (evt, itemCtx) {
	                var session = _self.session;
	                var sessionManager = _self.sessionManager;
	                // If customer set session info, apply their context; otherwise apply context automatically generated
	                if (session && isString(session.id)) {
	                    setValue(getSetValue(evt.ext, Extensions.AppExt), "sesId", session.id);
	                }
	                else if (sessionManager && sessionManager.automaticSession) {
	                    setValue(getSetValue(evt.ext, Extensions.AppExt), "sesId", sessionManager.automaticSession.id, isString);
	                }
	            };
	            _self.applyOperatingSystemContxt = function (evt, itemCtx) {
	                setValue(evt.ext, Extensions.OSExt, _self.os);
	            };
	            _self.applyApplicationContext = function (evt, itemCtx) {
	                var application = _self.application;
	                if (application) {
	                    // evt.ext.app
	                    var tags = getSetValue(evt, strTags);
	                    setValue(tags, CtxTagKeys.applicationVersion, application.ver, isString);
	                    setValue(tags, CtxTagKeys.applicationBuild, application.build, isString);
	                }
	            };
	            _self.applyDeviceContext = function (evt, itemCtx) {
	                var device = _self.device;
	                if (device) {
	                    // evt.ext.device
	                    var extDevice = getSetValue(getSetValue(evt, strExt), Extensions.DeviceExt);
	                    setValue(extDevice, "localId", device.id, isString);
	                    setValue(extDevice, "ip", device.ip, isString);
	                    setValue(extDevice, "model", device.model, isString);
	                    setValue(extDevice, "deviceClass", device.deviceClass, isString);
	                }
	            };
	            _self.applyInternalContext = function (evt, itemCtx) {
	                var internal = _self.internal;
	                if (internal) {
	                    var tags = getSetValue(evt, strTags);
	                    setValue(tags, CtxTagKeys.internalAgentVersion, internal.agentVersion, isString); // not mapped in CS 4.0
	                    setValue(tags, CtxTagKeys.internalSdkVersion, internal.sdkVersion, isString);
	                    if (evt.baseType === _InternalLogMessage.dataType || evt.baseType === PageView.dataType) {
	                        setValue(tags, CtxTagKeys.internalSnippet, internal.snippetVer, isString);
	                        setValue(tags, CtxTagKeys.internalSdkSrc, internal.sdkSrc, isString);
	                    }
	                }
	            };
	            _self.applyLocationContext = function (evt, itemCtx) {
	                var location = _this.location;
	                if (location) {
	                    setValue(getSetValue(evt, strTags, []), CtxTagKeys.locationIp, location.ip, isString);
	                }
	            };
	            _self.applyOperationContext = function (evt, itemCtx) {
	                var telemetryTrace = _self.telemetryTrace;
	                if (telemetryTrace) {
	                    var extTrace = getSetValue(getSetValue(evt, strExt), Extensions.TraceExt, { traceID: undefined, parentID: undefined });
	                    setValue(extTrace, "traceID", telemetryTrace.traceID, isString);
	                    setValue(extTrace, "name", telemetryTrace.name, isString);
	                    setValue(extTrace, "parentID", telemetryTrace.parentID, isString);
	                }
	            };
	            _self.applyWebContext = function (evt, itemCtx) {
	                var web = _this.web;
	                if (web) {
	                    setValue(getSetValue(evt, strExt), Extensions.WebExt, web);
	                }
	            };
	            _self.applyUserContext = function (evt, itemCtx) {
	                var user = _self.user;
	                if (user) {
	                    var tags = getSetValue(evt, strTags, []);
	                    // stays in tags
	                    setValue(tags, CtxTagKeys.userAccountId, user.accountId, isString);
	                    // CS 4.0
	                    var extUser = getSetValue(getSetValue(evt, strExt), Extensions.UserExt);
	                    setValue(extUser, "id", user.id, isString);
	                    setValue(extUser, "authId", user.authenticatedId, isString);
	                }
	            };
	            _self.cleanUp = function (evt, itemCtx) {
	                var ext = evt.ext;
	                if (ext) {
	                    _removeEmpty(ext, Extensions.DeviceExt);
	                    _removeEmpty(ext, Extensions.UserExt);
	                    _removeEmpty(ext, Extensions.WebExt);
	                    _removeEmpty(ext, Extensions.OSExt);
	                    _removeEmpty(ext, Extensions.AppExt);
	                    _removeEmpty(ext, Extensions.TraceExt);
	                }
	            };
	        });
	    }
	// Removed Stub for TelemetryContext.prototype.applySessionContext.
	// Removed Stub for TelemetryContext.prototype.applyOperatingSystemContxt.
	// Removed Stub for TelemetryContext.prototype.applyApplicationContext.
	// Removed Stub for TelemetryContext.prototype.applyDeviceContext.
	// Removed Stub for TelemetryContext.prototype.applyInternalContext.
	// Removed Stub for TelemetryContext.prototype.applyLocationContext.
	// Removed Stub for TelemetryContext.prototype.applyOperationContext.
	// Removed Stub for TelemetryContext.prototype.applyWebContext.
	// Removed Stub for TelemetryContext.prototype.applyUserContext.
	// Removed Stub for TelemetryContext.prototype.cleanUp.
	    return TelemetryContext;
	}());

	/*
	 * Application Insights JavaScript SDK - Properties Plugin, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var PropertiesPlugin = /** @class */ (function (_super) {
	    __extendsFn(PropertiesPlugin, _super);
	    function PropertiesPlugin() {
	        var _this = _super.call(this) || this;
	        _this.priority = 110;
	        _this.identifier = PropertiesPluginIdentifier;
	        var _breezeChannel; // optional. If exists, grab appId from it
	        var _extensionConfig;
	        dynamicProto(PropertiesPlugin, _this, function (_self, _base) {
	            _self.initialize = function (config, core, extensions, pluginChain) {
	                _base.initialize(config, core, extensions, pluginChain);
	                var ctx = _self._getTelCtx();
	                var identifier = _self.identifier;
	                var defaultConfig = PropertiesPlugin.getDefaultConfig();
	                _extensionConfig = _extensionConfig || {};
	                objForEachKey(defaultConfig, function (field, value) {
	                    _extensionConfig[field] = function () { return ctx.getConfig(identifier, field, value()); };
	                });
	                _self.context = new TelemetryContext(core, _extensionConfig);
	                _breezeChannel = getExtensionByName(extensions, BreezeChannelIdentifier);
	                _self.context.appId = function () { return _breezeChannel ? _breezeChannel["_appId"] : null; };
	                // Test hook to allow accessing the internal values -- explicitly not defined as an available property on the class
	                _self["_extConfig"] = _extensionConfig;
	            };
	            /**
	             * Add Part A fields to the event
	             * @param event The event that needs to be processed
	             */
	            _self.processTelemetry = function (event, itemCtx) {
	                if (isNullOrUndefined(event)) ;
	                else {
	                    itemCtx = _self._getTelCtx(itemCtx);
	                    // If the envelope is PageView, reset the internal message count so that we can send internal telemetry for the new page.
	                    if (event.name === PageView.envelopeType) {
	                        itemCtx.diagLog().resetInternalMessageCount();
	                    }
	                    var theContext = (_self.context || {});
	                    if (theContext.session) {
	                        // If customer did not provide custom session id update the session manager
	                        if (typeof _self.context.session.id !== "string" && theContext.sessionManager) {
	                            theContext.sessionManager.update();
	                        }
	                    }
	                    _processTelemetryInternal(event, itemCtx);
	                    if (theContext.user && theContext.user.isNewUser) {
	                        theContext.user.isNewUser = false;
	                        var message = new _InternalLogMessage(_InternalMessageId.SendBrowserInfoOnUserInit, ((getNavigator() || {}).userAgent || ""));
	                        itemCtx.diagLog().logInternalMessage(LoggingSeverity.CRITICAL, message);
	                    }
	                    _self.processNext(event, itemCtx);
	                }
	            };
	            function _processTelemetryInternal(evt, itemCtx) {
	                // Set Part A fields
	                getSetValue(evt, "tags", []);
	                getSetValue(evt, "ext", {});
	                var ctx = _self.context;
	                ctx.applySessionContext(evt, itemCtx);
	                ctx.applyApplicationContext(evt, itemCtx);
	                ctx.applyDeviceContext(evt, itemCtx);
	                ctx.applyOperationContext(evt, itemCtx);
	                ctx.applyUserContext(evt, itemCtx);
	                ctx.applyOperatingSystemContxt(evt, itemCtx);
	                ctx.applyWebContext(evt, itemCtx);
	                ctx.applyLocationContext(evt, itemCtx); // legacy tags
	                ctx.applyInternalContext(evt, itemCtx); // legacy tags
	                ctx.cleanUp(evt, itemCtx);
	            }
	        });
	        return _this;
	    }
	    PropertiesPlugin.getDefaultConfig = function () {
	        var defaultConfig = {
	            instrumentationKey: function () { return undefined; },
	            accountId: function () { return null; },
	            sessionRenewalMs: function () { return 30 * 60 * 1000; },
	            samplingPercentage: function () { return 100; },
	            sessionExpirationMs: function () { return 24 * 60 * 60 * 1000; },
	            cookieDomain: function () { return null; },
	            sdkExtension: function () { return null; },
	            isBrowserLinkTrackingEnabled: function () { return false; },
	            appId: function () { return null; },
	            namePrefix: function () { return undefined; },
	            sessionCookiePostfix: function () { return undefined; },
	            userCookiePostfix: function () { return undefined; },
	            idLength: function () { return 22; },
	            getNewId: function () { return null; }
	        };
	        return defaultConfig;
	    };
	// Removed Stub for PropertiesPlugin.prototype.initialize.
	// Removed Stub for PropertiesPlugin.prototype.processTelemetry.
	    return PropertiesPlugin;
	}(BaseTelemetryPlugin));

	/*
	 * Application Insights JavaScript SDK - Dependencies Plugin, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var strProperties$1 = "properties";
	/** @ignore */
	function _calcPerfDuration(resourceEntry, start, end) {
	    var result = 0;
	    var from = resourceEntry[start];
	    var to = resourceEntry[end];
	    if (from && to) {
	        result = dateTimeUtilsDuration(from, to);
	    }
	    return result;
	}
	/** @ignore */
	function _setPerfDuration(props, name, resourceEntry, start, end) {
	    var result = 0;
	    var value = _calcPerfDuration(resourceEntry, start, end);
	    if (value) {
	        result = _setPerfValue(props, name, msToTimeSpan(value));
	    }
	    return result;
	}
	/** @ignore */
	function _setPerfValue(props, name, value) {
	    var strPerf = "ajaxPerf";
	    var result = 0;
	    if (props && name && value) {
	        var perfData = props[strPerf] = (props[strPerf] || {});
	        perfData[name] = value;
	        result = 1;
	    }
	    return result;
	}
	/** @ignore */
	function _populatePerfData(ajaxData, dependency) {
	    /*
	    * https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API/Using_the_Resource_Timing_API
	    *  | -startTime
	    *  | -redirectStart
	    *  |            | -redirectEnd
	    *  |            | | -fetchStart
	    *  |            | |   | -domainLookupStart
	    *  |            | |   |                |- domainLookupEnd
	    *  |            | |   |                | | -connectStart
	    *  |            | |   |                | |  | -secureConnectionStart
	    *  |            | |   |                | |  |        | -connectEnd
	    *  |            | |   |                | |  |        | | -requestStart
	    *  |            | |   |                | |  |        | |           | | -responseStart
	    *  |            | |   |                | |  |        | |           | |            | | -responseEnd
	    *  +------------+-+---+----------------+-+--+--------+-+-----------+-+------------+-+
	    *  |--redirect--| |---|--domainLookup--| |--connect--| |--request--| |--response--| |
	    *  |-------------------networkConnect----------------|
	    *  |                                                   |---------sentRequest--------|
	    *  |------------------------------------perfTotal-----------------------------------|
	    */
	    var resourceEntry = ajaxData.perfTiming;
	    var props = dependency[strProperties$1] || {};
	    var propsSet = 0;
	    var strName = "name";
	    var strStart = "Start";
	    var strEnd = "End";
	    var strDomainLookup = "domainLookup";
	    var strConnect = "connect";
	    var strRedirect = "redirect";
	    var strRequest = "request";
	    var strResponse = "response";
	    var strDuration = "duration";
	    var strStartTime = "startTime";
	    var strDomainLookupStart = strDomainLookup + strStart;
	    var strDomainLookupEnd = strDomainLookup + strEnd;
	    var strConnectStart = strConnect + strStart;
	    var strConnectEnd = strConnect + strEnd;
	    var strRequestStart = strRequest + strStart;
	    var strRequestEnd = strRequest + strEnd;
	    var strResponseStart = strResponse + strStart;
	    var strResponseEnd = strResponse + strEnd;
	    var strRedirectStart = strRedirect + strStart;
	    var strRedirectEnd = strRedirect = strEnd;
	    var strTransferSize = "transferSize";
	    var strEncodedBodySize = "encodedBodySize";
	    var strDecodedBodySize = "decodedBodySize";
	    var strServerTiming = "serverTiming";
	    if (resourceEntry) {
	        // redirect
	        propsSet |= _setPerfDuration(props, strRedirect, resourceEntry, strRedirectStart, strRedirectEnd);
	        // domainLookup
	        propsSet |= _setPerfDuration(props, strDomainLookup, resourceEntry, strDomainLookupStart, strDomainLookupEnd);
	        // connect
	        propsSet |= _setPerfDuration(props, strConnect, resourceEntry, strConnectStart, strConnectEnd);
	        // request
	        propsSet |= _setPerfDuration(props, strRequest, resourceEntry, strRequestStart, strRequestEnd);
	        // response
	        propsSet |= _setPerfDuration(props, strResponse, resourceEntry, strResponseStart, strResponseEnd);
	        // Network connection time
	        propsSet |= _setPerfDuration(props, "networkConnect", resourceEntry, strStartTime, strConnectEnd);
	        // Sent Request
	        propsSet |= _setPerfDuration(props, "sentRequest", resourceEntry, strRequestStart, strResponseEnd);
	        // PerfTotal / Duration
	        var duration = resourceEntry[strDuration];
	        if (!duration) {
	            duration = _calcPerfDuration(resourceEntry, strStartTime, strResponseEnd) || 0;
	        }
	        propsSet |= _setPerfValue(props, strDuration, duration);
	        propsSet |= _setPerfValue(props, "perfTotal", duration);
	        var serverTiming = resourceEntry[strServerTiming];
	        if (serverTiming) {
	            var server_1 = {};
	            arrForEach(serverTiming, function (value, idx) {
	                var name = normalizeJsName(value[strName] || "" + idx);
	                var newValue = server_1[name] || {};
	                objForEachKey(value, function (key, val) {
	                    if (key !== strName && isString(val) || isNumber(val)) {
	                        if (newValue[key]) {
	                            val = newValue[key] + ";" + val;
	                        }
	                        if (val || !isString(val)) {
	                            // Only set the value if it has a value and it's not an empty string
	                            newValue[key] = val;
	                        }
	                    }
	                });
	                server_1[name] = newValue;
	            });
	            propsSet |= _setPerfValue(props, strServerTiming, server_1);
	        }
	        propsSet |= _setPerfValue(props, strTransferSize, resourceEntry[strTransferSize]);
	        propsSet |= _setPerfValue(props, strEncodedBodySize, resourceEntry[strEncodedBodySize]);
	        propsSet |= _setPerfValue(props, strDecodedBodySize, resourceEntry[strDecodedBodySize]);
	    }
	    else {
	        if (ajaxData.perfMark) {
	            propsSet |= _setPerfValue(props, "missing", ajaxData.perfAttempts);
	        }
	    }
	    if (propsSet) {
	        dependency[strProperties$1] = props;
	    }
	}
	var XHRMonitoringState = /** @class */ (function () {
	    function XHRMonitoringState() {
	        var self = this;
	        self.openDone = false;
	        self.setRequestHeaderDone = false;
	        self.sendDone = false;
	        self.abortDone = false;
	        // <summary>True, if onreadyStateChangeCallback function attached to xhr, otherwise false</summary>
	        self.stateChangeAttached = false;
	    }
	    return XHRMonitoringState;
	}());
	var ajaxRecord = /** @class */ (function () {
	    function ajaxRecord(traceID, spanID, logger) {
	        var self = this;
	        var _logger = logger;
	        var strResponseText = "responseText";
	        // Assigning the initial/default values within the constructor to avoid typescript from creating a bunch of
	        // this.XXXX = null
	        self.perfMark = null;
	        self.completed = false;
	        self.requestHeadersSize = null;
	        self.requestHeaders = null;
	        self.responseReceivingDuration = null;
	        self.callbackDuration = null;
	        self.ajaxTotalDuration = null;
	        self.aborted = 0;
	        self.pageUrl = null;
	        self.requestUrl = null;
	        self.requestSize = 0;
	        self.method = null;
	        self.status = null;
	        self.requestSentTime = null;
	        self.responseStartedTime = null;
	        self.responseFinishedTime = null;
	        self.callbackFinishedTime = null;
	        self.endTime = null;
	        self.xhrMonitoringState = new XHRMonitoringState();
	        self.clientFailure = 0;
	        self.traceID = traceID;
	        self.spanID = spanID;
	        dynamicProto(ajaxRecord, self, function (self) {
	            self.getAbsoluteUrl = function () {
	                return self.requestUrl ? urlGetAbsoluteUrl(self.requestUrl) : null;
	            };
	            self.getPathName = function () {
	                return self.requestUrl ? dataSanitizeUrl(_logger, urlGetCompleteUrl(self.method, self.requestUrl)) : null;
	            };
	            self.CreateTrackItem = function (ajaxType, enableRequestHeaderTracking, getResponse) {
	                // round to 3 decimal points
	                self.ajaxTotalDuration = Math.round(dateTimeUtilsDuration(self.requestSentTime, self.responseFinishedTime) * 1000) / 1000;
	                if (self.ajaxTotalDuration < 0) {
	                    return null;
	                }
	                var dependency = (_a = {
	                        id: "|" + self.traceID + "." + self.spanID,
	                        target: self.getAbsoluteUrl(),
	                        name: self.getPathName(),
	                        type: ajaxType,
	                        startTime: null,
	                        duration: self.ajaxTotalDuration,
	                        success: (+(self.status)) >= 200 && (+(self.status)) < 400,
	                        responseCode: (+(self.status)),
	                        method: self.method
	                    },
	                    _a[strProperties$1] = { HttpMethod: self.method },
	                    _a);
	                if (self.requestSentTime) {
	                    // Set the correct dependency start time
	                    dependency.startTime = new Date();
	                    dependency.startTime.setTime(self.requestSentTime);
	                }
	                // Add Ajax perf details if available
	                _populatePerfData(self, dependency);
	                if (enableRequestHeaderTracking) {
	                    if (objKeys(self.requestHeaders).length > 0) {
	                        dependency[strProperties$1] = dependency[strProperties$1] || {};
	                        dependency[strProperties$1].requestHeaders = self.requestHeaders;
	                    }
	                }
	                if (getResponse) {
	                    var response = getResponse();
	                    if (response) {
	                        // enrich dependency target with correlation context from the server
	                        var correlationContext = response.correlationContext;
	                        if (correlationContext) {
	                            dependency.correlationContext = /* dependency.target + " | " + */ correlationContext;
	                        }
	                        if (response.headerMap) {
	                            if (objKeys(response.headerMap).length > 0) {
	                                dependency[strProperties$1] = dependency[strProperties$1] || {};
	                                dependency[strProperties$1].responseHeaders = response.headerMap;
	                            }
	                        }
	                        if (self.status >= 400) {
	                            var responseType = response.type;
	                            dependency[strProperties$1] = dependency[strProperties$1] || {};
	                            if (responseType === "" || responseType === "text") {
	                                dependency[strProperties$1][strResponseText] = response[strResponseText] ? response.statusText + " - " + response[strResponseText] : response.statusText;
	                            }
	                            if (responseType === "json") {
	                                dependency[strProperties$1][strResponseText] = response.response ? response.statusText + " - " + JSON.stringify(response.response) : response.statusText;
	                            }
	                        }
	                    }
	                }
	                return dependency;
	                var _a;
	            };
	        });
	    }
	// Removed Stub for ajaxRecord.prototype.getAbsoluteUrl.
	// Removed Stub for ajaxRecord.prototype.getPathName.
	// Removed Stub for ajaxRecord.prototype.CreateTrackItem.
	    return ajaxRecord;
	}());

	/*
	 * Application Insights JavaScript SDK - Dependencies Plugin, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var Traceparent = /** @class */ (function () {
	    function Traceparent(traceId, spanId) {
	        var self = this;
	        self.traceFlag = Traceparent.DEFAULT_TRACE_FLAG;
	        self.version = Traceparent.DEFAULT_VERSION;
	        if (traceId && Traceparent.isValidTraceId(traceId)) {
	            self.traceId = traceId;
	        }
	        else {
	            self.traceId = generateW3CId();
	        }
	        if (spanId && Traceparent.isValidSpanId(spanId)) {
	            self.spanId = spanId;
	        }
	        else {
	            self.spanId = generateW3CId().substr(0, 16);
	        }
	    }
	    Traceparent.isValidTraceId = function (id) {
	        return id.match(/^[0-9a-f]{32}$/) && id !== "00000000000000000000000000000000";
	    };
	    Traceparent.isValidSpanId = function (id) {
	        return id.match(/^[0-9a-f]{16}$/) && id !== "0000000000000000";
	    };
	    Traceparent.prototype.toString = function () {
	        var self = this;
	        return self.version + "-" + self.traceId + "-" + self.spanId + "-" + self.traceFlag;
	    };
	    Traceparent.DEFAULT_TRACE_FLAG = "01";
	    Traceparent.DEFAULT_VERSION = "00";
	    return Traceparent;
	}());

	/*
	 * Application Insights JavaScript SDK - Dependencies Plugin, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var AJAX_MONITOR_PREFIX = "ai.ajxmn.";
	var strDiagLog = "diagLog";
	var strAjaxData = "ajaxData";
	var strThrowInternal = "throwInternal";
	var strFetch = "fetch";
	// Using a global value so that to handle same iKey with multiple app insights instances (mostly for testing)
	var _markCount = 0;
	/** @Ignore */
	function _supportsFetch() {
	    var _global = getGlobal();
	    if (!_global ||
	        isNullOrUndefined(_global.Request) ||
	        isNullOrUndefined(_global.Request[strShimPrototype]) ||
	        isNullOrUndefined(_global[strFetch])) {
	        return null;
	    }
	    return _global[strFetch];
	}
	/**
	 * Determines whether ajax monitoring can be enabled on this document
	 * @returns True if Ajax monitoring is supported on this page, otherwise false
	 * @ignore
	 */
	function _supportsAjaxMonitoring(ajaxMonitorInstance) {
	    var result = false;
	    if (typeof XMLHttpRequest !== strShimUndefined && !isNullOrUndefined(XMLHttpRequest)) {
	        var proto = XMLHttpRequest[strShimPrototype];
	        result = !isNullOrUndefined(proto) &&
	            !isNullOrUndefined(proto.open) &&
	            !isNullOrUndefined(proto.send) &&
	            !isNullOrUndefined(proto.abort);
	    }
	    var ieVer = getIEVersion();
	    if (ieVer && ieVer < 9) {
	        result = false;
	    }
	    if (result) {
	        // Disable if the XmlHttpRequest can't be extended or hooked
	        try {
	            var xhr = new XMLHttpRequest();
	            xhr[strAjaxData] = {};
	            // Check that we can update the prototype
	            var theOpen = XMLHttpRequest[strShimPrototype].open;
	            XMLHttpRequest[strShimPrototype].open = theOpen;
	        }
	        catch (e) {
	            // We can't decorate the xhr object so disable monitoring
	            result = false;
	            _throwInternalCritical(ajaxMonitorInstance, _InternalMessageId.FailedMonitorAjaxOpen, "Failed to enable XMLHttpRequest monitoring, extension is not supported", {
	                exception: dumpObj(e)
	            });
	        }
	    }
	    return result;
	}
	/** @Ignore */
	function _getFailedAjaxDiagnosticsMessage(xhr) {
	    var result = "";
	    try {
	        if (!isNullOrUndefined(xhr) &&
	            !isNullOrUndefined(xhr[strAjaxData]) &&
	            !isNullOrUndefined(xhr[strAjaxData].requestUrl)) {
	            result += "(url: '" + xhr[strAjaxData].requestUrl + "')";
	        }
	    }
	    catch (e) { }
	    return result;
	}
	/** @ignore */
	function _throwInternalCritical(ajaxMonitorInstance, msgId, message, properties, isUserAct) {
	    ajaxMonitorInstance[strDiagLog]()[strThrowInternal](LoggingSeverity.CRITICAL, msgId, message, properties, isUserAct);
	}
	/** @ignore */
	function _throwInternalWarning(ajaxMonitorInstance, msgId, message, properties, isUserAct) {
	    ajaxMonitorInstance[strDiagLog]()[strThrowInternal](LoggingSeverity.WARNING, msgId, message, properties, isUserAct);
	}
	/** @Ignore */
	function _createErrorCallbackFunc(ajaxMonitorInstance, internalMessage, message) {
	    // tslint:disable-next-line
	    return function (args) {
	        _throwInternalCritical(ajaxMonitorInstance, internalMessage, message, {
	            ajaxDiagnosticsMessage: _getFailedAjaxDiagnosticsMessage(args.inst),
	            exception: dumpObj(args.err)
	        });
	    };
	}
	function _indexOf(value, match) {
	    if (value && match) {
	        return value.indexOf(match);
	    }
	    return -1;
	}
	var AjaxMonitor = /** @class */ (function (_super) {
	    __extendsFn(AjaxMonitor, _super);
	    function AjaxMonitor() {
	        var _this = _super.call(this) || this;
	        _this.identifier = AjaxMonitor.identifier;
	        _this.priority = 120;
	        var strTrackDependencyDataInternal = "trackDependencyDataInternal"; // Using string to help with minification
	        var location = getLocation();
	        var _fetchInitialized = false; // fetch monitoring initialized
	        var _xhrInitialized = false; // XHR monitoring initialized
	        var _currentWindowHost = location && location.host && location.host.toLowerCase();
	        var _config = AjaxMonitor.getEmptyConfig();
	        var _enableRequestHeaderTracking = false;
	        var _trackAjaxAttempts = 0;
	        var _context;
	        var _isUsingW3CHeaders;
	        var _isUsingAIHeaders;
	        var _markPrefix;
	        var _enableAjaxPerfTracking = false;
	        var _maxAjaxCallsPerView = 0;
	        var _enableResponseHeaderTracking = false;
	        var _hooks = [];
	        var _disabledUrls = {};
	        var _excludeRequestFromAutoTrackingPatterns;
	        dynamicProto(AjaxMonitor, _this, function (_self, base) {
	            _self.initialize = function (config, core, extensions, pluginChain) {
	                if (!_self.isInitialized()) {
	                    base.initialize(config, core, extensions, pluginChain);
	                    var ctx_1 = _self._getTelCtx();
	                    var defaultConfig = AjaxMonitor.getDefaultConfig();
	                    objForEachKey(defaultConfig, function (field, value) {
	                        _config[field] = ctx_1.getConfig(AjaxMonitor.identifier, field, value);
	                    });
	                    var distributedTracingMode = _config.distributedTracingMode;
	                    _enableRequestHeaderTracking = _config.enableRequestHeaderTracking;
	                    _enableAjaxPerfTracking = _config.enableAjaxPerfTracking;
	                    _maxAjaxCallsPerView = _config.maxAjaxCallsPerView;
	                    _enableResponseHeaderTracking = _config.enableResponseHeaderTracking;
	                    _excludeRequestFromAutoTrackingPatterns = _config.excludeRequestFromAutoTrackingPatterns;
	                    _isUsingAIHeaders = distributedTracingMode === DistributedTracingModes.AI || distributedTracingMode === DistributedTracingModes.AI_AND_W3C;
	                    _isUsingW3CHeaders = distributedTracingMode === DistributedTracingModes.AI_AND_W3C || distributedTracingMode === DistributedTracingModes.W3C;
	                    if (_enableAjaxPerfTracking) {
	                        var iKey = config.instrumentationKey || "unkwn";
	                        if (iKey.length > 5) {
	                            _markPrefix = AJAX_MONITOR_PREFIX + iKey.substring(iKey.length - 5) + ".";
	                        }
	                        else {
	                            _markPrefix = AJAX_MONITOR_PREFIX + iKey + ".";
	                        }
	                    }
	                    if (_config.disableAjaxTracking === false) {
	                        _instrumentXhr();
	                    }
	                    _instrumentFetch();
	                    if (extensions.length > 0 && extensions) {
	                        var propExt = void 0, extIx = 0;
	                        while (!propExt && extIx < extensions.length) {
	                            if (extensions[extIx] && extensions[extIx].identifier === PropertiesPluginIdentifier) {
	                                propExt = extensions[extIx];
	                            }
	                            extIx++;
	                        }
	                        if (propExt) {
	                            _context = propExt.context; // we could move IPropertiesPlugin to common as well
	                        }
	                    }
	                }
	            };
	            _self.teardown = function () {
	                // Remove all instrumentation hooks
	                arrForEach(_hooks, function (fn) {
	                    fn.rm();
	                });
	                _hooks = [];
	                _fetchInitialized = false;
	                _xhrInitialized = false;
	                _self.setInitialized(false);
	            };
	            _self.trackDependencyData = function (dependency, properties) {
	                _self[strTrackDependencyDataInternal](dependency, properties);
	            };
	            _self.includeCorrelationHeaders = function (ajaxData, input, init, xhr) {
	                // Test Hook to allow the overriding of the location host
	                var currentWindowHost = _self["_currentWindowHost"] || _currentWindowHost;
	                if (input) {
	                    if (CorrelationIdHelper.canIncludeCorrelationHeader(_config, ajaxData.getAbsoluteUrl(), currentWindowHost)) {
	                        if (!init) {
	                            init = {};
	                        }
	                        // init headers override original request headers
	                        // so, if they exist use only them, otherwise use request's because they should have been applied in the first place
	                        // not using original request headers will result in them being lost
	                        init.headers = new Headers(init.headers || (input instanceof Request ? (input.headers || {}) : {}));
	                        if (_isUsingAIHeaders) {
	                            var id = "|" + ajaxData.traceID + "." + ajaxData.spanID;
	                            init.headers.set(RequestHeaders.requestIdHeader, id);
	                            if (_enableRequestHeaderTracking) {
	                                ajaxData.requestHeaders[RequestHeaders.requestIdHeader] = id;
	                            }
	                        }
	                        var appId = _config.appId || (_context && _context.appId());
	                        if (appId) {
	                            init.headers.set(RequestHeaders.requestContextHeader, RequestHeaders.requestContextAppIdFormat + appId);
	                            if (_enableRequestHeaderTracking) {
	                                ajaxData.requestHeaders[RequestHeaders.requestContextHeader] = RequestHeaders.requestContextAppIdFormat + appId;
	                            }
	                        }
	                        if (_isUsingW3CHeaders) {
	                            var traceparent = new Traceparent(ajaxData.traceID, ajaxData.spanID);
	                            init.headers.set(RequestHeaders.traceParentHeader, traceparent.toString());
	                            if (_enableRequestHeaderTracking) {
	                                ajaxData.requestHeaders[RequestHeaders.traceParentHeader] = traceparent.toString();
	                            }
	                        }
	                    }
	                    return init;
	                }
	                else if (xhr) {
	                    if (CorrelationIdHelper.canIncludeCorrelationHeader(_config, ajaxData.getAbsoluteUrl(), currentWindowHost)) {
	                        if (_isUsingAIHeaders) {
	                            var id = "|" + ajaxData.traceID + "." + ajaxData.spanID;
	                            xhr.setRequestHeader(RequestHeaders.requestIdHeader, id);
	                            if (_enableRequestHeaderTracking) {
	                                ajaxData.requestHeaders[RequestHeaders.requestIdHeader] = id;
	                            }
	                        }
	                        var appId = _config.appId || (_context && _context.appId());
	                        if (appId) {
	                            xhr.setRequestHeader(RequestHeaders.requestContextHeader, RequestHeaders.requestContextAppIdFormat + appId);
	                            if (_enableRequestHeaderTracking) {
	                                ajaxData.requestHeaders[RequestHeaders.requestContextHeader] = RequestHeaders.requestContextAppIdFormat + appId;
	                            }
	                        }
	                        if (_isUsingW3CHeaders) {
	                            var traceparent = new Traceparent(ajaxData.traceID, ajaxData.spanID);
	                            xhr.setRequestHeader(RequestHeaders.traceParentHeader, traceparent.toString());
	                            if (_enableRequestHeaderTracking) {
	                                ajaxData.requestHeaders[RequestHeaders.traceParentHeader] = traceparent.toString();
	                            }
	                        }
	                    }
	                    return xhr;
	                }
	                return undefined;
	            };
	            _self[strTrackDependencyDataInternal] = function (dependency, properties, systemProperties) {
	                if (_maxAjaxCallsPerView === -1 || _trackAjaxAttempts < _maxAjaxCallsPerView) {
	                    // Hack since expected format in w3c mode is |abc.def.
	                    // Non-w3c format is |abc.def
	                    // @todo Remove if better solution is available, e.g. handle in portal
	                    if ((_config.distributedTracingMode === DistributedTracingModes.W3C
	                        || _config.distributedTracingMode === DistributedTracingModes.AI_AND_W3C)
	                        && typeof dependency.id === "string" && dependency.id[dependency.id.length - 1] !== ".") {
	                        dependency.id += ".";
	                    }
	                    if (isNullOrUndefined(dependency.startTime)) {
	                        dependency.startTime = new Date();
	                    }
	                    var item = TelemetryItemCreator.create(dependency, RemoteDependencyData$1.dataType, RemoteDependencyData$1.envelopeType, _self[strDiagLog](), properties, systemProperties);
	                    _self.core.track(item);
	                }
	                else if (_trackAjaxAttempts === _maxAjaxCallsPerView) {
	                    _throwInternalCritical(_self, _InternalMessageId.MaxAjaxPerPVExceeded, "Maximum ajax per page view limit reached, ajax monitoring is paused until the next trackPageView(). In order to increase the limit set the maxAjaxCallsPerView configuration parameter.", true);
	                }
	                ++_trackAjaxAttempts;
	            };
	            // discard the header if it's defined as ignoreHeaders in ICorrelationConfig
	            function _canIncludeHeaders(header) {
	                var rlt = true;
	                if (header || _config.ignoreHeaders) {
	                    arrForEach(_config.ignoreHeaders, (function (key) {
	                        if (key.toLowerCase() === header.toLowerCase()) {
	                            rlt = false;
	                            return -1;
	                        }
	                    }));
	                }
	                return rlt;
	            }
	            // Fetch Stuff
	            function _instrumentFetch() {
	                var fetch = _supportsFetch();
	                if (!fetch) {
	                    return;
	                }
	                var global = getGlobal();
	                var isPolyfill = fetch.polyfill;
	                if (_config.disableFetchTracking === false) {
	                    _hooks.push(InstrumentFunc(global, strFetch, {
	                        // Add request hook
	                        req: function (callDetails, input, init) {
	                            var fetchData;
	                            if (_fetchInitialized &&
	                                !_isDisabledRequest(null, input, init) &&
	                                // If we have a polyfil and XHR instrumented then let XHR report otherwise we get duplicates
	                                !(isPolyfill && _xhrInitialized)) {
	                                var ctx = callDetails.ctx();
	                                fetchData = _createFetchRecord(input, init);
	                                var newInit = _self.includeCorrelationHeaders(fetchData, input, init);
	                                if (newInit !== init) {
	                                    callDetails.set(1, newInit);
	                                }
	                                ctx.data = fetchData;
	                            }
	                        },
	                        rsp: function (callDetails, input) {
	                            var fetchData = callDetails.ctx().data;
	                            if (fetchData) {
	                                // Replace the result with the new promise from this code
	                                callDetails.rslt = callDetails.rslt.then(function (response) {
	                                    _reportFetchMetrics(callDetails, (response || {}).status, response, fetchData, function () {
	                                        var ajaxResponse = {
	                                            statusText: response.statusText,
	                                            headerMap: null,
	                                            correlationContext: _getFetchCorrelationContext(response)
	                                        };
	                                        if (_enableResponseHeaderTracking) {
	                                            var responseHeaderMap_1 = {};
	                                            response.headers.forEach(function (value, name) {
	                                                if (_canIncludeHeaders(name)) {
	                                                    responseHeaderMap_1[name] = value;
	                                                }
	                                            });
	                                            ajaxResponse.headerMap = responseHeaderMap_1;
	                                        }
	                                        return ajaxResponse;
	                                    });
	                                    return response;
	                                })["catch"](function (reason) {
	                                    _reportFetchMetrics(callDetails, 0, input, fetchData, null, { error: reason.message });
	                                    throw reason;
	                                });
	                            }
	                        },
	                        // Create an error callback to report any hook errors
	                        hkErr: _createErrorCallbackFunc(_self, _InternalMessageId.FailedMonitorAjaxOpen, "Failed to monitor Window.fetch, monitoring data for this fetch call may be incorrect.")
	                    }));
	                    _fetchInitialized = true;
	                }
	                else if (isPolyfill) {
	                    // If fetch is a polyfill we need to capture the request to ensure that we correctly track
	                    // disabled request URLS (i.e. internal urls) to ensure we don't end up in a constant loop
	                    // of reporting ourselves, for example React Native uses a polyfill for fetch
	                    // Note: Polyfill implementations that don't support the "poyyfill" tag are not supported
	                    // the workaround is to add a polyfill property to your fetch implementation before initializing
	                    // App Insights
	                    _hooks.push(InstrumentFunc(global, strFetch, {
	                        req: function (callDetails, input, init) {
	                            // Just call so that we record any disabled URL
	                            _isDisabledRequest(null, input, init);
	                        }
	                    }));
	                }
	                if (isPolyfill) {
	                    // retag the instrumented fetch with the same polyfill settings this is mostly for testing
	                    // But also supports multiple App Insights usages
	                    global[strFetch].polyfill = isPolyfill;
	                }
	            }
	            function _hookProto(target, funcName, callbacks) {
	                _hooks.push(InstrumentProto(target, funcName, callbacks));
	            }
	            function _instrumentXhr() {
	                if (_supportsAjaxMonitoring(_self) && !_xhrInitialized) {
	                    // Instrument open
	                    _hookProto(XMLHttpRequest, "open", {
	                        req: function (args, method, url, async) {
	                            var xhr = args.inst;
	                            var ajaxData = xhr[strAjaxData];
	                            if (!_isDisabledRequest(xhr, url) && _isMonitoredXhrInstance(xhr, true) &&
	                                (!ajaxData || !ajaxData.xhrMonitoringState.openDone)) {
	                                _openHandler(xhr, method, url, async);
	                            }
	                        },
	                        hkErr: _createErrorCallbackFunc(_self, _InternalMessageId.FailedMonitorAjaxOpen, "Failed to monitor XMLHttpRequest.open, monitoring data for this ajax call may be incorrect.")
	                    });
	                    // Instrument send
	                    _hookProto(XMLHttpRequest, "send", {
	                        req: function (args, context) {
	                            var xhr = args.inst;
	                            var ajaxData = xhr[strAjaxData];
	                            if (_isMonitoredXhrInstance(xhr) && !ajaxData.xhrMonitoringState.sendDone) {
	                                _createMarkId("xhr", ajaxData);
	                                ajaxData.requestSentTime = dateTimeUtilsNow();
	                                _self.includeCorrelationHeaders(ajaxData, undefined, undefined, xhr);
	                                ajaxData.xhrMonitoringState.sendDone = true;
	                            }
	                        },
	                        hkErr: _createErrorCallbackFunc(_self, _InternalMessageId.FailedMonitorAjaxSend, "Failed to monitor XMLHttpRequest, monitoring data for this ajax call may be incorrect.")
	                    });
	                    // Instrument abort
	                    _hookProto(XMLHttpRequest, "abort", {
	                        req: function (args) {
	                            var xhr = args.inst;
	                            var ajaxData = xhr[strAjaxData];
	                            if (_isMonitoredXhrInstance(xhr) && !ajaxData.xhrMonitoringState.abortDone) {
	                                ajaxData.aborted = 1;
	                                ajaxData.xhrMonitoringState.abortDone = true;
	                            }
	                        },
	                        hkErr: _createErrorCallbackFunc(_self, _InternalMessageId.FailedMonitorAjaxAbort, "Failed to monitor XMLHttpRequest.abort, monitoring data for this ajax call may be incorrect.")
	                    });
	                    // Instrument setRequestHeader
	                    if (_enableRequestHeaderTracking) {
	                        _hookProto(XMLHttpRequest, "setRequestHeader", {
	                            req: function (args, header, value) {
	                                var xhr = args.inst;
	                                if (_isMonitoredXhrInstance(xhr) && _canIncludeHeaders(header)) {
	                                    xhr[strAjaxData].requestHeaders[header] = value;
	                                }
	                            },
	                            hkErr: _createErrorCallbackFunc(_self, _InternalMessageId.FailedMonitorAjaxSetRequestHeader, "Failed to monitor XMLHttpRequest.setRequestHeader, monitoring data for this ajax call may be incorrect.")
	                        });
	                    }
	                    _xhrInitialized = true;
	                }
	            }
	            function _isDisabledRequest(xhr, request, init) {
	                var isDisabled = false;
	                var theUrl = ((!isString(request) ? (request || {}).url || "" : request) || "").toLowerCase();
	                // check excludeRequestFromAutoTrackingPatterns before stripping off any query string
	                arrForEach(_excludeRequestFromAutoTrackingPatterns, function (regex) {
	                    var theRegex = regex;
	                    if (isString(regex)) {
	                        theRegex = new RegExp(regex);
	                    }
	                    if (!isDisabled) {
	                        isDisabled = theRegex.test(theUrl);
	                    }
	                });
	                // if request url matches with exclude regex pattern, return true and no need to check for headers
	                if (isDisabled) {
	                    return isDisabled;
	                }
	                var idx = _indexOf(theUrl, "?");
	                var idx2 = _indexOf(theUrl, "#");
	                if (idx === -1 || (idx2 !== -1 && idx2 < idx)) {
	                    idx = idx2;
	                }
	                if (idx !== -1) {
	                    // Strip off any Query string
	                    theUrl = theUrl.substring(0, idx);
	                }
	                // check that this instance is not not used by ajax call performed inside client side monitoring to send data to collector
	                if (!isNullOrUndefined(xhr)) {
	                    // Look on the XMLHttpRequest of the URL string value
	                    isDisabled = xhr[DisabledPropertyName] === true || theUrl[DisabledPropertyName] === true;
	                }
	                else if (!isNullOrUndefined(request)) {
	                    // Look for DisabledPropertyName in either Request or RequestInit
	                    isDisabled = (typeof request === 'object' ? request[DisabledPropertyName] === true : false) ||
	                        (init ? init[DisabledPropertyName] === true : false);
	                }
	                if (isDisabled) {
	                    // Add the disabled url if not present
	                    if (!_disabledUrls[theUrl]) {
	                        _disabledUrls[theUrl] = 1;
	                    }
	                }
	                else {
	                    // Check to see if the url is listed as disabled
	                    if (_disabledUrls[theUrl]) {
	                        isDisabled = true;
	                    }
	                }
	                return isDisabled;
	            }
	            /// <summary>Verifies that particalar instance of XMLHttpRequest needs to be monitored</summary>
	            /// <param name="excludeAjaxDataValidation">Optional parameter. True if ajaxData must be excluded from verification</param>
	            /// <returns type="bool">True if instance needs to be monitored, otherwise false</returns>
	            function _isMonitoredXhrInstance(xhr, excludeAjaxDataValidation) {
	                var ajaxValidation = true;
	                var initialized = _xhrInitialized;
	                if (!isNullOrUndefined(xhr)) {
	                    ajaxValidation = excludeAjaxDataValidation === true || !isNullOrUndefined(xhr[strAjaxData]);
	                }
	                // checking to see that all interested functions on xhr were instrumented
	                return initialized
	                    // checking on ajaxData to see that it was not removed in user code
	                    && ajaxValidation;
	            }
	            function _openHandler(xhr, method, url, async) {
	                var traceID = (_context && _context.telemetryTrace && _context.telemetryTrace.traceID) || generateW3CId();
	                var spanID = generateW3CId().substr(0, 16);
	                var ajaxData = new ajaxRecord(traceID, spanID, _self[strDiagLog]());
	                ajaxData.method = method;
	                ajaxData.requestUrl = url;
	                ajaxData.xhrMonitoringState.openDone = true;
	                ajaxData.requestHeaders = {};
	                ajaxData.async = async;
	                xhr[strAjaxData] = ajaxData;
	                _attachToOnReadyStateChange(xhr);
	            }
	            function _attachToOnReadyStateChange(xhr) {
	                xhr[strAjaxData].xhrMonitoringState.stateChangeAttached = EventHelper.Attach(xhr, "readystatechange", function () {
	                    try {
	                        if (xhr && xhr.readyState === 4 && _isMonitoredXhrInstance(xhr)) {
	                            _onAjaxComplete(xhr);
	                        }
	                    }
	                    catch (e) {
	                        var exceptionText = dumpObj(e);
	                        // ignore messages with c00c023f, as this a known IE9 XHR abort issue
	                        if (!exceptionText || _indexOf(exceptionText.toLowerCase(), "c00c023f") === -1) {
	                            _throwInternalCritical(_self, _InternalMessageId.FailedMonitorAjaxRSC, "Failed to monitor XMLHttpRequest 'readystatechange' event handler, monitoring data for this ajax call may be incorrect.", {
	                                ajaxDiagnosticsMessage: _getFailedAjaxDiagnosticsMessage(xhr),
	                                exception: exceptionText
	                            });
	                        }
	                    }
	                });
	            }
	            function _getResponseText(xhr) {
	                try {
	                    var responseType = xhr.responseType;
	                    if (responseType === "" || responseType === "text") {
	                        // As per the specification responseText is only valid if the type is an empty string or "text"
	                        return xhr.responseText;
	                    }
	                }
	                catch (e) {
	                    // This shouldn't happend because of the above check -- but just in case, so just ignore
	                }
	                return null;
	            }
	            function _onAjaxComplete(xhr) {
	                var ajaxData = xhr[strAjaxData];
	                ajaxData.responseFinishedTime = dateTimeUtilsNow();
	                ajaxData.status = xhr.status;
	                function _reportXhrError(e, failedProps) {
	                    var errorProps = failedProps || {};
	                    errorProps["ajaxDiagnosticsMessage"] = _getFailedAjaxDiagnosticsMessage(xhr);
	                    if (e) {
	                        errorProps["exception"] = dumpObj(e);
	                    }
	                    _throwInternalWarning(_self, _InternalMessageId.FailedMonitorAjaxDur, "Failed to calculate the duration of the ajax call, monitoring data for this ajax call won't be sent.", errorProps);
	                }
	                _findPerfResourceEntry("xmlhttprequest", ajaxData, function () {
	                    try {
	                        var dependency = ajaxData.CreateTrackItem("Ajax", _enableRequestHeaderTracking, function () {
	                            var ajaxResponse = {
	                                statusText: xhr.statusText,
	                                headerMap: null,
	                                correlationContext: _getAjaxCorrelationContext(xhr),
	                                type: xhr.responseType,
	                                responseText: _getResponseText(xhr),
	                                response: xhr.response
	                            };
	                            if (_enableResponseHeaderTracking) {
	                                var headers = xhr.getAllResponseHeaders();
	                                if (headers) {
	                                    // xhr.getAllResponseHeaders() method returns all the response headers, separated by CRLF, as a string or null
	                                    // the regex converts the header string into an array of individual headers
	                                    var arr = strTrim(headers).split(/[\r\n]+/);
	                                    var responseHeaderMap_2 = {};
	                                    arrForEach(arr, function (line) {
	                                        var parts = line.split(': ');
	                                        var header = parts.shift();
	                                        var value = parts.join(': ');
	                                        if (_canIncludeHeaders(header)) {
	                                            responseHeaderMap_2[header] = value;
	                                        }
	                                    });
	                                    ajaxResponse.headerMap = responseHeaderMap_2;
	                                }
	                            }
	                            return ajaxResponse;
	                        });
	                        if (dependency) {
	                            _self[strTrackDependencyDataInternal](dependency);
	                        }
	                        else {
	                            _reportXhrError(null, {
	                                requestSentTime: ajaxData.requestSentTime,
	                                responseFinishedTime: ajaxData.responseFinishedTime
	                            });
	                        }
	                    }
	                    finally {
	                        // cleanup telemetry data
	                        try {
	                            xhr[strAjaxData] = null;
	                        }
	                        catch (e) {
	                            // May throw in environments that prevent extension or freeze xhr
	                        }
	                    }
	                }, function (e) {
	                    _reportXhrError(e, null);
	                });
	            }
	            function _getAjaxCorrelationContext(xhr) {
	                try {
	                    var responseHeadersString = xhr.getAllResponseHeaders();
	                    if (responseHeadersString !== null) {
	                        var index = _indexOf(responseHeadersString.toLowerCase(), RequestHeaders.requestContextHeaderLowerCase);
	                        if (index !== -1) {
	                            var responseHeader = xhr.getResponseHeader(RequestHeaders.requestContextHeader);
	                            return CorrelationIdHelper.getCorrelationContext(responseHeader);
	                        }
	                    }
	                }
	                catch (e) {
	                    _throwInternalWarning(_self, _InternalMessageId.FailedMonitorAjaxGetCorrelationHeader, "Failed to get Request-Context correlation header as it may be not included in the response or not accessible.", {
	                        ajaxDiagnosticsMessage: _getFailedAjaxDiagnosticsMessage(xhr),
	                        exception: dumpObj(e)
	                    });
	                }
	            }
	            function _createMarkId(type, ajaxData) {
	                if (ajaxData.requestUrl && _markPrefix && _enableAjaxPerfTracking) {
	                    var performance_1 = getPerformance();
	                    if (performance_1 && isFunction$1(performance_1.mark)) {
	                        _markCount++;
	                        var markId = _markPrefix + type + "#" + _markCount;
	                        performance_1.mark(markId);
	                        var entries = performance_1.getEntriesByName(markId);
	                        if (entries && entries.length === 1) {
	                            ajaxData.perfMark = entries[0];
	                        }
	                    }
	                }
	            }
	            function _findPerfResourceEntry(initiatorType, ajaxData, trackCallback, reportError) {
	                var perfMark = ajaxData.perfMark;
	                var performance = getPerformance();
	                var maxAttempts = _config.maxAjaxPerfLookupAttempts;
	                var retryDelay = _config.ajaxPerfLookupDelay;
	                var requestUrl = ajaxData.requestUrl;
	                var attempt = 0;
	                (function locateResourceTiming() {
	                    try {
	                        if (performance && perfMark) {
	                            attempt++;
	                            var perfTiming = null;
	                            var entries = performance.getEntries();
	                            for (var lp = entries.length - 1; lp >= 0; lp--) {
	                                var entry = entries[lp];
	                                if (entry) {
	                                    if (entry.entryType === "resource") {
	                                        if (entry.initiatorType === initiatorType &&
	                                            (_indexOf(entry.name, requestUrl) !== -1 || _indexOf(requestUrl, entry.name) !== -1)) {
	                                            perfTiming = entry;
	                                        }
	                                    }
	                                    else if (entry.entryType === "mark" && entry.name === perfMark.name) {
	                                        // We hit the start event
	                                        ajaxData.perfTiming = perfTiming;
	                                        break;
	                                    }
	                                    if (entry.startTime < perfMark.startTime - 1000) {
	                                        // Fallback to try and reduce the time spent looking for the perf entry
	                                        break;
	                                    }
	                                }
	                            }
	                        }
	                        if (!perfMark || // - we don't have a perfMark or
	                            ajaxData.perfTiming || // - we have not found the perf entry or
	                            attempt >= maxAttempts || // - we have tried too many attempts or
	                            ajaxData.async === false) {
	                            if (perfMark && isFunction$1(performance.clearMarks)) {
	                                // Remove the mark so we don't fill up the performance resources too much
	                                performance.clearMarks(perfMark.name);
	                            }
	                            ajaxData.perfAttempts = attempt;
	                            // just continue and report the track event
	                            trackCallback();
	                        }
	                        else {
	                            // We need to wait for the browser to populate the window.performance entry
	                            // This needs to be at least 1ms as waiting <= 1 (on firefox) is not enough time for fetch or xhr,
	                            // this is a scheduling issue for the browser implementation
	                            setTimeout(locateResourceTiming, retryDelay);
	                        }
	                    }
	                    catch (e) {
	                        reportError(e);
	                    }
	                })();
	            }
	            function _createFetchRecord(input, init) {
	                var traceID = (_context && _context.telemetryTrace && _context.telemetryTrace.traceID) || generateW3CId();
	                var spanID = generateW3CId().substr(0, 16);
	                var ajaxData = new ajaxRecord(traceID, spanID, _self[strDiagLog]());
	                ajaxData.requestSentTime = dateTimeUtilsNow();
	                if (input instanceof Request) {
	                    ajaxData.requestUrl = input ? input.url : "";
	                }
	                else {
	                    ajaxData.requestUrl = input;
	                }
	                var method = "GET";
	                if (init && init.method) {
	                    method = init.method;
	                }
	                else if (input && input instanceof Request) {
	                    method = input.method;
	                }
	                ajaxData.method = method;
	                var requestHeaders = {};
	                if (_enableRequestHeaderTracking) {
	                    var headers = new Headers((init ? init.headers : 0) || (input instanceof Request ? (input.headers || {}) : {}));
	                    headers.forEach(function (value, key) {
	                        if (_canIncludeHeaders(key)) {
	                            requestHeaders[key] = value;
	                        }
	                    });
	                }
	                ajaxData.requestHeaders = requestHeaders;
	                _createMarkId("fetch", ajaxData);
	                return ajaxData;
	            }
	            function _getFailedFetchDiagnosticsMessage(input) {
	                var result = "";
	                try {
	                    if (!isNullOrUndefined(input)) {
	                        if (typeof (input) === "string") {
	                            result += "(url: '" + input + "')";
	                        }
	                        else {
	                            result += "(url: '" + input.url + "')";
	                        }
	                    }
	                }
	                catch (e) {
	                    _throwInternalCritical(_self, _InternalMessageId.FailedMonitorAjaxOpen, "Failed to grab failed fetch diagnostics message", { exception: dumpObj(e) });
	                }
	                return result;
	            }
	            function _reportFetchMetrics(callDetails, status, input, ajaxData, getResponse, properties) {
	                if (!ajaxData) {
	                    return;
	                }
	                function _reportFetchError(msgId, e, failedProps) {
	                    var errorProps = failedProps || {};
	                    errorProps["fetchDiagnosticsMessage"] = _getFailedFetchDiagnosticsMessage(input);
	                    if (e) {
	                        errorProps["exception"] = dumpObj(e);
	                    }
	                    _throwInternalWarning(_self, msgId, "Failed to calculate the duration of the fetch call, monitoring data for this fetch call won't be sent.", errorProps);
	                }
	                ajaxData.responseFinishedTime = dateTimeUtilsNow();
	                ajaxData.status = status;
	                _findPerfResourceEntry("fetch", ajaxData, function () {
	                    var dependency = ajaxData.CreateTrackItem("Fetch", _enableRequestHeaderTracking, getResponse);
	                    if (dependency) {
	                        _self[strTrackDependencyDataInternal](dependency);
	                    }
	                    else {
	                        _reportFetchError(_InternalMessageId.FailedMonitorAjaxDur, null, {
	                            requestSentTime: ajaxData.requestSentTime,
	                            responseFinishedTime: ajaxData.responseFinishedTime
	                        });
	                    }
	                }, function (e) {
	                    _reportFetchError(_InternalMessageId.FailedMonitorAjaxGetCorrelationHeader, e, null);
	                });
	            }
	            function _getFetchCorrelationContext(response) {
	                if (response && response.headers) {
	                    try {
	                        var responseHeader = response.headers.get(RequestHeaders.requestContextHeader);
	                        return CorrelationIdHelper.getCorrelationContext(responseHeader);
	                    }
	                    catch (e) {
	                        _throwInternalWarning(_self, _InternalMessageId.FailedMonitorAjaxGetCorrelationHeader, "Failed to get Request-Context correlation header as it may be not included in the response or not accessible.", {
	                            fetchDiagnosticsMessage: _getFailedFetchDiagnosticsMessage(response),
	                            exception: dumpObj(e)
	                        });
	                    }
	                }
	            }
	        });
	        return _this;
	    }
	    AjaxMonitor.getDefaultConfig = function () {
	        var config = {
	            maxAjaxCallsPerView: 500,
	            disableAjaxTracking: false,
	            disableFetchTracking: true,
	            excludeRequestFromAutoTrackingPatterns: undefined,
	            disableCorrelationHeaders: false,
	            distributedTracingMode: DistributedTracingModes.AI_AND_W3C,
	            correlationHeaderExcludedDomains: [
	                "*.blob.core.windows.net",
	                "*.blob.core.chinacloudapi.cn",
	                "*.blob.core.cloudapi.de",
	                "*.blob.core.usgovcloudapi.net"
	            ],
	            correlationHeaderDomains: undefined,
	            correlationHeaderExcludePatterns: undefined,
	            appId: undefined,
	            enableCorsCorrelation: false,
	            enableRequestHeaderTracking: false,
	            enableResponseHeaderTracking: false,
	            enableAjaxErrorStatusText: false,
	            enableAjaxPerfTracking: false,
	            maxAjaxPerfLookupAttempts: 3,
	            ajaxPerfLookupDelay: 25,
	            ignoreHeaders: [
	                "Authorization",
	                "X-API-Key",
	                "WWW-Authenticate"
	            ]
	        };
	        return config;
	    };
	    AjaxMonitor.getEmptyConfig = function () {
	        var emptyConfig = this.getDefaultConfig();
	        objForEachKey(emptyConfig, function (value) {
	            emptyConfig[value] = undefined;
	        });
	        return emptyConfig;
	    };
	// Removed Stub for AjaxMonitor.prototype.initialize.
	// Removed Stub for AjaxMonitor.prototype.teardown.
	    AjaxMonitor.prototype.processTelemetry = function (item, itemCtx) {
	        this.processNext(item, itemCtx);
	    };
	// Removed Stub for AjaxMonitor.prototype.trackDependencyData.
	// Removed Stub for AjaxMonitor.prototype.includeCorrelationHeaders.
	// Removed Stub for AjaxMonitor.prototype.trackDependencyDataInternal.
	    AjaxMonitor.identifier = "AjaxDependencyPlugin";
	    return AjaxMonitor;
	}(BaseTelemetryPlugin));

	/*
	 * Application Insights JavaScript SDK - Web, 2.6.5
	 * Copyright (c) Microsoft and contributors. All rights reserved.
	 */
	var _internalSdkSrc;
	// This is an exclude list of properties that should not be updated during initialization
	// They include a combination of private and internal property names
	var _ignoreUpdateSnippetProperties = [
	    "snippet", "dependencies", "properties", "_snippetVersion", "appInsightsNew", "getSKUDefaults",
	];
	/**
	 * Application Insights API
	 * @class Initialization
	 * @implements {IApplicationInsights}
	 */
	var Initialization = /** @class */ (function () {
	    function Initialization(snippet) {
	        var _self = this;
	        // initialize the queue and config in case they are undefined
	        _self._snippetVersion = "" + (snippet.sv || snippet.version || "");
	        snippet.queue = snippet.queue || [];
	        snippet.version = snippet.version || 2.0; // Default to new version
	        var config = snippet.config || {};
	        if (config.connectionString) {
	            var cs = parseConnectionString(config.connectionString);
	            var ingest = cs.ingestionendpoint;
	            config.endpointUrl = ingest ? ingest + "/v2/track" : config.endpointUrl; // only add /v2/track when from connectionstring
	            config.instrumentationKey = cs.instrumentationkey || config.instrumentationKey;
	        }
	        _self.appInsights = new ApplicationInsights();
	        _self.properties = new PropertiesPlugin();
	        _self.dependencies = new AjaxMonitor();
	        _self.core = new AppInsightsCore();
	        _self._sender = new Sender();
	        _self.snippet = snippet;
	        _self.config = config;
	        _self.getSKUDefaults();
	    }
	    // Analytics Plugin
	    /**
	     * Get the current cookie manager for this instance
	     */
	    Initialization.prototype.getCookieMgr = function () {
	        return this.appInsights.getCookieMgr();
	    };
	    /**
	     * Log a user action or other occurrence.
	     * @param {IEventTelemetry} event
	     * @param {ICustomProperties} [customProperties]
	     * @memberof Initialization
	     */
	    Initialization.prototype.trackEvent = function (event, customProperties) {
	        this.appInsights.trackEvent(event, customProperties);
	    };
	    /**
	     * Logs that a page, or similar container was displayed to the user.
	     * @param {IPageViewTelemetry} pageView
	     * @memberof Initialization
	     */
	    Initialization.prototype.trackPageView = function (pageView) {
	        var inPv = pageView || {};
	        this.appInsights.trackPageView(inPv);
	    };
	    /**
	     * Log a bag of performance information via the customProperties field.
	     * @param {IPageViewPerformanceTelemetry} pageViewPerformance
	     * @memberof Initialization
	     */
	    Initialization.prototype.trackPageViewPerformance = function (pageViewPerformance) {
	        var inPvp = pageViewPerformance || {};
	        this.appInsights.trackPageViewPerformance(inPvp);
	    };
	    /**
	     * Log an exception that you have caught.
	     * @param {IExceptionTelemetry} exception
	     * @memberof Initialization
	     */
	    Initialization.prototype.trackException = function (exception) {
	        if (exception && !exception.exception && exception.error) {
	            exception.exception = exception.error;
	        }
	        this.appInsights.trackException(exception);
	    };
	    /**
	     * Manually send uncaught exception telemetry. This method is automatically triggered
	     * on a window.onerror event.
	     * @param {IAutoExceptionTelemetry} exception
	     * @memberof Initialization
	     */
	    Initialization.prototype._onerror = function (exception) {
	        this.appInsights._onerror(exception);
	    };
	    /**
	     * Log a diagnostic scenario such entering or leaving a function.
	     * @param {ITraceTelemetry} trace
	     * @param {ICustomProperties} [customProperties]
	     * @memberof Initialization
	     */
	    Initialization.prototype.trackTrace = function (trace, customProperties) {
	        this.appInsights.trackTrace(trace, customProperties);
	    };
	    /**
	     * Log a numeric value that is not associated with a specific event. Typically used
	     * to send regular reports of performance indicators.
	     *
	     * To send a single measurement, just use the `name` and `average` fields
	     * of {@link IMetricTelemetry}.
	     *
	     * If you take measurements frequently, you can reduce the telemetry bandwidth by
	     * aggregating multiple measurements and sending the resulting average and modifying
	     * the `sampleCount` field of {@link IMetricTelemetry}.
	     * @param {IMetricTelemetry} metric input object argument. Only `name` and `average` are mandatory.
	     * @param {ICustomProperties} [customProperties]
	     * @memberof Initialization
	     */
	    Initialization.prototype.trackMetric = function (metric, customProperties) {
	        this.appInsights.trackMetric(metric, customProperties);
	    };
	    /**
	     * Starts the timer for tracking a page load time. Use this instead of `trackPageView` if you want to control when the page view timer starts and stops,
	     * but don't want to calculate the duration yourself. This method doesn't send any telemetry. Call `stopTrackPage` to log the end of the page view
	     * and send the event.
	     * @param name A string that idenfities this item, unique within this HTML document. Defaults to the document title.
	     */
	    Initialization.prototype.startTrackPage = function (name) {
	        this.appInsights.startTrackPage(name);
	    };
	    /**
	     * Stops the timer that was started by calling `startTrackPage` and sends the pageview load time telemetry with the specified properties and measurements.
	     * The duration of the page view will be the time between calling `startTrackPage` and `stopTrackPage`.
	     * @param   name  The string you used as the name in startTrackPage. Defaults to the document title.
	     * @param   url   String - a relative or absolute URL that identifies the page or other item. Defaults to the window location.
	     * @param   properties  map[string, string] - additional data used to filter pages and metrics in the portal. Defaults to empty.
	     * @param   measurements    map[string, number] - metrics associated with this page, displayed in Metrics Explorer on the portal. Defaults to empty.
	     */
	    Initialization.prototype.stopTrackPage = function (name, url, customProperties, measurements) {
	        this.appInsights.stopTrackPage(name, url, customProperties, measurements);
	    };
	    Initialization.prototype.startTrackEvent = function (name) {
	        this.appInsights.startTrackEvent(name);
	    };
	    /**
	     * Log an extended event that you started timing with `startTrackEvent`.
	     * @param   name    The string you used to identify this event in `startTrackEvent`.
	     * @param   properties  map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.
	     * @param   measurements    map[string, number] - metrics associated with this event, displayed in Metrics Explorer on the portal. Defaults to empty.
	     */
	    Initialization.prototype.stopTrackEvent = function (name, properties, measurements) {
	        this.appInsights.stopTrackEvent(name, properties, measurements); // Todo: Fix to pass measurements once type is updated
	    };
	    Initialization.prototype.addTelemetryInitializer = function (telemetryInitializer) {
	        return this.appInsights.addTelemetryInitializer(telemetryInitializer);
	    };
	    // Properties Plugin
	    /**
	     * Set the authenticated user id and the account id. Used for identifying a specific signed-in user. Parameters must not contain whitespace or ,;=|
	     *
	     * The method will only set the `authenticatedUserId` and `accountId` in the current page view. To set them for the whole session, you should set `storeInCookie = true`
	     * @param {string} authenticatedUserId
	     * @param {string} [accountId]
	     * @param {boolean} [storeInCookie=false]
	     * @memberof Initialization
	     */
	    Initialization.prototype.setAuthenticatedUserContext = function (authenticatedUserId, accountId, storeInCookie) {
	        if (storeInCookie === void 0) { storeInCookie = false; }
	        this.properties.context.user.setAuthenticatedUserContext(authenticatedUserId, accountId, storeInCookie);
	    };
	    /**
	     * Clears the authenticated user id and account id. The associated cookie is cleared, if present.
	     * @memberof Initialization
	     */
	    Initialization.prototype.clearAuthenticatedUserContext = function () {
	        this.properties.context.user.clearAuthenticatedUserContext();
	    };
	    // Dependencies Plugin
	    /**
	     * Log a dependency call (e.g. ajax)
	     * @param {IDependencyTelemetry} dependency
	     * @memberof Initialization
	     */
	    Initialization.prototype.trackDependencyData = function (dependency) {
	        this.dependencies.trackDependencyData(dependency);
	    };
	    // Misc
	    /**
	     * Manually trigger an immediate send of all telemetry still in the buffer.
	     * @param {boolean} [async=true]
	     * @memberof Initialization
	     */
	    Initialization.prototype.flush = function (async) {
	        var _this = this;
	        if (async === void 0) { async = true; }
	        doPerf(this.core, function () { return "AISKU.flush"; }, function () {
	            arrForEach(_this.core.getTransmissionControls(), function (channels) {
	                arrForEach(channels, function (channel) {
	                    channel.flush(async);
	                });
	            });
	        }, null, async);
	    };
	    /**
	     * Manually trigger an immediate send of all telemetry still in the buffer using beacon Sender.
	     * Fall back to xhr sender if beacon is not supported.
	     * @param {boolean} [async=true]
	     * @memberof Initialization
	     */
	    Initialization.prototype.onunloadFlush = function (async) {
	        if (async === void 0) { async = true; }
	        arrForEach(this.core.getTransmissionControls(), function (channels) {
	            arrForEach(channels, function (channel) {
	                if (channel.onunloadFlush) {
	                    channel.onunloadFlush();
	                }
	                else {
	                    channel.flush(async);
	                }
	            });
	        });
	    };
	    /**
	     * Initialize this instance of ApplicationInsights
	     * @returns {IApplicationInsights}
	     * @memberof Initialization
	     */
	    Initialization.prototype.loadAppInsights = function (legacyMode, logger, notificationManager) {
	        var _this = this;
	        if (legacyMode === void 0) { legacyMode = false; }
	        var _self = this;
	        function _updateSnippetProperties(snippet) {
	            if (snippet) {
	                var snippetVer = "";
	                if (!isNullOrUndefined(_self._snippetVersion)) {
	                    snippetVer += _self._snippetVersion;
	                }
	                if (legacyMode) {
	                    snippetVer += ".lg";
	                }
	                if (_self.context && _self.context.internal) {
	                    _self.context.internal.snippetVer = snippetVer || "-";
	                }
	                // apply updated properties to the global instance (snippet)
	                objForEachKey(_self, function (field, value) {
	                    if (isString(field) &&
	                        !isFunction$1(value) &&
	                        field && field[0] !== "_" && // Don't copy "internal" values
	                        _ignoreUpdateSnippetProperties.indexOf(field) === -1) {
	                        snippet[field] = value;
	                    }
	                });
	            }
	        }
	        // dont allow additional channels/other extensions for legacy mode; legacy mode is only to allow users to switch with no code changes!
	        if (legacyMode && _self.config.extensions && _self.config.extensions.length > 0) {
	            throwError("Extensions not allowed in legacy mode");
	        }
	        doPerf(_self.core, function () { return "AISKU.loadAppInsights"; }, function () {
	            var extensions = [];
	            extensions.push(_self._sender);
	            extensions.push(_self.properties);
	            extensions.push(_self.dependencies);
	            extensions.push(_self.appInsights);
	            // initialize core
	            _self.core.initialize(_self.config, extensions, logger, notificationManager);
	            _self.context = _self.properties.context;
	            if (_internalSdkSrc && _self.context) {
	                _self.context.internal.sdkSrc = _internalSdkSrc;
	            }
	            _updateSnippetProperties(_self.snippet);
	            // Empty queue of all api calls logged prior to sdk download
	            _self.emptyQueue();
	            _self.pollInternalLogs();
	            _self.addHousekeepingBeforeUnload(_this);
	        });
	        return _self;
	    };
	    /**
	     * Overwrite the lazy loaded fields of global window snippet to contain the
	     * actual initialized API methods
	     * @param {Snippet} snippet
	     * @memberof Initialization
	     */
	    Initialization.prototype.updateSnippetDefinitions = function (snippet) {
	        // apply full appInsights to the global instance
	        // Note: This must be called before loadAppInsights is called
	        proxyAssign(snippet, this, function (name) {
	            // Not excluding names prefixed with "_" as we need to proxy some functions like _onError
	            return name && _ignoreUpdateSnippetProperties.indexOf(name) === -1;
	        });
	    };
	    /**
	     * Call any functions that were queued before the main script was loaded
	     * @memberof Initialization
	     */
	    Initialization.prototype.emptyQueue = function () {
	        var _self = this;
	        // call functions that were queued before the main script was loaded
	        try {
	            if (isArray$1(_self.snippet.queue)) {
	                // note: do not check length in the for-loop conditional in case something goes wrong and the stub methods are not overridden.
	                var length_1 = _self.snippet.queue.length;
	                for (var i = 0; i < length_1; i++) {
	                    var call = _self.snippet.queue[i];
	                    call();
	                }
	                _self.snippet.queue = undefined;
	                delete _self.snippet.queue;
	            }
	        }
	        catch (exception) {
	            var properties = {};
	            if (exception && isFunction$1(exception.toString)) {
	                properties.exception = exception.toString();
	            }
	            // need from core
	            // Microsoft.ApplicationInsights._InternalLogging.throwInternal(
	            //     LoggingSeverity.WARNING,
	            //     _InternalMessageId.FailedToSendQueuedTelemetry,
	            //     "Failed to send queued telemetry",
	            //     properties);
	        }
	    };
	    Initialization.prototype.pollInternalLogs = function () {
	        this.core.pollInternalLogs();
	    };
	    Initialization.prototype.addHousekeepingBeforeUnload = function (appInsightsInstance) {
	        // Add callback to push events when the user navigates away
	        if (hasWindow() || hasDocument()) {
	            var performHousekeeping = function () {
	                // Adds the ability to flush all data before the page unloads.
	                // Note: This approach tries to push a sync request with all the pending events onbeforeunload.
	                // Firefox does not respect this.Other browsers DO push out the call with < 100% hit rate.
	                // Telemetry here will help us analyze how effective this approach is.
	                // Another approach would be to make this call sync with a acceptable timeout to reduce the
	                // impact on user experience.
	                // appInsightsInstance.context._sender.triggerSend();
	                appInsightsInstance.onunloadFlush(false);
	                // Back up the current session to local storage
	                // This lets us close expired sessions after the cookies themselves expire
	                arrForEach(appInsightsInstance.appInsights.core['_extensions'], function (ext) {
	                    if (ext.identifier === PropertiesPluginIdentifier) {
	                        if (ext && ext.context && ext.context._sessionManager) {
	                            ext.context._sessionManager.backup();
	                        }
	                        return -1;
	                    }
	                });
	            };
	            if (!appInsightsInstance.appInsights.config.disableFlushOnBeforeUnload) {
	                // Hook the unload event for the document, window and body to ensure that the client events are flushed to the server
	                // As just hooking the window does not always fire (on chrome) for page navigations.
	                var added = addEventHandler('beforeunload', performHousekeeping);
	                added = addEventHandler('unload', performHousekeeping) || added;
	                added = addEventHandler('pagehide', performHousekeeping) || added;
	                added = addEventHandler('visibilitychange', performHousekeeping) || added;
	                // A reactNative app may not have a window and therefore the beforeunload/pagehide events -- so don't
	                // log the failure in this case
	                if (!added && !isReactNative()) {
	                    appInsightsInstance.appInsights.core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedToAddHandlerForOnBeforeUnload, 'Could not add handler for beforeunload and pagehide');
	                }
	            }
	            // We also need to hook the pagehide and visibilitychange events as not all versions of Safari support load/unload events.
	            if (!appInsightsInstance.appInsights.config.disableFlushOnUnload) {
	                // Not adding any telemetry as pagehide as it's not supported on all browsers
	                addEventHandler('pagehide', performHousekeeping);
	                addEventHandler('visibilitychange', performHousekeeping);
	            }
	        }
	    };
	    Initialization.prototype.getSender = function () {
	        return this._sender;
	    };
	    Initialization.prototype.getSKUDefaults = function () {
	        var _self = this;
	        _self.config.diagnosticLogInterval =
	            _self.config.diagnosticLogInterval && _self.config.diagnosticLogInterval > 0 ? _self.config.diagnosticLogInterval : 10000;
	    };
	    return Initialization;
	}());
	// tslint:disable-next-line
	(function () {
	    var sdkSrc = null;
	    var cdns = [
	        "://js.monitor.azure.com/",
	        "://az416426.vo.msecnd.net/"
	    ];
	    try {
	        // Try and determine whether the sdk is being loaded from the CDN
	        // currentScript is only valid during initial processing
	        var scrpt = (document || {}).currentScript;
	        if (scrpt) {
	            sdkSrc = scrpt.src;
	            // } else {
	            //     // We need to update to at least typescript 2.9 for this to work :-(
	            //     // Leaving as a stub for now so after we upgrade this breadcrumb is available
	            //     let meta = import.meta;
	            //     sdkSrc = (meta || {}).url;
	            //     isModule = true;
	        }
	    }
	    catch (e) {
	        // eslint-disable-next-line no-empty
	    }
	    if (sdkSrc) {
	        try {
	            var url = sdkSrc.toLowerCase();
	            if (url) {
	                var src = "";
	                for (var idx = 0; idx < cdns.length; idx++) {
	                    if (url.indexOf(cdns[idx]) !== -1) {
	                        src = "cdn" + (idx + 1);
	                        if (url.indexOf("/scripts/") === -1) {
	                            if (url.indexOf("/next/") !== -1) {
	                                src += "-next";
	                            }
	                            else if (url.indexOf("/beta/") !== -1) {
	                                src += "-beta";
	                            }
	                        }
	                        _internalSdkSrc = src + ( "");
	                        break;
	                    }
	                }
	            }
	        }
	        catch (e) {
	            // eslint-disable-next-line no-empty
	        }
	    }
	})();

	/**
	 * @private
	 */
	var Insights = /** @class */ (function () {
	    function Insights(options) {
	        this.options = options;
	        if (!this.options.disableTelemetry && env.appInsightsKey) {
	            this.appInsights = new Initialization({
	                config: {
	                    instrumentationKey: env.appInsightsKey,
	                    // Don't globally track exceptions unless we call trackException()
	                    disableExceptionTracking: true,
	                    // Don't track every AJAX call
	                    disableAjaxTracking: true,
	                    // Play nice with other's AI instances by not using cookies
	                    isCookieUseDisabled: true,
	                    // Tighten the batch size window
	                    maxBatchInterval: 5000
	                }
	            });
	            // Load the app insights object.
	            // Add our app version number to all telemetry items.
	            this.appInsights.loadAppInsights();
	            this.appInsights.addTelemetryInitializer(function (item) {
	                // The applicationVersion property is special and defined by the app insights package.
	                item.tags[CtxTagKeys.applicationVersion] = Version.getFullVersion();
	            });
	        }
	    }
	    Insights.prototype.trackEvent = function (event, customProperties) {
	        if (!this.options.disableTelemetry && this.appInsights) {
	            this.appInsights.trackEvent(event, customProperties);
	        }
	    };
	    Insights.prototype.setAuthenticatedUserContext = function (authenticatedUserId, accountId) {
	        if (!this.options.disableTelemetry && this.appInsights) {
	            this.appInsights.setAuthenticatedUserContext(authenticatedUserId, accountId);
	        }
	    };
	    Insights.prototype.trackException = function (exception) {
	        if (!this.options.disableTelemetry && this.appInsights) {
	            this.appInsights.trackException(exception);
	        }
	    };
	    Insights.prototype.flush = function (async) {
	        if (!this.options.disableTelemetry && this.appInsights) {
	            this.appInsights.flush(async);
	        }
	    };
	    return Insights;
	}());

	/**
	 * The options for a CopyrightControl object.
	 */
	var CopyrightControlOptions = /** @class */ (function (_super) {
	    __extends(CopyrightControlOptions, _super);
	    function CopyrightControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The copyright plain text message to display. Will be appended to copyright content if provided
	         */
	        _this.copyrightMessage = undefined;
	        /**
	         * The copyright content element containing formatted copyright message
	         * this is the primary way of setting copyright by CopyrightDelegate
	         */
	        _this.copyrightContent = undefined;
	        /**
	         * Additional custom user attribution appended to the end as it is
	         */
	        _this.customAttribution = undefined;
	        /**
	         * If true will show a link to the map feedback page.
	         */
	        _this.showFeedbackLink = true;
	        /**
	         * If true will show the Microsoft logo.
	         */
	        _this.showLogo = true;
	        return _this;
	    }
	    return CopyrightControlOptions;
	}(Options));

	/**
	 * @private
	 */
	var CopyrightControl = /** @class */ (function (_super) {
	    __extends(CopyrightControl, _super);
	    function CopyrightControl(options) {
	        var _this = _super.call(this) || this;
	        _this.textAttribution = function (options) {
	            return [_this.options.copyrightMessage, _this.options.customAttribution]
	                .filter(function (message) { return message; })
	                .join("");
	        };
	        _this.options = new CopyrightControlOptions().merge(options);
	        return _this;
	    }
	    CopyrightControl.prototype.onAdd = function (map) {
	        this.container = this.buildContainer(map, exports.ControlStyle.auto);
	        this.container.className = "map-copyright";
	        this.copyrightDiv = this.buildCopyrightDiv();
	        this.copyrightDiv.className = "azure-map-copyright";
	        this.container.appendChild(this.copyrightDiv);
	        if (this.options.showLogo) {
	            this.addRemoveLogo(true);
	        }
	        if (this.options.showFeedbackLink) {
	            this.addRemoveFeedbackDiv(true);
	        }
	        return this.container;
	    };
	    CopyrightControl.prototype.onRemove = function () {
	        _super.prototype.onRemove.call(this);
	        delete this.container;
	    };
	    CopyrightControl.prototype.setOptions = function (options) {
	        var _this = this;
	        var newOptions = new CopyrightControlOptions().merge(this.options, options);
	        if (newOptions.copyrightMessage !== this.options.copyrightMessage
	            || newOptions.customAttribution !== this.options.customAttribution) {
	            this.copyrightDiv.innerText = this.textAttribution(newOptions);
	        }
	        if (newOptions.copyrightContent !== this.options.copyrightContent) {
	            if (this.options.copyrightContent) {
	                var prev = Array.from(this.copyrightDiv.children).find(function (elem) { return elem === _this.options.copyrightContent; });
	                this.copyrightDiv.removeChild(prev);
	            }
	            if (this.copyrightDiv.childNodes.length > 0) {
	                this.copyrightDiv.insertBefore(newOptions.copyrightContent, this.copyrightDiv.childNodes[0]);
	            }
	            else {
	                this.copyrightDiv.appendChild(newOptions.copyrightContent);
	            }
	            this.options.copyrightContent = newOptions.copyrightContent;
	        }
	        if (!newOptions.showLogo && this.logoDiv) {
	            this.addRemoveLogo(false);
	        }
	        else if (newOptions.showLogo && !this.logoDiv) {
	            this.addRemoveLogo(true);
	        }
	        if (!newOptions.showFeedbackLink && this.feedbackDiv) {
	            this.addRemoveFeedbackDiv(false);
	        }
	        else if (newOptions.showFeedbackLink && !this.feedbackDiv) {
	            this.addRemoveFeedbackDiv(true);
	        }
	        this.options = newOptions;
	    };
	    CopyrightControl.prototype.getDefaultAttributions = function () {
	        var currentYear = new Date().getFullYear();
	        var copyright = ["\u00A9" + currentYear + " TomTom"];
	        if (!this.options.showLogo) {
	            copyright.push("\u00A9" + currentYear + " Microsoft");
	        }
	        return copyright;
	    };
	    CopyrightControl.prototype.buildCopyrightDiv = function () {
	        var copyright = document.createElement("div");
	        copyright.innerText = this.textAttribution(this.options) || "";
	        return copyright;
	    };
	    CopyrightControl.prototype.buildFeedbackLink = function () {
	        var _this = this;
	        var link = document.createElement("a");
	        link.href = "https://feedback.azuremaps.com";
	        link.target = "_blank";
	        link.rel = "noopener";
	        link.className = "azure-map-feedback";
	        link.onmouseover = function () {
	            _this.tooltip.style.visibility = "visible";
	        };
	        link.onmouseout = function () {
	            _this.tooltip.style.visibility = "hidden";
	        };
	        return link;
	    };
	    CopyrightControl.prototype.addToolTip = function () {
	        var tooltip = document.createElement("div");
	        var tooltipText = document.createElement("div");
	        tooltipText.innerText = "Give Feedback";
	        tooltipText.className = "azure-map-feedback-tooltip";
	        var tooltipBeak = document.createElement("div");
	        tooltipBeak.className = "azure-map-feedback-tooltip-beak";
	        tooltip.appendChild(tooltipText);
	        tooltip.appendChild(tooltipBeak);
	        tooltip.style.visibility = "hidden";
	        tooltip.style.zIndex = "1000";
	        return tooltip;
	    };
	    CopyrightControl.prototype.addRemoveFeedbackDiv = function (add) {
	        if (add) {
	            this.feedbackDiv = this.buildFeedbackLink();
	            this.container.appendChild(this.feedbackDiv);
	            this.tooltip = this.addToolTip();
	            this.container.appendChild(this.tooltip);
	        }
	        else {
	            this.feedbackDiv.remove();
	            this.tooltip.remove();
	            delete this.tooltip;
	            delete this.feedbackDiv;
	        }
	    };
	    CopyrightControl.prototype.addRemoveLogo = function (add) {
	        if (add) {
	            this.logoDiv = document.createElement("div");
	            this.logoDiv.className = "azure-map-logo";
	            this.container.appendChild(this.logoDiv);
	        }
	        else {
	            this.logoDiv.remove();
	            delete this.logoDiv;
	        }
	    };
	    return CopyrightControl;
	}(ControlBase));

	/**
	 * Provides some static methods to translate Mapbox's event based errors to try/catch style.
	 */
	var ErrorHandler = /** @class */ (function () {
	    function ErrorHandler() {
	    }
	    /**
	     * Executes the specified function and throws an error if Mapbox fires an error event.
	     * A call to this should be wrapped in a try/catch.
	     * @param map Either our map or the Mapbox map that will be firing the error events.
	     * @param func The function to execute.
	     * @internal
	     */
	    ErrorHandler.throwOnError = function (map, func) {
	        // Work directly with the Mapbox map.
	        var mbMap = map instanceof Map$2 ? map._getMap() : map;
	        // Listen for the error event and throw if one is seen.
	        var throwError = function (data) {
	            mbMap.off("error", throwError);
	            throw data.error;
	        };
	        mbMap.on("error", throwError);
	        // Execute the specified function and return the result.
	        // Stop the error listener before returning.
	        var result = func();
	        mbMap.off("error", throwError);
	        return result;
	    };
	    /**
	     * Executes the specified function and and throws an error if Mapbox fires an error event.
	     * The call is wrapped in a try/catch.
	     * @param map Either our map or the Mapbox map that will be firing the error events.
	     * @param tryFunc The function to try executing.
	     * @param catchFunc The function to execute if an error is fired.
	     * @param finallyFunc An optional function to execute in the finally block.
	     */
	    ErrorHandler.tryCatch = function (map, tryFunc, catchFunc, finallyFunc) {
	        try {
	            return this.throwOnError(map, tryFunc);
	        }
	        catch (error) {
	            return catchFunc(error);
	        }
	        finally {
	            if (typeof finallyFunc === "function") {
	                finallyFunc();
	            }
	        }
	    };
	    /**
	     * Executes the specified function and and throws an error if Mapbox fires an error event.
	     * The call is wrapped in a try/finally.
	     * @param map Either our map or the Mapbox map that will be firing the error events.
	     * @param tryFunc The function to try executing.
	     * @param finallyFunc An optional function to execute in the finally block.
	     */
	    ErrorHandler.tryFinally = function (map, tryFunc, finallyFunc) {
	        try {
	            return this.throwOnError(map, tryFunc);
	        }
	        finally {
	            finallyFunc();
	        }
	    };
	    return ErrorHandler;
	}());

	/**
	 * @private
	 */
	var NearbyGeographySearchService = /** @class */ (function () {
	    function NearbyGeographySearchService(map) {
	        this.map = map;
	    }
	    NearbyGeographySearchService.prototype.request = function (options) {
	        var domain = this.map.getServiceOptions().domain;
	        var urlOptions = {
	            domain: domain,
	            path: "search/address/reverse/json",
	            queryParams: __assign({ "api-version": "1.0", "language": options.style.language, "limit": 1, "query": normalizeLatitude(options.position[1]) + "," + normalizeLongitude(options.position[0]) }, (options.style.view && { view: options.style.view }))
	        };
	        return new Url(this.map.authentication.signRequest(urlOptions)).get();
	    };
	    return NearbyGeographySearchService;
	}());

	/** A static class that maintains a cache of place labels. */
	var MapLabelCache = /** @class */ (function () {
	    function MapLabelCache() {
	        this._labelCache = {};
	        this._labelIdx = {};
	        this._preloadedCache = new Set();
	    }
	    /**
	     * Adds a label to the cache.
	     * @param label The label to cache.
	     * @param layerInfo The configu info for the label.
	     * @param pos The position of the label.
	     * @param lang The language of the label.
	     */
	    MapLabelCache.prototype.cache = function (name, layerInfo, pos, lang) {
	        var id = name + "_" + pos[0] + "_" + pos[1] + "_" + lang;
	        if (!this._labelIdx[layerInfo.labelType]) {
	            this._labelIdx[layerInfo.labelType] = [];
	            this._labelCache[layerInfo.labelType] = [];
	        }
	        if (this._labelIdx[layerInfo.labelType].indexOf(id) === -1) {
	            // Add label to cache.
	            this._labelCache[layerInfo.labelType].push({
	                name: name,
	                radius: layerInfo.radius,
	                minZoom: layerInfo.minZoom,
	                maxZoom: layerInfo.maxZoom || 24,
	                position: pos
	            });
	            // Add label to index.
	            this._labelIdx[layerInfo.labelType].push(id);
	        }
	    };
	    /**
	     * Calculates the nearest label in the cache.
	     * @param labelType The type/category of the label in which the label is seperated into.
	     * @param pos The position to center the search on.
	     */
	    MapLabelCache.prototype.getNearestLabel = function (labelType, pos, zoom) {
	        var nearest = null;
	        var c = this._labelCache[labelType];
	        if (c) {
	            var minDistance = Infinity;
	            for (var i = 0, len = c.length; i < len; i++) {
	                if (zoom >= c[i].minZoom && zoom <= c[i].maxZoom) {
	                    var d = getDistanceTo(c[i].position, pos);
	                    if (d <= c[i].radius && d <= minDistance) {
	                        minDistance = d;
	                        nearest = c[i];
	                    }
	                }
	            }
	        }
	        return nearest;
	    };
	    /**
	     * This function preloads the cache with major labels for a select few languages
	     * in which these labels are most likely to be used with.
	     * This is to help with identifying these major labels when the user is zoomed in close to the map.
	     * In testing, this has been found to drastically reduce the number of times "unknown" is returned
	     * for locations that border an ocean. Based on Bing Maps usage,
	     * the following languages cover 98% of traffic they recieve.
	     * Limiting the languages to those most likely to be used on the broder with an ocean.
	     * @param lang The language to load into the cache.
	     */
	    MapLabelCache.prototype._preloadCache = function (lang) {
	        // Only load a language once into cache.
	        if (!this._preloadedCache.has(lang)) {
	            // Translations for oceans: https://en.wikipedia.org/wiki/List_of_alternative_names_for_oceans
	            this._preloadedCache.add(lang);
	            var oceanConfig = {
	                source: ["Ocean label", "Ocean name"],
	                labelType: "water",
	                minZoom: 0,
	                radius: 3950000,
	                polygonSources: ["Ocean", "Ocean or sea"]
	            };
	            var shortLang = lang;
	            var index = shortLang.indexOf("-");
	            if (index !== -1) {
	                shortLang = shortLang.substr(0, index);
	            }
	            switch (shortLang) {
	                case "fr":
	                    this.cache("Océan Pacifique", oceanConfig, [-170, 32], lang);
	                    this.cache("Océan Pacifique", oceanConfig, [-138, -27], lang);
	                    this.cache("Océan Atlantique", oceanConfig, [-40, 32], lang);
	                    this.cache("Océan Atlantique", oceanConfig, [-17, -29], lang);
	                    break;
	                case "es":
	                    this.cache("Océan Pacifique", oceanConfig, [-170, 32], lang);
	                    this.cache("Océan Pacifique", oceanConfig, [-138, -27], lang);
	                    this.cache("Océano Atlántico", oceanConfig, [-40, 32], lang);
	                    this.cache("Océano Atlántico", oceanConfig, [-17, -29], lang);
	                    break;
	                case "pt":
	                    this.cache("Oceano Pacífico", oceanConfig, [-170, 32], lang);
	                    this.cache("Oceano Pacífico", oceanConfig, [-138, -27], lang);
	                    this.cache("Oceano Atlântico", oceanConfig, [-40, 32], lang);
	                    this.cache("Oceano Atlântico", oceanConfig, [-17, -29], lang);
	                    break;
	                case "ja":
	                    // Pacific Ocean
	                    this.cache("太平洋", oceanConfig, [-170, 32], lang);
	                    this.cache("太平洋", oceanConfig, [-138, -27], lang);
	                    break;
	                case "en":
	                    this.cache("Pacific Ocean", oceanConfig, [-170, 32], lang);
	                    this.cache("Pacific Ocean", oceanConfig, [-138, -27], lang);
	                    this.cache("Atlantic Ocean", oceanConfig, [-40, 32], lang);
	                    this.cache("Atlantic Ocean", oceanConfig, [-17, -29], lang);
	                    this.cache("Indian Ocean", oceanConfig, [77, -26], lang);
	                    break;
	            }
	        }
	    };
	    return MapLabelCache;
	}());

	/**
	 * This class analyizes the current view of a map and provides a description for use by accessibilty tools.
	 * TODO: Use services when in  GeoPol regions. (Kasmir) or when user region sensitive.
	 */
	var MapViewDescriptor = /** @class */ (function () {
	    function MapViewDescriptor(map, descCallback) {
	        var _this = this;
	        // Track if disposed.
	        this._disposed = false;
	        // Track when the last description update occurred due to rotation.
	        this._lastHeadingTime = 0;
	        // A queue of the actions that haven't been described yet.
	        this._actionQueue = [];
	        // Number of milliseconds required for the pointer to be held down to get a description of that location.
	        this._pointerUpdateDelay = 3000;
	        // Number of milliseconds required between move end and the description update.
	        this._camUpdateDelay = 1000;
	        // Number of milliseconds required between heading description updates.
	        this._headUpdateLimit = 1000;
	        // Number of milliseconds to wait before acting on a move event originating from a control element.
	        this._controlEventDelay = 500;
	        // The minium number of pixels the map must move to trigger an update.
	        // The larger this number is, the less updates will be triggered, but the less accurate the results will be.
	        this._moveThreshold = 25;
	        // The minium number of degrees the map must rotate to trigger an update.
	        // The larger this number is, the less updates will be triggered, but the less accurate the results will be.
	        this._headingThreshold = 5;
	        // The minium number of degrees the map must pitch to trigger an update.
	        // The larger this number is, the less updates will be triggered, but the less accurate the results will be.
	        this._pitchThreshold = 5;
	        // The number of pixels to search around the center for a road, or major label.
	        this._roadPixelRadius = 120;
	        // Minum distance a road has to be before it can be displayed. Only used when zoomed in close.
	        this._minRoadDistance = 25;
	        // Minium distance in pixels a second road must be in order to be considered an intersection.
	        this._minIntersectionPixelDistance = 50;
	        // The vector tile source id for Azure Maps.
	        this._baseVectorTileSourceId = "vectorTiles";
	        /*
	         * Show details based on zoom level.
	         *
	         * Country: 1+
	         * Water: 1+
	         * States: 4+
	         * City: 8+
	         * Major POI: 8+  or 12+
	         * Neighborhood: 12+
	         * Poi: 16+
	         * Road: 16+
	         *
	         * The following label types will be cached; Country, State, City, Water, and majorPoi.
	         * The purpose of the cache is to provide a backup if no information is found in the source,
	         * we can do a radial search for appropriate label type.
	         * These often cover large areas and only have a single label.
	         * When zoomed in, no icon is visible, so based on the type of polygon the center intersects with,
	         * we can make an educated guess on what cache to pull a label from.
	         *
	         * Vector Tile source layers: https://developer.tomtom.com/maps-api/maps-api-documentation-vector/tile
	         */
	        // Configuration for label extraction.
	        this._lableConfig = [
	            // Water labels
	            {
	                source: ["Ocean label", "Ocean name"],
	                labelType: "water",
	                minZoom: 0, radius: 3950000,
	                polygonSources: ["Ocean", "Ocean or sea"]
	            },
	            {
	                source: ["Sea label"],
	                labelType: "water",
	                minZoom: 3,
	                radius: 1000000,
	                polygonSources: ["Sea", "Ocean or sea"]
	            },
	            // Country labels
	            {
	                source: ["Country name"],
	                labelType: "country",
	                minZoom: 0,
	                maxZoom: 5,
	                radius: 300000
	            },
	            // State labels
	            {
	                source: ["State name", "State name short"],
	                labelType: "state",
	                minZoom: 4,
	                maxZoom: 7,
	                radius: 300000
	            },
	            // City labels
	            {
	                source: ["Capital city", "Large city"],
	                labelType: "city", minZoom: 8,
	                radius: 40000
	            },
	            {
	                source: ["Medium city"],
	                labelType: "city",
	                minZoom: 8,
	                radius: 30000
	            },
	            {
	                source: ["Small city"],
	                labelType: "city",
	                minZoom: 8,
	                radius: 20000
	            },
	            {
	                source: ["Island label"],
	                labelType: "city",
	                minZoom: 8,
	                radius: 10000
	            },
	            {
	                source: ["Town"],
	                labelType: "city",
	                minZoom: 10,
	                radius: 10000
	            },
	            // Neighbourhood labels
	            {
	                source: ["Village"],
	                labelType: "neighbourhood",
	                minZoom: 12,
	                radius: 6000
	            },
	            // POI labels
	            {
	                source: ["Amusement area label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 2000,
	                polygonSources: ["Amusement park"]
	            },
	            {
	                source: ["Hospital label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["Hospital"]
	            },
	            {
	                source: ["Shopping centre label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["Shopping"]
	            },
	            {
	                source: ["Stadium label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["Stadium"]
	            },
	            {
	                source: ["University/School label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["University"]
	            },
	            {
	                source: ["Zoo label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["Zoo"]
	            },
	            // Major Poi labels
	            {
	                source: ["Airport Label", "Airport name", "Airport POI"],
	                labelType: "majorPoi",
	                minZoom: 11,
	                radius: 3000,
	                polygonSources: ["Airport", "Runway"]
	            },
	            {
	                source: ["National park label"],
	                labelType: "majorPoi",
	                minZoom: 7,
	                radius: 15000,
	                polygonSources: ["National or state park", "National park", "Forest"]
	            },
	            {
	                source: ["Reservation label"],
	                labelType: "majorPoi",
	                minZoom: 7,
	                radius: 15000,
	                polygonSources: ["Reservation"]
	            }
	        ];
	        // Name of all polygon layers in which we want to do an intersection test with.
	        this._polygonStyleLayer = ["National or state park", "National park", "Reservation", "Airport",
	            "Runway", "Stadium", "University", "Zoo", "Shopping", "Hospital", "Amusement park", "Ocean", "Sea",
	            "Ocean or sea"];
	        // Name of all label types to cache.
	        this._labelCache = new Set(["city", "state", "country", "water", "majorPoi"]);
	        // Name of all road source layers.
	        this._roadLayers = new Set([
	            "Connecting road",
	            "Connecting road tunnel",
	            "International road",
	            "International road tunnel",
	            "Local road",
	            "Local road tunnel",
	            "Major local road",
	            "Major local road tunnel",
	            "Major road",
	            "Major road tunnel",
	            "Minor local road",
	            "Minor local road tunnel",
	            "Motorway",
	            "Motorway tunnel",
	            "Secondary road",
	            "Secondary road tunnel",
	            "Toll connecting road",
	            "Toll connecting road tunnel",
	            "Toll international road",
	            "Toll international road tunnel",
	            "Toll local road",
	            "Toll local road tunnel",
	            "Toll major local road",
	            "Toll major local road tunnel",
	            "Toll major road",
	            "Toll major road tunnel",
	            "Toll minor local road",
	            "Toll minor local road tunnel",
	            "Toll motorway",
	            "Toll motorway tunnel",
	            "Toll secondary road",
	            "Toll secondary road tunnel"
	        ]);
	        // Flag indicating if detailed descriptions which include zoom, lat/lon information should be returned.
	        this._returnDetailedDescriptions = false;
	        /** Event handler for shortcuts. */
	        this._shortcutListener = function (e) { return __awaiter(_this, void 0, void 0, function () {
	            var cam, styleOps, lang, style, camDesc;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        if (!(e.altKey && e.ctrlKey && e.keyCode === 68)) return [3 /*break*/, 2];
	                        this._returnDetailedDescriptions = !this._returnDetailedDescriptions;
	                        cam = this._map.getCamera();
	                        styleOps = this._map.getStyle();
	                        lang = styleOps.language.toLowerCase();
	                        style = styleOps.style.toLowerCase();
	                        return [4 /*yield*/, this._getLocDesc(cam, lang, style)];
	                    case 1:
	                        camDesc = _a.sent();
	                        this._descCallback(camDesc);
	                        _a.label = 2;
	                    case 2: return [2 /*return*/];
	                }
	            });
	        }); };
	        /** Event handler for when the map is actively rotating and should update the heading description. */
	        this._onRotate = function () {
	            if (!_this._rotateTimeout) {
	                if (Date.now() - _this._lastHeadingTime >= _this._headUpdateLimit) {
	                    // If the min required time has already passed just do the update.
	                    _this._rotateTimeout = setTimeout(_this._updateHeading, CompassControl.RotationDuration + 25);
	                }
	                else {
	                    // If the min required time hasn't passed start a timeout if doesn't already exist.
	                    _this._rotateTimeout = setTimeout(_this._updateHeading, _this._headUpdateLimit - (Date.now() - _this._lastHeadingTime));
	                }
	            }
	        };
	        /** Event handler for when the map is actively moving should wait to update the camera description. */
	        this._onMove = function () {
	            // Clear the timeout for updating the map's camera description.
	            if (_this._moveTimeout) {
	                clearTimeout(_this._moveTimeout);
	                delete _this._moveTimeout;
	            }
	            // Clear the timeout for delaying updates originating from control elements.
	            if (_this._controlTimeout) {
	                clearTimeout(_this._controlTimeout);
	                delete _this._controlTimeout;
	            }
	        };
	        /** Event handler for when the mas has stopped moving and thus a new description is needed. */
	        this._onMoveEnd = function (event) {
	            if (event.fromControl) {
	                // If the move end event originated from a control element delay the response to batch control clicks.
	                _this._controlTimeout = setTimeout(_this._updateCam, _this._controlEventDelay);
	            }
	            else {
	                // Otherwise start processing a new description immediately.
	                _this._updateCam();
	            }
	        };
	        /** Event handler for when the map has changed styles. */
	        this._onStyleData = function () {
	            // Use setTimeout with no delay to allow mapbox time to
	            // update the value of .loaded() before we check it.
	            setTimeout(_this._updateStyle);
	        };
	        /** Event handler for when the mouse or touch goes down */
	        this._onPointerDown = function (event) {
	            _this._lastPointerPos = _this._getEventPos(event);
	            _this._pointerTimeout = setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
	                var styleOps, lang, style, cam, loc;
	                return __generator(this, function (_a) {
	                    switch (_a.label) {
	                        case 0:
	                            styleOps = this._map.getStyle();
	                            lang = styleOps.language.toLowerCase();
	                            style = styleOps.style.toLowerCase();
	                            cam = this._map.getCamera();
	                            cam.center = this._map.pixelsToPositions([this._lastPointerPos])[0];
	                            return [4 /*yield*/, this._getLocDesc(cam, lang, style)];
	                        case 1:
	                            loc = _a.sent();
	                            this._descCallback(loc);
	                            this._onPointerUp();
	                            return [2 /*return*/];
	                    }
	                });
	            }); }, _this._pointerUpdateDelay);
	            // Start listening for the pointer moving in-case it moves far enough to cancel the location update.
	            _this._map.getCanvas().addEventListener("mousemove", _this._onPointerMove);
	            _this._map.getCanvas().addEventListener("touchmove", _this._onPointerMove);
	            // Start listening for the pointer to go up to cancel the location update.
	            _this._map.getCanvas().addEventListener("mouseup", _this._onPointerUp);
	            _this._map.getCanvas().addEventListener("touchend", _this._onPointerUp);
	        };
	        /** Event handler for when the mouse or touch is moved */
	        this._onPointerMove = function (event) {
	            var pos = _this._getEventPos(event);
	            var dx = _this._lastPointerPos[0] - pos[0];
	            var dy = _this._lastPointerPos[1] - pos[1];
	            var dist = Math.sqrt(dx * dx + dy * dy);
	            if (dist > _this._moveThreshold) {
	                _this._onPointerUp();
	            }
	        };
	        /** Event handler for when the mouse or touch goes up */
	        this._onPointerUp = function () {
	            clearTimeout(_this._pointerTimeout);
	            delete _this._pointerTimeout;
	            _this._map.getCanvas().removeEventListener("mousemove", _this._onPointerMove);
	            _this._map.getCanvas().removeEventListener("touchmove", _this._onPointerMove);
	            _this._map.getCanvas().removeEventListener("mouseup", _this._onPointerUp);
	            _this._map.getCanvas().removeEventListener("touchend", _this._onPointerUp);
	        };
	        /** Called when the map is rotating and needs a new description created */
	        this._updateHeading = function () {
	            // Update the heading description.
	            var cam = _this._map.getCamera();
	            if (!_this._lastHead || _this._checkHeadingThreshold(cam.bearing, _this._lastHead)) {
	                // Update the last heading value and update time.
	                var headDesc = _this._getHeadingDesc(cam);
	                _this._lastHead = cam.bearing;
	                _this._descCallback("<p>Map heading " + headDesc + ".</p>");
	                _this._lastHeadingTime = Date.now();
	            }
	            // Reset for the next rotate.
	            delete _this._rotateTimeout;
	        };
	        /** Called when the map has finished changing styles and is ready to create a new description */
	        this._updateStyle = function () { return __awaiter(_this, void 0, void 0, function () {
	            var cam, styleOps, lang, style, camDesc;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        cam = this._map.getCamera();
	                        styleOps = this._map.getStyle();
	                        lang = styleOps.language.toLowerCase();
	                        style = styleOps.style.toLowerCase();
	                        if (!(this._lastLang !== lang)) return [3 /*break*/, 2];
	                        MapViewDescriptor._labelCache._preloadCache(lang);
	                        return [4 /*yield*/, this._getLocDesc(cam, lang, style)];
	                    case 1:
	                        camDesc = _a.sent();
	                        return [3 /*break*/, 4];
	                    case 2:
	                        if (!(this._lastStyle !== style && this._lastStyle === "blank")) return [3 /*break*/, 4];
	                        return [4 /*yield*/, this._getLocDesc(cam, lang, style)];
	                    case 3:
	                        camDesc = _a.sent();
	                        _a.label = 4;
	                    case 4:
	                        // Update the last lang and style values.
	                        this._lastLang = lang;
	                        this._lastStyle = style;
	                        // Send the new description to the map.
	                        if (camDesc) {
	                            this._descCallback(camDesc);
	                        }
	                        return [2 /*return*/];
	                }
	            });
	        }); };
	        /** Called when the map has finished updating and is ready to create a new description */
	        this._updateCam = function (immediate) {
	            if (immediate === void 0) { immediate = false; }
	            var cam = _this._map.getCamera();
	            if (!_this._lastCam || _this._actionQueue.length > 0 || _this._checkThresholds(cam, _this._lastCam)) {
	                var styleOps = _this._map.getStyle();
	                var lang_1 = styleOps.language.toLowerCase();
	                var style_1 = styleOps.style.toLowerCase();
	                // Update the action queue if an action is provided.
	                var action = _this._getActionDesc(cam);
	                if (action) {
	                    _this._actionQueue.push(action);
	                }
	                // Update the last camera value.
	                _this._lastCam = cam;
	                // Make sure no other timeouts are active.
	                if (_this._moveTimeout) {
	                    clearTimeout(_this._moveTimeout);
	                    delete _this._moveTimeout;
	                }
	                // Send the new description to the map.
	                _this._moveTimeout = setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
	                    var loc;
	                    return __generator(this, function (_a) {
	                        switch (_a.label) {
	                            case 0:
	                                // Clear the rotate timeout as the move description will cover rotation.
	                                clearTimeout(this._rotateTimeout);
	                                delete this._rotateTimeout;
	                                return [4 /*yield*/, this._getLocDesc(cam, lang_1, style_1)];
	                            case 1:
	                                loc = _a.sent();
	                                // Build the message from the action queue and current loc description.
	                                if (this._actionQueue.length > 0) {
	                                    this._descCallback("<p>Map " + this._actionQueue.join(", then ") + ".</p>" + loc);
	                                    this._actionQueue = []; // Reset the queue because all actions have been delivered.
	                                }
	                                else {
	                                    this._descCallback(loc);
	                                }
	                                return [2 /*return*/];
	                        }
	                    });
	                }); }, immediate ? 0 : _this._camUpdateDelay);
	            }
	        };
	        this._map = map;
	        this._restFallback = map.getServiceOptions().enableAccessibilityLocationFallback;
	        this._descCallback = descCallback;
	        this._reverseSearch = new NearbyGeographySearchService(map);
	        if (!MapViewDescriptor._labelCache) {
	            MapViewDescriptor._labelCache = new MapLabelCache();
	        }
	        this._lastLang = this._map.getStyle().language.toLowerCase();
	        MapViewDescriptor._labelCache._preloadCache(this._lastLang);
	        this._map.events.addOnce("load", function () {
	            if (!_this._disposed) {
	                _this._updateCam(true);
	                // Add event listeners directly to mapbox because we will be using custom event data.
	                // We don't automatically forward all properties of a mapbox event, so the custom data would be lost.
	                _this._map._getMap().on("move", _this._onMove);
	                _this._map._getMap().on("moveend", _this._onMoveEnd);
	                _this._map._getMap().on("styledata", _this._onStyleData);
	                _this._map._getMap().on("rotate", _this._onRotate);
	                _this._map.getCanvas().addEventListener("mousedown", _this._onPointerDown);
	                _this._map.getCanvas().addEventListener("touchstart", _this._onPointerDown);
	            }
	        });
	        this._map.getMapContainer().addEventListener("keydown", this._shortcutListener);
	    }
	    /** Disposes the MapViewDescriptor preventing any further updates */
	    MapViewDescriptor.prototype.dispose = function () {
	        this._disposed = true;
	        // Event listeners were added directly to mapbox.
	        // Remove them directly from there too.
	        this._map._getMap().off("move", this._onMove);
	        this._map._getMap().off("moveend", this._onMoveEnd);
	        this._map._getMap().off("styledata", this._onStyleData);
	        this._map._getMap().off("rotate", this._onRotate);
	        this._map.getCanvas().removeEventListener("mousedown", this._onPointerDown);
	        this._map.getCanvas().removeEventListener("touchstart", this._onPointerDown);
	        this._map.getMapContainer().removeEventListener("keydown", this._shortcutListener);
	    };
	    MapViewDescriptor.prototype._getEventPos = function (event) {
	        if ("touches" in event) {
	            var touch = event.touches[0];
	            var rect = event.target.getBoundingClientRect();
	            return [touch.pageX - rect.left, touch.pageY - rect.top];
	        }
	        else {
	            return [event.offsetX, event.offsetY];
	        }
	    };
	    /** Checks if the camera has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkThresholds = function (newCam, lastCam) {
	        return this._checkZoomThreshold(newCam.zoom, lastCam.zoom) ||
	            this._checkPitchThreshold(newCam.pitch, lastCam.pitch) ||
	            this._checkLocThreshold(newCam.center, lastCam.center) ||
	            this._checkHeadingThreshold(newCam.bearing, lastCam.bearing);
	    };
	    /** Checks if the zoom has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkZoomThreshold = function (newZoom, lastZoom) {
	        return this._round(newZoom) !== this._round(lastZoom);
	    };
	    /** Checks if the pitch has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkPitchThreshold = function (newPitch, lastPitch) {
	        return Math.abs(newPitch - lastPitch) >= this._pitchThreshold;
	    };
	    /** Checks if the location has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkLocThreshold = function (newCenter, lastCenter) {
	        var _a = __read(this._map.positionsToPixels([lastCenter, newCenter]), 2), lastPixel = _a[0], newPixel = _a[1];
	        return Pixel.getDistance(lastPixel, newPixel) >= this._moveThreshold;
	    };
	    /** Checks if the heading has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkHeadingThreshold = function (newHeading, lastHeading) {
	        // Modify the heading values to always be positive.
	        if (newHeading < 0) {
	            newHeading += 360;
	        }
	        if (lastHeading < 0) {
	            lastHeading += 360;
	        }
	        // If the heading diff is greater than 180 it is
	        // less difference in the other direction of rotation.
	        var headDiff = Math.abs(newHeading - lastHeading);
	        if (headDiff > 180) {
	            headDiff = 360 - headDiff;
	        }
	        return headDiff >= this._headingThreshold;
	    };
	    /**
	     * Generates the description for the map view around the center of the map.
	     * @param cam The map camera informaiton.
	     */
	    MapViewDescriptor.prototype._getLocDesc = function (cam, lang, style) {
	        return __awaiter(this, void 0, void 0, function () {
	            var info_1, cPx_1, intersects_1, intersectingPolygon, intersectingType_1, i, cnt, layerInfo, cl_1;
	            var _this = this;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        if (!(style !== "blank")) return [3 /*break*/, 3];
	                        if (!!this._map._getMap().loaded()) return [3 /*break*/, 2];
	                        return [4 /*yield*/, new Promise(function (done) { return _this._map._getMap().once("idle", done); })];
	                    case 1:
	                        _a.sent();
	                        _a.label = 2;
	                    case 2:
	                        info_1 = {};
	                        cPx_1 = this._map.positionsToPixels([cam.center])[0];
	                        ErrorHandler.tryCatch(this._map, function () {
	                            intersects_1 = _this._map._getMap().queryRenderedFeatures(cPx_1, {
	                                layers: _this._polygonStyleLayer,
	                                filter: ["==", ["geometry-type"], "Polygon"]
	                            });
	                        }, function () { });
	                        intersectingPolygon = null;
	                        if (intersects_1 && intersects_1.length > 0) {
	                            intersectingPolygon = intersects_1[0];
	                        }
	                        intersectingType_1 = null;
	                        // Loop through each label config and try and retireve details about the map view.
	                        for (i = 0, cnt = this._lableConfig.length; i < cnt; i++) {
	                            layerInfo = this._lableConfig[i];
	                            if (cam.zoom >= layerInfo.minZoom) {
	                                // If the layer info has polygons defined, do an intersection test for matching.
	                                if (layerInfo.polygonSources) {
	                                    // Only if a value of the same type hasn't already been captured and the intersection polygon has the same source, retrieve a label.
	                                    if (intersectingPolygon &&
	                                        layerInfo.polygonSources.indexOf(intersectingPolygon.layer["source-layer"]) !== -1) {
	                                        intersectingType_1 = layerInfo.labelType;
	                                        this._getClosestLabel(layerInfo, cam, lang, info_1, false);
	                                    }
	                                    else {
	                                        // If the polygon doesn't intersect, cache labels.
	                                        this._getClosestLabel(layerInfo, cam, lang, info_1, true);
	                                    }
	                                }
	                                else {
	                                    this._getClosestLabel(layerInfo, cam, lang, info_1, false);
	                                }
	                            }
	                            else {
	                                this._getClosestLabel(layerInfo, cam, lang, info_1, true);
	                            }
	                        }
	                        if (cam.zoom >= 8) {
	                            // When zoomed in get all the roads as possible that roads might be only near edge.
	                            // Need road to determine state info when zoomed in.
	                            this._processRoads(info_1, cam, lang);
	                        }
	                        this._labelCache.forEach(function (label) {
	                            if (!info_1[label]) {
	                                cl_1 = null;
	                                if (label === "water" || label === "majorPoi") {
	                                    // Only check cache for water and majorPoi labels if the map is over top of water or a major Poi.
	                                    if (label === intersectingType_1) {
	                                        cl_1 = MapViewDescriptor._labelCache.getNearestLabel(label, cam.center, cam.zoom);
	                                    }
	                                }
	                                else {
	                                    cl_1 = MapViewDescriptor._labelCache.getNearestLabel(label, cam.center, cam.zoom);
	                                }
	                                if (cl_1) {
	                                    info_1[label] = cl_1.name;
	                                }
	                            }
	                        });
	                        return [2 /*return*/, this._processLocInfo(cam, intersectingType_1, info_1, true, this._restFallback)];
	                    case 3: 
	                    // If the style is blank don't provide a label as that would always require a reverse geocode api call.
	                    return [2 /*return*/, this._processLocInfo(cam, null, null, false, false)];
	                }
	            });
	        });
	    };
	    /**
	     * Generates the description for the map view around the center of the map.
	     * @param cam The map camera informaiton.
	     */
	    MapViewDescriptor.prototype._getHeadingDesc = function (cam) {
	        // Use the heading but shift any negative values.
	        var heading = cam.bearing;
	        if (heading < 0) {
	            heading += 360;
	        }
	        // Snap to the nearest 5 degrees.
	        heading = this._round(heading, this._headingThreshold);
	        // Generate a new description.
	        switch (heading) {
	            case 0:
	            case 360:
	                return "north";
	            case 45:
	                return "north east";
	            case 90:
	                return "east";
	            case 135:
	                return "south east";
	            case 180:
	                return "south";
	            case 225:
	                return "south west";
	            case 270:
	                return "west";
	            case 315:
	                return "north west";
	            default:
	                return heading + " degrees";
	        }
	    };
	    /**
	     * Gets the closest label to the center of the map.
	     * @param layerInfo The label lauyer information.
	     * @param cam The map camera information.
	     * @param info The result information.
	     * @param cacheOnly Specifies if labels should only be cached and not set on the result.
	     */
	    MapViewDescriptor.prototype._getClosestLabel = function (layerInfo, cam, lang, info, cacheOnly) {
	        var radius = layerInfo.radius;
	        // Loop through the label sources.
	        for (var i = 0, len = layerInfo.source.length; i < len; i++) {
	            var params = {
	                sourceLayer: layerInfo.source[i]
	            };
	            var labels = this._map._getMap().querySourceFeatures(this._baseVectorTileSourceId, params);
	            var closest = null;
	            var minDistance = Infinity;
	            var cacheLabels = this._labelCache.has(layerInfo.labelType);
	            if (!cacheOnly || (cacheOnly && cacheLabels)) {
	                for (var j = 0, cnt = labels.length; j < cnt; j++) {
	                    var p = labels[j].geometry.type === "Point" ?
	                        labels[j] :
	                        getClosestPointOnGeometry(cam.center, labels[j].geometry);
	                    if (!cacheOnly) {
	                        // Distance in meters.
	                        var d = labels[j].geometry.type === "Point" ?
	                            getDistanceTo(cam.center, p.geometry.coordinates) :
	                            p.properties.distance;
	                        if (d < minDistance) {
	                            minDistance = d;
	                            closest = labels[j];
	                        }
	                    }
	                    if (cacheLabels) {
	                        MapViewDescriptor._labelCache.cache(labels[j].properties.name, layerInfo, p.geometry.coordinates, lang);
	                    }
	                }
	            }
	            if (!cacheOnly) {
	                var disParam = layerInfo.labelType + "Dis";
	                if (closest && minDistance <= radius &&
	                    (typeof info[disParam] !== "number" || minDistance <= info[disParam])) {
	                    info[layerInfo.labelType] = closest.properties.name;
	                    info[disParam] = minDistance;
	                }
	            }
	        }
	    };
	    /**
	     * Retrieve road information and extracts the closest road (within a threshold), as well as any state/country data that might be on it.
	     * @param info The MapViewInfo object in which the results are added.
	     * @param cam The map camera information.
	     * @param searchArea An optional search area to limit the scope of where roads are extracted from.
	     */
	    MapViewDescriptor.prototype._processRoads = function (info, cam, lang, searchArea) {
	        // Try and get road data. This provides additional country/state info, and also road names.
	        var roads = this._map._getMap().queryRenderedFeatures(searchArea, {
	            filter: ["==", ["geometry-type"], "LineString"]
	        });
	        if (roads) {
	            var closestRoad = void 0;
	            var closestRoad2 = void 0;
	            var cPoint = void 0;
	            var cPoint2 = void 0;
	            // Get the closest road.
	            for (var i = 0, len = roads.length; i < len; i++) {
	                if (this._roadLayers.has(roads[i].layer["source-layer"])) {
	                    if (roads[i].properties.name && roads[i].properties.name !== "") {
	                        var cp = getClosestPointOnGeometry(cam.center, roads[i]);
	                        if (!cPoint || cp.properties.distance < cPoint.properties.distance) {
	                            if (closestRoad && roads[i].properties.name === closestRoad.properties.name) {
	                                cPoint = cp;
	                            }
	                            else if (!closestRoad || roads[i].properties.name !== closestRoad.properties.name) {
	                                cPoint2 = cPoint;
	                                closestRoad2 = closestRoad;
	                                cPoint = cp;
	                                closestRoad = roads[i];
	                            }
	                            else if (!cPoint2 || cp.properties.distance < cPoint2.properties.distance) {
	                                cPoint2 = cp;
	                                closestRoad2 = roads[i];
	                            }
	                        }
	                    }
	                }
	            }
	            if (closestRoad) {
	                // Capture state and country codes from the closest road to ensure we have the most accurate values.
	                if (!info.country) {
	                    info.country = closestRoad.properties.country_code;
	                    info.countryDis = 0;
	                    MapViewDescriptor._labelCache.cache(info.country, {
	                        source: ["Country name"],
	                        labelType: "country",
	                        radius: 5000,
	                        minZoom: 0
	                    }, cPoint.geometry.coordinates, lang);
	                }
	                if (!info.state) {
	                    info.state = closestRoad.properties.country_subdivision;
	                    info.stateDis = 0;
	                    MapViewDescriptor._labelCache.cache(info.state, {
	                        source: ["State name"],
	                        labelType: "state",
	                        radius: 5000,
	                        minZoom: 4
	                    }, cPoint.geometry.coordinates, lang);
	                }
	                // Only capture road name if zoomed in and close enough to the center of the map.
	                if (cam.zoom >= 15) {
	                    var pixels = this._map.positionsToPixels([cam.center, cPoint.geometry.coordinates]);
	                    var pxDis = Pixel.getDistance(pixels[0], pixels[1]);
	                    if (pxDis < this._roadPixelRadius || cPoint.properties.distance < this._minRoadDistance) {
	                        info.road = closestRoad.properties.name;
	                    }
	                    if (closestRoad2) {
	                        var px = this._map.positionsToPixels([cPoint2.geometry.coordinates]);
	                        pxDis = Pixel.getDistance(pixels[0], px[0]);
	                        if (pxDis < this._minIntersectionPixelDistance || cPoint2.properties.distance < this._minRoadDistance) {
	                            info.secondRoad = closestRoad2.properties.name;
	                            info.secondRoadDis = cPoint2.properties.distance;
	                        }
	                    }
	                }
	            }
	        }
	    };
	    /**
	     * Generates a description of the most recent map actions.
	     * @param cam The map camera information.
	     */
	    MapViewDescriptor.prototype._getActionDesc = function (cam) {
	        if (this._lastCam) {
	            // Build and array of actions that have occurred.
	            // Will be flattened into just a string at the end.
	            var actions = [];
	            // Panning/Center
	            if (this._checkLocThreshold(cam.center, this._lastCam.center)) {
	                // Build the panning message is stages.
	                var msg = ["panned"];
	                var heading = Math.round(getHeading(this._lastCam.center, cam.center));
	                // Assign a cardinal direction for the panning.
	                if (heading === 0 || heading === 360) {
	                    msg.push("north");
	                }
	                else if (heading < 90) {
	                    msg.push("north east");
	                }
	                else if (heading === 90) {
	                    msg.push("east");
	                }
	                else if (heading < 180) {
	                    msg.push("south east");
	                }
	                else if (heading === 180) {
	                    msg.push("south");
	                }
	                else if (heading < 270) {
	                    msg.push("south west");
	                }
	                else if (heading === 270) {
	                    msg.push("west");
	                }
	                else if (heading < 360) {
	                    msg.push("north west");
	                }
	                // If the distance is greater than 1000 use KM instead of meters.
	                var distance = getDistanceTo(this._lastCam.center, cam.center, DistanceUnits.meters);
	                msg.push(distance > 1000 ?
	                    _precision(distance / 1000, 2) + " kilometers" :
	                    _precision(distance, 2) + " meters");
	                // Add the complete message to the actions array.
	                actions.push(msg.join(" "));
	            }
	            // Zoom
	            if (this._checkZoomThreshold(cam.zoom, this._lastCam.zoom)) {
	                // Start with zoom and the direction of change.
	                var msg = ["zoomed"];
	                msg.push(this._lastCam.zoom < cam.zoom ? "in" : "out");
	                // Include the number of levels changed if greater than 1.
	                var diff = Math.abs(this._lastCam.zoom - cam.zoom);
	                if (diff >= 1) {
	                    // Round the zoom level difference to the nearest integer.
	                    diff = Math.ceil(diff);
	                    // Add the number of levels difference.
	                    msg.push(diff > 1 ?
	                        diff + " levels" :
	                        diff + " level");
	                }
	                // If the canonical zoom name is different include the new name.
	                if (this._getCanonicalZoom(this._lastCam.zoom) !== this._getCanonicalZoom(cam.zoom)) {
	                    msg.push("to " + this._getCanonicalZoom(cam.zoom) + " level");
	                }
	                // Add the complete message to the actions array.
	                actions.push(msg.join(" "));
	            }
	            // Pitch
	            if (this._checkPitchThreshold(cam.pitch, this._lastCam.pitch)) {
	                // If the pitch has changed enough add the new pitch value to the actions array.
	                var pitch = this._round(cam.pitch, this._pitchThreshold);
	                actions.push("pitched to " + pitch + " degrees");
	                if (cam.pitch === 60 || cam.pitch === 0) {
	                    var maxOrMim = cam.pitch === 60 ? "maximum" : "minimum";
	                    actions.push("reached " + maxOrMim + " of " + cam.pitch + " degrees");
	                }
	            }
	            // Heading
	            if (this._checkHeadingThreshold(this._lastCam.bearing, cam.bearing)) {
	                actions.push("rotated to " + this._getHeadingDesc(cam));
	            }
	            // Return the flattened list of actions as one string.
	            return actions.join(" and ") || null;
	        }
	        return null;
	    };
	    /** Gets the canonical zoom level name, such as world, country, or city level. */
	    MapViewDescriptor.prototype._getCanonicalZoom = function (zoom) {
	        // Determine the canonical name based on the rounded zoom level.
	        zoom = this._round(zoom);
	        // Determine the canonical name.
	        if (zoom < 2) {
	            return "world";
	        }
	        else if (zoom < 5) {
	            return "country";
	        }
	        else if (zoom < 11) {
	            return "state province";
	        }
	        else if (zoom < 15) {
	            return "city";
	        }
	        return "street"; // Zoom 15+ is street level.
	    };
	    /**
	     * Generates a description from extracted location information.
	     * @param cam The map camera information.
	     * @param info The extracted locaiton information.
	     * @returns A string description for the map view.
	     */
	    MapViewDescriptor.prototype._processLocInfo = function (cam, intersectingType, info, location, restFallback) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            var html = [];
	            if (location) {
	                /*
	                 * Show details based on zoom level.
	                 *
	                 * Country: 1+
	                 * Water: 1+
	                 * States: 4+
	                 * City: 6+
	                 * Major POI: 8+
	                 * Neighborhood: 12+
	                 * Poi: 14+
	                 * Road: 15+
	                 */
	                var text = [];
	                if (info) {
	                    if (intersectingType) {
	                        if (intersectingType === "water" && info.water) {
	                            text.push(info.water);
	                        }
	                        else if (intersectingType === "majorPoi" && info.majorPoi) {
	                            text.push(info.majorPoi);
	                        }
	                    }
	                    if (text.length === 0) {
	                        if (info.majorPoi && cam.zoom >= 8) {
	                            text.push(info.majorPoi);
	                        }
	                        else {
	                            if (info.poi && cam.zoom >= 14) {
	                                text.push(info.poi);
	                            }
	                            else if (info.road && cam.zoom >= 15) {
	                                if (info.secondRoad) {
	                                    text.push(info.road + " & " + info.secondRoad);
	                                }
	                                else {
	                                    text.push(info.road);
	                                }
	                            }
	                            if (info.neighbourhood && cam.zoom >= 12) {
	                                text.push(info.neighbourhood);
	                            }
	                            if (info.city && cam.zoom >= 6) {
	                                text.push(info.city);
	                            }
	                        }
	                        if (info.state && cam.zoom >= 4) {
	                            text.push(info.state);
	                        }
	                        if (text.length === 0) {
	                            if (info.water) {
	                                text.push(info.water);
	                            }
	                            else if (info.country) {
	                                text.push(info.country);
	                            }
	                        }
	                        else if (text.length === 1 && info.state && cam.zoom >= 4 && info.country) {
	                            text.push(info.country);
	                        }
	                    }
	                }
	                // TODO: need to support localization for these value.
	                if (text.length > 0) {
	                    html.push("<p>Location: ", text.join(", "), ".</p>");
	                }
	                else if (restFallback && intersectingType !== "water") {
	                    // No location text found, so fallback onto REST services, but only if map not over water.
	                    _this._reverseGeocodeDescription(cam).then(function (desc) {
	                        resolve(desc);
	                    }, function () {
	                        reject("<p>Location: unknown</p>");
	                    });
	                    return;
	                }
	            }
	            if (_this._returnDetailedDescriptions) {
	                html.push("<p>Zoom: ", _precision(cam.zoom, 2), ".</p>");
	                html.push("<p>Latitude: ", _precision(cam.center[1], 5), ".</p>");
	                html.push("<p>Longitude: ", _precision(cam.center[0], 5), ".</p>");
	            }
	            resolve(html.join(""));
	        });
	    };
	    /**
	     * Uses the reverse geocoding service to determine the description for the center of the map.
	     * @param cam The map camera information.
	     */
	    MapViewDescriptor.prototype._reverseGeocodeDescription = function (cam) {
	        var _this = this;
	        return new Promise(function (resolve) {
	            var style = _this._map.getStyle();
	            _this._reverseSearch.request({
	                position: cam.center,
	                style: style
	            }).then(function (r) {
	                var info = {};
	                if (r && r.addresses && r.addresses.length > 0) {
	                    if (r.addresses[0].address) {
	                        var a = r.addresses[0].address;
	                        if (a.country) {
	                            info.country = a.country;
	                            MapViewDescriptor._labelCache.cache(info.country, {
	                                source: ["Country name"],
	                                labelType: "country",
	                                radius: 5000,
	                                minZoom: 0
	                            }, cam.center, style.language);
	                        }
	                        if (a.countrySubdivision) {
	                            info.state = a.countrySubdivision;
	                            MapViewDescriptor._labelCache.cache(info.state, {
	                                source: ["State name"],
	                                labelType: "state",
	                                radius: 5000,
	                                minZoom: 4
	                            }, cam.center, style.language);
	                        }
	                        if (a.municipality) {
	                            info.city = a.municipality;
	                            MapViewDescriptor._labelCache.cache(info.state, {
	                                source: ["Small city"],
	                                labelType: "city",
	                                radius: 1000,
	                                minZoom: 10
	                            }, cam.center, style.language);
	                        }
	                        if (a.streetNameAndNumber) {
	                            info.road = a.streetNameAndNumber;
	                        }
	                        else if (a.street) {
	                            info.road = a.street;
	                        }
	                    }
	                }
	                _this._processLocInfo(cam, null, info, true, false).then(function (desc) {
	                    resolve(desc);
	                });
	            }, function (error) {
	                _this._processLocInfo(cam, null, null, true, false).then(function (desc) {
	                    resolve(desc);
	                });
	            }).catch(function (e) {
	                _this._processLocInfo(cam, null, null, true, false).then(function (desc) {
	                    resolve(desc);
	                });
	            });
	        });
	    };
	    /** Rounds the input value to the nearest multiple of the specified increment value. */
	    MapViewDescriptor.prototype._round = function (val, increment) {
	        if (increment === void 0) { increment = 1; }
	        return Math.round(val / increment) * increment;
	    };
	    return MapViewDescriptor;
	}());

	/**
	 * @private
	 */
	var AccessibleMapDelegate = /** @class */ (function () {
	    function AccessibleMapDelegate(map) {
	        var _this = this;
	        this.addToMap = function () {
	            _this.initializeMapLiveStateInfo();
	            _this.initializeMapStyleInfo();
	            _this.createMapKeyBindingInfo();
	            _this.map.getMapContainer().setAttribute("role", "application");
	            _this.map.getMapContainer().setAttribute("aria-label", "Map Application");
	            _this.map.getCanvas().setAttribute("aria-label", "Interactive Map");
	            _this.map.getCanvas().setAttribute("aria-describedby", "atlas-map-state atlas-map-style atlas-map-shortcuts");
	            _this.map.getCanvas().setAttribute("alt", "Interactive Map");
	        };
	        this.removeFromMap = function () {
	            if (_this.mapViewDesc != null) {
	                _this.mapViewDesc.dispose();
	            }
	            delete _this.mapViewDesc;
	            if (_this.atlasMapKeyBindings != null) {
	                _this.map.getCanvasContainer().removeChild(_this.atlasMapKeyBindings);
	            }
	            delete _this.atlasMapKeyBindings;
	            if (_this.atlasMapLiveStateInfo != null) {
	                _this.map.getCanvasContainer().removeChild(_this.atlasMapLiveStateInfo);
	            }
	            delete _this.atlasMapLiveStateInfo;
	            if (_this.atlasMapStyleInfo != null) {
	                _this.map.getCanvasContainer().removeChild(_this.atlasMapStyleInfo);
	            }
	            delete _this.atlasMapStyleInfo;
	            _this.map.getMapContainer().removeAttribute("role");
	            _this.map.getMapContainer().removeAttribute("aria-label");
	            _this.map.getCanvas().removeAttribute("aria-label");
	            _this.map.getCanvas().removeAttribute("aria-describedby");
	            _this.map.getCanvas().removeAttribute("alt");
	            _this.map.events.remove("styledata", _this.updateMapStyle);
	        };
	        this.createMapKeyBindingInfo = function () {
	            _this.atlasMapKeyBindings = document.createElement("div");
	            _this.atlasMapKeyBindings.setAttribute("tabindex", "-1");
	            _this.atlasMapKeyBindings.setAttribute("aria-hidden", "true");
	            _this.atlasMapKeyBindings.id = "atlas-map-shortcuts";
	            _this.atlasMapKeyBindings.classList.add("hidden-accessible-element");
	            _this.atlasMapKeyBindings.innerHTML = [
	                "Map shortcuts:",
	                "Zoom out: hyphen.",
	                "Zoom in: plus.",
	                "Pan right 100 pixels: right arrow.",
	                "Pan left 100 pixels: left arrow.",
	                "Pan up 100 pixels: up arrow.",
	                "Pan down 100 pixels: down arrow.",
	                "Rotate 15 degrees clockwise: shift + right arrow.",
	                "Rotate 15 degrees counter clockwise: shift + left arrow.",
	                "Increase pitch 10 degrees: shift + up arrow.",
	                "Decrease pitch 10 degrees: shift + down arrow.",
	                "Toggle verbose map state: control + alt + D.",
	                "Jump focus to the map: Escape."
	            ].join("\n");
	            _this.map.getCanvasContainer().appendChild(_this.atlasMapKeyBindings);
	            _this.atlasMapKeyBindings.setAttribute("aria-live", "polite");
	        };
	        this.initializeMapLiveStateInfo = function () {
	            _this.mapViewDesc = new MapViewDescriptor(_this.map, _this.updateMapState);
	            _this.atlasMapLiveStateInfo = document.createElement("div");
	            _this.atlasMapLiveStateInfo.setAttribute("tabindex", "-1");
	            _this.atlasMapLiveStateInfo.setAttribute("aria-hidden", "true");
	            _this.atlasMapLiveStateInfo.id = "atlas-map-state";
	            _this.atlasMapLiveStateInfo.classList.add("hidden-accessible-element");
	            _this.map.getCanvasContainer().appendChild(_this.atlasMapLiveStateInfo);
	            _this.atlasMapLiveStateInfo.setAttribute("aria-live", "polite");
	        };
	        this.initializeMapStyleInfo = function () {
	            _this.atlasMapStyleInfo = document.createElement("div");
	            _this.atlasMapStyleInfo.setAttribute("tabindex", "-1");
	            _this.atlasMapStyleInfo.setAttribute("aria-hidden", "true");
	            _this.atlasMapStyleInfo.id = "atlas-map-style";
	            _this.atlasMapStyleInfo.classList.add("hidden-accessible-element");
	            _this.updateMapStyle();
	            _this.map.events.add("styledata", _this.updateMapStyle);
	            _this.map.getCanvasContainer().appendChild(_this.atlasMapStyleInfo);
	            _this.atlasMapStyleInfo.setAttribute("aria-live", "polite");
	        };
	        this.updateMapStyle = function () {
	            _this.atlasMapStyleInfo.innerHTML = "<p>Map style: " + _this.map.getStyle().style + ".</p>";
	        };
	        this.updateMapState = function (desc) {
	            _this.atlasMapLiveStateInfo.innerHTML = desc;
	        };
	        this.map = map;
	    }
	    return AccessibleMapDelegate;
	}());

	/**
	 * @private
	 */
	var FlowServiceDelegate = /** @class */ (function () {
	    function FlowServiceDelegate(map) {
	        var _this = this;
	        this.listenerEnabled = false;
	        this.lastFlowMode = "none";
	        this.addToMap = function () {
	            // Check that the map is ready first.
	            if (!_this.map._isReady()) {
	                throw new Error("Traffic flow could not be added to the map because " +
	                    "the map is not ready. Please use a ready event listener to guarantee " +
	                    "the map is ready before enabling traffic flow.");
	            }
	            // Enable the styledata listener.
	            // The flowPath may need to change if the style changes.
	            if (!_this.listenerEnabled) {
	                _this.map.events.add("styledata", _this.addToMap);
	                _this.listenerEnabled = true;
	            }
	            var trafficOptions = _this.map.getTraffic();
	            if (trafficOptions.flow !== "none") {
	                var trafficFlowComponent = _this.map.layers.getLayerById("traffic_" + trafficOptions.flow);
	                if (trafficFlowComponent) {
	                    _this.lastFlowMode = trafficOptions.flow;
	                    trafficFlowComponent._updateLayoutProperty("visibility", "visible", "none");
	                }
	            }
	        };
	        this.removeFromMap = function () {
	            var trafficOptions = _this.map.getTraffic();
	            if (_this.lastFlowMode != "none") {
	                var trafficFlowComponent = _this.map.layers.getLayerById("traffic_" + _this.lastFlowMode);
	                if (trafficFlowComponent) {
	                    trafficFlowComponent._updateLayoutProperty("visibility", "none", "visible");
	                }
	                _this.lastFlowMode = "none";
	            }
	            // Disable the styledata listener
	            if (_this.listenerEnabled) {
	                _this.map.events.remove("styledata", _this.addToMap);
	                _this.listenerEnabled = false;
	            }
	        };
	        this.map = map;
	    }
	    return FlowServiceDelegate;
	}());

	/**
	 * @private
	 */
	var Incident = /** @class */ (function (_super) {
	    __extends(Incident, _super);
	    function Incident(data, point, localizedStrings) {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
	        var _this = this;
	        var iconCategory = ((_o = (_m = (_l = (_k = (_j = (_h = (_g = (_f = (_e = (_d = (_c = (_b = (_a = data.icon_category_12) !== null && _a !== void 0 ? _a : data.icon_category_11) !== null && _b !== void 0 ? _b : data.icon_category_10) !== null && _c !== void 0 ? _c : data.icon_category_9) !== null && _d !== void 0 ? _d : data.icon_category_8) !== null && _e !== void 0 ? _e : data.icon_category_7) !== null && _f !== void 0 ? _f : data.icon_category_6) !== null && _g !== void 0 ? _g : data.icon_category_5) !== null && _h !== void 0 ? _h : data.icon_category_4) !== null && _j !== void 0 ? _j : data.icon_category_3) !== null && _k !== void 0 ? _k : data.icon_category_2) !== null && _l !== void 0 ? _l : data.icon_category_1) !== null && _m !== void 0 ? _m : data.icon_category_0) !== null && _o !== void 0 ? _o : data.icon_category);
	        var description = ((_1 = (_0 = (_z = (_y = (_x = (_w = (_v = (_u = (_t = (_s = (_r = (_q = (_p = data.description_12) !== null && _p !== void 0 ? _p : data.description_11) !== null && _q !== void 0 ? _q : data.description_10) !== null && _r !== void 0 ? _r : data.description_9) !== null && _s !== void 0 ? _s : data.description_8) !== null && _t !== void 0 ? _t : data.description_7) !== null && _u !== void 0 ? _u : data.description_6) !== null && _v !== void 0 ? _v : data.description_5) !== null && _w !== void 0 ? _w : data.description_4) !== null && _x !== void 0 ? _x : data.description_3) !== null && _y !== void 0 ? _y : data.description_2) !== null && _z !== void 0 ? _z : data.description_1) !== null && _0 !== void 0 ? _0 : data.description_0) !== null && _1 !== void 0 ? _1 : data.description);
	        var incidentPinProperties = {
	            icon: Incident.getSeverityColorName(data.magnitude) + "-" + Incident.getIncidentTypeIconName(iconCategory),
	            incidentType: Incident.getIncidentTypeName(iconCategory, localizedStrings),
	            description: description,
	            // "length", "from", and "to" properties are currently not returned by
	            // the incident tile response
	            // length: data.length,
	            // from: data.from,
	            // to: data.to,
	            delay: data.delay,
	            color: Incident.getSeverityColorHexCode(data.magnitude),
	            id: data.id
	        };
	        _this = _super.call(this, point, incidentPinProperties) || this;
	        return _this;
	    }
	    Incident.getIncidentTypeName = function (incidentCategory, localizedStrings) {
	        switch (incidentCategory) {
	            case 0:
	                return localizedStrings.Unknown;
	            case 1:
	                return localizedStrings.Accident;
	            case 2:
	                return localizedStrings.Fog;
	            case 3:
	                return localizedStrings.Danger;
	            case 4:
	                return localizedStrings.Rain;
	            case 5:
	                return localizedStrings.Ice;
	            case 6:
	                return localizedStrings.Jam;
	            case 7:
	                return localizedStrings.LaneClosed;
	            case 8:
	                return localizedStrings.RoadClosed;
	            case 9:
	                return localizedStrings.RoadWorks;
	            case 10:
	                return localizedStrings.Wind;
	            case 11:
	                return localizedStrings.Flood;
	            case 12:
	                return localizedStrings.Detour;
	            default:
	                return localizedStrings.Unknown;
	        }
	    };
	    Incident.getIncidentTypeIconName = function (incidentCategory) {
	        switch (incidentCategory) {
	            case 0:
	                return "unknown";
	            case 1:
	                return "accident";
	            case 2:
	                return "fog";
	            case 3:
	                return "danger";
	            case 4:
	                return "rain";
	            case 5:
	                return "ice";
	            case 6:
	                return "jam";
	            case 7:
	                return "lane-closed";
	            case 8:
	                return "road-closed";
	            case 9:
	                return "road-work";
	            case 10:
	                return "wind";
	            case 11:
	                return "flood";
	            case 12:
	                return "detour";
	            default:
	                return "unknown";
	        }
	    };
	    Incident.getSeverityColorName = function (severity) {
	        switch (severity) {
	            case 0:
	                return "grey";
	            case 1:
	                return "yellow";
	            case 2:
	                return "orange";
	            case 3:
	                return "red";
	            case 4:
	                return "grey";
	            default:
	                return "grey";
	        }
	    };
	    Incident.getSeverityColorHexCode = function (severity) {
	        switch (severity) {
	            case 0:
	                return "#B5B6B7";
	            case 1:
	                return "#F4C951";
	            case 2:
	                return "#F4873F";
	            case 3:
	                return "#F04F4E";
	            case 4:
	                return "#B5B6B7";
	            default:
	                return "#B5B6B7";
	        }
	    };
	    return Incident;
	}(Feature));

	/**
	 * @private
	 */
	var IncidentPopupIconName;
	(function (IncidentPopupIconName) {
	    IncidentPopupIconName["DELAY"] = "delay";
	    IncidentPopupIconName["LENGTH"] = "length";
	    IncidentPopupIconName["FROM"] = "from";
	    IncidentPopupIconName["TO"] = "to";
	})(IncidentPopupIconName || (IncidentPopupIconName = {}));
	/**
	 * @private
	 */
	var IncidentPopupFactory = /** @class */ (function () {
	    function IncidentPopupFactory() {
	    }
	    IncidentPopupFactory.build = function (incident, languageCode) {
	        if (languageCode === void 0) { languageCode = "en-US"; }
	        var titleEl = document.createElement("div");
	        titleEl.classList.add("incident-popup-title");
	        titleEl.classList.add("font-segoeui-b");
	        titleEl.setAttribute("tabindex", "0");
	        titleEl.innerText = incident.properties.incidentType;
	        titleEl.setAttribute("aria-label", "Incident Type " + incident.properties.incidentType);
	        var subtitleEl = document.createElement("div");
	        subtitleEl.classList.add("incident-popup-subtitle");
	        subtitleEl.classList.add("font-segoeui-b");
	        subtitleEl.setAttribute("aria-label", "Incident Description " + incident.properties.description);
	        subtitleEl.setAttribute("tabindex", "0");
	        subtitleEl.innerText = incident.properties.description;
	        var headerEl = document.createElement("div");
	        headerEl.classList.add("incident-popup-header");
	        headerEl.style.backgroundColor = incident.properties.color;
	        headerEl.appendChild(titleEl);
	        headerEl.appendChild(subtitleEl);
	        var bodyEl = document.createElement("div");
	        bodyEl.classList.add("incident-popup-body");
	        if (incident.properties.delay) {
	            var delay = Math.floor(incident.properties.delay / 60) + " min";
	            var delayInfoEl = this.createInfoSection(delay, IncidentPopupIconName.DELAY);
	            bodyEl.appendChild(delayInfoEl);
	        }
	        if (incident.properties.length) {
	            var i18nNumberFormat = new Intl.NumberFormat([languageCode, "en-US"], {
	                maximumFractionDigits: 2
	            });
	            // If the language code is "en-US" it will always match this case
	            // because Localizer controls the final language value.
	            var i18nLength = void 0;
	            if (languageCode === "en-US") {
	                var lengthInMiles = convertDistance(incident.properties.length, "meters", "miles");
	                i18nLength = i18nNumberFormat.format(lengthInMiles) + " miles";
	            }
	            else {
	                var lengthInKm = convertDistance(incident.properties.length, "meters", "kilometers");
	                i18nLength = i18nNumberFormat.format(lengthInKm) + " km";
	            }
	            var lengthInfoEl = this.createInfoSection(i18nLength, IncidentPopupIconName.LENGTH);
	            bodyEl.appendChild(lengthInfoEl);
	        }
	        if (incident.properties.from) {
	            var fromInfoEl = this.createInfoSection(incident.properties.from, IncidentPopupIconName.FROM);
	            bodyEl.appendChild(fromInfoEl);
	        }
	        if (incident.properties.to) {
	            var toInfoEl = this.createInfoSection(incident.properties.to, IncidentPopupIconName.TO);
	            bodyEl.appendChild(toInfoEl);
	        }
	        var incidentPopupContentEl = document.createElement("div");
	        incidentPopupContentEl.classList.add("incident-popup-content");
	        incidentPopupContentEl.appendChild(headerEl);
	        incidentPopupContentEl.appendChild(bodyEl);
	        var incidentPopup = new Popup({
	            content: incidentPopupContentEl,
	            position: incident.geometry.coordinates
	        });
	        return incidentPopup;
	    };
	    IncidentPopupFactory.createInfoSection = function (message, iconName) {
	        var infoSectionEl = document.createElement("div");
	        infoSectionEl.classList.add("incident-popup-info");
	        var iconEl = document.createElement("div");
	        iconEl.classList.add("icon");
	        iconEl.classList.add(iconName);
	        var messageEl = document.createElement("span");
	        messageEl.classList.add("message");
	        messageEl.classList.add("font-segoeui");
	        messageEl.setAttribute("aria-label", "Incident " + iconName + " " + message);
	        messageEl.setAttribute("tabindex", "0");
	        messageEl.innerText = message;
	        infoSectionEl.appendChild(iconEl);
	        infoSectionEl.appendChild(messageEl);
	        return infoSectionEl;
	    };
	    return IncidentPopupFactory;
	}());

	/**
	 * @private
	 */
	var IncidentServiceDelegate = /** @class */ (function () {
	    function IncidentServiceDelegate(map) {
	        var _this = this;
	        this.incidentLayerName = "incidents";
	        this.incidentSourceName = "mapcontrol_traffic_incident";
	        this.addToMap = function () {
	            if (!_this.map.sources.getById(_this.incidentSourceName)) {
	                _this.map.sources.add(_this.vectorTileSource);
	            }
	            if (!_this.map.layers.getLayerById(_this.incidentLayerName)) {
	                _this.map.layers.add(_this.incidentLayer, "labels");
	            }
	            //Create a popup but leave it closed so we can update it and display it later.
	            _this.popup = new Popup({
	                position: [0, 0],
	                pixelOffset: [0, -18]
	            });
	            _this.map.addEventListener("mouseover", _this.incidentLayerName, _this.cursorToPointer);
	            _this.map.addEventListener("mouseleave", _this.incidentLayerName, _this.cursorToDefault);
	            _this.map.addEventListener("click", _this.incidentLayerName, _this.openIncidentPopup);
	        };
	        this.removeFromMap = function () {
	            if (_this.map.layers.getLayerById(_this.incidentLayerName) != null) {
	                _this.map.layers.remove(_this.incidentLayerName);
	            }
	            if (_this.map.sources.getById(_this.incidentSourceName) != null) {
	                _this.map.sources.remove(_this.incidentSourceName);
	            }
	        };
	        this.cursorToPointer = function (data) {
	            _this.map.getCanvas().style.cursor = "pointer";
	        };
	        this.cursorToDefault = function (data) {
	            _this.map.getCanvas().style.cursor = "";
	        };
	        this.openIncidentPopup = function (data) {
	            _this.popup.remove();
	            var incidentPosition = data.position;
	            var incidentFeature = data.features[0];
	            _this.map._getLocalizedStrings().then(function (localizedStrings) {
	                var point = new Point(new Position(incidentPosition[0], incidentPosition[1]));
	                var incident = new Incident(incidentFeature.properties, point, localizedStrings);
	                _this.popup = IncidentPopupFactory.build(incident, _this.incidentLanguage);
	                _this.popup.open(_this.map);
	            });
	        };
	        this.map = map;
	        this.vectorTileSource = new VectorTileSource(this.incidentSourceName, {
	            maxZoom: 22,
	            tiles: [
	                "https://" + constants.domainPlaceHolder + "/traffic/incident/tile/pbf?api-version=1.0&zoom={z}&x={x}&y={y}",
	            ],
	        });
	        var imageExpression = this.getIncidentIconImageExpression();
	        this.incidentLayer = new SymbolLayer(this.incidentSourceName, this.incidentLayerName, {
	            sourceLayer: "Traffic incident POI",
	            iconOptions: {
	                ignorePlacement: true,
	                allowOverlap: true,
	                image: imageExpression,
	                size: 0.75
	            }
	        });
	    }
	    IncidentServiceDelegate.prototype.getIncidentIconImageExpression = function () {
	        // incident icon color expression
	        var iconColorExpression = [
	            "let", "magnitude", ["get", "magnitude"],
	            [
	                "case",
	                ["==", ['var', 'magnitude'], 0],
	                "grey",
	                ["==", ['var', 'magnitude'], 1],
	                "yellow",
	                ["==", ['var', 'magnitude'], 2],
	                "orange",
	                ["==", ['var', 'magnitude'], 3],
	                "red",
	                ["==", ['var', 'magnitude'], 4],
	                "grey",
	                "grey",
	            ],
	        ];
	        // incident icon type name expression
	        var incidentCategoryExpression = [
	            "coalesce",
	            ["get", "icon_category_12"],
	            ["get", "icon_category_11"],
	            ["get", "icon_category_10"],
	            ["get", "icon_category_9"],
	            ["get", "icon_category_8"],
	            ["get", "icon_category_7"],
	            ["get", "icon_category_6"],
	            ["get", "icon_category_5"],
	            ["get", "icon_category_4"],
	            ["get", "icon_category_3"],
	            ["get", "icon_category_2"],
	            ["get", "icon_category_0"],
	            ["get", "icon_category"],
	            0
	        ];
	        var incidentTypeIconNameExpression = [
	            "let", "category", incidentCategoryExpression,
	            [
	                "case",
	                ["==", ["var", "category"], 0],
	                "unknown",
	                ["==", ["var", "category"], 1],
	                "accident",
	                ["==", ["var", "category"], 2],
	                "fog",
	                ["==", ["var", "category"], 3],
	                "danger",
	                ["==", ["var", "category"], 4],
	                "rain",
	                ["==", ["var", "category"], 5],
	                "ice",
	                ["==", ["var", "category"], 6],
	                "jam",
	                ["==", ["var", "category"], 7],
	                "lane-closed",
	                ["==", ["var", "category"], 8],
	                "road-closed",
	                ["==", ["var", "category"], 9],
	                "road-work",
	                ["==", ["var", "category"], 10],
	                "wind",
	                ["==", ["var", "category"], 11],
	                "flood",
	                ["==", ["var", "category"], 12],
	                "detour",
	                "unknown"
	            ]
	        ];
	        var incidentIconNameExpression = [
	            "concat", iconColorExpression, "-", incidentTypeIconNameExpression
	        ];
	        return incidentIconNameExpression;
	    };
	    return IncidentServiceDelegate;
	}());

	/**
	 * The options for enabling/disabling user interaction with the map.
	 */
	var UserInteractionOptions = /** @class */ (function (_super) {
	    __extends(UserInteractionOptions, _super);
	    function UserInteractionOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Whether the map is interactive or static. If false, all user interaction is disabled.  If true, only selected
	         * user interactions will enabled.
	         * default `true`
	         * @default true
	         */
	        _this.interactive = true;
	        /**
	         * Whether the map should zoom on scroll input.
	         * default `true`
	         * @default true
	         */
	        _this.scrollZoomInteraction = true;
	        /**
	         * Whether the Shift + left click and drag will draw a zoom box.
	         * default `true`
	         * @default true
	         */
	        _this.boxZoomInteraction = true;
	        /**
	         * Whether right click and drag will rotate and pitch the map.
	         * default `true`
	         * @default true
	         */
	        _this.dragRotateInteraction = true;
	        /**
	         * Whether left click and drag will pan the map.
	         * default `true`
	         * @default true
	         */
	        _this.dragPanInteraction = true;
	        /**
	         * Whether the keyboard interactions are enabled.
	         * <style> .k-key { border: 1px solid grey; border-radius: 6px; background-color: #ccc; line-height: 14px;
	         * font-size: 14px; padding: 2px; } </style>
	         * <p><span class="k-key">Escape</span>: Jump focus to the map.</p>
	         * <p><span class="k-key">+/=</span>: Increase zoom level by 1.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">+/=</span>: Increase the zoom level by 2.</p>
	         * <p><span class="k-key">-</span>: Decrease zoom level by 1.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">-</span>: Decrease zoom level by 2.</p>
	         * <p><span class="k-key">⇢</span>: Pan right 100 pixels.</p>
	         * <p><span class="k-key">⇠</span>: Pan left 100 pixels.</p>
	         * <p><span class="k-key">⇡</span>: Pan up 100 pixels.</p>
	         * <p><span class="k-key">⇣</span>: Pan down 100 pixels.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇢</span>: Rotate 15 degrees clockwise.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇠</span>: Rotate 15 degrees counter-clockwise.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇡</span>: Increase pitch by 10 degrees.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇣</span>: Decrease pitch by 10 degrees.</p>
	         * default `true`
	         * @default true
	         */
	        _this.keyboardInteraction = true;
	        /**
	         * Whether double left click will zoom the map inwards.
	         * default `true`
	         * @default true
	         */
	        _this.dblClickZoomInteraction = true;
	        /**
	         * Whether touch interactions are enabled for touch devices.
	         * default `true`
	         * @default true
	         */
	        _this.touchInteraction = true;
	        /**
	         * Sets the zoom rate of the mouse wheel
	         * default `1/450`
	         * @default 1/450
	         */
	        _this.wheelZoomRate = 1 / 450;
	        return _this;
	    }
	    return UserInteractionOptions;
	}(Options));

	/** A handler that adds a shortcut for jumping focus to the top map div. */
	var FocusShortcutHandler = /** @class */ (function () {
	    function FocusShortcutHandler(map) {
	        var _this = this;
	        /** A listener for the shortcut */
	        this._onKeyDown = function (event) {
	            if (event.keyCode === 27 /* Escape */) {
	                _this.map.getCanvas().focus();
	            }
	        };
	        this.map = map;
	    }
	    /** Enables the mobile pitch gesture support. */
	    FocusShortcutHandler.prototype.enable = function () {
	        this.map.getMapContainer().addEventListener("keydown", this._onKeyDown);
	    };
	    /** Disables the mobile pitch gesture support. */
	    FocusShortcutHandler.prototype.disable = function () {
	        this.map.getMapContainer().removeEventListener("keydown", this._onKeyDown);
	    };
	    return FocusShortcutHandler;
	}());

	/** A handler that adds support for pitch gestures on mobile devices. */
	var MobilePitchHandler = /** @class */ (function () {
	    function MobilePitchHandler(map) {
	        var _this = this;
	        // Constants for mobile pitch support.
	        this.minDiffX = 70; // min x distance to recognize pitch gesture
	        this.maxDiffY = 100; // max y distance to recognize pitch gesture
	        this.minDiff = 30; // min distance to recognize zoom gesture
	        this.delay = 160; // delay for pitch, in case it's a zoom gesture
	        /** Callback for the touch start event */
	        this._onTouchStart = function (data) {
	            if (data.points.length === 2) {
	                var diffY = data.points[0].y - data.points[1].y;
	                var diffX = data.points[0].x - data.points[1].x;
	                if (Math.abs(diffX) >= _this.minDiffX && Math.abs(diffY) <= _this.maxDiffY) {
	                    data.originalEvent.preventDefault(); // prevent browser refresh on pull down
	                    _this.map._getMap().touchZoomRotate.disable(); // disable native touch controls
	                    _this.map._getMap().dragPan.disable();
	                    _this.dpPoint = data.point;
	                    _this.dpPitch = _this.map._getMap().getPitch();
	                    _this.startTiming = Date.now();
	                    _this.startDistance = Math.hypot(diffX, diffY);
	                    _this.startEventData = data;
	                }
	            }
	        };
	        /** Callback for the touch move event */
	        this._onTouchMove = function (data) {
	            if (_this.dpPoint !== undefined && _this.dpPitch !== undefined) {
	                data.preventDefault();
	                data.originalEvent.preventDefault();
	                var diffY = data.points[0].y - data.points[1].y;
	                var diffX = data.points[0].x - data.points[1].x;
	                var distance = Math.hypot(diffX, diffY);
	                if (Math.abs(distance - _this.startDistance) >= _this.minDiff) {
	                    if (_this.dpPoint) {
	                        _this.map._getMap().touchZoomRotate.enable();
	                        _this.map._getMap().dragPan.enable();
	                        _this.map._getMap().touchZoomRotate.onStart(Date.now() - _this.startTiming >= _this.delay
	                            ? data.originalEvent
	                            : _this.startEventData.originalEvent);
	                    }
	                    _this.dpPoint = undefined;
	                    return;
	                }
	                if (Date.now() - _this.startTiming >= _this.delay) {
	                    var diff = (_this.dpPoint.y - data.point.y) * 0.5;
	                    _this.map._getMap().setPitch(_this.dpPitch + diff);
	                }
	            }
	        };
	        /** Callback for the touch end event */
	        this._onTouchEnd = function () {
	            if (_this.dpPoint) {
	                _this.map._getMap().touchZoomRotate.enable();
	                _this.map._getMap().dragPan.enable();
	            }
	            _this.dpPoint = undefined;
	        };
	        /** Callback for the touch cancel event */
	        this._onTouchCancel = function () {
	            if (_this.dpPoint) {
	                _this.map._getMap().touchZoomRotate.enable();
	                _this.map._getMap().dragPan.enable();
	            }
	            _this.dpPoint = undefined;
	        };
	        this.map = map;
	    }
	    /** Enables the mobile pitch gesture support. */
	    MobilePitchHandler.prototype.enable = function () {
	        this.map._getMap().on("touchstart", this._onTouchStart);
	        this.map._getMap().on("touchmove", this._onTouchMove);
	        this.map._getMap().on("touchend", this._onTouchEnd);
	        this.map._getMap().on("touchcancel", this._onTouchCancel);
	    };
	    /** Disables the mobile pitch gesture support. */
	    MobilePitchHandler.prototype.disable = function () {
	        this.map._getMap().off("touchstart", this._onTouchStart);
	        this.map._getMap().off("touchmove", this._onTouchMove);
	        this.map._getMap().off("touchend", this._onTouchEnd);
	        this.map._getMap().off("touchcancel", this._onTouchCancel);
	    };
	    return MobilePitchHandler;
	}());

	/** A handler that adds support for pinch and zoom gestures on devices without touch events. */
	var PinchZoomHandler = /** @class */ (function () {
	    function PinchZoomHandler(map) {
	        var _this = this;
	        this._onGestureStart = function (e) {
	            if (!_this.hasTouch) {
	                e.preventDefault();
	                _this.initZoom = _this.map.getCamera().zoom;
	            }
	        };
	        this._onGestureChange = function (e) {
	            if (!_this.hasTouch) {
	                e.preventDefault();
	                _this.map.setCamera({ zoom: _this.initZoom + e.scale - 1 });
	            }
	        };
	        this._onTouchStart = function (e) {
	            _this.hasTouch = true;
	        };
	        this._onTouchEnd = function (e) {
	            if (e.touches.length === 0) {
	                _this.hasTouch = false;
	            }
	        };
	        this.map = map;
	    }
	    /** Enables the mobile pitch gesture support. */
	    PinchZoomHandler.prototype.enable = function () {
	        this.map.getCanvasContainer().addEventListener("gesturestart", this._onGestureStart);
	        this.map.getCanvasContainer().addEventListener("gesturechange", this._onGestureChange);
	        this.map.getCanvasContainer().addEventListener("touchstart", this._onTouchStart);
	        this.map.getCanvasContainer().addEventListener("touchend", this._onTouchEnd);
	    };
	    /** Disables the mobile pitch gesture support. */
	    PinchZoomHandler.prototype.disable = function () {
	        this.map.getCanvasContainer().removeEventListener("gesturestart", this._onGestureStart);
	        this.map.getCanvasContainer().removeEventListener("gesturechange", this._onGestureChange);
	        this.map.getCanvasContainer().removeEventListener("touchstart", this._onTouchStart);
	        this.map.getCanvasContainer().removeEventListener("touchend", this._onTouchEnd);
	    };
	    return PinchZoomHandler;
	}());

	/**
	 * @private
	 */
	var UserInteractionDelegate = /** @class */ (function () {
	    function UserInteractionDelegate(map, options) {
	        this.added = false;
	        this.map = map;
	        this.mobilePitch = new MobilePitchHandler(map);
	        this.focusShortcut = new FocusShortcutHandler(map);
	        this.pinchZoom = new PinchZoomHandler(map);
	        this.options = new UserInteractionOptions().merge(options);
	    }
	    UserInteractionDelegate.prototype.addToMap = function () {
	        if (!this.added) {
	            this.added = true;
	            this._setInteractions(this.options);
	        }
	    };
	    UserInteractionDelegate.prototype.removeFromMap = function () {
	        if (this.added) {
	            this.added = false;
	            this._setInteractions({ interactive: false });
	        }
	    };
	    /**
	     * Set the map control's user interaction handlers. Any options not specified will default to their current values.
	     * @param options The options for enabling/disabling the user interaction handlers.
	     */
	    UserInteractionDelegate.prototype.setOptions = function (options) {
	        this.options = new UserInteractionOptions().merge(this.options, options);
	        // Only need to actually update things if the delegate has already been added to the map
	        if (this.added) {
	            this._setInteractions(this.options);
	        }
	    };
	    /**
	     * Return the map control's current user interaction handler settings.
	     */
	    UserInteractionDelegate.prototype.getOptions = function () {
	        return Object.assign({}, this.options);
	    };
	    /** Sets the interaction config based on the specified options. */
	    UserInteractionDelegate.prototype._setInteractions = function (options) {
	        if (!options.interactive) {
	            // Disable everything
	            this.map._getMap().boxZoom.disable();
	            this.map._getMap().doubleClickZoom.disable();
	            this.map._getMap().dragPan.disable();
	            this.map._getMap().dragRotate.disable();
	            this.map._getMap().keyboard.disable();
	            this.focusShortcut.disable();
	            this.map._getMap().scrollZoom.disable();
	            this.map._getMap().touchZoomRotate.disable();
	            this.mobilePitch.disable();
	            this.pinchZoom.disable();
	        }
	        else {
	            // Box Zoom
	            if (options.boxZoomInteraction) {
	                this.map._getMap().boxZoom.enable();
	            }
	            else {
	                this.map._getMap().boxZoom.disable();
	            }
	            // Double Click Zoom
	            if (options.dblClickZoomInteraction) {
	                this.map._getMap().doubleClickZoom.enable();
	            }
	            else {
	                this.map._getMap().doubleClickZoom.disable();
	            }
	            // Drag Pan
	            if (options.dragPanInteraction) {
	                this.map._getMap().dragPan.enable();
	            }
	            else {
	                this.map._getMap().dragPan.disable();
	            }
	            // Drag Rotate
	            if (options.dragRotateInteraction) {
	                this.map._getMap().dragRotate.enable();
	            }
	            else {
	                this.map._getMap().dragRotate.disable();
	            }
	            // Keyboard
	            if (options.keyboardInteraction) {
	                this.map._getMap().keyboard.enable();
	                this.focusShortcut.enable();
	            }
	            else {
	                this.map._getMap().keyboard.disable();
	                this.focusShortcut.disable();
	            }
	            // Scroll Zoom
	            if (options.scrollZoomInteraction) {
	                this.map._getMap().scrollZoom.enable();
	                this.map._getMap().scrollZoom.setWheelZoomRate(options.wheelZoomRate);
	            }
	            else {
	                this.map._getMap().scrollZoom.disable();
	            }
	            // Touch
	            if (options.touchInteraction) {
	                this.map._getMap().touchZoomRotate.enable();
	                this.mobilePitch.enable();
	                this.pinchZoom.enable();
	            }
	            else {
	                this.map._getMap().touchZoomRotate.disable();
	                this.mobilePitch.disable();
	                this.pinchZoom.enable();
	            }
	        }
	    };
	    return UserInteractionDelegate;
	}());

	/**
	 * @module helpers
	 */
	/**
	 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
	 *
	 * @name feature
	 * @param {Geometry} geometry input geometry
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature} a GeoJSON Feature
	 * @example
	 * var geometry = {
	 *   "type": "Point",
	 *   "coordinates": [110, 50]
	 * };
	 *
	 * var feature = turf.feature(geometry);
	 *
	 * //=feature
	 */
	function feature(geom, properties, options) {
	    if (options === void 0) { options = {}; }
	    var feat = { type: "Feature" };
	    if (options.id === 0 || options.id) {
	        feat.id = options.id;
	    }
	    if (options.bbox) {
	        feat.bbox = options.bbox;
	    }
	    feat.properties = properties || {};
	    feat.geometry = geom;
	    return feat;
	}
	/**
	 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
	 *
	 * @name polygon
	 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Polygon>} Polygon Feature
	 * @example
	 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
	 *
	 * //=polygon
	 */
	function polygon(coordinates, properties, options) {
	    if (options === void 0) { options = {}; }
	    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
	        var ring = coordinates_1[_i];
	        if (ring.length < 4) {
	            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
	        }
	        for (var j = 0; j < ring[ring.length - 1].length; j++) {
	            // Check if first point of Polygon contains two numbers
	            if (ring[ring.length - 1][j] !== ring[0][j]) {
	                throw new Error("First and last Position are not equivalent.");
	            }
	        }
	    }
	    var geom = {
	        type: "Polygon",
	        coordinates: coordinates,
	    };
	    return feature(geom, properties, options);
	}
	/**
	 * Creates a {@link Feature<MultiPolygon>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPolygon
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPolygon>} a multipolygon feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
	 *
	 * //=multiPoly
	 *
	 */
	function multiPolygon(coordinates, properties, options) {
	    if (options === void 0) { options = {}; }
	    var geom = {
	        type: "MultiPolygon",
	        coordinates: coordinates,
	    };
	    return feature(geom, properties, options);
	}

	/**
	 * Get Geometry from Feature or Geometry Object
	 *
	 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
	 * @returns {Geometry|null} GeoJSON Geometry Object
	 * @throws {Error} if geojson is not a Feature or Geometry Object
	 * @example
	 * var point = {
	 *   "type": "Feature",
	 *   "properties": {},
	 *   "geometry": {
	 *     "type": "Point",
	 *     "coordinates": [110, 40]
	 *   }
	 * }
	 * var geom = turf.getGeom(point)
	 * //={"type": "Point", "coordinates": [110, 40]}
	 */
	function getGeom(geojson) {
	    if (geojson.type === "Feature") {
	        return geojson.geometry;
	    }
	    return geojson;
	}

	var polygonClipping_umd = createCommonjsModule(function (module, exports) {
	(function (global, factory) {
	   module.exports = factory() ;
	}(commonjsGlobal, (function () {
	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  function _defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  function _createClass(Constructor, protoProps, staticProps) {
	    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) _defineProperties(Constructor, staticProps);
	    return Constructor;
	  }

	  /**
	   * splaytree v3.1.0
	   * Fast Splay tree for Node and browser
	   *
	   * @author Alexander Milevski <info@w8r.name>
	   * @license MIT
	   * @preserve
	   */
	  var Node =
	  /** @class */
	  function () {
	    function Node(key, data) {
	      this.next = null;
	      this.key = key;
	      this.data = data;
	      this.left = null;
	      this.right = null;
	    }

	    return Node;
	  }();
	  /* follows "An implementation of top-down splaying"
	   * by D. Sleator <sleator@cs.cmu.edu> March 1992
	   */


	  function DEFAULT_COMPARE(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }
	  /**
	   * Simple top down splay, not requiring i to be in the tree t.
	   */


	  function splay(i, t, comparator) {
	    var N = new Node(null, null);
	    var l = N;
	    var r = N;

	    while (true) {
	      var cmp = comparator(i, t.key); //if (i < t.key) {

	      if (cmp < 0) {
	        if (t.left === null) break; //if (i < t.left.key) {

	        if (comparator(i, t.left.key) < 0) {
	          var y = t.left;
	          /* rotate right */

	          t.left = y.right;
	          y.right = t;
	          t = y;
	          if (t.left === null) break;
	        }

	        r.left = t;
	        /* link right */

	        r = t;
	        t = t.left; //} else if (i > t.key) {
	      } else if (cmp > 0) {
	        if (t.right === null) break; //if (i > t.right.key) {

	        if (comparator(i, t.right.key) > 0) {
	          var y = t.right;
	          /* rotate left */

	          t.right = y.left;
	          y.left = t;
	          t = y;
	          if (t.right === null) break;
	        }

	        l.right = t;
	        /* link left */

	        l = t;
	        t = t.right;
	      } else break;
	    }
	    /* assemble */


	    l.right = t.left;
	    r.left = t.right;
	    t.left = N.right;
	    t.right = N.left;
	    return t;
	  }

	  function insert(i, data, t, comparator) {
	    var node = new Node(i, data);

	    if (t === null) {
	      node.left = node.right = null;
	      return node;
	    }

	    t = splay(i, t, comparator);
	    var cmp = comparator(i, t.key);

	    if (cmp < 0) {
	      node.left = t.left;
	      node.right = t;
	      t.left = null;
	    } else if (cmp >= 0) {
	      node.right = t.right;
	      node.left = t;
	      t.right = null;
	    }

	    return node;
	  }

	  function split(key, v, comparator) {
	    var left = null;
	    var right = null;

	    if (v) {
	      v = splay(key, v, comparator);
	      var cmp = comparator(v.key, key);

	      if (cmp === 0) {
	        left = v.left;
	        right = v.right;
	      } else if (cmp < 0) {
	        right = v.right;
	        v.right = null;
	        left = v;
	      } else {
	        left = v.left;
	        v.left = null;
	        right = v;
	      }
	    }

	    return {
	      left: left,
	      right: right
	    };
	  }

	  function merge(left, right, comparator) {
	    if (right === null) return left;
	    if (left === null) return right;
	    right = splay(left.key, right, comparator);
	    right.left = left;
	    return right;
	  }
	  /**
	   * Prints level of the tree
	   */


	  function printRow(root, prefix, isTail, out, printNode) {
	    if (root) {
	      out("" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + "\n");
	      var indent = prefix + (isTail ? '    ' : '│   ');
	      if (root.left) printRow(root.left, indent, false, out, printNode);
	      if (root.right) printRow(root.right, indent, true, out, printNode);
	    }
	  }

	  var Tree =
	  /** @class */
	  function () {
	    function Tree(comparator) {
	      if (comparator === void 0) {
	        comparator = DEFAULT_COMPARE;
	      }

	      this._root = null;
	      this._size = 0;
	      this._comparator = comparator;
	    }
	    /**
	     * Inserts a key, allows duplicates
	     */


	    Tree.prototype.insert = function (key, data) {
	      this._size++;
	      return this._root = insert(key, data, this._root, this._comparator);
	    };
	    /**
	     * Adds a key, if it is not present in the tree
	     */


	    Tree.prototype.add = function (key, data) {
	      var node = new Node(key, data);

	      if (this._root === null) {
	        node.left = node.right = null;
	        this._size++;
	        this._root = node;
	      }

	      var comparator = this._comparator;
	      var t = splay(key, this._root, comparator);
	      var cmp = comparator(key, t.key);
	      if (cmp === 0) this._root = t;else {
	        if (cmp < 0) {
	          node.left = t.left;
	          node.right = t;
	          t.left = null;
	        } else if (cmp > 0) {
	          node.right = t.right;
	          node.left = t;
	          t.right = null;
	        }

	        this._size++;
	        this._root = node;
	      }
	      return this._root;
	    };
	    /**
	     * @param  {Key} key
	     * @return {Node|null}
	     */


	    Tree.prototype.remove = function (key) {
	      this._root = this._remove(key, this._root, this._comparator);
	    };
	    /**
	     * Deletes i from the tree if it's there
	     */


	    Tree.prototype._remove = function (i, t, comparator) {
	      var x;
	      if (t === null) return null;
	      t = splay(i, t, comparator);
	      var cmp = comparator(i, t.key);

	      if (cmp === 0) {
	        /* found it */
	        if (t.left === null) {
	          x = t.right;
	        } else {
	          x = splay(i, t.left, comparator);
	          x.right = t.right;
	        }

	        this._size--;
	        return x;
	      }

	      return t;
	      /* It wasn't there */
	    };
	    /**
	     * Removes and returns the node with smallest key
	     */


	    Tree.prototype.pop = function () {
	      var node = this._root;

	      if (node) {
	        while (node.left) {
	          node = node.left;
	        }

	        this._root = splay(node.key, this._root, this._comparator);
	        this._root = this._remove(node.key, this._root, this._comparator);
	        return {
	          key: node.key,
	          data: node.data
	        };
	      }

	      return null;
	    };
	    /**
	     * Find without splaying
	     */


	    Tree.prototype.findStatic = function (key) {
	      var current = this._root;
	      var compare = this._comparator;

	      while (current) {
	        var cmp = compare(key, current.key);
	        if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;
	      }

	      return null;
	    };

	    Tree.prototype.find = function (key) {
	      if (this._root) {
	        this._root = splay(key, this._root, this._comparator);
	        if (this._comparator(key, this._root.key) !== 0) return null;
	      }

	      return this._root;
	    };

	    Tree.prototype.contains = function (key) {
	      var current = this._root;
	      var compare = this._comparator;

	      while (current) {
	        var cmp = compare(key, current.key);
	        if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;
	      }

	      return false;
	    };

	    Tree.prototype.forEach = function (visitor, ctx) {
	      var current = this._root;
	      var Q = [];
	      /* Initialize stack s */

	      var done = false;

	      while (!done) {
	        if (current !== null) {
	          Q.push(current);
	          current = current.left;
	        } else {
	          if (Q.length !== 0) {
	            current = Q.pop();
	            visitor.call(ctx, current);
	            current = current.right;
	          } else done = true;
	        }
	      }

	      return this;
	    };
	    /**
	     * Walk key range from `low` to `high`. Stops if `fn` returns a value.
	     */


	    Tree.prototype.range = function (low, high, fn, ctx) {
	      var Q = [];
	      var compare = this._comparator;
	      var node = this._root;
	      var cmp;

	      while (Q.length !== 0 || node) {
	        if (node) {
	          Q.push(node);
	          node = node.left;
	        } else {
	          node = Q.pop();
	          cmp = compare(node.key, high);

	          if (cmp > 0) {
	            break;
	          } else if (compare(node.key, low) >= 0) {
	            if (fn.call(ctx, node)) return this; // stop if smth is returned
	          }

	          node = node.right;
	        }
	      }

	      return this;
	    };
	    /**
	     * Returns array of keys
	     */


	    Tree.prototype.keys = function () {
	      var keys = [];
	      this.forEach(function (_a) {
	        var key = _a.key;
	        return keys.push(key);
	      });
	      return keys;
	    };
	    /**
	     * Returns array of all the data in the nodes
	     */


	    Tree.prototype.values = function () {
	      var values = [];
	      this.forEach(function (_a) {
	        var data = _a.data;
	        return values.push(data);
	      });
	      return values;
	    };

	    Tree.prototype.min = function () {
	      if (this._root) return this.minNode(this._root).key;
	      return null;
	    };

	    Tree.prototype.max = function () {
	      if (this._root) return this.maxNode(this._root).key;
	      return null;
	    };

	    Tree.prototype.minNode = function (t) {
	      if (t === void 0) {
	        t = this._root;
	      }

	      if (t) while (t.left) {
	        t = t.left;
	      }
	      return t;
	    };

	    Tree.prototype.maxNode = function (t) {
	      if (t === void 0) {
	        t = this._root;
	      }

	      if (t) while (t.right) {
	        t = t.right;
	      }
	      return t;
	    };
	    /**
	     * Returns node at given index
	     */


	    Tree.prototype.at = function (index) {
	      var current = this._root;
	      var done = false;
	      var i = 0;
	      var Q = [];

	      while (!done) {
	        if (current) {
	          Q.push(current);
	          current = current.left;
	        } else {
	          if (Q.length > 0) {
	            current = Q.pop();
	            if (i === index) return current;
	            i++;
	            current = current.right;
	          } else done = true;
	        }
	      }

	      return null;
	    };

	    Tree.prototype.next = function (d) {
	      var root = this._root;
	      var successor = null;

	      if (d.right) {
	        successor = d.right;

	        while (successor.left) {
	          successor = successor.left;
	        }

	        return successor;
	      }

	      var comparator = this._comparator;

	      while (root) {
	        var cmp = comparator(d.key, root.key);
	        if (cmp === 0) break;else if (cmp < 0) {
	          successor = root;
	          root = root.left;
	        } else root = root.right;
	      }

	      return successor;
	    };

	    Tree.prototype.prev = function (d) {
	      var root = this._root;
	      var predecessor = null;

	      if (d.left !== null) {
	        predecessor = d.left;

	        while (predecessor.right) {
	          predecessor = predecessor.right;
	        }

	        return predecessor;
	      }

	      var comparator = this._comparator;

	      while (root) {
	        var cmp = comparator(d.key, root.key);
	        if (cmp === 0) break;else if (cmp < 0) root = root.left;else {
	          predecessor = root;
	          root = root.right;
	        }
	      }

	      return predecessor;
	    };

	    Tree.prototype.clear = function () {
	      this._root = null;
	      this._size = 0;
	      return this;
	    };

	    Tree.prototype.toList = function () {
	      return toList(this._root);
	    };
	    /**
	     * Bulk-load items. Both array have to be same size
	     */


	    Tree.prototype.load = function (keys, values, presort) {
	      if (values === void 0) {
	        values = [];
	      }

	      if (presort === void 0) {
	        presort = false;
	      }

	      var size = keys.length;
	      var comparator = this._comparator; // sort if needed

	      if (presort) sort(keys, values, 0, size - 1, comparator);

	      if (this._root === null) {
	        // empty tree
	        this._root = loadRecursive(keys, values, 0, size);
	        this._size = size;
	      } else {
	        // that re-builds the whole tree from two in-order traversals
	        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
	        size = this._size + size;
	        this._root = sortedListToBST({
	          head: mergedList
	        }, 0, size);
	      }

	      return this;
	    };

	    Tree.prototype.isEmpty = function () {
	      return this._root === null;
	    };

	    Object.defineProperty(Tree.prototype, "size", {
	      get: function get() {
	        return this._size;
	      },
	      enumerable: true,
	      configurable: true
	    });
	    Object.defineProperty(Tree.prototype, "root", {
	      get: function get() {
	        return this._root;
	      },
	      enumerable: true,
	      configurable: true
	    });

	    Tree.prototype.toString = function (printNode) {
	      if (printNode === void 0) {
	        printNode = function printNode(n) {
	          return String(n.key);
	        };
	      }

	      var out = [];
	      printRow(this._root, '', true, function (v) {
	        return out.push(v);
	      }, printNode);
	      return out.join('');
	    };

	    Tree.prototype.update = function (key, newKey, newData) {
	      var comparator = this._comparator;

	      var _a = split(key, this._root, comparator),
	          left = _a.left,
	          right = _a.right;

	      if (comparator(key, newKey) < 0) {
	        right = insert(newKey, newData, right, comparator);
	      } else {
	        left = insert(newKey, newData, left, comparator);
	      }

	      this._root = merge(left, right, comparator);
	    };

	    Tree.prototype.split = function (key) {
	      return split(key, this._root, this._comparator);
	    };

	    return Tree;
	  }();

	  function loadRecursive(keys, values, start, end) {
	    var size = end - start;

	    if (size > 0) {
	      var middle = start + Math.floor(size / 2);
	      var key = keys[middle];
	      var data = values[middle];
	      var node = new Node(key, data);
	      node.left = loadRecursive(keys, values, start, middle);
	      node.right = loadRecursive(keys, values, middle + 1, end);
	      return node;
	    }

	    return null;
	  }

	  function createList(keys, values) {
	    var head = new Node(null, null);
	    var p = head;

	    for (var i = 0; i < keys.length; i++) {
	      p = p.next = new Node(keys[i], values[i]);
	    }

	    p.next = null;
	    return head.next;
	  }

	  function toList(root) {
	    var current = root;
	    var Q = [];
	    var done = false;
	    var head = new Node(null, null);
	    var p = head;

	    while (!done) {
	      if (current) {
	        Q.push(current);
	        current = current.left;
	      } else {
	        if (Q.length > 0) {
	          current = p = p.next = Q.pop();
	          current = current.right;
	        } else done = true;
	      }
	    }

	    p.next = null; // that'll work even if the tree was empty

	    return head.next;
	  }

	  function sortedListToBST(list, start, end) {
	    var size = end - start;

	    if (size > 0) {
	      var middle = start + Math.floor(size / 2);
	      var left = sortedListToBST(list, start, middle);
	      var root = list.head;
	      root.left = left;
	      list.head = list.head.next;
	      root.right = sortedListToBST(list, middle + 1, end);
	      return root;
	    }

	    return null;
	  }

	  function mergeLists(l1, l2, compare) {
	    var head = new Node(null, null); // dummy

	    var p = head;
	    var p1 = l1;
	    var p2 = l2;

	    while (p1 !== null && p2 !== null) {
	      if (compare(p1.key, p2.key) < 0) {
	        p.next = p1;
	        p1 = p1.next;
	      } else {
	        p.next = p2;
	        p2 = p2.next;
	      }

	      p = p.next;
	    }

	    if (p1 !== null) {
	      p.next = p1;
	    } else if (p2 !== null) {
	      p.next = p2;
	    }

	    return head.next;
	  }

	  function sort(keys, values, left, right, compare) {
	    if (left >= right) return;
	    var pivot = keys[left + right >> 1];
	    var i = left - 1;
	    var j = right + 1;

	    while (true) {
	      do {
	        i++;
	      } while (compare(keys[i], pivot) < 0);

	      do {
	        j--;
	      } while (compare(keys[j], pivot) > 0);

	      if (i >= j) break;
	      var tmp = keys[i];
	      keys[i] = keys[j];
	      keys[j] = tmp;
	      tmp = values[i];
	      values[i] = values[j];
	      values[j] = tmp;
	    }

	    sort(keys, values, left, j, compare);
	    sort(keys, values, j + 1, right, compare);
	  }

	  /**
	   * A bounding box has the format:
	   *
	   *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }
	   *
	   */
	  var isInBbox = function isInBbox(bbox, point) {
	    return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;
	  };
	  /* Returns either null, or a bbox (aka an ordered pair of points)
	   * If there is only one point of overlap, a bbox with identical points
	   * will be returned */

	  var getBboxOverlap = function getBboxOverlap(b1, b2) {
	    // check if the bboxes overlap at all
	    if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values

	    var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
	    var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values

	    var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
	    var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap

	    return {
	      ll: {
	        x: lowerX,
	        y: lowerY
	      },
	      ur: {
	        x: upperX,
	        y: upperY
	      }
	    };
	  };

	  /* Javascript doesn't do integer math. Everything is
	   * floating point with percision Number.EPSILON.
	   *
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON
	   */
	  var epsilon = Number.EPSILON; // IE Polyfill

	  if (epsilon === undefined) epsilon = Math.pow(2, -52);
	  var EPSILON_SQ = epsilon * epsilon;
	  /* FLP comparator */

	  var cmp = function cmp(a, b) {
	    // check if they're both 0
	    if (-epsilon < a && a < epsilon) {
	      if (-epsilon < b && b < epsilon) {
	        return 0;
	      }
	    } // check if they're flp equal


	    var ab = a - b;

	    if (ab * ab < EPSILON_SQ * a * b) {
	      return 0;
	    } // normal comparison


	    return a < b ? -1 : 1;
	  };

	  /**
	   * This class rounds incoming values sufficiently so that
	   * floating points problems are, for the most part, avoided.
	   *
	   * Incoming points are have their x & y values tested against
	   * all previously seen x & y values. If either is 'too close'
	   * to a previously seen value, it's value is 'snapped' to the
	   * previously seen value.
	   *
	   * All points should be rounded by this class before being
	   * stored in any data structures in the rest of this algorithm.
	   */

	  var PtRounder = /*#__PURE__*/function () {
	    function PtRounder() {
	      _classCallCheck(this, PtRounder);

	      this.reset();
	    }

	    _createClass(PtRounder, [{
	      key: "reset",
	      value: function reset() {
	        this.xRounder = new CoordRounder();
	        this.yRounder = new CoordRounder();
	      }
	    }, {
	      key: "round",
	      value: function round(x, y) {
	        return {
	          x: this.xRounder.round(x),
	          y: this.yRounder.round(y)
	        };
	      }
	    }]);

	    return PtRounder;
	  }();

	  var CoordRounder = /*#__PURE__*/function () {
	    function CoordRounder() {
	      _classCallCheck(this, CoordRounder);

	      this.tree = new Tree(); // preseed with 0 so we don't end up with values < Number.EPSILON

	      this.round(0);
	    } // Note: this can rounds input values backwards or forwards.
	    //       You might ask, why not restrict this to just rounding
	    //       forwards? Wouldn't that allow left endpoints to always
	    //       remain left endpoints during splitting (never change to
	    //       right). No - it wouldn't, because we snap intersections
	    //       to endpoints (to establish independence from the segment
	    //       angle for t-intersections).


	    _createClass(CoordRounder, [{
	      key: "round",
	      value: function round(coord) {
	        var node = this.tree.add(coord);
	        var prevNode = this.tree.prev(node);

	        if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
	          this.tree.remove(coord);
	          return prevNode.key;
	        }

	        var nextNode = this.tree.next(node);

	        if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
	          this.tree.remove(coord);
	          return nextNode.key;
	        }

	        return coord;
	      }
	    }]);

	    return CoordRounder;
	  }(); // singleton available by import


	  var rounder = new PtRounder();

	  /* Cross Product of two vectors with first point at origin */

	  var crossProduct = function crossProduct(a, b) {
	    return a.x * b.y - a.y * b.x;
	  };
	  /* Dot Product of two vectors with first point at origin */

	  var dotProduct = function dotProduct(a, b) {
	    return a.x * b.x + a.y * b.y;
	  };
	  /* Comparator for two vectors with same starting point */

	  var compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {
	    var v1 = {
	      x: endPt1.x - basePt.x,
	      y: endPt1.y - basePt.y
	    };
	    var v2 = {
	      x: endPt2.x - basePt.x,
	      y: endPt2.y - basePt.y
	    };
	    var kross = crossProduct(v1, v2);
	    return cmp(kross, 0);
	  };
	  var length = function length(v) {
	    return Math.sqrt(dotProduct(v, v));
	  };
	  /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */

	  var sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {
	    var vBase = {
	      x: pBase.x - pShared.x,
	      y: pBase.y - pShared.y
	    };
	    var vAngle = {
	      x: pAngle.x - pShared.x,
	      y: pAngle.y - pShared.y
	    };
	    return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);
	  };
	  /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */

	  var cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {
	    var vBase = {
	      x: pBase.x - pShared.x,
	      y: pBase.y - pShared.y
	    };
	    var vAngle = {
	      x: pAngle.x - pShared.x,
	      y: pAngle.y - pShared.y
	    };
	    return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);
	  };
	  /* Get the x coordinate where the given line (defined by a point and vector)
	   * crosses the horizontal line with the given y coordiante.
	   * In the case of parrallel lines (including overlapping ones) returns null. */

	  var horizontalIntersection = function horizontalIntersection(pt, v, y) {
	    if (v.y === 0) return null;
	    return {
	      x: pt.x + v.x / v.y * (y - pt.y),
	      y: y
	    };
	  };
	  /* Get the y coordinate where the given line (defined by a point and vector)
	   * crosses the vertical line with the given x coordiante.
	   * In the case of parrallel lines (including overlapping ones) returns null. */

	  var verticalIntersection = function verticalIntersection(pt, v, x) {
	    if (v.x === 0) return null;
	    return {
	      x: x,
	      y: pt.y + v.y / v.x * (x - pt.x)
	    };
	  };
	  /* Get the intersection of two lines, each defined by a base point and a vector.
	   * In the case of parrallel lines (including overlapping ones) returns null. */

	  var intersection = function intersection(pt1, v1, pt2, v2) {
	    // take some shortcuts for vertical and horizontal lines
	    // this also ensures we don't calculate an intersection and then discover
	    // it's actually outside the bounding box of the line
	    if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);
	    if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);
	    if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);
	    if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.
	    // This algorithm is based on Schneider and Eberly.
	    // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244

	    var kross = crossProduct(v1, v2);
	    if (kross == 0) return null;
	    var ve = {
	      x: pt2.x - pt1.x,
	      y: pt2.y - pt1.y
	    };
	    var d1 = crossProduct(ve, v1) / kross;
	    var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error

	    var x1 = pt1.x + d2 * v1.x,
	        x2 = pt2.x + d1 * v2.x;
	    var y1 = pt1.y + d2 * v1.y,
	        y2 = pt2.y + d1 * v2.y;
	    var x = (x1 + x2) / 2;
	    var y = (y1 + y2) / 2;
	    return {
	      x: x,
	      y: y
	    };
	  };

	  var SweepEvent = /*#__PURE__*/function () {
	    _createClass(SweepEvent, null, [{
	      key: "compare",
	      // for ordering sweep events in the sweep event queue
	      value: function compare(a, b) {
	        // favor event with a point that the sweep line hits first
	        var ptCmp = SweepEvent.comparePoints(a.point, b.point);
	        if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed

	        if (a.point !== b.point) a.link(b); // favor right events over left

	        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints
	        // ordering of this case is the same as for their segments

	        return Segment.compare(a.segment, b.segment);
	      } // for ordering points in sweep line order

	    }, {
	      key: "comparePoints",
	      value: function comparePoints(aPt, bPt) {
	        if (aPt.x < bPt.x) return -1;
	        if (aPt.x > bPt.x) return 1;
	        if (aPt.y < bPt.y) return -1;
	        if (aPt.y > bPt.y) return 1;
	        return 0;
	      } // Warning: 'point' input will be modified and re-used (for performance)

	    }]);

	    function SweepEvent(point, isLeft) {
	      _classCallCheck(this, SweepEvent);

	      if (point.events === undefined) point.events = [this];else point.events.push(this);
	      this.point = point;
	      this.isLeft = isLeft; // this.segment, this.otherSE set by factory
	    }

	    _createClass(SweepEvent, [{
	      key: "link",
	      value: function link(other) {
	        if (other.point === this.point) {
	          throw new Error('Tried to link already linked events');
	        }

	        var otherEvents = other.point.events;

	        for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {
	          var evt = otherEvents[i];
	          this.point.events.push(evt);
	          evt.point = this.point;
	        }

	        this.checkForConsuming();
	      }
	      /* Do a pass over our linked events and check to see if any pair
	       * of segments match, and should be consumed. */

	    }, {
	      key: "checkForConsuming",
	      value: function checkForConsuming() {
	        // FIXME: The loops in this method run O(n^2) => no good.
	        //        Maintain little ordered sweep event trees?
	        //        Can we maintaining an ordering that avoids the need
	        //        for the re-sorting with getLeftmostComparator in geom-out?
	        // Compare each pair of events to see if other events also match
	        var numEvents = this.point.events.length;

	        for (var i = 0; i < numEvents; i++) {
	          var evt1 = this.point.events[i];
	          if (evt1.segment.consumedBy !== undefined) continue;

	          for (var j = i + 1; j < numEvents; j++) {
	            var evt2 = this.point.events[j];
	            if (evt2.consumedBy !== undefined) continue;
	            if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
	            evt1.segment.consume(evt2.segment);
	          }
	        }
	      }
	    }, {
	      key: "getAvailableLinkedEvents",
	      value: function getAvailableLinkedEvents() {
	        // point.events is always of length 2 or greater
	        var events = [];

	        for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {
	          var evt = this.point.events[i];

	          if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
	            events.push(evt);
	          }
	        }

	        return events;
	      }
	      /**
	       * Returns a comparator function for sorting linked events that will
	       * favor the event that will give us the smallest left-side angle.
	       * All ring construction starts as low as possible heading to the right,
	       * so by always turning left as sharp as possible we'll get polygons
	       * without uncessary loops & holes.
	       *
	       * The comparator function has a compute cache such that it avoids
	       * re-computing already-computed values.
	       */

	    }, {
	      key: "getLeftmostComparator",
	      value: function getLeftmostComparator(baseEvent) {
	        var _this = this;

	        var cache = new Map();

	        var fillCache = function fillCache(linkedEvent) {
	          var nextEvent = linkedEvent.otherSE;
	          cache.set(linkedEvent, {
	            sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),
	            cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)
	          });
	        };

	        return function (a, b) {
	          if (!cache.has(a)) fillCache(a);
	          if (!cache.has(b)) fillCache(b);

	          var _cache$get = cache.get(a),
	              asine = _cache$get.sine,
	              acosine = _cache$get.cosine;

	          var _cache$get2 = cache.get(b),
	              bsine = _cache$get2.sine,
	              bcosine = _cache$get2.cosine; // both on or above x-axis


	          if (asine >= 0 && bsine >= 0) {
	            if (acosine < bcosine) return 1;
	            if (acosine > bcosine) return -1;
	            return 0;
	          } // both below x-axis


	          if (asine < 0 && bsine < 0) {
	            if (acosine < bcosine) return -1;
	            if (acosine > bcosine) return 1;
	            return 0;
	          } // one above x-axis, one below


	          if (bsine < asine) return -1;
	          if (bsine > asine) return 1;
	          return 0;
	        };
	      }
	    }]);

	    return SweepEvent;
	  }();

	  // segments and sweep events when all else is identical

	  var segmentId = 0;

	  var Segment = /*#__PURE__*/function () {
	    _createClass(Segment, null, [{
	      key: "compare",

	      /* This compare() function is for ordering segments in the sweep
	       * line tree, and does so according to the following criteria:
	       *
	       * Consider the vertical line that lies an infinestimal step to the
	       * right of the right-more of the two left endpoints of the input
	       * segments. Imagine slowly moving a point up from negative infinity
	       * in the increasing y direction. Which of the two segments will that
	       * point intersect first? That segment comes 'before' the other one.
	       *
	       * If neither segment would be intersected by such a line, (if one
	       * or more of the segments are vertical) then the line to be considered
	       * is directly on the right-more of the two left inputs.
	       */
	      value: function compare(a, b) {
	        var alx = a.leftSE.point.x;
	        var blx = b.leftSE.point.x;
	        var arx = a.rightSE.point.x;
	        var brx = b.rightSE.point.x; // check if they're even in the same vertical plane

	        if (brx < alx) return 1;
	        if (arx < blx) return -1;
	        var aly = a.leftSE.point.y;
	        var bly = b.leftSE.point.y;
	        var ary = a.rightSE.point.y;
	        var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?

	        if (alx < blx) {
	          // are the two segments in the same horizontal plane?
	          if (bly < aly && bly < ary) return 1;
	          if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?

	          var aCmpBLeft = a.comparePoint(b.leftSE.point);
	          if (aCmpBLeft < 0) return 1;
	          if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?

	          var bCmpARight = b.comparePoint(a.rightSE.point);
	          if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more
	          // left endpoint to be first (arbitrary?)

	          return -1;
	        } // is left endpoint of segment A the right-more?


	        if (alx > blx) {
	          if (aly < bly && aly < bry) return -1;
	          if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?

	          var bCmpALeft = b.comparePoint(a.leftSE.point);
	          if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?

	          var aCmpBRight = a.comparePoint(b.rightSE.point);
	          if (aCmpBRight < 0) return 1;
	          if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more
	          // left endpoint to be first (arbitrary?)

	          return 1;
	        } // if we get here, the two left endpoints are in the same
	        // vertical plane, ie alx === blx
	        // consider the lower left-endpoint to come first


	        if (aly < bly) return -1;
	        if (aly > bly) return 1; // left endpoints are identical
	        // check for colinearity by using the left-more right endpoint
	        // is the A right endpoint more left-more?

	        if (arx < brx) {
	          var _bCmpARight = b.comparePoint(a.rightSE.point);

	          if (_bCmpARight !== 0) return _bCmpARight;
	        } // is the B right endpoint more left-more?


	        if (arx > brx) {
	          var _aCmpBRight = a.comparePoint(b.rightSE.point);

	          if (_aCmpBRight < 0) return 1;
	          if (_aCmpBRight > 0) return -1;
	        }

	        if (arx !== brx) {
	          // are these two [almost] vertical segments with opposite orientation?
	          // if so, the one with the lower right endpoint comes first
	          var ay = ary - aly;
	          var ax = arx - alx;
	          var by = bry - bly;
	          var bx = brx - blx;
	          if (ay > ax && by < bx) return 1;
	          if (ay < ax && by > bx) return -1;
	        } // we have colinear segments with matching orientation
	        // consider the one with more left-more right endpoint to be first


	        if (arx > brx) return 1;
	        if (arx < brx) return -1; // if we get here, two two right endpoints are in the same
	        // vertical plane, ie arx === brx
	        // consider the lower right-endpoint to come first

	        if (ary < bry) return -1;
	        if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential
	        // fall back on creation order as consistent tie-breaker

	        if (a.id < b.id) return -1;
	        if (a.id > b.id) return 1; // identical segment, ie a === b

	        return 0;
	      }
	      /* Warning: a reference to ringWindings input will be stored,
	       *  and possibly will be later modified */

	    }]);

	    function Segment(leftSE, rightSE, rings, windings) {
	      _classCallCheck(this, Segment);

	      this.id = ++segmentId;
	      this.leftSE = leftSE;
	      leftSE.segment = this;
	      leftSE.otherSE = rightSE;
	      this.rightSE = rightSE;
	      rightSE.segment = this;
	      rightSE.otherSE = leftSE;
	      this.rings = rings;
	      this.windings = windings; // left unset for performance, set later in algorithm
	      // this.ringOut, this.consumedBy, this.prev
	    }

	    _createClass(Segment, [{
	      key: "replaceRightSE",

	      /* When a segment is split, the rightSE is replaced with a new sweep event */
	      value: function replaceRightSE(newRightSE) {
	        this.rightSE = newRightSE;
	        this.rightSE.segment = this;
	        this.rightSE.otherSE = this.leftSE;
	        this.leftSE.otherSE = this.rightSE;
	      }
	    }, {
	      key: "bbox",
	      value: function bbox() {
	        var y1 = this.leftSE.point.y;
	        var y2 = this.rightSE.point.y;
	        return {
	          ll: {
	            x: this.leftSE.point.x,
	            y: y1 < y2 ? y1 : y2
	          },
	          ur: {
	            x: this.rightSE.point.x,
	            y: y1 > y2 ? y1 : y2
	          }
	        };
	      }
	      /* A vector from the left point to the right */

	    }, {
	      key: "vector",
	      value: function vector() {
	        return {
	          x: this.rightSE.point.x - this.leftSE.point.x,
	          y: this.rightSE.point.y - this.leftSE.point.y
	        };
	      }
	    }, {
	      key: "isAnEndpoint",
	      value: function isAnEndpoint(pt) {
	        return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
	      }
	      /* Compare this segment with a point.
	       *
	       * A point P is considered to be colinear to a segment if there
	       * exists a distance D such that if we travel along the segment
	       * from one * endpoint towards the other a distance D, we find
	       * ourselves at point P.
	       *
	       * Return value indicates:
	       *
	       *   1: point lies above the segment (to the left of vertical)
	       *   0: point is colinear to segment
	       *  -1: point lies below the segment (to the right of vertical)
	       */

	    }, {
	      key: "comparePoint",
	      value: function comparePoint(point) {
	        if (this.isAnEndpoint(point)) return 0;
	        var lPt = this.leftSE.point;
	        var rPt = this.rightSE.point;
	        var v = this.vector(); // Exactly vertical segments.

	        if (lPt.x === rPt.x) {
	          if (point.x === lPt.x) return 0;
	          return point.x < lPt.x ? 1 : -1;
	        } // Nearly vertical segments with an intersection.
	        // Check to see where a point on the line with matching Y coordinate is.


	        var yDist = (point.y - lPt.y) / v.y;
	        var xFromYDist = lPt.x + yDist * v.x;
	        if (point.x === xFromYDist) return 0; // General case.
	        // Check to see where a point on the line with matching X coordinate is.

	        var xDist = (point.x - lPt.x) / v.x;
	        var yFromXDist = lPt.y + xDist * v.y;
	        if (point.y === yFromXDist) return 0;
	        return point.y < yFromXDist ? -1 : 1;
	      }
	      /**
	       * Given another segment, returns the first non-trivial intersection
	       * between the two segments (in terms of sweep line ordering), if it exists.
	       *
	       * A 'non-trivial' intersection is one that will cause one or both of the
	       * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
	       *
	       *   * endpoint of segA with endpoint of segB --> trivial
	       *   * endpoint of segA with point along segB --> non-trivial
	       *   * endpoint of segB with point along segA --> non-trivial
	       *   * point along segA with point along segB --> non-trivial
	       *
	       * If no non-trivial intersection exists, return null
	       * Else, return null.
	       */

	    }, {
	      key: "getIntersection",
	      value: function getIntersection(other) {
	        // If bboxes don't overlap, there can't be any intersections
	        var tBbox = this.bbox();
	        var oBbox = other.bbox();
	        var bboxOverlap = getBboxOverlap(tBbox, oBbox);
	        if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.
	        // This will 'snap' intersections to endpoints if possible, and will
	        // handle cases of colinearity.

	        var tlp = this.leftSE.point;
	        var trp = this.rightSE.point;
	        var olp = other.leftSE.point;
	        var orp = other.rightSE.point; // does each endpoint touch the other segment?
	        // note that we restrict the 'touching' definition to only allow segments
	        // to touch endpoints that lie forward from where we are in the sweep line pass

	        var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
	        var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
	        var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
	        var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?

	        if (touchesThisLSE && touchesOtherLSE) {
	          // these two cases are for colinear segments with matching left
	          // endpoints, and one segment being longer than the other
	          if (touchesThisRSE && !touchesOtherRSE) return trp;
	          if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)
	          // or just on their left endpoint (one trivial intersection

	          return null;
	        } // does this left endpoint matches (other doesn't)


	        if (touchesThisLSE) {
	          // check for segments that just intersect on opposing endpoints
	          if (touchesOtherRSE) {
	            if (tlp.x === orp.x && tlp.y === orp.y) return null;
	          } // t-intersection on left endpoint


	          return tlp;
	        } // does other left endpoint matches (this doesn't)


	        if (touchesOtherLSE) {
	          // check for segments that just intersect on opposing endpoints
	          if (touchesThisRSE) {
	            if (trp.x === olp.x && trp.y === olp.y) return null;
	          } // t-intersection on left endpoint


	          return olp;
	        } // trivial intersection on right endpoints


	        if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint

	        if (touchesThisRSE) return trp;
	        if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between
	        // infinite lines laid over the segments

	        var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,
	        // they would have an endpoint intersection and that case was already handled above

	        if (pt === null) return null; // is the intersection found between the lines not on the segments?

	        if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed

	        return rounder.round(pt.x, pt.y);
	      }
	      /**
	       * Split the given segment into multiple segments on the given points.
	       *  * Each existing segment will retain its leftSE and a new rightSE will be
	       *    generated for it.
	       *  * A new segment will be generated which will adopt the original segment's
	       *    rightSE, and a new leftSE will be generated for it.
	       *  * If there are more than two points given to split on, new segments
	       *    in the middle will be generated with new leftSE and rightSE's.
	       *  * An array of the newly generated SweepEvents will be returned.
	       *
	       * Warning: input array of points is modified
	       */

	    }, {
	      key: "split",
	      value: function split(point) {
	        var newEvents = [];
	        var alreadyLinked = point.events !== undefined;
	        var newLeftSE = new SweepEvent(point, true);
	        var newRightSE = new SweepEvent(point, false);
	        var oldRightSE = this.rightSE;
	        this.replaceRightSE(newRightSE);
	        newEvents.push(newRightSE);
	        newEvents.push(newLeftSE);
	        var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,
	        // sometimes one of the resulting new segments is vertical, in which
	        // case its left and right events may need to be swapped

	        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
	          newSeg.swapEvents();
	        }

	        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
	          this.swapEvents();
	        } // in the point we just used to create new sweep events with was already
	        // linked to other events, we need to check if either of the affected
	        // segments should be consumed


	        if (alreadyLinked) {
	          newLeftSE.checkForConsuming();
	          newRightSE.checkForConsuming();
	        }

	        return newEvents;
	      }
	      /* Swap which event is left and right */

	    }, {
	      key: "swapEvents",
	      value: function swapEvents() {
	        var tmpEvt = this.rightSE;
	        this.rightSE = this.leftSE;
	        this.leftSE = tmpEvt;
	        this.leftSE.isLeft = true;
	        this.rightSE.isLeft = false;

	        for (var i = 0, iMax = this.windings.length; i < iMax; i++) {
	          this.windings[i] *= -1;
	        }
	      }
	      /* Consume another segment. We take their rings under our wing
	       * and mark them as consumed. Use for perfectly overlapping segments */

	    }, {
	      key: "consume",
	      value: function consume(other) {
	        var consumer = this;
	        var consumee = other;

	        while (consumer.consumedBy) {
	          consumer = consumer.consumedBy;
	        }

	        while (consumee.consumedBy) {
	          consumee = consumee.consumedBy;
	        }

	        var cmp = Segment.compare(consumer, consumee);
	        if (cmp === 0) return; // already consumed
	        // the winner of the consumption is the earlier segment
	        // according to sweep line ordering

	        if (cmp > 0) {
	          var tmp = consumer;
	          consumer = consumee;
	          consumee = tmp;
	        } // make sure a segment doesn't consume it's prev


	        if (consumer.prev === consumee) {
	          var _tmp = consumer;
	          consumer = consumee;
	          consumee = _tmp;
	        }

	        for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {
	          var ring = consumee.rings[i];
	          var winding = consumee.windings[i];
	          var index = consumer.rings.indexOf(ring);

	          if (index === -1) {
	            consumer.rings.push(ring);
	            consumer.windings.push(winding);
	          } else consumer.windings[index] += winding;
	        }

	        consumee.rings = null;
	        consumee.windings = null;
	        consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue

	        consumee.leftSE.consumedBy = consumer.leftSE;
	        consumee.rightSE.consumedBy = consumer.rightSE;
	      }
	      /* The first segment previous segment chain that is in the result */

	    }, {
	      key: "prevInResult",
	      value: function prevInResult() {
	        if (this._prevInResult !== undefined) return this._prevInResult;
	        if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();
	        return this._prevInResult;
	      }
	    }, {
	      key: "beforeState",
	      value: function beforeState() {
	        if (this._beforeState !== undefined) return this._beforeState;
	        if (!this.prev) this._beforeState = {
	          rings: [],
	          windings: [],
	          multiPolys: []
	        };else {
	          var seg = this.prev.consumedBy || this.prev;
	          this._beforeState = seg.afterState();
	        }
	        return this._beforeState;
	      }
	    }, {
	      key: "afterState",
	      value: function afterState() {
	        if (this._afterState !== undefined) return this._afterState;
	        var beforeState = this.beforeState();
	        this._afterState = {
	          rings: beforeState.rings.slice(0),
	          windings: beforeState.windings.slice(0),
	          multiPolys: []
	        };
	        var ringsAfter = this._afterState.rings;
	        var windingsAfter = this._afterState.windings;
	        var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter

	        for (var i = 0, iMax = this.rings.length; i < iMax; i++) {
	          var ring = this.rings[i];
	          var winding = this.windings[i];
	          var index = ringsAfter.indexOf(ring);

	          if (index === -1) {
	            ringsAfter.push(ring);
	            windingsAfter.push(winding);
	          } else windingsAfter[index] += winding;
	        } // calcualte polysAfter


	        var polysAfter = [];
	        var polysExclude = [];

	        for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {
	          if (windingsAfter[_i] === 0) continue; // non-zero rule

	          var _ring = ringsAfter[_i];
	          var poly = _ring.poly;
	          if (polysExclude.indexOf(poly) !== -1) continue;
	          if (_ring.isExterior) polysAfter.push(poly);else {
	            if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);

	            var _index = polysAfter.indexOf(_ring.poly);

	            if (_index !== -1) polysAfter.splice(_index, 1);
	          }
	        } // calculate multiPolysAfter


	        for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {
	          var mp = polysAfter[_i2].multiPoly;
	          if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
	        }

	        return this._afterState;
	      }
	      /* Is this segment part of the final result? */

	    }, {
	      key: "isInResult",
	      value: function isInResult() {
	        // if we've been consumed, we're not in the result
	        if (this.consumedBy) return false;
	        if (this._isInResult !== undefined) return this._isInResult;
	        var mpsBefore = this.beforeState().multiPolys;
	        var mpsAfter = this.afterState().multiPolys;

	        switch (operation.type) {
	          case 'union':
	            {
	              // UNION - included iff:
	              //  * On one side of us there is 0 poly interiors AND
	              //  * On the other side there is 1 or more.
	              var noBefores = mpsBefore.length === 0;
	              var noAfters = mpsAfter.length === 0;
	              this._isInResult = noBefores !== noAfters;
	              break;
	            }

	          case 'intersection':
	            {
	              // INTERSECTION - included iff:
	              //  * on one side of us all multipolys are rep. with poly interiors AND
	              //  * on the other side of us, not all multipolys are repsented
	              //    with poly interiors
	              var least;
	              var most;

	              if (mpsBefore.length < mpsAfter.length) {
	                least = mpsBefore.length;
	                most = mpsAfter.length;
	              } else {
	                least = mpsAfter.length;
	                most = mpsBefore.length;
	              }

	              this._isInResult = most === operation.numMultiPolys && least < most;
	              break;
	            }

	          case 'xor':
	            {
	              // XOR - included iff:
	              //  * the difference between the number of multipolys represented
	              //    with poly interiors on our two sides is an odd number
	              var diff = Math.abs(mpsBefore.length - mpsAfter.length);
	              this._isInResult = diff % 2 === 1;
	              break;
	            }

	          case 'difference':
	            {
	              // DIFFERENCE included iff:
	              //  * on exactly one side, we have just the subject
	              var isJustSubject = function isJustSubject(mps) {
	                return mps.length === 1 && mps[0].isSubject;
	              };

	              this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
	              break;
	            }

	          default:
	            throw new Error("Unrecognized operation type found ".concat(operation.type));
	        }

	        return this._isInResult;
	      }
	    }], [{
	      key: "fromRing",
	      value: function fromRing(pt1, pt2, ring) {
	        var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering

	        var cmpPts = SweepEvent.comparePoints(pt1, pt2);

	        if (cmpPts < 0) {
	          leftPt = pt1;
	          rightPt = pt2;
	          winding = 1;
	        } else if (cmpPts > 0) {
	          leftPt = pt2;
	          rightPt = pt1;
	          winding = -1;
	        } else throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));

	        var leftSE = new SweepEvent(leftPt, true);
	        var rightSE = new SweepEvent(rightPt, false);
	        return new Segment(leftSE, rightSE, [ring], [winding]);
	      }
	    }]);

	    return Segment;
	  }();

	  var RingIn = /*#__PURE__*/function () {
	    function RingIn(geomRing, poly, isExterior) {
	      _classCallCheck(this, RingIn);

	      if (!Array.isArray(geomRing) || geomRing.length === 0) {
	        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
	      }

	      this.poly = poly;
	      this.isExterior = isExterior;
	      this.segments = [];

	      if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {
	        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
	      }

	      var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
	      this.bbox = {
	        ll: {
	          x: firstPoint.x,
	          y: firstPoint.y
	        },
	        ur: {
	          x: firstPoint.x,
	          y: firstPoint.y
	        }
	      };
	      var prevPoint = firstPoint;

	      for (var i = 1, iMax = geomRing.length; i < iMax; i++) {
	        if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {
	          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
	        }

	        var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points

	        if (point.x === prevPoint.x && point.y === prevPoint.y) continue;
	        this.segments.push(Segment.fromRing(prevPoint, point, this));
	        if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;
	        if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;
	        if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;
	        if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;
	        prevPoint = point;
	      } // add segment from last to first if last is not the same as first


	      if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
	        this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
	      }
	    }

	    _createClass(RingIn, [{
	      key: "getSweepEvents",
	      value: function getSweepEvents() {
	        var sweepEvents = [];

	        for (var i = 0, iMax = this.segments.length; i < iMax; i++) {
	          var segment = this.segments[i];
	          sweepEvents.push(segment.leftSE);
	          sweepEvents.push(segment.rightSE);
	        }

	        return sweepEvents;
	      }
	    }]);

	    return RingIn;
	  }();
	  var PolyIn = /*#__PURE__*/function () {
	    function PolyIn(geomPoly, multiPoly) {
	      _classCallCheck(this, PolyIn);

	      if (!Array.isArray(geomPoly)) {
	        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
	      }

	      this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value

	      this.bbox = {
	        ll: {
	          x: this.exteriorRing.bbox.ll.x,
	          y: this.exteriorRing.bbox.ll.y
	        },
	        ur: {
	          x: this.exteriorRing.bbox.ur.x,
	          y: this.exteriorRing.bbox.ur.y
	        }
	      };
	      this.interiorRings = [];

	      for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {
	        var ring = new RingIn(geomPoly[i], this, false);
	        if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;
	        if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;
	        if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;
	        if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;
	        this.interiorRings.push(ring);
	      }

	      this.multiPoly = multiPoly;
	    }

	    _createClass(PolyIn, [{
	      key: "getSweepEvents",
	      value: function getSweepEvents() {
	        var sweepEvents = this.exteriorRing.getSweepEvents();

	        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
	          var ringSweepEvents = this.interiorRings[i].getSweepEvents();

	          for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
	            sweepEvents.push(ringSweepEvents[j]);
	          }
	        }

	        return sweepEvents;
	      }
	    }]);

	    return PolyIn;
	  }();
	  var MultiPolyIn = /*#__PURE__*/function () {
	    function MultiPolyIn(geom, isSubject) {
	      _classCallCheck(this, MultiPolyIn);

	      if (!Array.isArray(geom)) {
	        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
	      }

	      try {
	        // if the input looks like a polygon, convert it to a multipolygon
	        if (typeof geom[0][0][0] === 'number') geom = [geom];
	      } catch (ex) {// The input is either malformed or has empty arrays.
	        // In either case, it will be handled later on.
	      }

	      this.polys = [];
	      this.bbox = {
	        ll: {
	          x: Number.POSITIVE_INFINITY,
	          y: Number.POSITIVE_INFINITY
	        },
	        ur: {
	          x: Number.NEGATIVE_INFINITY,
	          y: Number.NEGATIVE_INFINITY
	        }
	      };

	      for (var i = 0, iMax = geom.length; i < iMax; i++) {
	        var poly = new PolyIn(geom[i], this);
	        if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;
	        if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;
	        if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;
	        if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;
	        this.polys.push(poly);
	      }

	      this.isSubject = isSubject;
	    }

	    _createClass(MultiPolyIn, [{
	      key: "getSweepEvents",
	      value: function getSweepEvents() {
	        var sweepEvents = [];

	        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
	          var polySweepEvents = this.polys[i].getSweepEvents();

	          for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
	            sweepEvents.push(polySweepEvents[j]);
	          }
	        }

	        return sweepEvents;
	      }
	    }]);

	    return MultiPolyIn;
	  }();

	  var RingOut = /*#__PURE__*/function () {
	    _createClass(RingOut, null, [{
	      key: "factory",

	      /* Given the segments from the sweep line pass, compute & return a series
	       * of closed rings from all the segments marked to be part of the result */
	      value: function factory(allSegments) {
	        var ringsOut = [];

	        for (var i = 0, iMax = allSegments.length; i < iMax; i++) {
	          var segment = allSegments[i];
	          if (!segment.isInResult() || segment.ringOut) continue;
	          var prevEvent = null;
	          var event = segment.leftSE;
	          var nextEvent = segment.rightSE;
	          var events = [event];
	          var startingPoint = event.point;
	          var intersectionLEs = [];
	          /* Walk the chain of linked events to form a closed ring */

	          while (true) {
	            prevEvent = event;
	            event = nextEvent;
	            events.push(event);
	            /* Is the ring complete? */

	            if (event.point === startingPoint) break;

	            while (true) {
	              var availableLEs = event.getAvailableLinkedEvents();
	              /* Did we hit a dead end? This shouldn't happen. Indicates some earlier
	               * part of the algorithm malfunctioned... please file a bug report. */

	              if (availableLEs.length === 0) {
	                var firstPt = events[0].point;
	                var lastPt = events[events.length - 1].point;
	                throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
	              }
	              /* Only one way to go, so cotinue on the path */


	              if (availableLEs.length === 1) {
	                nextEvent = availableLEs[0].otherSE;
	                break;
	              }
	              /* We must have an intersection. Check for a completed loop */


	              var indexLE = null;

	              for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
	                if (intersectionLEs[j].point === event.point) {
	                  indexLE = j;
	                  break;
	                }
	              }
	              /* Found a completed loop. Cut that off and make a ring */


	              if (indexLE !== null) {
	                var intersectionLE = intersectionLEs.splice(indexLE)[0];
	                var ringEvents = events.splice(intersectionLE.index);
	                ringEvents.unshift(ringEvents[0].otherSE);
	                ringsOut.push(new RingOut(ringEvents.reverse()));
	                continue;
	              }
	              /* register the intersection */


	              intersectionLEs.push({
	                index: events.length,
	                point: event.point
	              });
	              /* Choose the left-most option to continue the walk */

	              var comparator = event.getLeftmostComparator(prevEvent);
	              nextEvent = availableLEs.sort(comparator)[0].otherSE;
	              break;
	            }
	          }

	          ringsOut.push(new RingOut(events));
	        }

	        return ringsOut;
	      }
	    }]);

	    function RingOut(events) {
	      _classCallCheck(this, RingOut);

	      this.events = events;

	      for (var i = 0, iMax = events.length; i < iMax; i++) {
	        events[i].segment.ringOut = this;
	      }

	      this.poly = null;
	    }

	    _createClass(RingOut, [{
	      key: "getGeom",
	      value: function getGeom() {
	        // Remove superfluous points (ie extra points along a straight line),
	        var prevPt = this.events[0].point;
	        var points = [prevPt];

	        for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {
	          var _pt = this.events[i].point;
	          var _nextPt = this.events[i + 1].point;
	          if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;
	          points.push(_pt);
	          prevPt = _pt;
	        } // ring was all (within rounding error of angle calc) colinear points


	        if (points.length === 1) return null; // check if the starting point is necessary

	        var pt = points[0];
	        var nextPt = points[1];
	        if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();
	        points.push(points[0]);
	        var step = this.isExteriorRing() ? 1 : -1;
	        var iStart = this.isExteriorRing() ? 0 : points.length - 1;
	        var iEnd = this.isExteriorRing() ? points.length : -1;
	        var orderedPoints = [];

	        for (var _i = iStart; _i != iEnd; _i += step) {
	          orderedPoints.push([points[_i].x, points[_i].y]);
	        }

	        return orderedPoints;
	      }
	    }, {
	      key: "isExteriorRing",
	      value: function isExteriorRing() {
	        if (this._isExteriorRing === undefined) {
	          var enclosing = this.enclosingRing();
	          this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
	        }

	        return this._isExteriorRing;
	      }
	    }, {
	      key: "enclosingRing",
	      value: function enclosingRing() {
	        if (this._enclosingRing === undefined) {
	          this._enclosingRing = this._calcEnclosingRing();
	        }

	        return this._enclosingRing;
	      }
	      /* Returns the ring that encloses this one, if any */

	    }, {
	      key: "_calcEnclosingRing",
	      value: function _calcEnclosingRing() {
	        // start with the ealier sweep line event so that the prevSeg
	        // chain doesn't lead us inside of a loop of ours
	        var leftMostEvt = this.events[0];

	        for (var i = 1, iMax = this.events.length; i < iMax; i++) {
	          var evt = this.events[i];
	          if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
	        }

	        var prevSeg = leftMostEvt.segment.prevInResult();
	        var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;

	        while (true) {
	          // no segment found, thus no ring can enclose us
	          if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev
	          // segment must loop back around and enclose us

	          if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev
	          // segment must either loop around us or the ring of the prev prev
	          // seg, which would make us and the ring of the prev peers

	          if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
	            if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
	              return prevSeg.ringOut;
	            } else return prevSeg.ringOut.enclosingRing();
	          } // two segments are from the same ring, so this was a penisula
	          // of that ring. iterate downward, keep searching


	          prevSeg = prevPrevSeg.prevInResult();
	          prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
	        }
	      }
	    }]);

	    return RingOut;
	  }();
	  var PolyOut = /*#__PURE__*/function () {
	    function PolyOut(exteriorRing) {
	      _classCallCheck(this, PolyOut);

	      this.exteriorRing = exteriorRing;
	      exteriorRing.poly = this;
	      this.interiorRings = [];
	    }

	    _createClass(PolyOut, [{
	      key: "addInterior",
	      value: function addInterior(ring) {
	        this.interiorRings.push(ring);
	        ring.poly = this;
	      }
	    }, {
	      key: "getGeom",
	      value: function getGeom() {
	        var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points

	        if (geom[0] === null) return null;

	        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
	          var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points

	          if (ringGeom === null) continue;
	          geom.push(ringGeom);
	        }

	        return geom;
	      }
	    }]);

	    return PolyOut;
	  }();
	  var MultiPolyOut = /*#__PURE__*/function () {
	    function MultiPolyOut(rings) {
	      _classCallCheck(this, MultiPolyOut);

	      this.rings = rings;
	      this.polys = this._composePolys(rings);
	    }

	    _createClass(MultiPolyOut, [{
	      key: "getGeom",
	      value: function getGeom() {
	        var geom = [];

	        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
	          var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points

	          if (polyGeom === null) continue;
	          geom.push(polyGeom);
	        }

	        return geom;
	      }
	    }, {
	      key: "_composePolys",
	      value: function _composePolys(rings) {
	        var polys = [];

	        for (var i = 0, iMax = rings.length; i < iMax; i++) {
	          var ring = rings[i];
	          if (ring.poly) continue;
	          if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {
	            var enclosingRing = ring.enclosingRing();
	            if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));
	            enclosingRing.poly.addInterior(ring);
	          }
	        }

	        return polys;
	      }
	    }]);

	    return MultiPolyOut;
	  }();

	  /**
	   * NOTE:  We must be careful not to change any segments while
	   *        they are in the SplayTree. AFAIK, there's no way to tell
	   *        the tree to rebalance itself - thus before splitting
	   *        a segment that's in the tree, we remove it from the tree,
	   *        do the split, then re-insert it. (Even though splitting a
	   *        segment *shouldn't* change its correct position in the
	   *        sweep line tree, the reality is because of rounding errors,
	   *        it sometimes does.)
	   */

	  var SweepLine = /*#__PURE__*/function () {
	    function SweepLine(queue) {
	      var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;

	      _classCallCheck(this, SweepLine);

	      this.queue = queue;
	      this.tree = new Tree(comparator);
	      this.segments = [];
	    }

	    _createClass(SweepLine, [{
	      key: "process",
	      value: function process(event) {
	        var segment = event.segment;
	        var newEvents = []; // if we've already been consumed by another segment,
	        // clean up our body parts and get out

	        if (event.consumedBy) {
	          if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);
	          return newEvents;
	        }

	        var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);
	        if (!node) throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + 'in SweepLine tree. Please submit a bug report.');
	        var prevNode = node;
	        var nextNode = node;
	        var prevSeg = undefined;
	        var nextSeg = undefined; // skip consumed segments still in tree

	        while (prevSeg === undefined) {
	          prevNode = this.tree.prev(prevNode);
	          if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;
	        } // skip consumed segments still in tree


	        while (nextSeg === undefined) {
	          nextNode = this.tree.next(nextNode);
	          if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;
	        }

	        if (event.isLeft) {
	          // Check for intersections against the previous segment in the sweep line
	          var prevMySplitter = null;

	          if (prevSeg) {
	            var prevInter = prevSeg.getIntersection(segment);

	            if (prevInter !== null) {
	              if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;

	              if (!prevSeg.isAnEndpoint(prevInter)) {
	                var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);

	                for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
	                  newEvents.push(newEventsFromSplit[i]);
	                }
	              }
	            }
	          } // Check for intersections against the next segment in the sweep line


	          var nextMySplitter = null;

	          if (nextSeg) {
	            var nextInter = nextSeg.getIntersection(segment);

	            if (nextInter !== null) {
	              if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;

	              if (!nextSeg.isAnEndpoint(nextInter)) {
	                var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);

	                for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {
	                  newEvents.push(_newEventsFromSplit[_i]);
	                }
	              }
	            }
	          } // For simplicity, even if we find more than one intersection we only
	          // spilt on the 'earliest' (sweep-line style) of the intersections.
	          // The other intersection will be handled in a future process().


	          if (prevMySplitter !== null || nextMySplitter !== null) {
	            var mySplitter = null;
	            if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {
	              var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
	              mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
	            } // Rounding errors can cause changes in ordering,
	            // so remove afected segments and right sweep events before splitting

	            this.queue.remove(segment.rightSE);
	            newEvents.push(segment.rightSE);

	            var _newEventsFromSplit2 = segment.split(mySplitter);

	            for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {
	              newEvents.push(_newEventsFromSplit2[_i2]);
	            }
	          }

	          if (newEvents.length > 0) {
	            // We found some intersections, so re-do the current event to
	            // make sure sweep line ordering is totally consistent for later
	            // use with the segment 'prev' pointers
	            this.tree.remove(segment);
	            newEvents.push(event);
	          } else {
	            // done with left event
	            this.segments.push(segment);
	            segment.prev = prevSeg;
	          }
	        } else {
	          // event.isRight
	          // since we're about to be removed from the sweep line, check for
	          // intersections between our previous and next segments
	          if (prevSeg && nextSeg) {
	            var inter = prevSeg.getIntersection(nextSeg);

	            if (inter !== null) {
	              if (!prevSeg.isAnEndpoint(inter)) {
	                var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);

	                for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {
	                  newEvents.push(_newEventsFromSplit3[_i3]);
	                }
	              }

	              if (!nextSeg.isAnEndpoint(inter)) {
	                var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);

	                for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {
	                  newEvents.push(_newEventsFromSplit4[_i4]);
	                }
	              }
	            }
	          }

	          this.tree.remove(segment);
	        }

	        return newEvents;
	      }
	      /* Safely split a segment that is currently in the datastructures
	       * IE - a segment other than the one that is currently being processed. */

	    }, {
	      key: "_splitSafely",
	      value: function _splitSafely(seg, pt) {
	        // Rounding errors can cause changes in ordering,
	        // so remove afected segments and right sweep events before splitting
	        // removeNode() doesn't work, so have re-find the seg
	        // https://github.com/w8r/splay-tree/pull/5
	        this.tree.remove(seg);
	        var rightSE = seg.rightSE;
	        this.queue.remove(rightSE);
	        var newEvents = seg.split(pt);
	        newEvents.push(rightSE); // splitting can trigger consumption

	        if (seg.consumedBy === undefined) this.tree.insert(seg);
	        return newEvents;
	      }
	    }]);

	    return SweepLine;
	  }();

	  var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;
	  var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;
	  var Operation = /*#__PURE__*/function () {
	    function Operation() {
	      _classCallCheck(this, Operation);
	    }

	    _createClass(Operation, [{
	      key: "run",
	      value: function run(type, geom, moreGeoms) {
	        operation.type = type;
	        rounder.reset();
	        /* Convert inputs to MultiPoly objects */

	        var multipolys = [new MultiPolyIn(geom, true)];

	        for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {
	          multipolys.push(new MultiPolyIn(moreGeoms[i], false));
	        }

	        operation.numMultiPolys = multipolys.length;
	        /* BBox optimization for difference operation
	         * If the bbox of a multipolygon that's part of the clipping doesn't
	         * intersect the bbox of the subject at all, we can just drop that
	         * multiploygon. */

	        if (operation.type === 'difference') {
	          // in place removal
	          var subject = multipolys[0];
	          var _i = 1;

	          while (_i < multipolys.length) {
	            if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);
	          }
	        }
	        /* BBox optimization for intersection operation
	         * If we can find any pair of multipolygons whose bbox does not overlap,
	         * then the result will be empty. */


	        if (operation.type === 'intersection') {
	          // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,
	          //       it could be optimized to O(n * ln(n))
	          for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {
	            var mpA = multipolys[_i2];

	            for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {
	              if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
	            }
	          }
	        }
	        /* Put segment endpoints in a priority queue */


	        var queue = new Tree(SweepEvent.compare);

	        for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {
	          var sweepEvents = multipolys[_i3].getSweepEvents();

	          for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {
	            queue.insert(sweepEvents[_j]);

	            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
	              // prevents an infinite loop, an otherwise common manifestation of bugs
	              throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');
	            }
	          }
	        }
	        /* Pass the sweep line over those endpoints */


	        var sweepLine = new SweepLine(queue);
	        var prevQueueSize = queue.size;
	        var node = queue.pop();

	        while (node) {
	          var evt = node.key;

	          if (queue.size === prevQueueSize) {
	            // prevents an infinite loop, an otherwise common manifestation of bugs
	            var seg = evt.segment;
	            throw new Error("Unable to pop() ".concat(evt.isLeft ? 'left' : 'right', " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue. ") + 'Please file a bug report.');
	          }

	          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
	            // prevents an infinite loop, an otherwise common manifestation of bugs
	            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');
	          }

	          if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
	            // prevents an infinite loop, an otherwise common manifestation of bugs
	            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');
	          }

	          var newEvents = sweepLine.process(evt);

	          for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {
	            var _evt = newEvents[_i4];
	            if (_evt.consumedBy === undefined) queue.insert(_evt);
	          }

	          prevQueueSize = queue.size;
	          node = queue.pop();
	        } // free some memory we don't need anymore


	        rounder.reset();
	        /* Collect and compile segments we're keeping into a multipolygon */

	        var ringsOut = RingOut.factory(sweepLine.segments);
	        var result = new MultiPolyOut(ringsOut);
	        return result.getGeom();
	      }
	    }]);

	    return Operation;
	  }(); // singleton available by import

	  var operation = new Operation();

	  var union = function union(geom) {
	    for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      moreGeoms[_key - 1] = arguments[_key];
	    }

	    return operation.run('union', geom, moreGeoms);
	  };

	  var intersection$1 = function intersection(geom) {
	    for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	      moreGeoms[_key2 - 1] = arguments[_key2];
	    }

	    return operation.run('intersection', geom, moreGeoms);
	  };

	  var xor = function xor(geom) {
	    for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	      moreGeoms[_key3 - 1] = arguments[_key3];
	    }

	    return operation.run('xor', geom, moreGeoms);
	  };

	  var difference = function difference(subjectGeom) {
	    for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	      clippingGeoms[_key4 - 1] = arguments[_key4];
	    }

	    return operation.run('difference', subjectGeom, clippingGeoms);
	  };

	  var index = {
	    union: union,
	    intersection: intersection$1,
	    xor: xor,
	    difference: difference
	  };

	  return index;

	})));
	});

	/**
	 * Takes two {@link Polygon|polygon} or {@link MultiPolygon|multi-polygon} geometries and
	 * finds their polygonal intersection. If they don't intersect, returns null.
	 *
	 * @name intersect
	 * @param {Feature<Polygon | MultiPolygon>} poly1 the first polygon or multipolygon
	 * @param {Feature<Polygon | MultiPolygon>} poly2 the second polygon or multipolygon
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Object} [options.properties={}] Translate GeoJSON Properties to Feature
	 * @returns {Feature|null} returns a feature representing the area they share (either a {@link Polygon} or
	 * {@link MultiPolygon}). If they do not share any area, returns `null`.
	 * @example
	 * var poly1 = turf.polygon([[
	 *   [-122.801742, 45.48565],
	 *   [-122.801742, 45.60491],
	 *   [-122.584762, 45.60491],
	 *   [-122.584762, 45.48565],
	 *   [-122.801742, 45.48565]
	 * ]]);
	 *
	 * var poly2 = turf.polygon([[
	 *   [-122.520217, 45.535693],
	 *   [-122.64038, 45.553967],
	 *   [-122.720031, 45.526554],
	 *   [-122.669906, 45.507309],
	 *   [-122.723464, 45.446643],
	 *   [-122.532577, 45.408574],
	 *   [-122.487258, 45.477466],
	 *   [-122.520217, 45.535693]
	 * ]]);
	 *
	 * var intersection = turf.intersect(poly1, poly2);
	 *
	 * //addToMap
	 * var addToMap = [poly1, poly2, intersection];
	 */
	function intersect(poly1, poly2, options) {
	    if (options === void 0) { options = {}; }
	    var geom1 = getGeom(poly1);
	    var geom2 = getGeom(poly2);
	    var intersection = polygonClipping_umd.intersection(geom1.coordinates, geom2.coordinates);
	    if (intersection.length === 0)
	        return null;
	    if (intersection.length === 1)
	        return polygon(intersection[0], options.properties);
	    return multiPolygon(intersection, options.properties);
	}

	/**
	 * Discard invocations that take less than the specified time between output
	 * (latest invocation is made if duration has been passed and no new invocations made to decorated method)
	 * This mimics the behaviour of rxjs debounceTime: https://www.learnrxjs.io/learn-rxjs/operators/filtering/debouncetime but via decorator
	 *
	 * @param duration debounce time interval duration in milliseconds
	 */
	/**
	 * Emit first value then ignore for specified duration
	 * This mimics the behaviour of rxjs throttleTime: https://www.learnrxjs.io/learn-rxjs/operators/filtering/throttletime but via decorator
	 *
	 * @param duration throttle time interval duration in milliseconds
	 */
	var throttleTime = function (duration) { return function (target, propertyKey, descriptor) {
	    var originalMethod = descriptor.value;
	    var shouldCancel = new Map();
	    descriptor.value = function () {
	        var context = this;
	        var args = arguments;
	        var cancel = shouldCancel.get(context) || false;
	        if (!cancel) {
	            originalMethod.apply(context, args);
	            shouldCancel.set(context, true);
	            setTimeout(function () { return shouldCancel.delete(context); }, duration);
	        }
	    };
	    return descriptor;
	}; };

	var allowedAttributionTags = [
	    'DIV',
	    'SPAN',
	    'A'
	];
	var attributionRuleAttributes = [
	    'data-azure-maps-attribution-minzoom',
	    'data-azure-maps-attribution-maxzoom',
	    'data-azure-maps-attribution-geometry',
	    'data-azure-maps-attribution-tileset',
	    'data-azure-maps-attribution-order',
	    'data-azure-maps-attribution-dynamic'
	];
	var allowedAttributionAttributes = __spread([
	    'href'
	], attributionRuleAttributes);
	var AttributionRuleProxy = /** @class */ (function () {
	    function AttributionRuleProxy(element, attributionChangeCallback) {
	        var _this = this;
	        this.lastFetchState = {
	            bounds: null,
	            zoom: null
	        };
	        this.getElement = function () { return _this.element; };
	        this.element = element;
	        this.attributionChangeCallback = attributionChangeCallback;
	    }
	    /** Whether one rule equals another: this doesn't imply the equivalence in terms of attribution, while rules can be the same, the content inside might differ */
	    AttributionRuleProxy.prototype.equals = function (other) {
	        return this.stringRepresentation === other.stringRepresentation;
	    };
	    Object.defineProperty(AttributionRuleProxy.prototype, "stringRepresentation", {
	        get: function () {
	            // NOTE: order is not included here as it does not affect the attribution rule
	            return [
	                this.minZoom !== undefined ? "minzoom=" + this.minZoom : '',
	                this.maxZoom !== undefined ? "maxzoom=" + this.maxZoom : '',
	                this.geometry !== undefined ? this.element.attributes.getNamedItem('data-azure-maps-attribution-geometry').value : '',
	                this.tilesetId !== undefined ? "tilesetId=" + this.tilesetId : '',
	                this.dynamic ? "dynamic" : ''
	            ].filter(function (comp) { return comp.length > 0; }).join(';');
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /** checks whether attribution rule is used on an element: i.e: whether element contains at least one attribution property */
	    AttributionRuleProxy.applicable = function (element) {
	        return Array.from(element.attributes)
	            .map(function (attr) { return attributionRuleAttributes.includes(attr.name); })
	            .reduce(function (atLeastOneRuleAttribute, includes) { return atLeastOneRuleAttribute || includes; }, false);
	    };
	    Object.defineProperty(AttributionRuleProxy.prototype, "minZoom", {
	        /** The HTML anchor describing an attribution zone that includes minzoom and maxzoom will be scoped to that range */
	        get: function () {
	            var attr = this.element.attributes.getNamedItem('data-azure-maps-attribution-minzoom');
	            return attr && !isNaN(attr.value) ? parseInt(attr.value) : undefined;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(AttributionRuleProxy.prototype, "maxZoom", {
	        /** The HTML anchor describing an attribution zone that includes minzoom and maxzoom will be scoped to that range */
	        get: function () {
	            var attr = this.element.attributes.getNamedItem('data-azure-maps-attribution-maxzoom');
	            return attr && !isNaN(attr.value) ? parseInt(attr.value) : undefined;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(AttributionRuleProxy.prototype, "geometry", {
	        /** The HTML anchor describing an attribution zone that includes a GeoJSON geometry will be scoped to that area. */
	        get: function () {
	            var attr = this.element.attributes.getNamedItem('data-azure-maps-attribution-geometry');
	            if (attr && attr.value) {
	                try {
	                    var json = JSON.parse(attr.value);
	                    return json;
	                }
	                catch (e) {
	                    // SyntaxError
	                    return undefined;
	                }
	            }
	            else {
	                return undefined;
	            }
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(AttributionRuleProxy.prototype, "tilesetId", {
	        /** Attribution associated tilesetId, used for dynamic attribution requests */
	        get: function () {
	            var attr = this.element.attributes.getNamedItem('data-azure-maps-attribution-tileset');
	            return attr && attr.value ? attr.value : undefined;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(AttributionRuleProxy.prototype, "order", {
	        /** the position of attribution message */
	        get: function () {
	            var attr = this.element.attributes.getNamedItem('data-azure-maps-attribution-order');
	            return attr && !isNaN(attr.value) ? parseInt(attr.value) : undefined;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(AttributionRuleProxy.prototype, "dynamic", {
	        /**
	         * The HTML anchor text is ignored, instead the tilesetId will be used to call the tile metadata service to determine attribution based on the current map view.
	         * Supplants minzoom, maxzoom, and geometry attributes.
	         */
	        get: function () {
	            return this.element.attributes.getNamedItem('data-azure-maps-attribution-dynamic') !== null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(AttributionRuleProxy.prototype, "hidesElement", {
	        /** whether the underlying element is hidden */
	        get: function () {
	            return this.element.style.display == 'none';
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /** hides the underlying element */
	    AttributionRuleProxy.prototype.forceHide = function () {
	        this.element.style.display = 'none';
	    };
	    /**
	     * Checks whether the provided camera state satisfies this rule
	     *
	     * @param camera current state of map control camera: map.getCamera()
	     * @returns
	     */
	    AttributionRuleProxy.prototype.satisfied = function (camera) {
	        var satisfiesMinZoom = this.minZoom && camera.zoom ? camera.zoom >= this.minZoom : true;
	        var satisfiesMaxZoom = this.maxZoom && camera.zoom ? camera.zoom <= this.maxZoom : true;
	        var satisfiesGeometry = true;
	        if (this.geometry && camera.bounds) {
	            var geometry = {
	                type: 'Feature',
	                geometry: this.geometry,
	                properties: {}
	            };
	            var viewport = {
	                type: 'Feature',
	                geometry: {
	                    type: 'Polygon',
	                    coordinates: [[
	                            BoundingBox.getNorthWest(camera.bounds),
	                            BoundingBox.getNorthEast(camera.bounds),
	                            BoundingBox.getSouthEast(camera.bounds),
	                            BoundingBox.getSouthWest(camera.bounds),
	                            BoundingBox.getNorthWest(camera.bounds)
	                        ]]
	                },
	                properties: {}
	            };
	            satisfiesGeometry = intersect(geometry, viewport) !== null;
	        }
	        return satisfiesMinZoom && satisfiesMaxZoom && satisfiesGeometry;
	    };
	    /**
	     * Applies the rule to the underlying attribution element
	     *
	     * @param map map control
	     * @param event original event that triggered this apply call
	     * returns whether any dom modification were made
	     */
	    AttributionRuleProxy.prototype.apply = function (map, event) {
	        var _this = this;
	        if (event === void 0) { event = null; }
	        var satisfied = this.satisfied(map.getCamera());
	        var willFetch = this.dynamic && this.tilesetId;
	        var hidesElement = this.hidesElement;
	        // wait for map idle event if call was triggered from dragend / zoomend / pitchend
	        var shouldFetchOnMapIdle = event && ['dragend', 'zoomend', 'pitchend'].includes(event.type);
	        if (!satisfied && !hidesElement) {
	            this.element.style.display = 'none';
	        }
	        else if (satisfied && (hidesElement || willFetch)) {
	            if (satisfied && hidesElement) {
	                this.element.style.removeProperty('display');
	            }
	            if (willFetch) {
	                if (shouldFetchOnMapIdle) {
	                    map.events.addOnce('idle', function (event) { return _this.fetchAndApplyDynamicAttribution(map); });
	                }
	                else {
	                    this.fetchAndApplyDynamicAttribution(map);
	                }
	            }
	        }
	        return satisfied === hidesElement;
	    };
	    AttributionRuleProxy.prototype.fetchAndApplyDynamicAttribution = function (map) {
	        var _this = this;
	        var camera = map.getCamera();
	        if (this.lastFetchState && BoundingBox.containsBoundingBox(this.lastFetchState.bounds, camera.bounds) && Math.floor(this.lastFetchState.zoom) == Math.floor(camera.zoom)) {
	            // viewport is fully contained in the area used in previous attribution request, and zoom level hasn't changed, do nothing
	            return;
	        }
	        var attributionEndpointOrigin = 'https://{{azMapsDomain}}';
	        // expand the viewport bounding box and fetch attribution for a larger area, use expanded viewport to filter out subsequent calls if viewport is fully contained 
	        var expSouthWest = interpolate(camera.center, BoundingBox.getSouthWest(camera.bounds), AttributionRuleProxy.viewportBufferExpansionRatio);
	        var expNorthEast = interpolate(camera.center, BoundingBox.getNorthEast(camera.bounds), AttributionRuleProxy.viewportBufferExpansionRatio);
	        var antimeridianAdjusted = (expNorthEast[0] < expSouthWest[0])
	            // west, south, east, north
	            ? [[expSouthWest[0], expSouthWest[1], 180.0, expNorthEast[1]], [-180.0, expSouthWest[1], expNorthEast[0], expNorthEast[1]]]
	            : [[expSouthWest[0], expSouthWest[1], expNorthEast[0], expNorthEast[1]]];
	        var requests = antimeridianAdjusted.map(function (bbox) {
	            var params = new URLSearchParams({
	                'api-version': '2.1',
	                tilesetId: _this.tilesetId,
	                zoom: camera.zoom !== undefined ? "" + Math.floor(camera.zoom) : undefined,
	                bounds: bbox.join(',')
	            });
	            var attributionUrl = attributionEndpointOrigin + "/map/attribution";
	            var toReplace = { url: attributionUrl };
	            map._substituteDomainLanguageViewAndSignInRequest(attributionUrl, toReplace);
	            var targetUrl = toReplace.url + "&" + params.toString();
	            return map._sendRequest(targetUrl, 'Attribution').then(function (response) { return response.json(); });
	        });
	        Promise.all(requests).then(function (response) {
	            _this.applyAttributionResponse(response);
	            _this.lastFetchState = {
	                bounds: new BoundingBox([expSouthWest[0], expSouthWest[1], expNorthEast[0], expNorthEast[1]]),
	                zoom: camera.zoom
	            };
	        })
	            // TODO: any specific error formatting here?
	            .catch(function (error) { return console.error(error); });
	    };
	    AttributionRuleProxy.prototype.applyAttributionResponse = function (attributions) {
	        var _this = this;
	        var copyrights = attributions.map(function (resp) { return resp.copyrights || []; }).reduce(function (flat, copyrights) { return __spread(flat, copyrights); }, []);
	        if (copyrights.length == 0) {
	            // no attribution for a provided tileset/bbox/z
	            return;
	        }
	        var target = Html.parseWithFilter(copyrights.join(''), function (elem) { return true; }, function (elem) { return elem; }, 
	        // use current element as the grouping element for attribution, drop existing content
	        function () {
	            _this.element.innerHTML = '';
	            return _this.element;
	        });
	        if (target === null) {
	            // attribution was filtered out
	            console.warn('Dynamic attribution is empty after filtering');
	            return;
	        }
	        var newAttribution = typeof target === 'string'
	            ? (function () { var e = document.createElement('span'); e.innerHTML = target; return e; })()
	            : target;
	        var newRuleElement;
	        // handles multiple attributions wrapped into current element
	        if (newAttribution === this.element) {
	            // use a span element to group multiple (likely anchors)
	            // this will replace current rule element to ensure consistent behavior (we don't want to add child nodes to anchors etc)
	            var container_1 = document.createElement('span');
	            Array.from(this.element.childNodes).forEach(function (node) { return container_1.appendChild(node); });
	            newRuleElement = container_1;
	        }
	        else {
	            newRuleElement = newAttribution;
	        }
	        // reassign all rule attributes to preserve state
	        Array.from(this.element.attributes).filter(function (attrib) { return attributionRuleAttributes.includes(attrib.name); }).forEach(function (attrib) {
	            return newRuleElement.attributes.setNamedItem(attrib.cloneNode());
	        });
	        newRuleElement.style.display = this.element.style.display;
	        var parent = this.element.parentElement;
	        this.element.remove();
	        parent.append(newRuleElement);
	        this.element = newRuleElement;
	        this.attributionChangeCallback(this);
	    };
	    AttributionRuleProxy.viewportBufferExpansionRatio = 2;
	    __decorate([
	        throttleTime(1000)
	    ], AttributionRuleProxy.prototype, "fetchAndApplyDynamicAttribution", null);
	    return AttributionRuleProxy;
	}());

	// contains phrases that should be filtered out from all attribution content
	var attributionFilters = [
	    /all rights reserved/gi
	];
	var CopyrightDelegate = /** @class */ (function () {
	    function CopyrightDelegate(map, copyrightControl, options) {
	        var _this = this;
	        this.rules = [];
	        /**
	         * represents the source of truth for parsed aggregated attribution markup without any filtering, text deduplication
	         * this gets hidden/on/off mutated as rules come into play.
	         */
	        this.virtualContext = (function () {
	            var elem = document.createElement('span');
	            elem.className = 'azure-map-copyright-context';
	            return elem;
	        })();
	        /**
	         * represents the actual DOM that gets attached to the copyright control
	         * a clone of virtual context with textual nodes redacted
	         */
	        this.renderContext = this.virtualContext.cloneNode(false);
	        this.addAttributionFromSource = function (source) {
	            //FundamentalMapSources are handled on style.load
	        };
	        this.removeAttributionFromSource = function (source) {
	            //FundamentalMapSources are handled on style.load
	        };
	        this.getMapStyleSources = function () {
	            var map = _this.map._getMap();
	            return Object.entries(map.getStyle().sources).map(function (_a) {
	                var _b = __read(_a, 1), key = _b[0];
	                return map.getSource(key);
	            });
	        };
	        this.loadAttributionOnceSourcesLoaded = function () {
	            var sources = _this.getMapStyleSources();
	            Promise.all(sources.map(function (source) { return new Promise(function (resolve, reject) {
	                if ('tiles' in source) {
	                    resolve(source);
	                }
	                else {
	                    source.on('data', function sourceDataListener(event) {
	                        if (event.sourceDataType == 'metadata') {
	                            source.off('data', sourceDataListener);
	                            resolve(source);
	                        }
	                    });
	                    source.on('error', function tilejsonLoadError(event) {
	                        source.off('error', tilejsonLoadError);
	                        reject(event);
	                    });
	                }
	            })
	                // mimics https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled 
	                // until wider availability (https://caniuse.com/?search=allSettled)
	                .then(function (source) { return ({ status: 'fulfilled', value: source }); })
	                .catch(function (error) { return ({ status: 'rejected', reason: error }); }); })).then(function (loadResults) {
	                // reload attribution no matter tilejson loaded gracefully or errored
	                _this.reloadAttribution();
	            });
	        };
	        this.reloadAttribution = function () {
	            var sources = _this.getMapStyleSources();
	            // keep track of all rules as well as registered to determine redundant rules that won't get applied.
	            // a rule is considered redundant when it is has same rule attributes(excluding order) as well as endpoints
	            // a rule with the minimum order will be picked 
	            var allRules = new Set();
	            var registeredRules = {};
	            var attributions = Object.values(sources)
	                // also ignore sources that don't specify tile endpoints
	                .filter(function (source) { return 'attribution' in source && source.attribution && 'tiles' in source && source.tiles.length > 0; })
	                // map(a => a) with narrowing types based on above filter to make typescript happy
	                .map(function (source) { return source; })
	                .map(function (_a) {
	                var attribution = _a.attribution;
	                return Html.parseWithFilter(attribution, function (elem) { return allowedAttributionTags.includes(elem.tagName)
	                    && Array.from(elem.attributes).map(function (attr) { return allowedAttributionAttributes.includes(attr.name); }).reduce(function (allAllowed, inclAllowed) { return allAllowed && inclAllowed; }, true); }, function (elem) {
	                    // effect: register rules for elements with at least one rule attribute 
	                    // and add flexbox order attribute if order is set
	                    var rule = null;
	                    if (elem instanceof HTMLElement && AttributionRuleProxy.applicable(elem)) {
	                        // NOTE: the first tile endpoint will be used to derive the base url for dynamic attribution requests
	                        rule = new AttributionRuleProxy(elem, function () { return _this.renderAttribution(); });
	                        allRules.add(rule);
	                        if (rule.order !== undefined) {
	                            elem.style.order = "" + rule.order;
	                        }
	                    }
	                    if (rule && elem instanceof HTMLElement) {
	                        var ruleKey = rule.stringRepresentation;
	                        if (!(ruleKey in registeredRules)) {
	                            registeredRules[ruleKey] = rule;
	                            // equivalent rules: prefer the lowest order rule
	                        }
	                        else if ((rule.order !== undefined && registeredRules[ruleKey].order !== undefined && rule.order < registeredRules[ruleKey].order ||
	                            rule.order !== undefined && registeredRules[ruleKey].order === undefined)) {
	                            registeredRules[ruleKey] = rule;
	                        }
	                    }
	                    return elem;
	                }, function () { return document.createElement('span'); });
	            });
	            var registeredRuleSet = new Set(Object.values(registeredRules));
	            var redundantRules = new Set(__spread(allRules).filter(function (rule) { return !registeredRuleSet.has(rule); }));
	            var redundantElements = new Set(__spread(redundantRules).map(function (rule) { return rule.getElement(); }));
	            // eject redundant rules associated elements altogether
	            __spread(redundantElements).filter(function (elem) { return elem.parentElement !== null; })
	                .forEach(function (elem) { return elem.parentElement.removeChild(elem); });
	            _this.rules = Object.values(registeredRules);
	            var attributionsToApply = attributions
	                .filter(function (attribution) { return typeof attribution === 'string' || !redundantElements.has(attribution); })
	                .map(function (attribution) { return typeof (attribution) === 'string' ? new Text(attribution) : attribution; });
	            var virtualContext = document.createElement('span');
	            if (attributionsToApply.length > 0) {
	                attributionsToApply.forEach(function (attribution) { return virtualContext.appendChild(attribution); });
	            }
	            else {
	                _this.getDefaultAttribution().forEach(function (attribution) { return virtualContext.appendChild(attribution); });
	            }
	            _this.virtualContext = virtualContext;
	            _this.copyrightControl.setOptions({
	                copyrightContent: _this.renderContext
	            });
	            _this.applyRules();
	            _this.renderAttribution();
	        };
	        this.applyRules = function (mapEvent) {
	            if (mapEvent === void 0) { mapEvent = null; }
	            var hasDOMChanges = _this.rules.reduce(function (hasDomChanges, rule) {
	                var ruleChangedDOM = rule.apply(_this.map, mapEvent);
	                return hasDomChanges || ruleChangedDOM;
	            }, false);
	            if (hasDOMChanges)
	                (_this.renderAttribution());
	        };
	        /**
	         * clones virtual context, reduces textual nodes for visual purposes (dedups years, common phrases) and sets the actual rendered context
	         */
	        this.renderAttribution = function () {
	            var visibleTextNodes = function (elem) {
	                return Array.from(elem.style.display != 'none' ? elem.children : [])
	                    .map(function (elem) { return visibleTextNodes(elem); })
	                    .reduce(function (flattened, nodes) { return __spread(flattened, nodes); }, Array.from(elem.style.display != 'none' ? elem.childNodes : []).filter(function (node) { return node.nodeType == node.TEXT_NODE; }));
	            };
	            var newRenderContext = _this.virtualContext.cloneNode(true);
	            var visibleNodes = visibleTextNodes(newRenderContext);
	            // Do not extract years for now
	            // Just deduplicate full matches
	            //
	            // const years = new Set<number>();
	            // visibleNodes.forEach(node => { 
	            //     let match: RegExpExecArray | null = null
	            //     while((match = copyrightYearPattern.exec(node.textContent)) != null){
	            //         years.add(parseInt(match[1])) 
	            //     }
	            // });
	            // strip all predefined keywords 
	            visibleNodes.forEach(function (node) { return node.textContent = __spread(attributionFilters).reduce(function (target, filter) { return target.replace(filter, '').trim(); }, node.textContent); });
	            // strip year from each node
	            // visibleNodes.forEach(node => node.textContent = node.textContent.replace(copyrightYearPattern, '').trim());
	            // deduplicate attribution text
	            visibleNodes.reduce(function (attributions, node) {
	                if (attributions.has(node.textContent)) {
	                    node.textContent = '';
	                    if (node.parentElement) {
	                        node.parentElement.removeChild(node);
	                    }
	                }
	                else {
	                    attributions.add(node.textContent);
	                }
	                return attributions;
	            }, new Set());
	            _this.renderContext.innerHTML = '';
	            // don't use this.renderContext.innerHTML = newRenderContext.innerHTML
	            // as original dom structure might be changed
	            Array.from(newRenderContext.childNodes).forEach(function (node) { return _this.renderContext.appendChild(node); });
	            // add years text node as the first text node in render context 
	            // to make sure flexbox order has no effect on where copyright years will appear
	            // if(years.size > 0){
	            //     const yearsNode = new Text(`©${[...years].sort((lhs, rhs) => lhs - rhs).join(',')}`);
	            //     if(this.renderContext.children.length > 0){
	            //         this.renderContext.insertBefore(yearsNode, this.renderContext.children[0])
	            //     } else {
	            //         this.renderContext.appendChild(yearsNode);
	            //     }
	            // }
	        };
	        this.map = map;
	        this.copyrightControl = copyrightControl;
	        this.options = options;
	    }
	    CopyrightDelegate.prototype.addToMap = function () {
	        this.map.events.add('stylechanged', this.loadAttributionOnceSourcesLoaded);
	        // this.map.events.add('sourceadded', this.addAttributionFromSource);
	        // this.map.events.add('sourceremoved', this.removeAttributionFromSource);
	        this.map.events.add('dragend', this.applyRules);
	        this.map.events.add('zoomend', this.applyRules);
	        this.map.events.add('pitchend', this.applyRules);
	    };
	    CopyrightDelegate.prototype.removeFromMap = function () {
	        this.map.events.remove('stylechanged', this.loadAttributionOnceSourcesLoaded);
	        // this.map.events.remove('sourceadded', this.addAttributionFromSource);
	        // this.map.events.remove('sourceremoved', this.removeAttributionFromSource);
	        this.map.events.remove('dragend', this.applyRules);
	        this.map.events.remove('zoomend', this.applyRules);
	        this.map.events.remove('pitchend', this.applyRules);
	    };
	    /**
	     * Gets the default fallback copyright caption
	     */
	    CopyrightDelegate.prototype.getDefaultAttribution = function () {
	        var anchor = function (content) {
	            var elem = document.createElement('a');
	            elem.textContent = content;
	            return elem;
	        };
	        return this.copyrightControl.getDefaultAttributions().map(function (copyright) { return anchor(copyright); });
	    };
	    return CopyrightDelegate;
	}());

	var adal = createCommonjsModule(function (module) {
	//----------------------------------------------------------------------
	// AdalJS v1.0.18
	// @preserve Copyright (c) Microsoft Open Technologies, Inc.
	// All Rights Reserved
	// Apache License 2.0
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//id
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//----------------------------------------------------------------------

	var AuthenticationContext = (function () {

	    /**
	     * Configuration options for Authentication Context.
	     * @class config
	     *  @property {string} tenant - Your target tenant.
	     *  @property {string} clientId - Client ID assigned to your app by Azure Active Directory.
	     *  @property {string} redirectUri - Endpoint at which you expect to receive tokens.Defaults to `window.location.href`.
	     *  @property {string} instance - Azure Active Directory Instance.Defaults to `https://login.microsoftonline.com/`.
	     *  @property {Array} endpoints - Collection of {Endpoint-ResourceId} used for automatically attaching tokens in webApi calls.
	     *  @property {Boolean} popUp - Set this to true to enable login in a popup winodow instead of a full redirect.Defaults to `false`.
	     *  @property {string} localLoginUrl - Set this to redirect the user to a custom login page.
	     *  @property {function} displayCall - User defined function of handling the navigation to Azure AD authorization endpoint in case of login. Defaults to 'null'.
	     *  @property {string} postLogoutRedirectUri - Redirects the user to postLogoutRedirectUri after logout. Defaults is 'redirectUri'.
	     *  @property {string} cacheLocation - Sets browser storage to either 'localStorage' or sessionStorage'. Defaults to 'sessionStorage'.
	     *  @property {Array.<string>} anonymousEndpoints Array of keywords or URI's. Adal will not attach a token to outgoing requests that have these keywords or uri. Defaults to 'null'.
	     *  @property {number} expireOffsetSeconds If the cached token is about to be expired in the expireOffsetSeconds (in seconds), Adal will renew the token instead of using the cached token. Defaults to 300 seconds.
	     *  @property {string} correlationId Unique identifier used to map the request with the response. Defaults to RFC4122 version 4 guid (128 bits).
	     *  @property {number} loadFrameTimeout The number of milliseconds of inactivity before a token renewal response from AAD should be considered timed out.
	     */

	    /**
	     * Creates a new AuthenticationContext object.
	     * @constructor
	     * @param {config}  config               Configuration options for AuthenticationContext
	     */

	    AuthenticationContext = function (config) {
	        /**
	         * Enum for request type
	         * @enum {string}
	         */
	        this.REQUEST_TYPE = {
	            LOGIN: 'LOGIN',
	            RENEW_TOKEN: 'RENEW_TOKEN',
	            UNKNOWN: 'UNKNOWN'
	        };

	        this.RESPONSE_TYPE = {
	            ID_TOKEN_TOKEN: 'id_token token',
	            TOKEN: 'token'
	        };

	        /**
	         * Enum for storage constants
	         * @enum {string}
	         */
	        this.CONSTANTS = {
	            ACCESS_TOKEN: 'access_token',
	            EXPIRES_IN: 'expires_in',
	            ID_TOKEN: 'id_token',
	            ERROR_DESCRIPTION: 'error_description',
	            SESSION_STATE: 'session_state',
	            ERROR: 'error',
	            STORAGE: {
	                TOKEN_KEYS: 'adal.token.keys',
	                ACCESS_TOKEN_KEY: 'adal.access.token.key',
	                EXPIRATION_KEY: 'adal.expiration.key',
	                STATE_LOGIN: 'adal.state.login',
	                STATE_RENEW: 'adal.state.renew',
	                NONCE_IDTOKEN: 'adal.nonce.idtoken',
	                SESSION_STATE: 'adal.session.state',
	                USERNAME: 'adal.username',
	                IDTOKEN: 'adal.idtoken',
	                ERROR: 'adal.error',
	                ERROR_DESCRIPTION: 'adal.error.description',
	                LOGIN_REQUEST: 'adal.login.request',
	                LOGIN_ERROR: 'adal.login.error',
	                RENEW_STATUS: 'adal.token.renew.status',
	                ANGULAR_LOGIN_REQUEST: 'adal.angular.login.request'
	            },
	            RESOURCE_DELIMETER: '|',
	            CACHE_DELIMETER: '||',
	            LOADFRAME_TIMEOUT: 6000,
	            TOKEN_RENEW_STATUS_CANCELED: 'Canceled',
	            TOKEN_RENEW_STATUS_COMPLETED: 'Completed',
	            TOKEN_RENEW_STATUS_IN_PROGRESS: 'In Progress',
	            LOGGING_LEVEL: {
	                ERROR: 0,
	                WARN: 1,
	                INFO: 2,
	                VERBOSE: 3
	            },
	            LEVEL_STRING_MAP: {
	                0: 'ERROR:',
	                1: 'WARNING:',
	                2: 'INFO:',
	                3: 'VERBOSE:'
	            },
	            POPUP_WIDTH: 483,
	            POPUP_HEIGHT: 600
	        };

	        if (AuthenticationContext.prototype._singletonInstance) {
	            return AuthenticationContext.prototype._singletonInstance;
	        }
	        AuthenticationContext.prototype._singletonInstance = this;

	        // public
	        this.instance = 'https://login.microsoftonline.com/';
	        this.config = {};
	        this.callback = null;
	        this.popUp = false;
	        this.isAngular = false;

	        // private
	        this._user = null;
	        this._activeRenewals = {};
	        this._loginInProgress = false;
	        this._acquireTokenInProgress = false;
	        this._renewStates = [];
	        this._callBackMappedToRenewStates = {};
	        this._callBacksMappedToRenewStates = {};
	        this._openedWindows = [];
	        this._requestType = this.REQUEST_TYPE.LOGIN;
	        window._adalInstance = this;

	        // validate before constructor assignments
	        if (config.displayCall && typeof config.displayCall !== 'function') {
	            throw new Error('displayCall is not a function');
	        }

	        if (!config.clientId) {
	            throw new Error('clientId is required');
	        }

	        this.config = this._cloneConfig(config);

	        if (this.config.navigateToLoginRequestUrl === undefined)
	            this.config.navigateToLoginRequestUrl = true;

	        if (this.config.popUp)
	            this.popUp = true;

	        if (this.config.callback && typeof this.config.callback === 'function')
	            this.callback = this.config.callback;

	        if (this.config.instance) {
	            this.instance = this.config.instance;
	        }

	        // App can request idtoken for itself using clientid as resource
	        if (!this.config.loginResource) {
	            this.config.loginResource = this.config.clientId;
	        }

	        // redirect and logout_redirect are set to current location by default
	        if (!this.config.redirectUri) {
	            // strip off query parameters or hashes from the redirect uri as AAD does not allow those.
	            this.config.redirectUri = window.location.href.split("?")[0].split("#")[0];
	        }

	        if (!this.config.postLogoutRedirectUri) {
	            // strip off query parameters or hashes from the post logout redirect uri as AAD does not allow those.
	            this.config.postLogoutRedirectUri = window.location.href.split("?")[0].split("#")[0];
	        }

	        if (!this.config.anonymousEndpoints) {
	            this.config.anonymousEndpoints = [];
	        }

	        if (this.config.isAngular) {
	            this.isAngular = this.config.isAngular;
	        }

	        if (this.config.loadFrameTimeout) {
	            this.CONSTANTS.LOADFRAME_TIMEOUT = this.config.loadFrameTimeout;
	        }
	    };

	    if (typeof window !== 'undefined') {
	        window.Logging = {
	            piiLoggingEnabled: false,
	            level: 0,
	            log: function (message) { }
	        };
	    }

	    /**
	     * Initiates the login process by redirecting the user to Azure AD authorization endpoint.
	     */
	    AuthenticationContext.prototype.login = function () {
	        if (this._loginInProgress) {
	            this.info("Login in progress");
	            return;
	        }

	        this._loginInProgress = true;

	        // Token is not present and user needs to login
	        var expectedState = this._guid();
	        this.config.state = expectedState;
	        this._idTokenNonce = this._guid();
	        var loginStartPage = this._getItem(this.CONSTANTS.STORAGE.ANGULAR_LOGIN_REQUEST);

	        if (!loginStartPage || loginStartPage === "") {
	            loginStartPage = window.location.href;
	        }
	        else {
	            this._saveItem(this.CONSTANTS.STORAGE.ANGULAR_LOGIN_REQUEST, "");
	        }

	        this.verbose('Expected state: ' + expectedState + ' startPage:' + loginStartPage);
	        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, loginStartPage);
	        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');
	        this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, expectedState, true);
	        this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce, true);
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');
	        var urlNavigate = this._getNavigateUrl('id_token', null) + '&nonce=' + encodeURIComponent(this._idTokenNonce);

	        if (this.config.displayCall) {
	            // User defined way of handling the navigation
	            this.config.displayCall(urlNavigate);
	        }
	        else if (this.popUp) {
	            this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, '');// so requestInfo does not match redirect case
	            this._renewStates.push(expectedState);
	            this.registerCallback(expectedState, this.config.clientId, this.callback);
	            this._loginPopup(urlNavigate);
	        }
	        else {
	            this.promptUser(urlNavigate);
	        }
	    };

	    /**
	     * Configures popup window for login.
	     * @ignore
	     */
	    AuthenticationContext.prototype._openPopup = function (urlNavigate, title, popUpWidth, popUpHeight) {
	        try {
	            /**
	            * adding winLeft and winTop to account for dual monitor
	            * using screenLeft and screenTop for IE8 and earlier
	            */
	            var winLeft = window.screenLeft ? window.screenLeft : window.screenX;
	            var winTop = window.screenTop ? window.screenTop : window.screenY;
	            /**
	            * window.innerWidth displays browser window's height and width excluding toolbars
	            * using document.documentElement.clientWidth for IE8 and earlier
	            */
	            var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
	            var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
	            var left = ((width / 2) - (popUpWidth / 2)) + winLeft;
	            var top = ((height / 2) - (popUpHeight / 2)) + winTop;

	            var popupWindow = window.open(urlNavigate, title, 'width=' + popUpWidth + ', height=' + popUpHeight + ', top=' + top + ', left=' + left);

	            if (popupWindow.focus) {
	                popupWindow.focus();
	            }

	            return popupWindow;
	        } catch (e) {
	            this.warn('Error opening popup, ' + e.message);
	            this._loginInProgress = false;
	            this._acquireTokenInProgress = false;
	            return null;
	        }
	    };

	    AuthenticationContext.prototype._handlePopupError = function (loginCallback, resource, error, errorDesc, loginError) {
	        this.warn(errorDesc);
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR, error);
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, errorDesc);
	        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, loginError);

	        if (resource && this._activeRenewals[resource]) {
	            this._activeRenewals[resource] = null;
	        }

	        this._loginInProgress = false;
	        this._acquireTokenInProgress = false;

	        if (loginCallback) {
	            loginCallback(errorDesc, null, error);
	        }
	    };

	    /**
	     * After authorization, the user will be sent to your specified redirect_uri with the user's bearer token
	     * attached to the URI fragment as an id_token field. It closes popup window after redirection.
	     * @ignore
	     */
	    AuthenticationContext.prototype._loginPopup = function (urlNavigate, resource, callback) {
	        var popupWindow = this._openPopup(urlNavigate, "login", this.CONSTANTS.POPUP_WIDTH, this.CONSTANTS.POPUP_HEIGHT);
	        var loginCallback = callback || this.callback;

	        if (popupWindow == null) {
	            var error = 'Error opening popup';
	            var errorDesc = 'Popup Window is null. This can happen if you are using IE';
	            this._handlePopupError(loginCallback, resource, error, errorDesc, errorDesc);
	            return;
	        }

	        this._openedWindows.push(popupWindow);

	        if (this.config.redirectUri.indexOf('#') != -1) {
	            var registeredRedirectUri = this.config.redirectUri.split("#")[0];
	        }

	        else {
	            var registeredRedirectUri = this.config.redirectUri;
	        }

	        var that = this;

	        var pollTimer = window.setInterval(function () {
	            if (!popupWindow || popupWindow.closed || popupWindow.closed === undefined) {
	                var error = 'Popup Window closed';
	                var errorDesc = 'Popup Window closed by UI action/ Popup Window handle destroyed due to cross zone navigation in IE/Edge';

	                if (that.isAngular) {
	                    that._broadcast('adal:popUpClosed', errorDesc + that.CONSTANTS.RESOURCE_DELIMETER + error);
	                }

	                that._handlePopupError(loginCallback, resource, error, errorDesc, errorDesc);
	                window.clearInterval(pollTimer);
	                return;
	            }
	            try {
	                var popUpWindowLocation = popupWindow.location;
	                if (encodeURI(popUpWindowLocation.href).indexOf(encodeURI(registeredRedirectUri)) != -1) {
	                    if (that.isAngular) {
	                        that._broadcast('adal:popUpHashChanged', popUpWindowLocation.hash);
	                    }
	                    else {
	                        that.handleWindowCallback(popUpWindowLocation.hash);
	                    }

	                    window.clearInterval(pollTimer);
	                    that._loginInProgress = false;
	                    that._acquireTokenInProgress = false;
	                    that.info("Closing popup window");
	                    that._openedWindows = [];
	                    popupWindow.close();
	                    return;
	                }
	            } catch (e) {
	            }
	        }, 1);
	    };

	    AuthenticationContext.prototype._broadcast = function (eventName, data) {
	        // Custom Event is not supported in IE, below IIFE will polyfill the CustomEvent() constructor functionality in Internet Explorer 9 and higher
	        (function () {

	            if (typeof window.CustomEvent === "function") {
	                return false;
	            }

	            function CustomEvent(event, params) {
	                params = params || { bubbles: false, cancelable: false, detail: undefined };
	                var evt = document.createEvent('CustomEvent');
	                evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
	                return evt;
	            }

	            CustomEvent.prototype = window.Event.prototype;
	            window.CustomEvent = CustomEvent;
	        })();

	        var evt = new CustomEvent(eventName, { detail: data });
	        window.dispatchEvent(evt);
	    };

	    AuthenticationContext.prototype.loginInProgress = function () {
	        return this._loginInProgress;
	    };

	    /**
	     * Checks for the resource in the cache. By default, cache location is Session Storage
	     * @ignore
	     * @returns {Boolean} 'true' if login is in progress, else returns 'false'.
	     */
	    AuthenticationContext.prototype._hasResource = function (key) {
	        var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);
	        return keys && !this._isEmpty(keys) && (keys.indexOf(key + this.CONSTANTS.RESOURCE_DELIMETER) > -1);
	    };

	    /**
	     * Gets token for the specified resource from the cache.
	     * @param {string}   resource A URI that identifies the resource for which the token is requested.
	     * @returns {string} token if if it exists and not expired, otherwise null.
	     */
	    AuthenticationContext.prototype.getCachedToken = function (resource) {
	        if (!this._hasResource(resource)) {
	            return null;
	        }

	        var token = this._getItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource);
	        var expiry = this._getItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource);

	        // If expiration is within offset, it will force renew
	        var offset = this.config.expireOffsetSeconds || 300;

	        if (expiry && (expiry > this._now() + offset)) {
	            return token;
	        } else {
	            this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');
	            this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);
	            return null;
	        }
	    };

	    /**
	    * User information from idtoken.
	    *  @class User
	    *  @property {string} userName - username assigned from upn or email.
	    *  @property {object} profile - properties parsed from idtoken.
	    */

	    /**
	     * If user object exists, returns it. Else creates a new user object by decoding id_token from the cache.
	     * @returns {User} user object
	     */
	    AuthenticationContext.prototype.getCachedUser = function () {
	        if (this._user) {
	            return this._user;
	        }

	        var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);
	        this._user = this._createUser(idtoken);
	        return this._user;
	    };

	    /**
	     * Adds the passed callback to the array of callbacks for the specified resource and puts the array on the window object. 
	     * @param {string}   resource A URI that identifies the resource for which the token is requested.
	     * @param {string}   expectedState A unique identifier (guid).
	     * @param {tokenCallback} callback - The callback provided by the caller. It will be called with token or error.
	     */
	    AuthenticationContext.prototype.registerCallback = function (expectedState, resource, callback) {
	        this._activeRenewals[resource] = expectedState;

	        if (!this._callBacksMappedToRenewStates[expectedState]) {
	            this._callBacksMappedToRenewStates[expectedState] = [];
	        }

	        var self = this;
	        this._callBacksMappedToRenewStates[expectedState].push(callback);

	        if (!this._callBackMappedToRenewStates[expectedState]) {
	            this._callBackMappedToRenewStates[expectedState] = function (errorDesc, token, error, tokenType) {
	                self._activeRenewals[resource] = null;

	                for (var i = 0; i < self._callBacksMappedToRenewStates[expectedState].length; ++i) {
	                    try {
	                        self._callBacksMappedToRenewStates[expectedState][i](errorDesc, token, error, tokenType);
	                    }
	                    catch (error) {
	                        self.warn(error);
	                    }
	                }

	                self._callBacksMappedToRenewStates[expectedState] = null;
	                self._callBackMappedToRenewStates[expectedState] = null;
	            };
	        }
	    };

	    // var errorResponse = {error:'', error_description:''};
	    // var token = 'string token';
	    // callback(errorResponse, token)
	    // with callback
	    /**
	     * Acquires access token with hidden iframe
	     * @ignore
	     */
	    AuthenticationContext.prototype._renewToken = function (resource, callback, responseType) {
	        // use iframe to try to renew token
	        // use given resource to create new authz url
	        this.info('renewToken is called for resource:' + resource);
	        var frameHandle = this._addAdalFrame('adalRenewFrame' + resource);
	        var expectedState = this._guid() + '|' + resource;
	        this.config.state = expectedState;
	        // renew happens in iframe, so it keeps javascript context
	        this._renewStates.push(expectedState);
	        this.verbose('Renew token Expected state: ' + expectedState);
	        // remove the existing prompt=... query parameter and add prompt=none
	        responseType = responseType || 'token';
	        var urlNavigate = this._urlRemoveQueryStringParameter(this._getNavigateUrl(responseType, resource), 'prompt');

	        if (responseType === this.RESPONSE_TYPE.ID_TOKEN_TOKEN) {
	            this._idTokenNonce = this._guid();
	            this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce, true);
	            urlNavigate += '&nonce=' + encodeURIComponent(this._idTokenNonce);
	        }

	        urlNavigate = urlNavigate + '&prompt=none';
	        urlNavigate = this._addHintParameters(urlNavigate);
	        this.registerCallback(expectedState, resource, callback);
	        this.verbosePii('Navigate to:' + urlNavigate);
	        frameHandle.src = 'about:blank';
	        this._loadFrameTimeout(urlNavigate, 'adalRenewFrame' + resource, resource);

	    };

	    /**
	     * Renews idtoken for app's own backend when resource is clientId and calls the callback with token/error
	     * @ignore
	     */
	    AuthenticationContext.prototype._renewIdToken = function (callback, responseType) {
	        // use iframe to try to renew token
	        this.info('renewIdToken is called');
	        var frameHandle = this._addAdalFrame('adalIdTokenFrame');
	        var expectedState = this._guid() + '|' + this.config.clientId;
	        this._idTokenNonce = this._guid();
	        this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce, true);
	        this.config.state = expectedState;
	        // renew happens in iframe, so it keeps javascript context
	        this._renewStates.push(expectedState);
	        this.verbose('Renew Idtoken Expected state: ' + expectedState);
	        // remove the existing prompt=... query parameter and add prompt=none
	        var resource = responseType === null || typeof (responseType) === "undefined" ? null : this.config.clientId;
	        var responseType = responseType || 'id_token';
	        var urlNavigate = this._urlRemoveQueryStringParameter(this._getNavigateUrl(responseType, resource), 'prompt');
	        urlNavigate = urlNavigate + '&prompt=none';
	        urlNavigate = this._addHintParameters(urlNavigate);
	        urlNavigate += '&nonce=' + encodeURIComponent(this._idTokenNonce);
	        this.registerCallback(expectedState, this.config.clientId, callback);
	        this.verbosePii('Navigate to:' + urlNavigate);
	        frameHandle.src = 'about:blank';
	        this._loadFrameTimeout(urlNavigate, 'adalIdTokenFrame', this.config.clientId);
	    };

	    /**
	     * Checks if the authorization endpoint URL contains query string parameters
	     * @ignore
	     */
	    AuthenticationContext.prototype._urlContainsQueryStringParameter = function (name, url) {
	        // regex to detect pattern of a ? or & followed by the name parameter and an equals character
	        var regex = new RegExp("[\\?&]" + name + "=");
	        return regex.test(url);
	    };

	    /**
	     * Removes the query string parameter from the authorization endpoint URL if it exists
	     * @ignore
	     */
	    AuthenticationContext.prototype._urlRemoveQueryStringParameter = function (url, name) {
	        // we remove &name=value, name=value& and name=value
	        // &name=value
	        var regex = new RegExp('(\\&' + name + '=)[^\&]+');
	        url = url.replace(regex, '');
	        // name=value&
	        regex = new RegExp('(' + name + '=)[^\&]+&');
	        url = url.replace(regex, '');
	        // name=value
	        regex = new RegExp('(' + name + '=)[^\&]+');
	        url = url.replace(regex, '');
	        return url;
	    };

	    // Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left
	    // registered when network errors occur and subsequent token requests for same resource are registered to the pending request
	    /**
	     * @ignore
	     */
	    AuthenticationContext.prototype._loadFrameTimeout = function (urlNavigation, frameName, resource) {
	        //set iframe session to pending
	        this.verbose('Set loading state to pending for: ' + resource);
	        this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS);
	        this._loadFrame(urlNavigation, frameName);
	        var self = this;

	        setTimeout(function () {
	            if (self._getItem(self.CONSTANTS.STORAGE.RENEW_STATUS + resource) === self.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS) {
	                // fail the iframe session if it's in pending state
	                self.verbose('Loading frame has timed out after: ' + (self.CONSTANTS.LOADFRAME_TIMEOUT / 1000) + ' seconds for resource ' + resource);
	                var expectedState = self._activeRenewals[resource];

	                if (expectedState && self._callBackMappedToRenewStates[expectedState]) {
	                    self._callBackMappedToRenewStates[expectedState]('Token renewal operation failed due to timeout', null, 'Token Renewal Failed');
	                }

	                self._saveItem(self.CONSTANTS.STORAGE.RENEW_STATUS + resource, self.CONSTANTS.TOKEN_RENEW_STATUS_CANCELED);
	            }
	        }, self.CONSTANTS.LOADFRAME_TIMEOUT);
	    };

	    /**
	     * Loads iframe with authorization endpoint URL
	     * @ignore
	     */
	    AuthenticationContext.prototype._loadFrame = function (urlNavigate, frameName) {
	        // This trick overcomes iframe navigation in IE
	        // IE does not load the page consistently in iframe
	        var self = this;
	        self.info('LoadFrame: ' + frameName);
	        var frameCheck = frameName;
	        setTimeout(function () {
	            var frameHandle = self._addAdalFrame(frameCheck);

	            if (frameHandle.src === '' || frameHandle.src === 'about:blank') {
	                frameHandle.src = urlNavigate;
	                self._loadFrame(urlNavigate, frameCheck);
	            }

	        }, 500);
	    };

	    /**
	     * @callback tokenCallback
	     * @param {string} error_description error description returned from AAD if token request fails.
	     * @param {string} token token returned from AAD if token request is successful.
	     * @param {string} error error message returned from AAD if token request fails.
	     */

	    /**
	     * Acquires token from the cache if it is not expired. Otherwise sends request to AAD to obtain a new token.
	     * @param {string}   resource  ResourceUri identifying the target resource
	     * @param {tokenCallback} callback -  The callback provided by the caller. It will be called with token or error.
	     */
	    AuthenticationContext.prototype.acquireToken = function (resource, callback) {
	        if (this._isEmpty(resource)) {
	            this.warn('resource is required');
	            callback('resource is required', null, 'resource is required');
	            return;
	        }

	        var token = this.getCachedToken(resource);

	        if (token) {
	            this.info('Token is already in cache for resource:' + resource);
	            callback(null, token, null);
	            return;
	        }

	        if (!this._user && !(this.config.extraQueryParameter && this.config.extraQueryParameter.indexOf('login_hint') !== -1)) {
	            this.warn('User login is required');
	            callback('User login is required', null, 'login required');
	            return;
	        }

	        // renew attempt with iframe
	        // Already renewing for this resource, callback when we get the token.
	        if (this._activeRenewals[resource]) {
	            // Active renewals contains the state for each renewal.
	            this.registerCallback(this._activeRenewals[resource], resource, callback);
	        }
	        else {
	            this._requestType = this.REQUEST_TYPE.RENEW_TOKEN;
	            if (resource === this.config.clientId) {
	                // App uses idtoken to send to api endpoints
	                // Default resource is tracked as clientid to store this token
	                if (this._user) {
	                    this.verbose('renewing idtoken');
	                    this._renewIdToken(callback);
	                }
	                else {
	                    this.verbose('renewing idtoken and access_token');
	                    this._renewIdToken(callback, this.RESPONSE_TYPE.ID_TOKEN_TOKEN);
	                }
	            } else {
	                if (this._user) {
	                    this.verbose('renewing access_token');
	                    this._renewToken(resource, callback);
	                }
	                else {
	                    this.verbose('renewing idtoken and access_token');
	                    this._renewToken(resource, callback, this.RESPONSE_TYPE.ID_TOKEN_TOKEN);
	                }
	            }
	        }
	    };

	    /**
	  * Acquires token (interactive flow using a popUp window) by sending request to AAD to obtain a new token.
	  * @param {string}   resource  ResourceUri identifying the target resource
	  * @param {string}   extraQueryParameters  extraQueryParameters to add to the authentication request
	  * @param {tokenCallback} callback -  The callback provided by the caller. It will be called with token or error.
	  */
	    AuthenticationContext.prototype.acquireTokenPopup = function (resource, extraQueryParameters, claims, callback) {
	        if (this._isEmpty(resource)) {
	            this.warn('resource is required');
	            callback('resource is required', null, 'resource is required');
	            return;
	        }

	        if (!this._user) {
	            this.warn('User login is required');
	            callback('User login is required', null, 'login required');
	            return;
	        }

	        if (this._acquireTokenInProgress) {
	            this.warn("Acquire token interactive is already in progress");
	            callback("Acquire token interactive is already in progress", null, "Acquire token interactive is already in progress");
	            return;
	        }

	        var expectedState = this._guid() + '|' + resource;
	        this.config.state = expectedState;
	        this._renewStates.push(expectedState);
	        this._requestType = this.REQUEST_TYPE.RENEW_TOKEN;
	        this.verbose('Renew token Expected state: ' + expectedState);
	        // remove the existing prompt=... query parameter and add prompt=select_account
	        var urlNavigate = this._urlRemoveQueryStringParameter(this._getNavigateUrl('token', resource), 'prompt');
	        urlNavigate = urlNavigate + '&prompt=select_account';

	        if (extraQueryParameters) {
	            urlNavigate += extraQueryParameters;
	        }

	        if (claims && (urlNavigate.indexOf("&claims") === -1)) {
	            urlNavigate += '&claims=' + encodeURIComponent(claims);
	        }
	        else if (claims && (urlNavigate.indexOf("&claims") !== -1)) {
	            throw new Error('Claims cannot be passed as an extraQueryParameter');
	        }

	        urlNavigate = this._addHintParameters(urlNavigate);
	        this._acquireTokenInProgress = true;
	        this.info('acquireToken interactive is called for the resource ' + resource);
	        this.registerCallback(expectedState, resource, callback);
	        this._loginPopup(urlNavigate, resource, callback);

	    };

	    /**
	      * Acquires token (interactive flow using a redirect) by sending request to AAD to obtain a new token. In this case the callback passed in the Authentication
	      * request constructor will be called.
	      * @param {string}   resource  ResourceUri identifying the target resource
	      * @param {string}   extraQueryParameters  extraQueryParameters to add to the authentication request
	      */
	    AuthenticationContext.prototype.acquireTokenRedirect = function (resource, extraQueryParameters, claims) {
	        if (this._isEmpty(resource)) {
	            this.warn('resource is required');
	            callback('resource is required', null, 'resource is required');
	            return;
	        }

	        var callback = this.callback;

	        if (!this._user) {
	            this.warn('User login is required');
	            callback('User login is required', null, 'login required');
	            return;
	        }

	        if (this._acquireTokenInProgress) {
	            this.warn("Acquire token interactive is already in progress");
	            callback("Acquire token interactive is already in progress", null, "Acquire token interactive is already in progress");
	            return;
	        }

	        var expectedState = this._guid() + '|' + resource;
	        this.config.state = expectedState;
	        this.verbose('Renew token Expected state: ' + expectedState);

	        // remove the existing prompt=... query parameter and add prompt=select_account
	        var urlNavigate = this._urlRemoveQueryStringParameter(this._getNavigateUrl('token', resource), 'prompt');
	        urlNavigate = urlNavigate + '&prompt=select_account';
	        if (extraQueryParameters) {
	            urlNavigate += extraQueryParameters;
	        }

	        if (claims && (urlNavigate.indexOf("&claims") === -1)) {
	            urlNavigate += '&claims=' + encodeURIComponent(claims);
	        }
	        else if (claims && (urlNavigate.indexOf("&claims") !== -1)) {
	            throw new Error('Claims cannot be passed as an extraQueryParameter');
	        }

	        urlNavigate = this._addHintParameters(urlNavigate);
	        this._acquireTokenInProgress = true;
	        this.info('acquireToken interactive is called for the resource ' + resource);
	        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, window.location.href);
	        this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, expectedState, true);
	        this.promptUser(urlNavigate);
	    };
	    /**
	     * Redirects the browser to Azure AD authorization endpoint.
	     * @param {string}   urlNavigate  Url of the authorization endpoint.
	     */
	    AuthenticationContext.prototype.promptUser = function (urlNavigate) {
	        if (urlNavigate) {
	            this.infoPii('Navigate to:' + urlNavigate);
	            window.location.replace(urlNavigate);
	        } else {
	            this.info('Navigate url is empty');
	        }
	    };

	    /**
	     * Clears cache items.
	     */
	    AuthenticationContext.prototype.clearCache = function () {
	        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');
	        this._saveItem(this.CONSTANTS.STORAGE.ANGULAR_LOGIN_REQUEST, '');
	        this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, '');
	        this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, '');
	        this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, '');
	        this._renewStates = [];
	        this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, '');
	        this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, '');
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');
	        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');
	        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');
	        var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);

	        if (!this._isEmpty(keys)) {
	            keys = keys.split(this.CONSTANTS.RESOURCE_DELIMETER);
	            for (var i = 0; i < keys.length && keys[i] !== ""; i++) {
	                this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + keys[i], '');
	                this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + keys[i], 0);
	            }
	        }

	        this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, '');
	    };

	    /**
	     * Clears cache items for a given resource.
	     * @param {string}  resource a URI that identifies the resource.
	     */
	    AuthenticationContext.prototype.clearCacheForResource = function (resource) {
	        this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, '');
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');

	        if (this._hasResource(resource)) {
	            this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');
	            this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);
	        }
	    };

	    /**
	     * Redirects user to logout endpoint.
	     * After logout, it will redirect to postLogoutRedirectUri if added as a property on the config object.
	     */
	    AuthenticationContext.prototype.logOut = function () {
	        this.clearCache();
	        this._user = null;
	        var urlNavigate;

	        if (this.config.logOutUri) {
	            urlNavigate = this.config.logOutUri;
	        } else {
	            var tenant = 'common';
	            var logout = '';

	            if (this.config.tenant) {
	                tenant = this.config.tenant;
	            }

	            if (this.config.postLogoutRedirectUri) {
	                logout = 'post_logout_redirect_uri=' + encodeURIComponent(this.config.postLogoutRedirectUri);
	            }

	            urlNavigate = this.instance + tenant + '/oauth2/logout?' + logout;
	        }

	        this.infoPii('Logout navigate to: ' + urlNavigate);
	        this.promptUser(urlNavigate);
	    };

	    AuthenticationContext.prototype._isEmpty = function (str) {
	        return (typeof str === 'undefined' || !str || 0 === str.length);
	    };

	    /**
	     * @callback userCallback
	     * @param {string} error error message if user info is not available.
	     * @param {User} user user object retrieved from the cache.
	     */

	    /**
	     * Calls the passed in callback with the user object or error message related to the user.
	     * @param {userCallback} callback - The callback provided by the caller. It will be called with user or error.
	     */
	    AuthenticationContext.prototype.getUser = function (callback) {
	        // IDToken is first call
	        if (typeof callback !== 'function') {
	            throw new Error('callback is not a function');
	        }

	        // user in memory
	        if (this._user) {
	            callback(null, this._user);
	            return;
	        }

	        // frame is used to get idtoken
	        var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);

	        if (!this._isEmpty(idtoken)) {
	            this.info('User exists in cache: ');
	            this._user = this._createUser(idtoken);
	            callback(null, this._user);
	        } else {
	            this.warn('User information is not available');
	            callback('User information is not available', null);
	        }
	    };

	    /**
	     * Adds login_hint to authorization URL which is used to pre-fill the username field of sign in page for the user if known ahead of time.
	     * domain_hint can be one of users/organisations which when added skips the email based discovery process of the user.
	     * @ignore
	     */
	    AuthenticationContext.prototype._addHintParameters = function (urlNavigate) {
	        //If you don�t use prompt=none, then if the session does not exist, there will be a failure.
	        //If sid is sent alongside domain or login hints, there will be a failure since request is ambiguous.
	        //If sid is sent with a prompt value other than none or attempt_none, there will be a failure since the request is ambiguous.

	        if (this._user && this._user.profile) {
	            if (this._user.profile.sid && urlNavigate.indexOf('&prompt=none') !== -1) {
	                // don't add sid twice if user provided it in the extraQueryParameter value
	                if (!this._urlContainsQueryStringParameter("sid", urlNavigate)) {
	                    // add sid
	                    urlNavigate += '&sid=' + encodeURIComponent(this._user.profile.sid);
	                }
	            }
	            else if (this._user.profile.upn) {
	                // don't add login_hint twice if user provided it in the extraQueryParameter value
	                if (!this._urlContainsQueryStringParameter("login_hint", urlNavigate)) {
	                    // add login_hint
	                    urlNavigate += '&login_hint=' + encodeURIComponent(this._user.profile.upn);
	                }
	                // don't add domain_hint twice if user provided it in the extraQueryParameter value
	                if (!this._urlContainsQueryStringParameter("domain_hint", urlNavigate) && this._user.profile.upn.indexOf('@') > -1) {
	                    var parts = this._user.profile.upn.split('@');
	                    // local part can include @ in quotes. Sending last part handles that.
	                    urlNavigate += '&domain_hint=' + encodeURIComponent(parts[parts.length - 1]);
	                }
	            }

	        }

	        return urlNavigate;
	    };

	    /**
	     * Creates a user object by decoding the id_token
	     * @ignore
	     */
	    AuthenticationContext.prototype._createUser = function (idToken) {
	        var user = null;
	        var parsedJson = this._extractIdToken(idToken);
	        if (parsedJson && parsedJson.hasOwnProperty('aud')) {
	            if (parsedJson.aud.toLowerCase() === this.config.clientId.toLowerCase()) {

	                user = {
	                    userName: '',
	                    profile: parsedJson
	                };

	                if (parsedJson.hasOwnProperty('upn')) {
	                    user.userName = parsedJson.upn;
	                } else if (parsedJson.hasOwnProperty('email')) {
	                    user.userName = parsedJson.email;
	                }
	            } else {
	                this.warn('IdToken has invalid aud field');
	            }

	        }

	        return user;
	    };

	    /**
	     * Returns the anchor part(#) of the URL
	     * @ignore
	     */
	    AuthenticationContext.prototype._getHash = function (hash) {
	        if (hash.indexOf('#/') > -1) {
	            hash = hash.substring(hash.indexOf('#/') + 2);
	        } else if (hash.indexOf('#') > -1) {
	            hash = hash.substring(1);
	        }

	        return hash;
	    };

	    /**
	     * Checks if the URL fragment contains access token, id token or error_description.
	     * @param {string} hash  -  Hash passed from redirect page
	     * @returns {Boolean} true if response contains id_token, access_token or error, false otherwise.
	     */
	    AuthenticationContext.prototype.isCallback = function (hash) {
	        hash = this._getHash(hash);
	        var parameters = this._deserialize(hash);
	        return (
	            parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) ||
	            parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) ||
	            parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)
	        );
	    };

	    /**
	     * Gets login error
	     * @returns {string} error message related to login.
	     */
	    AuthenticationContext.prototype.getLoginError = function () {
	        return this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR);
	    };

	    /**
	     * Request info object created from the response received from AAD.
	     *  @class RequestInfo
	     *  @property {object} parameters - object comprising of fields such as id_token/error, session_state, state, e.t.c.
	     *  @property {REQUEST_TYPE} requestType - either LOGIN, RENEW_TOKEN or UNKNOWN.
	     *  @property {boolean} stateMatch - true if state is valid, false otherwise.
	     *  @property {string} stateResponse - unique guid used to match the response with the request.
	     *  @property {boolean} valid - true if requestType contains id_token, access_token or error, false otherwise.
	     */

	    /**
	     * Creates a requestInfo object from the URL fragment and returns it.
	     * @returns {RequestInfo} an object created from the redirect response from AAD comprising of the keys - parameters, requestType, stateMatch, stateResponse and valid.
	     */
	    AuthenticationContext.prototype.getRequestInfo = function (hash) {
	        hash = this._getHash(hash);
	        var parameters = this._deserialize(hash);
	        var requestInfo = {
	            valid: false,
	            parameters: {},
	            stateMatch: false,
	            stateResponse: '',
	            requestType: this.REQUEST_TYPE.UNKNOWN,
	        };

	        if (parameters) {
	            requestInfo.parameters = parameters;
	            if (parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) ||
	                parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) ||
	                parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {

	                requestInfo.valid = true;

	                // which call
	                var stateResponse = '';
	                if (parameters.hasOwnProperty('state')) {
	                    this.verbose('State: ' + parameters.state);
	                    stateResponse = parameters.state;
	                } else {
	                    this.warn('No state returned');
	                    return requestInfo;
	                }

	                requestInfo.stateResponse = stateResponse;

	                // async calls can fire iframe and login request at the same time if developer does not use the API as expected
	                // incoming callback needs to be looked up to find the request type
	                if (this._matchState(requestInfo)) { // loginRedirect or acquireTokenRedirect
	                    return requestInfo;
	                }

	                // external api requests may have many renewtoken requests for different resource
	                if (!requestInfo.stateMatch && window.parent) {
	                    requestInfo.requestType = this._requestType;
	                    var statesInParentContext = this._renewStates;
	                    for (var i = 0; i < statesInParentContext.length; i++) {
	                        if (statesInParentContext[i] === requestInfo.stateResponse) {
	                            requestInfo.stateMatch = true;
	                            break;
	                        }
	                    }
	                }
	            }
	        }
	        return requestInfo;
	    };

	    /**
	    * Matches nonce from the request with the response.
	    * @ignore
	    */
	    AuthenticationContext.prototype._matchNonce = function (user) {
	        var requestNonce = this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN);

	        if (requestNonce) {
	            requestNonce = requestNonce.split(this.CONSTANTS.CACHE_DELIMETER);
	            for (var i = 0; i < requestNonce.length; i++) {
	                if (requestNonce[i] && requestNonce[i] === user.profile.nonce) {
	                    return true;
	                }
	            }
	        }

	        return false;
	    };

	    /**
	    * Matches state from the request with the response.
	    * @ignore
	    */
	    AuthenticationContext.prototype._matchState = function (requestInfo) {
	        var loginStates = this._getItem(this.CONSTANTS.STORAGE.STATE_LOGIN);

	        if (loginStates) {
	            loginStates = loginStates.split(this.CONSTANTS.CACHE_DELIMETER);
	            for (var i = 0; i < loginStates.length; i++) {
	                if (loginStates[i] && loginStates[i] === requestInfo.stateResponse) {
	                    requestInfo.requestType = this.REQUEST_TYPE.LOGIN;
	                    requestInfo.stateMatch = true;
	                    return true;
	                }
	            }
	        }

	        var acquireTokenStates = this._getItem(this.CONSTANTS.STORAGE.STATE_RENEW);

	        if (acquireTokenStates) {
	            acquireTokenStates = acquireTokenStates.split(this.CONSTANTS.CACHE_DELIMETER);
	            for (var i = 0; i < acquireTokenStates.length; i++) {
	                if (acquireTokenStates[i] && acquireTokenStates[i] === requestInfo.stateResponse) {
	                    requestInfo.requestType = this.REQUEST_TYPE.RENEW_TOKEN;
	                    requestInfo.stateMatch = true;
	                    return true;
	                }
	            }
	        }

	        return false;

	    };

	    /**
	     * Extracts resource value from state.
	     * @ignore
	     */
	    AuthenticationContext.prototype._getResourceFromState = function (state) {
	        if (state) {
	            var splitIndex = state.indexOf('|');

	            if (splitIndex > -1 && splitIndex + 1 < state.length) {
	                return state.substring(splitIndex + 1);
	            }
	        }

	        return '';
	    };

	    /**
	     * Saves token or error received in the response from AAD in the cache. In case of id_token, it also creates the user object.
	     */
	    AuthenticationContext.prototype.saveTokenFromHash = function (requestInfo) {
	        this.info('State status:' + requestInfo.stateMatch + '; Request type:' + requestInfo.requestType);
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');

	        var resource = this._getResourceFromState(requestInfo.stateResponse);

	        // Record error
	        if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION)) {
	            this.infoPii('Error :' + requestInfo.parameters.error + '; Error description:' + requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);
	            this._saveItem(this.CONSTANTS.STORAGE.ERROR, requestInfo.parameters.error);
	            this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);

	            if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {
	                this._loginInProgress = false;
	                this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, requestInfo.parameters.error_description);
	            }
	        } else {
	            // It must verify the state from redirect
	            if (requestInfo.stateMatch) {
	                // record tokens to storage if exists
	                this.info('State is right');
	                if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.SESSION_STATE)) {
	                    this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, requestInfo.parameters[this.CONSTANTS.SESSION_STATE]);
	                }

	                var keys;

	                if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)) {
	                    this.info('Fragment has access token');

	                    if (!this._hasResource(resource)) {
	                        keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';
	                        this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);
	                    }

	                    // save token with related resource
	                    this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN]);
	                    this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._expiresIn(requestInfo.parameters[this.CONSTANTS.EXPIRES_IN]));
	                }

	                if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {
	                    this.info('Fragment has id token');
	                    this._loginInProgress = false;
	                    this._user = this._createUser(requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);
	                    if (this._user && this._user.profile) {
	                        if (!this._matchNonce(this._user)) {
	                            this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Nonce received: ' + this._user.profile.nonce + ' is not same as requested: ' +
	                                this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN));
	                            this._user = null;
	                        } else {
	                            this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);

	                            // Save idtoken as access token for app itself
	                            resource = this.config.loginResource ? this.config.loginResource : this.config.clientId;

	                            if (!this._hasResource(resource)) {
	                                keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';
	                                this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);
	                            }

	                            this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);
	                            this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._user.profile.exp);
	                        }
	                    }
	                    else {
	                        requestInfo.parameters['error'] = 'invalid id_token';
	                        requestInfo.parameters['error_description'] = 'Invalid id_token. id_token: ' + requestInfo.parameters[this.CONSTANTS.ID_TOKEN];
	                        this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'invalid id_token');
	                        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid id_token. id_token: ' + requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);
	                    }
	                }
	            } else {
	                requestInfo.parameters['error'] = 'Invalid_state';
	                requestInfo.parameters['error_description'] = 'Invalid_state. state: ' + requestInfo.stateResponse;
	                this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Invalid_state');
	                this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid_state. state: ' + requestInfo.stateResponse);
	            }
	        }

	        this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_COMPLETED);
	    };

	    /**
	     * Gets resource for given endpoint if mapping is provided with config.
	     * @param {string} endpoint  -  The URI for which the resource Id is requested.
	     * @returns {string} resource for this API endpoint.
	     */
	    AuthenticationContext.prototype.getResourceForEndpoint = function (endpoint) {

	        // if user specified list of anonymous endpoints, no need to send token to these endpoints, return null.
	        if (this.config && this.config.anonymousEndpoints) {
	            for (var i = 0; i < this.config.anonymousEndpoints.length; i++) {
	                if (endpoint.indexOf(this.config.anonymousEndpoints[i]) > -1) {
	                    return null;
	                }
	            }
	        }

	        if (this.config && this.config.endpoints) {
	            for (var configEndpoint in this.config.endpoints) {
	                // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1
	                if (endpoint.indexOf(configEndpoint) > -1) {
	                    return this.config.endpoints[configEndpoint];
	                }
	            }
	        }

	        // default resource will be clientid if nothing specified
	        // App will use idtoken for calls to itself
	        // check if it's staring from http or https, needs to match with app host
	        if (endpoint.indexOf('http://') > -1 || endpoint.indexOf('https://') > -1) {
	            if (this._getHostFromUri(endpoint) === this._getHostFromUri(this.config.redirectUri)) {
	                return this.config.loginResource;
	            }
	        }
	        else {
	            // in angular level, the url for $http interceptor call could be relative url,
	            // if it's relative call, we'll treat it as app backend call.            
	            return this.config.loginResource;
	        }

	        // if not the app's own backend or not a domain listed in the endpoints structure
	        return null;
	    };

	    /**
	     * Strips the protocol part of the URL and returns it.
	     * @ignore
	     */
	    AuthenticationContext.prototype._getHostFromUri = function (uri) {
	        // remove http:// or https:// from uri
	        var extractedUri = String(uri).replace(/^(https?:)\/\//, '');
	        extractedUri = extractedUri.split('/')[0];
	        return extractedUri;
	    };

	    /**
	     * This method must be called for processing the response received from AAD. It extracts the hash, processes the token or error, saves it in the cache and calls the registered callbacks with the result.
	     * @param {string} [hash=window.location.hash] - Hash fragment of Url.
	     */
	    AuthenticationContext.prototype.handleWindowCallback = function (hash) {
	        // This is for regular javascript usage for redirect handling
	        // need to make sure this is for callback
	        if (hash == null) {
	            hash = window.location.hash;
	        }

	        if (this.isCallback(hash)) {
	            var self = null;
	            var isPopup = false;

	            if (this._openedWindows.length > 0 && this._openedWindows[this._openedWindows.length - 1].opener
	                && this._openedWindows[this._openedWindows.length - 1].opener._adalInstance) {
	                self = this._openedWindows[this._openedWindows.length - 1].opener._adalInstance;
	                isPopup = true;
	            }
	            else if (window.parent && window.parent._adalInstance) {
	                self = window.parent._adalInstance;
	            }

	            var requestInfo = self.getRequestInfo(hash);
	            var token, tokenReceivedCallback, tokenType = null;

	            if (isPopup || window.parent !== window) {
	                tokenReceivedCallback = self._callBackMappedToRenewStates[requestInfo.stateResponse];
	            }
	            else {
	                tokenReceivedCallback = self.callback;
	            }

	            self.info("Returned from redirect url");
	            self.saveTokenFromHash(requestInfo);

	            if ((requestInfo.requestType === this.REQUEST_TYPE.RENEW_TOKEN) && window.parent) {
	                if (window.parent !== window) {
	                    self.verbose("Window is in iframe, acquiring token silently");
	                } else {
	                    self.verbose("acquiring token interactive in progress");
	                }

	                token = requestInfo.parameters[self.CONSTANTS.ACCESS_TOKEN] || requestInfo.parameters[self.CONSTANTS.ID_TOKEN];
	                tokenType = self.CONSTANTS.ACCESS_TOKEN;
	            } else if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {
	                token = requestInfo.parameters[self.CONSTANTS.ID_TOKEN];
	                tokenType = self.CONSTANTS.ID_TOKEN;
	            }

	            var errorDesc = requestInfo.parameters[self.CONSTANTS.ERROR_DESCRIPTION];
	            var error = requestInfo.parameters[self.CONSTANTS.ERROR];
	            try {
	                if (tokenReceivedCallback) {
	                    tokenReceivedCallback(errorDesc, token, error, tokenType);
	                }

	            } catch (err) {
	                self.error("Error occurred in user defined callback function: " + err);
	            }

	            if (window.parent === window && !isPopup) {
	                if (self.config.navigateToLoginRequestUrl) {
	                    window.location.href = self._getItem(self.CONSTANTS.STORAGE.LOGIN_REQUEST);
	                } else window.location.hash = '';
	            }
	        }
	    };

	    /**
	     * Constructs the authorization endpoint URL and returns it.
	     * @ignore
	     */
	    AuthenticationContext.prototype._getNavigateUrl = function (responseType, resource) {
	        var tenant = 'common';
	        if (this.config.tenant) {
	            tenant = this.config.tenant;
	        }

	        var urlNavigate = this.instance + tenant + '/oauth2/authorize' + this._serialize(responseType, this.config, resource) + this._addLibMetadata();
	        this.info('Navigate url:' + urlNavigate);
	        return urlNavigate;
	    };

	    /**
	     * Returns the decoded id_token.
	     * @ignore
	     */
	    AuthenticationContext.prototype._extractIdToken = function (encodedIdToken) {
	        // id token will be decoded to get the username
	        var decodedToken = this._decodeJwt(encodedIdToken);

	        if (!decodedToken) {
	            return null;
	        }

	        try {
	            var base64IdToken = decodedToken.JWSPayload;
	            var base64Decoded = this._base64DecodeStringUrlSafe(base64IdToken);

	            if (!base64Decoded) {
	                this.info('The returned id_token could not be base64 url safe decoded.');
	                return null;
	            }

	            // ECMA script has JSON built-in support
	            return JSON.parse(base64Decoded);
	        } catch (err) {
	            this.error('The returned id_token could not be decoded', err);
	        }

	        return null;
	    };

	    /**
	     * Decodes a string of data which has been encoded using base-64 encoding.
	     * @ignore
	     */
	    AuthenticationContext.prototype._base64DecodeStringUrlSafe = function (base64IdToken) {
	        // html5 should support atob function for decoding
	        base64IdToken = base64IdToken.replace(/-/g, '+').replace(/_/g, '/');

	        if (window.atob) {
	            return decodeURIComponent(escape(window.atob(base64IdToken))); // jshint ignore:line
	        }
	        else {
	            return decodeURIComponent(escape(this._decode(base64IdToken)));
	        }
	    };

	    //Take https://cdnjs.cloudflare.com/ajax/libs/Base64/0.3.0/base64.js and https://en.wikipedia.org/wiki/Base64 as reference. 
	    AuthenticationContext.prototype._decode = function (base64IdToken) {
	        var codes = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	        base64IdToken = String(base64IdToken).replace(/=+$/, '');

	        var length = base64IdToken.length;

	        if (length % 4 === 1) {
	            throw new Error('The token to be decoded is not correctly encoded.');
	        }

	        var h1, h2, h3, h4, bits, c1, c2, c3, decoded = '';

	        for (var i = 0; i < length; i += 4) {
	            //Every 4 base64 encoded character will be converted to 3 byte string, which is 24 bits
	            // then 6 bits per base64 encoded character
	            h1 = codes.indexOf(base64IdToken.charAt(i));
	            h2 = codes.indexOf(base64IdToken.charAt(i + 1));
	            h3 = codes.indexOf(base64IdToken.charAt(i + 2));
	            h4 = codes.indexOf(base64IdToken.charAt(i + 3));

	            // For padding, if last two are '='
	            if (i + 2 === length - 1) {
	                bits = h1 << 18 | h2 << 12 | h3 << 6;
	                c1 = bits >> 16 & 255;
	                c2 = bits >> 8 & 255;
	                decoded += String.fromCharCode(c1, c2);
	                break;
	            }
	            // if last one is '='
	            else if (i + 1 === length - 1) {
	                bits = h1 << 18 | h2 << 12;
	                c1 = bits >> 16 & 255;
	                decoded += String.fromCharCode(c1);
	                break;
	            }

	            bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

	            // then convert to 3 byte chars
	            c1 = bits >> 16 & 255;
	            c2 = bits >> 8 & 255;
	            c3 = bits & 255;

	            decoded += String.fromCharCode(c1, c2, c3);
	        }

	        return decoded;
	    };

	    /**
	     * Decodes an id token into an object with header, payload and signature fields.
	     * @ignore
	     */
	    // Adal.node js crack function
	    AuthenticationContext.prototype._decodeJwt = function (jwtToken) {
	        if (this._isEmpty(jwtToken)) {
	            return null;
	        }
	        var idTokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;

	        var matches = idTokenPartsRegex.exec(jwtToken);

	        if (!matches || matches.length < 4) {
	            this.warn('The returned id_token is not parseable.');
	            return null;
	        }

	        var crackedToken = {
	            header: matches[1],
	            JWSPayload: matches[2],
	            JWSSig: matches[3]
	        };

	        return crackedToken;
	    };

	    /**
	     * Converts string to represent binary data in ASCII string format by translating it into a radix-64 representation and returns it
	     * @ignore
	     */
	    AuthenticationContext.prototype._convertUrlSafeToRegularBase64EncodedString = function (str) {
	        return str.replace('-', '+').replace('_', '/');
	    };

	    /**
	     * Serializes the parameters for the authorization endpoint URL and returns the serialized uri string.
	     * @ignore
	     */
	    AuthenticationContext.prototype._serialize = function (responseType, obj, resource) {
	        var str = [];

	        if (obj !== null) {
	            str.push('?response_type=' + responseType);
	            str.push('client_id=' + encodeURIComponent(obj.clientId));
	            if (resource) {
	                str.push('resource=' + encodeURIComponent(resource));
	            }

	            str.push('redirect_uri=' + encodeURIComponent(obj.redirectUri));
	            str.push('state=' + encodeURIComponent(obj.state));

	            if (obj.hasOwnProperty('slice')) {
	                str.push('slice=' + encodeURIComponent(obj.slice));
	            }

	            if (obj.hasOwnProperty('extraQueryParameter')) {
	                str.push(obj.extraQueryParameter);
	            }

	            var correlationId = obj.correlationId ? obj.correlationId : this._guid();
	            str.push('client-request-id=' + encodeURIComponent(correlationId));
	        }

	        return str.join('&');
	    };

	    /**
	     * Parses the query string parameters into a key-value pair object.
	     * @ignore
	     */
	    AuthenticationContext.prototype._deserialize = function (query) {
	        var match,
	            pl = /\+/g,  // Regex for replacing addition symbol with a space
	            search = /([^&=]+)=([^&]*)/g,
	            decode = function (s) {
	                return decodeURIComponent(s.replace(pl, ' '));
	            },
	            obj = {};
	        match = search.exec(query);

	        while (match) {
	            obj[decode(match[1])] = decode(match[2]);
	            match = search.exec(query);
	        }

	        return obj;
	    };

	    /**
	     * Converts decimal value to hex equivalent
	     * @ignore
	     */
	    AuthenticationContext.prototype._decimalToHex = function (number) {
	        var hex = number.toString(16);

	        while (hex.length < 2) {
	            hex = '0' + hex;
	        }
	        return hex;
	    };

	    /**
	     * Generates RFC4122 version 4 guid (128 bits)
	     * @ignore
	     */
	    /* jshint ignore:start */
	    AuthenticationContext.prototype._guid = function () {
	        // RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or
	        // pseudo-random numbers.
	        // The algorithm is as follows:
	        //     Set the two most significant bits (bits 6 and 7) of the
	        //        clock_seq_hi_and_reserved to zero and one, respectively.
	        //     Set the four most significant bits (bits 12 through 15) of the
	        //        time_hi_and_version field to the 4-bit version number from
	        //        Section 4.1.3. Version4
	        //     Set all the other bits to randomly (or pseudo-randomly) chosen
	        //     values.
	        // UUID                   = time-low "-" time-mid "-"time-high-and-version "-"clock-seq-reserved and low(2hexOctet)"-" node
	        // time-low               = 4hexOctet
	        // time-mid               = 2hexOctet
	        // time-high-and-version  = 2hexOctet
	        // clock-seq-and-reserved = hexOctet:
	        // clock-seq-low          = hexOctet
	        // node                   = 6hexOctet
	        // Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
	        // y could be 1000, 1001, 1010, 1011 since most significant two bits needs to be 10
	        // y values are 8, 9, A, B
	        var cryptoObj = window.crypto || window.msCrypto; // for IE 11
	        if (cryptoObj && cryptoObj.getRandomValues) {
	            var buffer = new Uint8Array(16);
	            cryptoObj.getRandomValues(buffer);
	            //buffer[6] and buffer[7] represents the time_hi_and_version field. We will set the four most significant bits (4 through 7) of buffer[6] to represent decimal number 4 (UUID version number).
	            buffer[6] |= 0x40; //buffer[6] | 01000000 will set the 6 bit to 1.
	            buffer[6] &= 0x4f; //buffer[6] & 01001111 will set the 4, 5, and 7 bit to 0 such that bits 4-7 == 0100 = "4".
	            //buffer[8] represents the clock_seq_hi_and_reserved field. We will set the two most significant bits (6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.
	            buffer[8] |= 0x80; //buffer[8] | 10000000 will set the 7 bit to 1.
	            buffer[8] &= 0xbf; //buffer[8] & 10111111 will set the 6 bit to 0.
	            return this._decimalToHex(buffer[0]) + this._decimalToHex(buffer[1]) + this._decimalToHex(buffer[2]) + this._decimalToHex(buffer[3]) + '-' + this._decimalToHex(buffer[4]) + this._decimalToHex(buffer[5]) + '-' + this._decimalToHex(buffer[6]) + this._decimalToHex(buffer[7]) + '-' +
	                this._decimalToHex(buffer[8]) + this._decimalToHex(buffer[9]) + '-' + this._decimalToHex(buffer[10]) + this._decimalToHex(buffer[11]) + this._decimalToHex(buffer[12]) + this._decimalToHex(buffer[13]) + this._decimalToHex(buffer[14]) + this._decimalToHex(buffer[15]);
	        }
	        else {
	            var guidHolder = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
	            var hex = '0123456789abcdef';
	            var r = 0;
	            var guidResponse = "";
	            for (var i = 0; i < 36; i++) {
	                if (guidHolder[i] !== '-' && guidHolder[i] !== '4') {
	                    // each x and y needs to be random
	                    r = Math.random() * 16 | 0;
	                }
	                if (guidHolder[i] === 'x') {
	                    guidResponse += hex[r];
	                } else if (guidHolder[i] === 'y') {
	                    // clock-seq-and-reserved first hex is filtered and remaining hex values are random
	                    r &= 0x3; // bit and with 0011 to set pos 2 to zero ?0??
	                    r |= 0x8; // set pos 3 to 1 as 1???
	                    guidResponse += hex[r];
	                } else {
	                    guidResponse += guidHolder[i];
	                }
	            }
	            return guidResponse;
	        }
	    };
	    /* jshint ignore:end */

	    /**
	     * Calculates the expires in value in milliseconds for the acquired token
	     * @ignore
	     */
	    AuthenticationContext.prototype._expiresIn = function (expires) {
	        // if AAD did not send "expires_in" property, use default expiration of 3599 seconds, for some reason AAD sends 3599 as "expires_in" value instead of 3600
	        if (!expires) expires = 3599;
	        return this._now() + parseInt(expires, 10);
	    };

	    /**
	     * Return the number of milliseconds since 1970/01/01
	     * @ignore
	     */
	    AuthenticationContext.prototype._now = function () {
	        return Math.round(new Date().getTime() / 1000.0);
	    };

	    /**
	     * Adds the hidden iframe for silent token renewal
	     * @ignore
	     */
	    AuthenticationContext.prototype._addAdalFrame = function (iframeId) {
	        if (typeof iframeId === 'undefined') {
	            return;
	        }

	        this.info('Add adal frame to document:' + iframeId);
	        var adalFrame = document.getElementById(iframeId);

	        if (!adalFrame) {
	            if (document.createElement && document.documentElement &&
	                (window.opera || window.navigator.userAgent.indexOf('MSIE 5.0') === -1)) {
	                var ifr = document.createElement('iframe');
	                ifr.setAttribute('id', iframeId);
	                ifr.setAttribute('aria-hidden', 'true');
	                ifr.style.visibility = 'hidden';
	                ifr.style.position = 'absolute';
	                ifr.style.width = ifr.style.height = ifr.borderWidth = '0px';

	                adalFrame = document.getElementsByTagName('body')[0].appendChild(ifr);
	            }
	            else if (document.body && document.body.insertAdjacentHTML) {
	                document.body.insertAdjacentHTML('beforeEnd', '<iframe name="' + iframeId + '" id="' + iframeId + '" style="display:none"></iframe>');
	            }
	            if (window.frames && window.frames[iframeId]) {
	                adalFrame = window.frames[iframeId];
	            }
	        }

	        return adalFrame;
	    };

	    /**
	     * Saves the key-value pair in the cache
	     * @ignore
	     */
	    AuthenticationContext.prototype._saveItem = function (key, obj, preserve) {

	        if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {

	            if (!this._supportsLocalStorage()) {
	                this.info('Local storage is not supported');
	                return false;
	            }

	            if (preserve) {
	                var value = this._getItem(key) || '';
	                localStorage.setItem(key, value + obj + this.CONSTANTS.CACHE_DELIMETER);
	            }
	            else {
	                localStorage.setItem(key, obj);
	            }

	            return true;
	        }

	        // Default as session storage
	        if (!this._supportsSessionStorage()) {
	            this.info('Session storage is not supported');
	            return false;
	        }

	        sessionStorage.setItem(key, obj);
	        return true;
	    };

	    /**
	     * Searches the value for the given key in the cache
	     * @ignore
	     */
	    AuthenticationContext.prototype._getItem = function (key) {

	        if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {

	            if (!this._supportsLocalStorage()) {
	                this.info('Local storage is not supported');
	                return null;
	            }

	            return localStorage.getItem(key);
	        }

	        // Default as session storage
	        if (!this._supportsSessionStorage()) {
	            this.info('Session storage is not supported');
	            return null;
	        }

	        return sessionStorage.getItem(key);
	    };

	    /**
	     * Returns true if browser supports localStorage, false otherwise.
	     * @ignore
	     */
	    AuthenticationContext.prototype._supportsLocalStorage = function () {
	        try {
	            if (!window.localStorage) return false; // Test availability
	            window.localStorage.setItem('storageTest', 'A'); // Try write
	            if (window.localStorage.getItem('storageTest') != 'A') return false; // Test read/write
	            window.localStorage.removeItem('storageTest'); // Try delete
	            if (window.localStorage.getItem('storageTest')) return false; // Test delete
	            return true; // Success
	        } catch (e) {
	            return false;
	        }
	    };

	    /**
	     * Returns true if browser supports sessionStorage, false otherwise.
	     * @ignore
	     */
	    AuthenticationContext.prototype._supportsSessionStorage = function () {
	        try {
	            if (!window.sessionStorage) return false; // Test availability
	            window.sessionStorage.setItem('storageTest', 'A'); // Try write
	            if (window.sessionStorage.getItem('storageTest') != 'A') return false; // Test read/write
	            window.sessionStorage.removeItem('storageTest'); // Try delete
	            if (window.sessionStorage.getItem('storageTest')) return false; // Test delete
	            return true; // Success
	        } catch (e) {
	            return false;
	        }
	    };

	    /**
	     * Returns a cloned copy of the passed object.
	     * @ignore
	     */
	    AuthenticationContext.prototype._cloneConfig = function (obj) {
	        if (null === obj || 'object' !== typeof obj) {
	            return obj;
	        }

	        var copy = {};
	        for (var attr in obj) {
	            if (obj.hasOwnProperty(attr)) {
	                copy[attr] = obj[attr];
	            }
	        }
	        return copy;
	    };

	    /**
	     * Adds the library version and returns it.
	     * @ignore
	     */
	    AuthenticationContext.prototype._addLibMetadata = function () {
	        // x-client-SKU
	        // x-client-Ver
	        return '&x-client-SKU=Js&x-client-Ver=' + this._libVersion();
	    };

	    /**
	     * Checks the Logging Level, constructs the Log message and logs it. Users need to implement/override this method to turn on Logging. 
	     * @param {number} level  -  Level can be set 0,1,2 and 3 which turns on 'error', 'warning', 'info' or 'verbose' level logging respectively.
	     * @param {string} message  -  Message to log.
	     * @param {string} error  -  Error to log.
	     */
	    AuthenticationContext.prototype.log = function (level, message, error, containsPii) {

	        if (level <= Logging.level) {

	            if (!Logging.piiLoggingEnabled && containsPii)
	                return;

	            var timestamp = new Date().toUTCString();
	            var formattedMessage = '';

	            if (this.config.correlationId)
	                formattedMessage = timestamp + ':' + this.config.correlationId + '-' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;
	            else
	                formattedMessage = timestamp + ':' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;

	            if (error) {
	                formattedMessage += '\nstack:\n' + error.stack;
	            }

	            Logging.log(formattedMessage);
	        }
	    };

	    /**
	     * Logs messages when Logging Level is set to 0.
	     * @param {string} message  -  Message to log.
	     * @param {string} error  -  Error to log.
	     */
	    AuthenticationContext.prototype.error = function (message, error) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR, message, error);
	    };

	    /**
	     * Logs messages when Logging Level is set to 1.
	     * @param {string} message  -  Message to log.
	     */
	    AuthenticationContext.prototype.warn = function (message) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.WARN, message, null);
	    };

	    /**
	     * Logs messages when Logging Level is set to 2.
	     * @param {string} message  -  Message to log.
	     */
	    AuthenticationContext.prototype.info = function (message) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.INFO, message, null);
	    };

	    /**
	     * Logs messages when Logging Level is set to 3.
	     * @param {string} message  -  Message to log.
	     */
	    AuthenticationContext.prototype.verbose = function (message) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE, message, null);
	    };

	    /**
	    * Logs Pii messages when Logging Level is set to 0 and window.piiLoggingEnabled is set to true.
	    * @param {string} message  -  Message to log.
	    * @param {string} error  -  Error to log.
	    */
	    AuthenticationContext.prototype.errorPii = function (message, error) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR, message, error, true);
	    };

	    /**
	     * Logs  Pii messages when Logging Level is set to 1 and window.piiLoggingEnabled is set to true.
	     * @param {string} message  -  Message to log.
	     */
	    AuthenticationContext.prototype.warnPii = function (message) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.WARN, message, null, true);
	    };

	    /**
	     * Logs messages when Logging Level is set to 2 and window.piiLoggingEnabled is set to true.
	     * @param {string} message  -  Message to log.
	     */
	    AuthenticationContext.prototype.infoPii = function (message) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.INFO, message, null, true);
	    };

	    /**
	     * Logs messages when Logging Level is set to 3 and window.piiLoggingEnabled is set to true.
	     * @param {string} message  -  Message to log.
	     */
	    AuthenticationContext.prototype.verbosePii = function (message) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE, message, null, true);
	    };
	    /**
	     * Returns the library version.
	     * @ignore
	     */
	    AuthenticationContext.prototype._libVersion = function () {
	        return '1.0.18';
	    };

	    /**
	     * Returns a reference of Authentication Context as a result of a require call.
	     * @ignore
	     */
	    if ( module.exports) {
	        module.exports = AuthenticationContext;
	        module.exports.inject = function (conf) {
	            return new AuthenticationContext(conf);
	        };
	    }

	    return AuthenticationContext;

	}());
	});
	var adal_1 = adal.inject;

	/**
	 * The code was extracted from:
	 * https://github.com/davidchambers/Base64.js
	 */

	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	function InvalidCharacterError(message) {
	  this.message = message;
	}

	InvalidCharacterError.prototype = new Error();
	InvalidCharacterError.prototype.name = 'InvalidCharacterError';

	function polyfill (input) {
	  var str = String(input).replace(/=+$/, '');
	  if (str.length % 4 == 1) {
	    throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
	  }
	  for (
	    // initialize result and counters
	    var bc = 0, bs, buffer, idx = 0, output = '';
	    // get next character
	    buffer = str.charAt(idx++);
	    // character found in table? initialize bit storage and add its ascii value;
	    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
	      // and if not first of each 4 characters,
	      // convert the first 8 bits to one ascii character
	      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
	  ) {
	    // try to find character in table (0-63, not found => -1)
	    buffer = chars.indexOf(buffer);
	  }
	  return output;
	}


	var atob = typeof window !== 'undefined' && window.atob && window.atob.bind(window) || polyfill;

	function b64DecodeUnicode(str) {
	  return decodeURIComponent(atob(str).replace(/(.)/g, function (m, p) {
	    var code = p.charCodeAt(0).toString(16).toUpperCase();
	    if (code.length < 2) {
	      code = '0' + code;
	    }
	    return '%' + code;
	  }));
	}

	var base64_url_decode = function(str) {
	  var output = str.replace(/-/g, "+").replace(/_/g, "/");
	  switch (output.length % 4) {
	    case 0:
	      break;
	    case 2:
	      output += "==";
	      break;
	    case 3:
	      output += "=";
	      break;
	    default:
	      throw "Illegal base64url string!";
	  }

	  try{
	    return b64DecodeUnicode(output);
	  } catch (err) {
	    return atob(output);
	  }
	};

	function InvalidTokenError(message) {
	  this.message = message;
	}

	InvalidTokenError.prototype = new Error();
	InvalidTokenError.prototype.name = 'InvalidTokenError';

	var lib = function (token,options) {
	  if (typeof token !== 'string') {
	    throw new InvalidTokenError('Invalid token specified');
	  }

	  options = options || {};
	  var pos = options.header === true ? 0 : 1;
	  try {
	    return JSON.parse(base64_url_decode(token.split('.')[pos]));
	  } catch (e) {
	    throw new InvalidTokenError('Invalid token specified: ' + e.message);
	  }
	};

	var InvalidTokenError_1 = InvalidTokenError;
	lib.InvalidTokenError = InvalidTokenError_1;

	/**
	 * A manager for the map control's authentication.
	 * Exposed through the authentication property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var AuthenticationManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function AuthenticationManager(map) {
	        var _this = this;
	        /**
	         * A static fallback storage for when localStorage and sessionStorage are unavailable.
	         */
	        this.fallbackStorage = {};
	        /**
	         * Triggers the user provided function to fetch the token and stores it.
	         * @internal
	         */
	        this._triggerTokenFetch = function () {
	            return new Promise(function (resolve, reject) {
	                _this.options.getToken(function (token) {
	                    try {
	                        // Try to get the timeout first as this will guarantee the token is correctly formatted.
	                        var timeout = _this._getTokenExpiry(token) - AuthenticationManager.constants.tokenRefreshClockSkew;
	                        _this._storeAccessToken(token);
	                        clearTimeout(_this.tokenTimeOutHandle); // Clear the previous refresh timeout in case it hadn't triggered yet.
	                        // @ts-ignore
	                        _this.tokenTimeOutHandle = setTimeout(_this._triggerTokenFetch, timeout * 1000);
	                        resolve();
	                    }
	                    catch (_a) {
	                        reject(new Error("Invalid token returned by getToken function"));
	                    }
	                }, function (error) {
	                    reject(error);
	                }, _this.map);
	            });
	        };
	        var serviceOptions = map.getServiceOptions();
	        this.options = serviceOptions.authOptions;
	        this.sessionId = serviceOptions.sessionId;
	        this.map = map;
	    }
	    /**
	     * Initializes the authentication mechanism specified in AuthenticationOptions.
	     * If this method has been called before the original initialize promise is returned.
	     */
	    AuthenticationManager.prototype.initialize = function () {
	        var _this = this;
	        if (!this.initPromise) {
	            // If an init promise hasn't been created this is the first initialize call.
	            this.initPromise = new Promise(function (resolve, reject) {
	                if (_this.options.authType === exports.AuthenticationType.subscriptionKey) {
	                    resolve();
	                }
	                else if (_this.options.authType === exports.AuthenticationType.aad) {
	                    // If a specific auth context was provided to the map use that.
	                    // If not use/create a default auth context shared between maps.
	                    _this.options.authContext = _this.options.authContext ||
	                        AuthenticationManager.getDefaultAuthContext(_this.options);
	                    // If this window is a callback then it is the hidden iframe created by ADAL.
	                    // The map doesn't need to finish constructing, so we can dispose it.
	                    _this.options.authContext.handleWindowCallback();
	                    if (_this.options.authContext.getLoginError()) {
	                        reject(new Error("Error logging in the AAD users: " +
	                            _this.options.authContext.getLoginError()));
	                        return;
	                    }
	                    if (_this.options.authContext.isCallback(window.location.hash)) {
	                        _this.map.dispose();
	                        return;
	                    }
	                    // Login and acquire a token.
	                    // Fire it async so that users can add any listeners for token acquire events first.
	                    setTimeout(function () { return _this._loginAndAcquire(resolve, reject); });
	                }
	                else if (_this.options.authType === exports.AuthenticationType.anonymous) {
	                    // Anonymous authentication, just call the users provided callback.
	                    resolve(_this._triggerTokenFetch());
	                }
	                else {
	                    reject(new Error("An invalid authentication type was specified."));
	                }
	            });
	        }
	        return this.initPromise;
	    };
	    /**
	     * Gets the default auth context to be shared between maps without one specified to them.
	     */
	    AuthenticationManager.getDefaultAuthContext = function (options) {
	        if (!options.aadAppId) {
	            throw new Error("No AAD app ID was specified.");
	        }
	        if (!options.aadTenant) {
	            throw new Error("No AAD tenant was specified.");
	        }
	        // Create a new auth context if one doesn't already exist.
	        if (!this.defaultAuthContext) {
	            this.defaultAuthContext = new adal({
	                instance: options.aadInstance || env.aadInstance,
	                tenant: options.aadTenant,
	                clientId: options.aadAppId,
	                cacheLocation: this.constants.preferredCacheLocation
	            });
	        }
	        // Return either a reused auth context or the one created just above.
	        return this.defaultAuthContext;
	    };
	    /**
	     * The login callback function, called after user interactive login session is completed
	     * @param resolve the resolve callback for the promise created from the initialize call
	     */
	    AuthenticationManager.prototype._loginAndAcquire = function (resolve, reject) {
	        var _this = this;
	        var acquireAndResolve = function () {
	            // Check that we can acquire a token and then resolve the promise.
	            // Reject if an error occurs when acquiring the token.
	            _this.options.authContext.acquireToken(constants.resourceId, function (error) {
	                if (error) {
	                    reject(new Error(error));
	                }
	                else {
	                    var tokenEvent = {
	                        map: _this.map,
	                        type: AuthenticationManager.constants.events.tokenAcquired
	                    };
	                    _this.map.events.invoke(AuthenticationManager.constants.events.tokenAcquired, tokenEvent);
	                    resolve();
	                }
	            });
	        };
	        var cachedToken = this.options.authContext.getCachedToken(this.options.aadAppId);
	        var cachedUser = this.options.authContext.getCachedUser();
	        if (cachedToken && cachedUser) {
	            // If a cached token and user are available we should be able to
	            // acquire the access token and then resolve the promise.
	            acquireAndResolve();
	        }
	        else {
	            // If a login isn't already in progress start a new one.
	            if (!this.options.authContext.loginInProgress()) {
	                this.options.authContext.login();
	            }
	            // Poll for when the login done and then use the cached token.
	            var loginPoll_1 = setInterval(function () {
	                if (!_this.options.authContext.loginInProgress()) {
	                    // Stop polling for login done.
	                    clearInterval(loginPoll_1);
	                    if (_this.options.authContext.getCachedToken(_this.options.aadAppId)) {
	                        // If a token for the specified AAD app id is available we are ready
	                        // to acquire the access token and resolve the init promise.
	                        acquireAndResolve();
	                    }
	                    else {
	                        // If done logging in but no token for the specified AAD app ID is cached
	                        // then there is a mistake in the auth context config.
	                        reject(new Error(_this.options.authContext.getLoginError() ||
	                            "The AAD authentication context is not logged-in for the specified app ID: " +
	                                _this.options.aadAppId));
	                    }
	                }
	            }, 25);
	        }
	    };
	    /**
	     * Returns the current authentication type in use.
	     */
	    AuthenticationManager.prototype.getAuthType = function () {
	        return this.options.authType;
	    };
	    /**
	     * Returns the current client ID in use.
	     */
	    AuthenticationManager.prototype.getClientId = function () {
	        return this.options.clientId;
	    };
	    /**
	     * Returns the access token with an audience URI of https://atlas.microsoft.com.
	     */
	    AuthenticationManager.prototype.getToken = function () {
	        var _this = this;
	        if (this.options.authType === exports.AuthenticationType.aad) {
	            var token_1 = this.options.authContext.getCachedToken(constants.resourceId);
	            if (!token_1) {
	                if (!this.options.authContext.getCachedUser()) {
	                    // Login if a user isn't cached. This shouldn't typically happen.
	                    this.options.authContext.login();
	                }
	                this.options.authContext.acquireToken(constants.resourceId, function (error, renewedToken) {
	                    if (!error) {
	                        token_1 = renewedToken;
	                        var tokenEvent = {
	                            map: _this.map,
	                            type: AuthenticationManager.constants.events.tokenAcquired
	                        };
	                        _this.map.events.invoke(AuthenticationManager.constants.events.tokenAcquired, tokenEvent);
	                    }
	                });
	            }
	            return token_1;
	        }
	        else if (this.options.authType === exports.AuthenticationType.anonymous) {
	            var token = this._getItem(AuthenticationManager.constants.storage.accessTokenKey);
	            if (!token) {
	                // Cached Token not present, invoke the user provided callback function to fetch function
	                this._triggerTokenFetch();
	            }
	            else {
	                // check for cached token validity
	                var expiresIn = this._getTokenExpiry(token);
	                if (expiresIn < 300 && expiresIn > 0) {
	                    // We are within a window for the token expiry,
	                    // trigger a new token fetch, but still return the current token
	                    this._triggerTokenFetch();
	                }
	                else if (expiresIn <= 0) {
	                    // token renew failed and dont have a token.
	                    this._saveItem(AuthenticationManager.constants.storage.accessTokenKey, "");
	                    throw new Error(AuthenticationManager.constants.errors.tokenExpired);
	                }
	            }
	            return token;
	        }
	        else if (this.options.authType === exports.AuthenticationType.subscriptionKey) {
	            return this.options.subscriptionKey;
	        }
	    };
	    /**
	     * Given a token, calculate the time left for token expiry
	     * @param token
	     * @internal
	     */
	    AuthenticationManager.prototype._getTokenExpiry = function (token) {
	        var decodedToken = lib(token);
	        var expiresIn = decodedToken.exp;
	        var now = this._getCurrentTime();
	        return expiresIn - now > 0 ? expiresIn - now : -1;
	    };
	    /**
	     * stores the token
	     * @param token token fetched from the user's server endpoint
	     * @internal
	     */
	    AuthenticationManager.prototype._storeAccessToken = function (token) {
	        // Store the value
	        this._saveItem(AuthenticationManager.constants.storage.accessTokenKey, token);
	        var tokenEvent = {
	            map: this.map,
	            type: AuthenticationManager.constants.events.tokenAcquired
	        };
	        this.map.events.invoke(AuthenticationManager.constants.events.tokenAcquired, tokenEvent);
	    };
	    /**
	     * Saves the item to storage
	     * @param key key/identifier
	     * @param value value to be stored
	     */
	    AuthenticationManager.prototype._saveItem = function (key, value) {
	        if (this._supportsLocalStorage()) {
	            localStorage.setItem(key, value);
	            return true;
	        }
	        else if (this._supportsSessionStorage()) {
	            sessionStorage.setItem(key, value);
	            return true;
	        }
	        else {
	            this.fallbackStorage[key] = value;
	            return true;
	        }
	    };
	    /**
	     * Gets an item saved in storage
	     * @param key Key/Identifier to be used for lookup
	     */
	    AuthenticationManager.prototype._getItem = function (key) {
	        if (this._supportsLocalStorage()) {
	            return localStorage.getItem(key);
	        }
	        else if (this._supportsSessionStorage()) {
	            return sessionStorage.getItem(key);
	        }
	        else if (key in this.fallbackStorage) {
	            return this.fallbackStorage[key];
	        }
	        return null;
	    };
	    /**
	     * Returns true if browser supports localStorage, false otherwise.
	     * @ignore
	     */
	    AuthenticationManager.prototype._supportsLocalStorage = function () {
	        try {
	            if (!window.localStorage) {
	                return false;
	            } // Test availability
	            window.localStorage.setItem(AuthenticationManager.constants.storage.testStorageKey, "A"); // Try write
	            if (window.localStorage.getItem(AuthenticationManager.constants.storage.testStorageKey) !== "A") {
	                return false;
	            } // Test read/write
	            window.localStorage.removeItem(AuthenticationManager.constants.storage.testStorageKey); // Try delete
	            if (window.localStorage.getItem(AuthenticationManager.constants.storage.testStorageKey)) {
	                return false;
	            } // Test delete
	            return true; // Success
	        }
	        catch (e) {
	            return false;
	        }
	    };
	    /**
	     * Returns true if browser supports sessionStorage, false otherwise.
	     * @ignore
	     */
	    AuthenticationManager.prototype._supportsSessionStorage = function () {
	        try {
	            if (!window.sessionStorage) {
	                return false;
	            } // Test availability
	            window.sessionStorage.setItem(AuthenticationManager.constants.storage.testStorageKey, "A"); // Try write
	            if (window.sessionStorage.getItem(AuthenticationManager.constants.storage.testStorageKey) !== "A") {
	                return false;
	            } // Test read/write
	            window.sessionStorage.removeItem(AuthenticationManager.constants.storage.testStorageKey); // Try delete
	            if (window.sessionStorage.getItem(AuthenticationManager.constants.storage.testStorageKey)) {
	                return false;
	            } // Test delete
	            return true; // Success
	        }
	        catch (e) {
	            return false;
	        }
	    };
	    /**
	     * Return the number of milliseconds since 1970/01/01
	     * @ignore
	     */
	    AuthenticationManager.prototype._getCurrentTime = function () {
	        return Math.round(new Date().getTime() / 1000.0);
	    };
	    AuthenticationManager.prototype.signRequest = function (request) {
	        // Add the headers used for identifying a request is from the map control.
	        request.headers = request.headers || {};
	        request.headers[constants.sessionIdHeaderName] = this.sessionId;
	        request.headers[constants.msOriginHeaderName] = constants.msOriginHeaderValue;
	        request.headers[constants.mapAgentHeaderName] = "MapControl/" + version + " (Web)";
	        var token = this.getToken();
	        switch (this.options.authType) {
	            case exports.AuthenticationType.aad:
	            case exports.AuthenticationType.anonymous:
	                request.headers[constants.msClientIdHeaderName] = this.options.clientId;
	                request.headers[constants.authorizationHeaderName] = constants.authorizationTokenPrefix + token;
	                break;
	            case exports.AuthenticationType.subscriptionKey:
	                if ("url" in request) {
	                    if (request.url.indexOf("?") !== -1) {
	                        request.url += "&subscription-key=" + token;
	                    }
	                    else {
	                        request.url += "?&subscription-key=" + token;
	                    }
	                }
	                else if ("domain" in request) {
	                    request.queryParams = request.queryParams || {};
	                    request.queryParams["subscription-key"] = token;
	                }
	                else {
	                    throw new Error("Could not determine if the provided object was UrlOptions or RequestParameters");
	                }
	                break;
	            default:
	                throw new Error("An invalid authentication type was specified");
	        }
	        return request;
	    };
	    /**
	     * Constants for internal use
	     */
	    AuthenticationManager.constants = {
	        // Enable localStorage for IE, as sessionStorage does not work for localhost.
	        preferredCacheLocation: "localStorage",
	        storage: {
	            accessTokenKey: "access.token.key",
	            testStorageKey: "testStorage"
	        },
	        events: {
	            tokenAcquired: "tokenacquired"
	        },
	        tokenExpiresIn: 3599,
	        tokenRefreshClockSkew: 300,
	        errors: {
	            tokenExpired: "Token Expired, Try again"
	        }
	    };
	    return AuthenticationManager;
	}());

	/**
	 * A manager for the map control's controls.
	 * Exposed through the controls property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var ControlManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function ControlManager(map) {
	        this.map = map;
	        // Add containers for map controls
	        this.controlContainer = document.createElement("div");
	        this.controlContainer.classList.add("atlas-control-container");
	        for (var controlPosition in exports.ControlPosition) {
	            if (exports.ControlPosition.hasOwnProperty(controlPosition)) {
	                var subcontrolContainer = document.createElement("div");
	                subcontrolContainer.classList.add(exports.ControlPosition[controlPosition]);
	                subcontrolContainer.classList.add("subcontrol-container");
	                this.controlContainer.appendChild(subcontrolContainer);
	            }
	        }
	        this.map.getMapContainer().appendChild(this.controlContainer);
	        this.controls = new Set();
	    }
	    /**
	     * Add a control(s) to the map.
	     * @param control The control to add.
	     * @param options The options for the added control.
	     */
	    ControlManager.prototype.add = function (control, options) {
	        var e_1, _a;
	        if (Array.isArray(control)) {
	            try {
	                for (var control_1 = __values(control), control_1_1 = control_1.next(); !control_1_1.done; control_1_1 = control_1.next()) {
	                    var c = control_1_1.value;
	                    this._add(c, options);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (control_1_1 && !control_1_1.done && (_a = control_1.return)) _a.call(control_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this._add(control, options);
	        }
	    };
	    /**
	     * Gets an array of all controls on the map
	     */
	    ControlManager.prototype.getControls = function () {
	        return Array.from(this.controls);
	    };
	    /**
	     * Remove a control(s) from the map.
	     * @param control The control to remove.
	     */
	    ControlManager.prototype.remove = function (control) {
	        var e_2, _a;
	        if (Array.isArray(control)) {
	            try {
	                for (var control_2 = __values(control), control_2_1 = control_2.next(); !control_2_1.done; control_2_1 = control_2.next()) {
	                    var c = control_2_1.value;
	                    this._remove(c);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (control_2_1 && !control_2_1.done && (_a = control_2.return)) _a.call(control_2);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        else {
	            this._remove(control);
	        }
	    };
	    /**
	     * Add a control from the map.
	     * @internal
	     */
	    ControlManager.prototype._add = function (control, options) {
	        this.controls.add(control);
	        var controlOptions = new ControlOptions().merge(options);
	        var controlHtml = control.onAdd(this.map, options);
	        var subcontrolContainers = this.controlContainer.getElementsByClassName(controlOptions.position);
	        if (subcontrolContainers.length > 0) {
	            subcontrolContainers.item(0).appendChild(controlHtml);
	        }
	        else {
	            throw new Error("Control position " + controlOptions.position + " does not exist.");
	        }
	    };
	    /**
	     * Remove a control from the map.
	     * @internal
	     */
	    ControlManager.prototype._remove = function (control) {
	        control.onRemove();
	        this.controls.delete(control);
	    };
	    return ControlManager;
	}());

	/**
	 * @private
	 */
	var MapCallbackHandler = /** @class */ (function () {
	    function MapCallbackHandler(map) {
	        // Dictionary keys represent the following: layer name -> event type -> user callback => [modified callback, once].
	        this.callbacks = new Dictionary();
	        this.map = map;
	    }
	    MapCallbackHandler.prototype.addCallback = function (eventType, layer, callback, legacy, once) {
	        var _this = this;
	        var modifiedCallback;
	        // If using legacy callbacks provide a MapEventData object to the user's callback
	        // Legacy callbacks cannot be added as once handles, so we don't need any logic for the once case.
	        if (legacy) {
	            modifiedCallback = function (data) {
	                var position = (data.lngLat) ?
	                    new Position(data.lngLat.lng, data.lngLat.lat) :
	                    undefined;
	                var coordinate = (data.point) ?
	                    [data.point.x, data.point.y] :
	                    undefined;
	                var features = (data.features) ?
	                    data.features.map(function (f) { return new Feature(f.geometry, f.properties, f.id); }) :
	                    [];
	                var mapEventData = {
	                    type: data.type,
	                    originalEvent: data.originalEvent,
	                    position: position,
	                    coordinate: coordinate,
	                    features: features
	                };
	                callback(mapEventData);
	            };
	        }
	        else {
	            var lastOriginalEvent_1;
	            switch (eventType) {
	                case "data":
	                case "sourcedata":
	                case "styledata":
	                    modifiedCallback = function (data) {
	                        var mapEventData = __assign(__assign({ dataType: data.dataType }, (data.dataType === "source" && __assign(__assign(__assign({ isSourceLoaded: data.isSourceLoaded }, (data.sourceDataType && { sourceDataType: data.sourceDataType })), { source: _this.map.sources.getById(data.sourceId) }), (data.tile && {
	                            tile: {
	                                id: {
	                                    x: data.tile.tileID.canonical.x,
	                                    y: data.tile.tileID.canonical.y,
	                                    z: data.tile.tileID.canonical.z
	                                },
	                                size: data.tile.tileSize,
	                                state: data.tile.state
	                            }
	                        })))), { map: _this.map, type: data.type });
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "error":
	                    modifiedCallback = function (data) {
	                        var mapEventData = {
	                            error: data.error,
	                            map: _this.map,
	                            type: data.type
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "touchstart":
	                case "touchend":
	                case "touchmove":
	                case "touchcancel":
	                    modifiedCallback = function (data) {
	                        // Check if this callback was just called for the originating event.
	                        // If so return to prevent multiple callback calls for layers which build multiple mapbox layers.
	                        if (data.originalEvent) {
	                            if (data.originalEvent !== lastOriginalEvent_1) {
	                                lastOriginalEvent_1 = data.originalEvent;
	                            }
	                            else {
	                                return;
	                            }
	                        }
	                        var pixel = (data.point) ?
	                            new Pixel(data.point.x, data.point.y) :
	                            undefined;
	                        var pixels = (data.points) ?
	                            data.points.map(function (p) { return new Pixel(p.x, p.y); }) :
	                            [];
	                        var position = (data.lngLat) ?
	                            new Position(data.lngLat.lng, data.lngLat.lat) :
	                            undefined;
	                        var positions = (data.lngLats) ?
	                            data.lngLats.map(function (l) { return new Position(l.lng, l.lat); }) :
	                            [];
	                        var shapes = position ?
	                            _this.map.layers.getRenderedShapes(new Point(position), layer ? [layer] : undefined) :
	                            [];
	                        var mapEventData = {
	                            map: _this.map,
	                            originalEvent: data.originalEvent,
	                            pixel: pixel,
	                            pixels: pixels,
	                            position: position,
	                            positions: positions,
	                            shapes: shapes,
	                            layerId: layer || undefined,
	                            preventDefault: function () { return data.preventDefault(); },
	                            type: data.type,
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "mousedown":
	                case "mouseup":
	                case "mouseover":
	                case "mousemove":
	                case "click":
	                case "dblclick":
	                case "mouseout":
	                case "mouseenter":
	                case "mouseleave":
	                case "contextmenu":
	                    modifiedCallback = function (data) {
	                        // Check if this callback was just called for the originating event.
	                        // If so return to prevent multiple callback calls for layers which build multiple mapbox layers.
	                        if (data.originalEvent) {
	                            if (data.originalEvent !== lastOriginalEvent_1) {
	                                lastOriginalEvent_1 = data.originalEvent;
	                            }
	                            else {
	                                return;
	                            }
	                        }
	                        var position = (data.lngLat) ?
	                            new Position(data.lngLat.lng, data.lngLat.lat) :
	                            undefined;
	                        var pixel = (data.point) ?
	                            new Pixel(data.point.x, data.point.y) :
	                            undefined;
	                        var shapes = position ?
	                            _this.map.layers.getRenderedShapes(new Point(position), layer ? [layer] : undefined) :
	                            [];
	                        var mapEventData = {
	                            map: _this.map,
	                            originalEvent: data.originalEvent,
	                            position: position,
	                            pixel: pixel,
	                            preventDefault: function () { return data.preventDefault(); },
	                            shapes: shapes,
	                            layerId: layer || undefined,
	                            type: data.type
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "styleimagemissing":
	                    modifiedCallback = function (data) {
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(data.id);
	                    };
	                    break;
	                case "wheel":
	                    modifiedCallback = function (data) {
	                        // Check if this callback was just called for the originating event.
	                        // If so return to prevent multiple callback calls for layers which build multiple mapbox layers.
	                        if (data.originalEvent) {
	                            if (data.originalEvent !== lastOriginalEvent_1) {
	                                lastOriginalEvent_1 = data.originalEvent;
	                            }
	                            else {
	                                return;
	                            }
	                        }
	                        var mapEventData = {
	                            map: _this.map,
	                            originalEvent: data.originalEvent,
	                            preventDefault: function () { return data.preventDefault(); },
	                            type: data.type,
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "resize":
	                    // The resize event is technically one of the default callback types.
	                    // However, since users can specify custom eventData to add to the resize event
	                    // we need to make sure to include that in our modified callback.
	                    modifiedCallback = function (data) {
	                        var mapEventData = {
	                            map: _this.map,
	                            type: data.type
	                        };
	                        // Add any extra properties to the modified callback data.
	                        // Skip the "type" and "target" properties as these are
	                        // replaced by the "type" and "map" properties above.
	                        for (var prop in data) {
	                            if (prop !== "type" && prop !== "target") {
	                                mapEventData[prop] = data[prop];
	                            }
	                        }
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                default:
	                    modifiedCallback = function (data) {
	                        var mapEventData = {
	                            map: _this.map,
	                            type: data.type
	                        };
	                        // Not every event will have an originalEvent property.
	                        // Only add this properties to our modified callback's data if it will be defined.
	                        if (data.originalEvent) {
	                            mapEventData.originalEvent = data.originalEvent;
	                        }
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	            }
	        }
	        // Add an empty dictionary for the specified layer if one doesn't already exist.
	        if (!this.callbacks.has(layer)) {
	            this.callbacks.set(layer, new Dictionary());
	        }
	        // Add an empty dictionary for the specified event type if one doesn't already exist.
	        if (!this.callbacks.get(layer).has(eventType)) {
	            this.callbacks.get(layer).set(eventType, new Map());
	        }
	        this.callbacks.get(layer).get(eventType).set(callback, [modifiedCallback, once]);
	    };
	    MapCallbackHandler.prototype.removeCallback = function (eventType, layer, callback) {
	        if (this.callbacks.has(layer) &&
	            this.callbacks.get(layer).has(eventType) &&
	            this.callbacks.get(layer).get(eventType).has(callback)) {
	            this.callbacks.get(layer).get(eventType).delete(callback);
	        }
	    };
	    MapCallbackHandler.prototype.getModifiedCallback = function (eventType, layer, callback) {
	        if (this.callbacks.has(layer) &&
	            this.callbacks.get(layer).has(eventType) &&
	            this.callbacks.get(layer).get(eventType).has(callback)) {
	            return this.callbacks.get(layer).get(eventType).get(callback)[0];
	        }
	        return undefined;
	    };
	    MapCallbackHandler.prototype.getLayerCallbacks = function (layer) {
	        if (this.callbacks.has(layer)) {
	            return this.callbacks.get(layer);
	        }
	        return undefined;
	    };
	    MapCallbackHandler.prototype.getEventCallbacks = function (eventType, layer) {
	        if (this.callbacks.has(layer)) {
	            var layerCallbacks = this.callbacks.get(layer);
	            if (layerCallbacks.has(eventType)) {
	                return layerCallbacks.get(eventType);
	            }
	        }
	        return undefined;
	    };
	    return MapCallbackHandler;
	}());

	// Disable unified signatures linter rule so we can generate separate docs for function overloads.
	// tslint:disable:unified-signatures
	/**
	 * A manager for the map control's events.
	 * Exposed through the events property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var EventManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function EventManager(map) {
	        this.map = map;
	        this.mapCallbackHandler = new MapCallbackHandler(this.map);
	    }
	    EventManager.prototype.add = function (eventType, targetOrCallback, callback) {
	        var e_1, _a;
	        if (typeof targetOrCallback === "function") {
	            this._addGlobalListener(eventType, targetOrCallback, false, false);
	        }
	        else {
	            targetOrCallback = Array.isArray(targetOrCallback) ? targetOrCallback : [targetOrCallback];
	            try {
	                for (var targetOrCallback_1 = __values(targetOrCallback), targetOrCallback_1_1 = targetOrCallback_1.next(); !targetOrCallback_1_1.done; targetOrCallback_1_1 = targetOrCallback_1.next()) {
	                    var target = targetOrCallback_1_1.value;
	                    if (target instanceof Layer && Layer._isMBoxEvent(eventType)) {
	                        this._addLayerListener(eventType, target, callback, false, false);
	                    }
	                    else {
	                        target._addEventListener(eventType, callback, false);
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (targetOrCallback_1_1 && !targetOrCallback_1_1.done && (_a = targetOrCallback_1.return)) _a.call(targetOrCallback_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	    };
	    EventManager.prototype.addOnce = function (eventType, targetOrCallback, callback) {
	        if (typeof targetOrCallback === "function") {
	            this._addGlobalListener(eventType, targetOrCallback, false, true);
	        }
	        else if (targetOrCallback instanceof Layer && Layer._isMBoxEvent(eventType)) {
	            this._addLayerListener(eventType, targetOrCallback, callback, false, true);
	        }
	        else {
	            targetOrCallback._addEventListener(eventType, callback, true);
	        }
	    };
	    EventManager.prototype._addLegacy = function (eventType, targetOrCallback, callback) {
	        if (typeof targetOrCallback === "function") {
	            this._addGlobalListener(eventType, targetOrCallback, true, false);
	        }
	        else {
	            this._addLayerListener(eventType, targetOrCallback, callback, true, false);
	        }
	    };
	    /**
	     * Adds a listener to a single layer. Will add the event listeners to the layer's underlying Mapbox layers too.
	     * @private
	     */
	    EventManager.prototype._addLayerListener = function (eventType, target, callback, legacy, once) {
	        var e_2, _a, e_3, _b;
	        var layerId = target instanceof Layer ? target.getId() : target;
	        var layer = this.map.layers.getLayerById(layerId);
	        var modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, layerId, callback);
	        // If a callback already exists disable it so the new one can replace it.
	        // Must disable it on every Mapbox layer our layer builds.
	        if (modifiedCallback && layer) {
	            try {
	                for (var _c = __values(layer._getLayerIds()), _d = _c.next(); !_d.done; _d = _c.next()) {
	                    var id = _d.value;
	                    this.map._getMap().off(eventType, id, modifiedCallback);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        // Get a new modified callback.
	        this.mapCallbackHandler.addCallback(eventType, layerId, callback, legacy, once);
	        // If the layer already exists on the map immediately add the callbacks.
	        // Otherwise the callbacks will be added once the layer is added to the map.
	        if (layer) {
	            modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, layerId, callback);
	            try {
	                for (var _e = __values(layer._getLayerIds()), _f = _e.next(); !_f.done; _f = _e.next()) {
	                    var id = _f.value;
	                    this.map._getMap().on(eventType, id, modifiedCallback);
	                }
	            }
	            catch (e_3_1) { e_3 = { error: e_3_1 }; }
	            finally {
	                try {
	                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
	                }
	                finally { if (e_3) throw e_3.error; }
	            }
	        }
	    };
	    /**
	     * Adds a listener to a single layer. Will add the event listeners to the layer's underlying Mapbox layers too.
	     * @private
	     */
	    EventManager.prototype._addGlobalListener = function (eventType, callback, legacy, once) {
	        var oldModifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, "", callback);
	        // Get a new modified callback.
	        this.mapCallbackHandler.addCallback(eventType, "", callback, legacy, once);
	        var modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, "", callback);
	        // Enable the new modified callback on the Mapbox map.
	        if (eventType === "load" && this.map._isLoaded()) {
	            // Manually execute the callback if the load event has already fired.
	            // Use setTimeout to execute the callback async.
	            // This is for consistency with the case where the load event hasn't already fired.
	            // If the load event hasn't already fired the callback will also be executed async once it does fire.
	            var loadData_1 = { type: "load", map: this.map };
	            setTimeout(function () { return modifiedCallback(loadData_1); });
	        }
	        else if (eventType === "ready") {
	            // The ready event doesn't exist on the Mapbox map.
	            // Don't enable the callback for the Mapbox map.
	            if (this.map._isReady()) {
	                // Manually execute the callback if the ready event has already fired.
	                var readyData_1 = { type: "ready", map: this.map };
	                setTimeout(function () { return modifiedCallback(readyData_1); });
	            }
	        }
	        else if (["minzoomchanged", "maxzoomchanged"].includes(eventType)) {
	            this.map._addEventListener(eventType, callback, once);
	        }
	        else {
	            // If a callback already exists disable it so the new one can replace it.
	            if (oldModifiedCallback) {
	                this.map._getMap().off(eventType, oldModifiedCallback);
	            }
	            this.map._getMap().on(eventType, modifiedCallback);
	        }
	    };
	    EventManager.prototype.invoke = function (eventType, targetOrArgs, args) {
	        // If args is undefined assume there is not target for the event.
	        if (typeof args === "undefined") {
	            // Empty string indicates the map global level.
	            this._invokeListeners(eventType, "", targetOrArgs);
	        }
	        else {
	            if (targetOrArgs instanceof Layer && Layer._isMBoxEvent(eventType)) {
	                this._invokeListeners(eventType, targetOrArgs.getId(), args);
	            }
	            else if (targetOrArgs instanceof EventEmitter) {
	                targetOrArgs._invokeEvent(eventType, args);
	            }
	            else {
	                throw new Error("The invoke target is invalid.");
	            }
	        }
	    };
	    /**
	     * Invokes all listeners for the given event and layer.
	     * @param eventType The event type to invoke.
	     * @param layer The layer to invoke the event for. Use an empty string for map global events.
	     * @param args The data to pass to the listener callbacks.
	     * @private
	     */
	    EventManager.prototype._invokeListeners = function (eventType, layer, args) {
	        var _this = this;
	        var callbacks = this.mapCallbackHandler.getEventCallbacks(eventType, layer);
	        if (callbacks) {
	            callbacks.forEach(function (_a, callback) {
	                var _b = __read(_a, 2), _ = _b[0], once = _b[1];
	                // Invoking a listener this way circumvents the fire once logic in the modified callback.
	                // So we check if the callback was added as a fire once and if so remove it here.
	                if (once) {
	                    _this._removeListener(eventType, layer, callback);
	                }
	                callback(args);
	            });
	        }
	        else if (eventType === "error") {
	            // If there are no user specified callback for the error event print to console.
	            // tslint:disable-next-line:no-console
	            console.error("error" in args ? args.error : args);
	        }
	    };
	    EventManager.prototype.remove = function (eventType, targetOrCallback, callback) {
	        var e_4, _a;
	        if (typeof targetOrCallback === "function") {
	            this._removeListener(eventType, "", targetOrCallback);
	        }
	        else {
	            targetOrCallback = Array.isArray(targetOrCallback) ? targetOrCallback : [targetOrCallback];
	            try {
	                for (var targetOrCallback_2 = __values(targetOrCallback), targetOrCallback_2_1 = targetOrCallback_2.next(); !targetOrCallback_2_1.done; targetOrCallback_2_1 = targetOrCallback_2.next()) {
	                    var target = targetOrCallback_2_1.value;
	                    if (target instanceof Layer && Layer._isMBoxEvent(eventType)) {
	                        this._removeListener(eventType, target, callback);
	                    }
	                    else {
	                        target._removeEventListener(eventType, callback);
	                    }
	                }
	            }
	            catch (e_4_1) { e_4 = { error: e_4_1 }; }
	            finally {
	                try {
	                    if (targetOrCallback_2_1 && !targetOrCallback_2_1.done && (_a = targetOrCallback_2.return)) _a.call(targetOrCallback_2);
	                }
	                finally { if (e_4) throw e_4.error; }
	            }
	        }
	    };
	    EventManager.prototype._removeLegacy = function (eventType, targetOrCallback, callback) {
	        if (typeof targetOrCallback === "function") {
	            this._removeListener(eventType, "", targetOrCallback);
	        }
	        else {
	            this._removeListener(eventType, targetOrCallback, callback);
	        }
	    };
	    /**
	     * Removes a listener from the map or a single layer.
	     * Will remove the event listeners from the layer's underlying Mapbox layers too.
	     * @internal
	     */
	    EventManager.prototype._removeListener = function (eventType, target, callback) {
	        var e_5, _a;
	        var layerId = target instanceof Layer ? target.getId() : target;
	        var modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, layerId, callback);
	        // If a callback already exists disable it so the new one can replace it.
	        if (modifiedCallback) {
	            // An empty layerId indicates the listener is being removed from the global map.
	            if (layerId) {
	                // If a callback already exists disable it so the new one can replace it.
	                // Must disable it on every Mapbox layer our layer builds.
	                var layer = this.map.layers.getLayerById(layerId);
	                if (layer) {
	                    try {
	                        for (var _b = __values(layer._getLayerIds()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                            var id = _c.value;
	                            this.map._getMap().off(eventType, id, modifiedCallback);
	                        }
	                    }
	                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
	                    finally {
	                        try {
	                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                        }
	                        finally { if (e_5) throw e_5.error; }
	                    }
	                }
	            }
	            else {
	                this.map._getMap().off(eventType, modifiedCallback);
	            }
	        }
	        this.mapCallbackHandler.removeCallback(eventType, layerId, callback);
	    };
	    /**
	     * Enables all the events associated with the specified layers.
	     * Enables the events on the underlying Mapbox layers too.
	     * @param layers The list of layers to enable the events associated with them.
	     * @internal
	     */
	    EventManager.prototype._enableLayerEvents = function (layer) {
	        var _this = this;
	        var eventDict = this.mapCallbackHandler.getLayerCallbacks(layer.getId());
	        // For every event callback added to the layer add the callback
	        // to all Mapbox layers build by the specified layer.
	        if (eventDict) {
	            eventDict.forEach(function (callbackDict, eventType) {
	                callbackDict.forEach(function (_a) {
	                    var e_6, _b;
	                    var _c = __read(_a, 1), modifiedCallback = _c[0];
	                    try {
	                        for (var _d = __values(layer._getLayerIds()), _e = _d.next(); !_e.done; _e = _d.next()) {
	                            var mbLayerId = _e.value;
	                            _this.map._getMap().on(eventType, mbLayerId, modifiedCallback);
	                        }
	                    }
	                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
	                    finally {
	                        try {
	                            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
	                        }
	                        finally { if (e_6) throw e_6.error; }
	                    }
	                });
	            });
	        }
	    };
	    /**
	     * Disables all the events associated with the specified layers.
	     * Disables the events on the underlying Mapbox layers too.
	     * @param layers The list of layers to enable the events associated with them.
	     * @internal
	     */
	    EventManager.prototype._disableLayerEvents = function (layer) {
	        var _this = this;
	        var eventDict = this.mapCallbackHandler.getLayerCallbacks(layer.getId());
	        // For every event callback added to the layer add the callback
	        // to all Mapbox layers build by the specified layer.
	        if (eventDict) {
	            eventDict.forEach(function (callbackDict, eventType) {
	                callbackDict.forEach(function (_a) {
	                    var e_7, _b;
	                    var _c = __read(_a, 1), modifiedCallback = _c[0];
	                    try {
	                        for (var _d = __values(layer._getLayerIds()), _e = _d.next(); !_e.done; _e = _d.next()) {
	                            var mbLayerId = _e.value;
	                            _this.map._getMap().off(eventType, mbLayerId, modifiedCallback);
	                        }
	                    }
	                    catch (e_7_1) { e_7 = { error: e_7_1 }; }
	                    finally {
	                        try {
	                            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
	                        }
	                        finally { if (e_7) throw e_7.error; }
	                    }
	                });
	            });
	        }
	    };
	    return EventManager;
	}());

	/**
	 * A manager for the map control's HTML markers.
	 * Exposed through the markers property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var HtmlMarkerManager = /** @class */ (function () {
	    /**
	     * Constructs the marker manager to be exposed only through the markers property of the Map class.
	     * @param map The map whose markers are being managed by this.
	     * @internal
	     */
	    function HtmlMarkerManager(map) {
	        this.markers = new Set();
	        this.map = map;
	    }
	    HtmlMarkerManager.prototype.add = function (element, position) {
	        var e_1, _a;
	        if (Array.isArray(element)) {
	            try {
	                for (var element_1 = __values(element), element_1_1 = element_1.next(); !element_1_1.done; element_1_1 = element_1.next()) {
	                    var marker = element_1_1.value;
	                    this._addMarker(marker, position);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (element_1_1 && !element_1_1.done && (_a = element_1.return)) _a.call(element_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this._addMarker(element, position);
	        }
	    };
	    /**
	     * Adds a single marker.
	     */
	    HtmlMarkerManager.prototype._addMarker = function (marker, position) {
	        marker._addToMap(this.map, position);
	        this.markers.add(marker);
	    };
	    /**
	     * Gets an array of all the markers on the map.
	     */
	    HtmlMarkerManager.prototype.getMarkers = function () {
	        return Array.from(this.markers);
	    };
	    /**
	     * Removes one or more HTML markers from the map.
	     * @param marker A HtmlMarker instance, a string id of a marker's htmlContent, or an array of these.
	     */
	    HtmlMarkerManager.prototype.remove = function (marker) {
	        var e_2, _a;
	        if (Array.isArray(marker)) {
	            try {
	                for (var marker_1 = __values(marker), marker_1_1 = marker_1.next(); !marker_1_1.done; marker_1_1 = marker_1.next()) {
	                    var singleMarker = marker_1_1.value;
	                    this._removeMarker(singleMarker);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (marker_1_1 && !marker_1_1.done && (_a = marker_1.return)) _a.call(marker_1);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        else {
	            this._removeMarker(marker);
	        }
	    };
	    /**
	     * Removes a single marker.
	     */
	    HtmlMarkerManager.prototype._removeMarker = function (marker) {
	        var _this = this;
	        if (marker instanceof HtmlMarker) {
	            marker._removeFromMap();
	            this.markers.delete(marker);
	        }
	        else {
	            this.markers.forEach(function (singleMarker) {
	                if (singleMarker._getId() === marker) {
	                    singleMarker._removeFromMap();
	                    _this.markers.delete(singleMarker);
	                }
	            });
	        }
	    };
	    /**
	     * Clears all markers.
	     */
	    HtmlMarkerManager.prototype.clear = function () {
	        var _this = this;
	        this.markers.forEach(function (singleMarker) {
	            singleMarker._removeFromMap();
	            _this.markers.delete(singleMarker);
	        });
	    };
	    return HtmlMarkerManager;
	}());

	/**
	 * A manager for the map control's image sprite.
	 * Exposed through the imageSprite property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var ImageSpriteManager = /** @class */ (function () {
	    /**
	     * Constructs the image sprite manager to be exposed only through the imageSprite property of the Map class.
	     * @param map The Map object this will manage the image sprite for.
	     * @internal
	     */
	    function ImageSpriteManager(map) {
	        this.userImages = new Dictionary();
	        this.imageLoadTimeout = 5000;
	        this.map = map;
	    }
	    /**
	     * Add an icon image to the map's image sprite for use with symbols and patterns.
	     * @param id The image's id.
	     * If the specified id matches the id of a previously added image the new image will be ignored.
	     * @param icon The image to add to the map's sprite. Can be a data URI, inline SVG, or image URL.
	     */
	    ImageSpriteManager.prototype.add = function (id, icon) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            // Take no action if the new image uses the id of a previously added image.
	            if (_this.userImages.has(id)) {
	                resolve();
	                return;
	            }
	            if (icon instanceof HTMLImageElement || icon instanceof ImageData) {
	                _this.map._getMap().addImage(id, icon);
	                _this.userImages.set(id, icon);
	                resolve();
	            }
	            else if (typeof icon === "string") {
	                var imageSrc = void 0;
	                // Assume an inline svg image string if icon doesn't start with "data:", but does include "<svg"
	                if (/<svg/i.test(icon) && !(/^data:/i.test(icon))) {
	                    imageSrc = "data:image/svg+xml;base64," + window.btoa(icon);
	                }
	                else {
	                    imageSrc = icon;
	                }
	                // Use a timer to prevent the request from waiting forever.
	                var timeoutId_1;
	                var timedOut_1 = false;
	                // Use the map to send the request so transformRequest is used.
	                _this.map._sendRequest(imageSrc, "Image").then(function (response) {
	                    if (!timedOut_1) {
	                        return response.blob();
	                    }
	                }).then(function (blob) {
	                    if (!timedOut_1) {
	                        clearTimeout(timeoutId_1);
	                        var imageEle_1 = new Image();
	                        // Wait for the blob to load into the element.
	                        imageEle_1.onload = function () {
	                            _this.map._getMap().addImage(id, imageEle_1);
	                            _this.userImages.set(id, imageEle_1);
	                            resolve();
	                        };
	                        // Reject if the blob failed to load in the element.
	                        imageEle_1.onerror = imageEle_1.onabort = function () {
	                            reject("Failed to load image into HTML element.");
	                        };
	                        // Convert the blob to a data url then load it into an Image element.
	                        imageEle_1.src = URL.createObjectURL(blob);
	                    }
	                }).catch(function () {
	                    if (!timedOut_1) {
	                        clearTimeout(timeoutId_1);
	                        reject("Failed to load image into HTML element.");
	                    }
	                });
	                // Allow the image a fixed amount of time to load the image before aborting.
	                // @ts-ignore
	                timeoutId_1 = setTimeout(function () {
	                    timedOut_1 = true;
	                    reject("Failed to load image within specified timeout: " + _this.imageLoadTimeout + " ms.");
	                }, _this.imageLoadTimeout);
	            }
	        });
	    };
	    /**
	     * Removes all images added by the user.
	     */
	    ImageSpriteManager.prototype.clear = function () {
	        var _this = this;
	        this.userImages.forEach(function (image, id) {
	            _this.map._getMap().removeImage(id);
	        });
	        // Clear the list of user added image ids.
	        this.userImages.clear();
	    };
	    /**
	     * Gets a list of all the image ids that have been added to the maps image sprite.
	     */
	    ImageSpriteManager.prototype.getImageIds = function () {
	        var ids = [];
	        this.userImages.forEach(function (image, id) {
	            ids.push(id);
	        });
	        return ids;
	    };
	    /**
	     * Creates and adds an image to the maps image sprite. Provide the name of the built-in template to use, and a color to apply.
	     * Optionally, specifiy a secondary color if the template supports one. A scale can also be specified.
	     * This will allow the SVG to be scaled before it is converted into an image and thus look much better when scaled up.
	     * Returns a promise.
	     * Reference this in the Polygon or Symbol layer.
	     * @param id  The image's id. If the specified id matches the id of a previously added image the new image will be ignored.
	     * @param templateName The name of the template to use.
	     * @param color The primary color value. Default: #1A73AA
	     * @param secondaryColor A secondary color value. Default: white
	     * @param scale Specifies how much to scale the template. For best results, scale the icon to the maximum size you want to display it on the map, then use the symbol layers icon size option to scale down if needed. This will reduce blurriness due to scaling. Default: 1
	     */
	    ImageSpriteManager.prototype.createFromTemplate = function (id, templateName, color, secondaryColor, scale) {
	        color = color || "#1A73AA";
	        secondaryColor = secondaryColor || "#fff";
	        var t = getImageTemplate(templateName, scale);
	        t = t.replace(/{color}/g, color).replace(/{secondaryColor}/g, secondaryColor).replace(/{text}/g, "");
	        return this.add(id, t);
	    };
	    /**
	     * Checks to see if an image is already loaded into the maps image sprite.
	     * @param id The id to check the map's image sprite for.
	     */
	    ImageSpriteManager.prototype.hasImage = function (id) {
	        return this.userImages.has(id);
	    };
	    /**
	     * Removes an image from the map's image sprite.
	     * @param id The id of the image to remove.
	     */
	    ImageSpriteManager.prototype.remove = function (id) {
	        this.map._getMap().removeImage(id);
	        this.userImages.delete(id);
	    };
	    /**
	     * Restores the images the user has added to the Mapbox image sprite.
	     * @internal
	     */
	    ImageSpriteManager.prototype._restoreImages = function () {
	        var _this = this;
	        // Check that all user added images still exist in the sprite after changing styles.
	        // Currently Mapbox doesn't support diff operations for sprites.
	        // Therefore changing a sprite will cause a full style rebuild.
	        this.userImages.forEach(function (image, id) {
	            if (!_this.map._getMap().hasImage(id)) {
	                _this.map._getMap().addImage(id, image);
	            }
	        });
	    };
	    return ImageSpriteManager;
	}());

	/**
	 * Used to represent the layer described by a resource files.
	 * Serves primarily as a wrapper for multiple Mapbox layers in LayerManger.
	 * @private
	 */
	var FundamentalMapLayer = /** @class */ (function (_super) {
	    __extends(FundamentalMapLayer, _super);
	    /**
	     * Constructs a base layer used to represent the base, transit, and labels layers.
	     * @param mbLayers The stylesheet used to define the style sources and style layers.
	     * @param id The layer's id.
	     */
	    function FundamentalMapLayer(mbLayers, id) {
	        var _this = _super.call(this, id) || this;
	        _this.layers = mbLayers;
	        return _this;
	    }
	    /**
	     * @internal
	     */
	    FundamentalMapLayer.prototype._buildLayers = function () {
	        return this.layers;
	    };
	    /**
	     * @internal
	     */
	    FundamentalMapLayer.prototype._getLayerIds = function () {
	        return this.layers.map(function (l) { return l.id; });
	    };
	    /**
	     * @internal
	     */
	    FundamentalMapLayer.prototype._getSourceIds = function () {
	        var e_1, _a;
	        var ids = new Set();
	        try {
	            for (var _b = __values(this.layers), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var layer = _c.value;
	                if (typeof layer.source === "string") {
	                    // If the layer's source is just a string id use that.
	                    ids.add(layer.source);
	                }
	                else if (layer.source) {
	                    // If the layer has an inline source definition the id will match the layer's.
	                    ids.add(layer.id);
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return ids;
	    };
	    FundamentalMapLayer.prototype._updateLayoutProperty = function (name, newValue, oldValue, subValue) {
	        var _this = this;
	        this.layers.forEach(function (layer) {
	            if (!(isEqual_1(newValue, oldValue))) {
	                _this.map._getMap().setLayoutProperty(layer.id, name, subValue || newValue);
	            }
	        });
	    };
	    return FundamentalMapLayer;
	}(Layer));

	/**
	 * A manager for the map control's layers.
	 * Exposed through the layers property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var LayerManager = /** @class */ (function () {
	    /**
	     * Constructs the layer manager to be exposed only through the layers property of the Map class.
	     * @param map The map whose layers are being managed by this.
	     * @internal
	     */
	    function LayerManager(map) {
	        this.layerIndex = [];
	        this.userLayers = [];
	        this.map = map;
	    }
	    LayerManager.prototype.add = function (layer, before) {
	        var e_1, _a;
	        var beforeId = before instanceof Layer ?
	            before.getId() :
	            before;
	        if (Array.isArray(layer)) {
	            try {
	                for (var layer_1 = __values(layer), layer_1_1 = layer_1.next(); !layer_1_1.done; layer_1_1 = layer_1.next()) {
	                    var singleLayer = layer_1_1.value;
	                    this._addLayer(singleLayer, beforeId);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (layer_1_1 && !layer_1_1.done && (_a = layer_1.return)) _a.call(layer_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this._addLayer(layer, beforeId);
	        }
	    };
	    /**
	     * Adds a single layer to the map.
	     * @private
	     */
	    LayerManager.prototype._addLayer = function (layer, before) {
	        if (!this.map._isReady() && !(layer instanceof FundamentalMapLayer)) {
	            throw new Error("The layer '" + layer.getId() + "' could not be added to the map because " +
	                "the map is not ready. Please use a ready event listener to guarantee " +
	                "the map is ready before adding a layer to it.");
	        }
	        if (before !== layer.getId() && this.layerIndex.find(function (l) { return before === l.getId(); })) {
	            if (this._getMapboxLayerExists(layer)) {
	                // Replace the existing layer with the new one.
	                // Place the new layer behind the specified before layer.
	                var layerIndex = this.layerIndex.findIndex(function (l) { return l.getId() === layer.getId(); });
	                var tempLayer = this.layerIndex[layerIndex];
	                this._removeMapboxLayers(layer);
	                this._addMapboxLayers(layer, before);
	                this.map.events._disableLayerEvents(tempLayer);
	                this.map.events._enableLayerEvents(layer);
	                this.layerIndex.splice(layerIndex, 1);
	                var beforeIndex = this.layerIndex.findIndex(function (l) { return l.getId() === before; });
	                this.layerIndex.splice(beforeIndex, 0, layer);
	                if (!(layer instanceof FundamentalMapLayer))
	                    this.userLayers.push({ layer: layer, before: before });
	                tempLayer.onRemove();
	                layer.onAdd(this.map);
	            }
	            else {
	                // Add the new layer behind the specified before layer.
	                this._addMapboxLayers(layer, before);
	                this.map.events._enableLayerEvents(layer);
	                var beforeIndex = this.layerIndex.findIndex(function (l) { return l.getId() === before; });
	                this.layerIndex.splice(beforeIndex, 0, layer);
	                if (!(layer instanceof FundamentalMapLayer))
	                    this.userLayers.push({ layer: layer, before: before });
	                layer.onAdd(this.map);
	            }
	        }
	        else {
	            var layerIndex = this.layerIndex.findIndex(function (l) { return l.getId() === layer.getId(); });
	            if (layerIndex >= 0) {
	                // Replace the existing layer with the new one.
	                var tempLayer = this.layerIndex[layerIndex];
	                this._removeMapboxLayers(tempLayer);
	                this._addMapboxLayers(layer, layerIndex + 1);
	                this.map.events._disableLayerEvents(tempLayer);
	                this.map.events._enableLayerEvents(layer);
	                this.layerIndex[layerIndex] = layer;
	                tempLayer.onRemove();
	                layer.onAdd(this.map);
	            }
	            else {
	                // Add the layer to the top of the z-order.
	                this._addMapboxLayers(layer);
	                this.map.events._enableLayerEvents(layer);
	                this.layerIndex.push(layer);
	                if (!(layer instanceof FundamentalMapLayer))
	                    this.userLayers.push({ layer: layer, before: before });
	                layer.onAdd(this.map);
	            }
	        }
	    };
	    /**
	     * Adds all the Mapbox layers built by an atlas layer to the Mapbox map.
	     * @private
	     */
	    LayerManager.prototype._addMapboxLayers = function (layer, before) {
	        var e_2, _a;
	        // if the TileLayer's tile URL isn't defined yet, don't add the source and layer.
	        if (layer instanceof TileLayer && !layer.getOptions().tileUrl) {
	            return;
	        }
	        // FundamentalMapLayers are a special case because they are created indirectly by StyleManager when mapbox
	        // loads a style by URL. When a FundamentalMapLayer is added to the LayerManager it is being done
	        // so to reflect layers that are already loaded in mapbox so they do not need to be added a second 
	        // time
	        if (layer instanceof FundamentalMapLayer) {
	            this.map.events._enableLayerEvents(layer);
	            return;
	        }
	        // SourceBuildingLayers are a special case because they create their own source and manage it internally.
	        // If adding a SourceBuildingLayer the source associated must also be added.
	        if (layer instanceof SourceBuildingLayer) {
	            this.map._getMap().addSource(layer._getSourceId(), layer._buildSource());
	        }
	        var mbBefore = this._getMapboxBefore(before);
	        try {
	            for (var _b = __values(layer._buildLayers()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var mbLayer = _c.value;
	                this.map._getMap().addLayer(mbLayer, mbBefore);
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	        this.map.events._enableLayerEvents(layer);
	    };
	    /**
	     * Removes all the Mapbox layers built by an atlas layer from the Mapbox map.
	     * @private
	     */
	    LayerManager.prototype._removeMapboxLayers = function (layer, force) {
	        var e_3, _a;
	        // FundamentalMapLayers are a special case because they are created indirectly by StyleManager when mapbox
	        // loads a style by URL. When a FundamentalMapLayer is removed from the LayerManager it is being done
	        // so to reflect layers that are already removed from mapbox so they do not need to be removed a second 
	        // time
	        if (layer instanceof FundamentalMapLayer && !force) {
	            this.map.events._disableLayerEvents(layer);
	            return;
	        }
	        try {
	            for (var _b = __values(layer._getLayerIds()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var mbLayerId = _c.value;
	                // Check if the layer does exist.
	                if (this.map._getMap().getLayer(mbLayerId)) {
	                    this.map._getMap().removeLayer(mbLayerId);
	                }
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        this.map.events._disableLayerEvents(layer);
	        // SourceBuildingLayer are a special case because they create their own source and manage it internally.
	        // If removing a SourceBuildingLayer the source associated must also be removed.
	        if (layer instanceof SourceBuildingLayer &&
	            this.map._getMap().getSource(layer._getSourceId())) {
	            this.map._getMap().removeSource(layer._getSourceId());
	        }
	    };
	    /**
	     * Test if mapbox contains a mapbox.Layer defined in an atlas Layer.
	     *
	     * @param layer: Atlas layer or layerID to test.
	     * @returns True if layer exists in mapbox.
	     */
	    LayerManager.prototype._getMapboxLayerExists = function (layer) {
	        var _this = this;
	        var found = false;
	        if (typeof layer === "string") {
	            layer = this.layerIndex.find(function (l) { return l.getId() === layer; });
	            if (!layer) {
	                return false;
	            }
	            return true;
	        }
	        layer._getLayerIds().forEach(function (mbLayerId) {
	            var mbLayer = _this.map._getMap().getLayer(mbLayerId);
	            if (mbLayer)
	                found = true;
	        });
	        return found;
	    };
	    /**
	     * Gets the ID of the Mapbox layer to add before given the id of the atlas before layer.
	     * @private
	     */
	    LayerManager.prototype._getMapboxBefore = function (before) {
	        var e_4, _a, e_5, _b;
	        // If passed a string use it as the name of an atlas layer.
	        if (typeof before === "string") {
	            var beforeLayer = this.layerIndex.find(function (l) { return l.getId() === before; });
	            // If the before layer exists iterate over the mapbox layers
	            // it would build until a layer exists on the mapbox map.
	            if (beforeLayer) {
	                try {
	                    for (var _c = __values(beforeLayer._getLayerIds()), _d = _c.next(); !_d.done; _d = _c.next()) {
	                        var layerId = _d.value;
	                        if (this.map._getMap().getLayer(layerId)) {
	                            return layerId;
	                        }
	                    }
	                }
	                catch (e_4_1) { e_4 = { error: e_4_1 }; }
	                finally {
	                    try {
	                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	                    }
	                    finally { if (e_4) throw e_4.error; }
	                }
	                // If none of the layers built by the specified before layer
	                // actually exists on the map start checking the next layers.
	                before = this.layerIndex.findIndex(function (l) { return l.getId() === before; }) + 1;
	            }
	            else {
	                // If the before layer hasn't been added just return undefined.
	                return undefined;
	            }
	        }
	        // If passed a number assume it is the index of the before layer.
	        // Or the string passed didn't lead to finding any existing mapbox layers.
	        //
	        // Iterate over all layers at or after the before index until one of
	        // the mapbox layers built by an atlas layer exists in the mapbox map.
	        for (var i = before; i < this.layerIndex.length; i++) {
	            try {
	                for (var _e = (e_5 = void 0, __values(this.layerIndex[i]._getLayerIds())), _f = _e.next(); !_f.done; _f = _e.next()) {
	                    var layerId = _f.value;
	                    if (this.map._getMap().getLayer(layerId)) {
	                        return layerId;
	                    }
	                }
	            }
	            catch (e_5_1) { e_5 = { error: e_5_1 }; }
	            finally {
	                try {
	                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
	                }
	                finally { if (e_5) throw e_5.error; }
	            }
	        }
	        // If nothing was found just return undefined.
	        return undefined;
	    };
	    /**
	     * Removes all user added layers from the map.
	     */
	    LayerManager.prototype.clear = function () {
	        for (var layerIndexIndex = this.layerIndex.length - 1; layerIndexIndex >= 0; layerIndexIndex--) {
	            var tempLayer = this.layerIndex[layerIndexIndex];
	            this._removeMapboxLayers(tempLayer, true);
	            this.layerIndex.splice(layerIndexIndex, 1);
	            tempLayer.onRemove();
	        }
	        this.userLayers = [];
	    };
	    /**
	     * Retrieves a layer with the specified id.
	     * @param id The id of the layer to retrieve.
	     */
	    LayerManager.prototype.getLayerById = function (id) {
	        var result = this.layerIndex.find(function (l) { return l.getId() === id; });
	        if (result)
	            return result;
	        return undefined;
	    };
	    /**
	     * Retrieves all layers that have been added to the map.
	     */
	    LayerManager.prototype.getLayers = function () {
	        return this.layerIndex.slice(0);
	    };
	    /**
	     * Returns a set of all the source IDs that any layers depend on.
	     * @internal
	     */
	    LayerManager.prototype._getSourceIds = function () {
	        var e_6, _a;
	        var ids = new Set();
	        try {
	            for (var _b = __values(this.layerIndex), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var layer = _c.value;
	                layer._getSourceIds().forEach(function (id) { return ids.add(id); });
	            }
	        }
	        catch (e_6_1) { e_6 = { error: e_6_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_6) throw e_6.error; }
	        }
	        return ids;
	    };
	    /**
	     *
	     * @returns Returns a set of all layers added through this SDK.
	     * @internal
	     */
	    LayerManager.prototype._getUserLayers = function () {
	        return Array.from(this.userLayers);
	    };
	    /**
	     * Moves a layer to a different z-position.
	     * @param layer The layer or id of the layer to move.
	     * @param before Optionally specify to move the layer before this.
	     */
	    LayerManager.prototype.move = function (layer, before) {
	        var layerId = layer instanceof Layer ? layer.getId() : layer;
	        var beforeId = before instanceof Layer ? before.getId() : before;
	        if (!this.layerIndex.find(function (l) { return l.getId() === layerId; })) {
	            throw new Error("The layer '" + layerId + "' has not been added to the map and cannot be moved.");
	        }
	        var layerIndex = this.layerIndex.findIndex(function (l) { return l.getId() === layerId; });
	        this._moveMapboxLayers(this.layerIndex[layerIndex], beforeId);
	        layer = this.layerIndex[layerIndex];
	        this.layerIndex.splice(layerIndex, 1);
	        var beforeIndex = this.layerIndex.findIndex(function (l) { return l.getId() === beforeId; });
	        if (beforeIndex > -1) {
	            this.layerIndex.splice(beforeIndex, 0, layer);
	        }
	        else {
	            this.layerIndex.push(layer);
	        }
	    };
	    LayerManager.prototype._moveMapboxLayers = function (layer, before) {
	        var e_7, _a;
	        var mbBefore = this._getMapboxBefore(before);
	        try {
	            for (var _b = __values(layer._getLayerIds()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var mbLayerId = _c.value;
	                this.map._getMap().moveLayer(mbLayerId, mbBefore);
	            }
	        }
	        catch (e_7_1) { e_7 = { error: e_7_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_7) throw e_7.error; }
	        }
	    };
	    /**
	        * Retrieve all Shapes and GeoJSON features that are visible on the map that are in a DataSource or VectorTileSource.
	        * Shape objects are editable, while Feature objects are not editable and either reside in a VectorTileSource or represent a cluster point.
	        * Clusters have the following properties:
	        * <p>cluster: `boolean` - Indicates that the point is a cluster.
	        * This will be set to true if Point object represents a cluster.
	        * All other point objects are unlikely to have this value unless
	        * a property with this same name was added to the Point property data from your app.</p>
	        * <p>cluster_id: `string` - A unique id for the cluster.</p>
	        * <p>point_count: `number` - The number of points inside the cluster.</p>
	        * <p>point_count_abbreviated: `string` - An abbreviated string version of the point count. i.e. `"10K"`</p>
	        * Features/Shapes that are not visible or who's layer zoom range does not include the current zoom level will not be returned.
	        * Symbol features/Shapes that have been hidden due to text or icon collisions are not included.
	        * Features/Shapes from all other layers are included even if they have no contribution to the map rendering, e.g. alpha set to zero.
	        * The topmost rendered features/shapes appears first in the returned array and subsequent features are sorted in descending z-order.
	        * @param geometry A Position, Point, or BoundingBox that returned features must intersect. If not specified the whole visible world is used.
	        * @param layers An array of layers or their ids to limit the query to.
	        * @param filter A expression to filter the returned features by.
	        */
	    LayerManager.prototype.getRenderedShapes = function (geometry, layers, filter) {
	        var e_8, _a;
	        var _this = this;
	        // If no geometry was provided use a bounding box covering the whole world.
	        if (!geometry) {
	            geometry = [-180, -85.0511, 180, 85.0511];
	        }
	        // Mapbox's queryRenderedFeatures uses screen coordinates not GeoJSON positions.
	        // Here we convert the input bounding box or point into screen coordinates.
	        var scope;
	        if (Array.isArray(geometry)) {
	            if (geometry.length === 4 || geometry.length === 6) {
	                // BoundingBox has length of 4 or 6: [west, south, east, north] or [west, south, elevation1, east, north, elevation2]
	                scope = this.map.positionsToPixels([
	                    BoundingBox.getSouthWest(geometry),
	                    BoundingBox.getNorthEast(geometry)
	                ]);
	            }
	            else if (geometry.length === 2 || geometry.length === 3) {
	                // Position has length of 2, or 3: [lon, lat] or [lon, lat, elv]
	                scope = this.map.positionsToPixels([geometry])[0];
	            }
	        }
	        else {
	            scope = this.map.positionsToPixels([geometry.coordinates])[0];
	        }
	        // Create an array of all the mapbox layer ids that make up the layers specified by the user.
	        // Skip any mapbox layer ids that don't currently exist in the mapbox style.
	        var layerIds;
	        if (layers) {
	            layers = Array.isArray(layers) ? layers : [layers];
	            layerIds = [];
	            var _loop_1 = function (layer) {
	                var layerId = layer instanceof Layer ? layer.getId() : layer;
	                // If a specified layer hasn't been added to the map throw an error.
	                var index = this_1.layerIndex.findIndex(function (l) { return l.getId() === layerId; });
	                if (index > -1) {
	                    layerIds.push.apply(layerIds, __spread(this_1.layerIndex[index]._getLayerIds()
	                        .filter(function (id) { return !!_this.map._getMap().getLayer(id); })));
	                }
	                else {
	                    throw new Error("The layer '" + layerId + "' has not been added to the map " +
	                        "and its rendered features cannot be retrieved.");
	                }
	            };
	            var this_1 = this;
	            try {
	                for (var layers_1 = __values(layers), layers_1_1 = layers_1.next(); !layers_1_1.done; layers_1_1 = layers_1.next()) {
	                    var layer = layers_1_1.value;
	                    _loop_1(layer);
	                }
	            }
	            catch (e_8_1) { e_8 = { error: e_8_1 }; }
	            finally {
	                try {
	                    if (layers_1_1 && !layers_1_1.done && (_a = layers_1.return)) _a.call(layers_1);
	                }
	                finally { if (e_8) throw e_8.error; }
	            }
	        }
	        // Use queryRenderedFeatures to get a basic list of the features
	        // within the scope and belonging to the specified layers.
	        var features = this.map._getMap().queryRenderedFeatures(scope, {
	            layers: layerIds,
	            filter: filter
	        });
	        // Any features belonging to a DataSource will be mapped to the Shapes that wrap them.
	        return this.map.sources._mapFeaturesToShapes(features);
	    };
	    LayerManager.prototype.remove = function (layer) {
	        var e_9, _a;
	        if (Array.isArray(layer)) {
	            try {
	                for (var layer_2 = __values(layer), layer_2_1 = layer_2.next(); !layer_2_1.done; layer_2_1 = layer_2.next()) {
	                    var singleLayer = layer_2_1.value;
	                    this._removeLayer(singleLayer);
	                }
	            }
	            catch (e_9_1) { e_9 = { error: e_9_1 }; }
	            finally {
	                try {
	                    if (layer_2_1 && !layer_2_1.done && (_a = layer_2.return)) _a.call(layer_2);
	                }
	                finally { if (e_9) throw e_9.error; }
	            }
	        }
	        else {
	            this._removeLayer(layer);
	        }
	    };
	    /**
	     * Removes a single layer from the map.
	     * @private
	     */
	    LayerManager.prototype._removeLayer = function (layer) {
	        var layerId = layer instanceof Layer ? layer.getId() : layer;
	        if (!this.layerIndex.find(function (l) { return l.getId() === layerId; })) {
	            throw new Error("The layer '" + layerId + "' has not been added to the map and cannot be removed.");
	        }
	        var layerIndex = this.layerIndex.findIndex(function (l) { return l.getId() === layerId; });
	        var tempLayer = this.layerIndex[layerIndex];
	        this._removeMapboxLayers(tempLayer);
	        this.layerIndex.splice(layerIndex, 1);
	        var userLayerIndex = this.userLayers.findIndex(function (ul) { return ul.layer.getId() === tempLayer.getId(); });
	        if (userLayerIndex >= 0) {
	            this.userLayers.splice(userLayerIndex, 1);
	        }
	        tempLayer.onRemove();
	    };
	    return LayerManager;
	}());

	/**
	 * A manager for the map control's popups.
	 * Exposed through the `popups` property of the `atlas.Map` class.
	 * Cannot be instantiated by the user.
	 */
	var PopupManager = /** @class */ (function () {
	    /**
	     * Constructs the popup manager to be exposed only through the `popups` property of the `Map` class.
	     * @param map The map whose popups are being managed by this.
	     * @internal
	     */
	    function PopupManager(map) {
	        var _this = this;
	        /**
	         * Listens for mouse or touch movement when dragging popups.
	         */
	        this._onDrag = function (event) {
	            // Determine the new x and y from the event data.
	            var x;
	            var y;
	            if (event.type === "mousemove") {
	                event = event;
	                x = event.clientX;
	                y = event.clientY;
	            }
	            else if (event.type === "touchmove") {
	                event = event;
	                x = event.touches[0].clientX;
	                y = event.touches[0].clientY;
	            }
	            _this.draggedPopups.forEach(function (popup) {
	                popup._dragToPixel([x, y]);
	            });
	        };
	        /**
	         * Listens for mouse up or touch end to indicate popups aren't being dragged anymore.
	         */
	        this._onUp = function () {
	            // Remove the listeners since no popups are being dragged anymore.
	            _this.map.getMapContainer().removeEventListener("mousemove", _this._onDrag);
	            _this.map.getMapContainer().removeEventListener("touchmove", _this._onDrag);
	            _this.map.getMapContainer().removeEventListener("mouseup", _this._onUp);
	            _this.map.getMapContainer().removeEventListener("touchend", _this._onUp);
	            _this.draggedPopups.forEach(function (popup) {
	                _this.draggedPopups.delete(popup);
	                popup._onUp();
	            });
	        };
	        this.map = map;
	        this.popups = new Set();
	        this.draggedPopups = new Set();
	    }
	    /**
	     * Adds a popup to the map
	     * @param popup The popup(s) to add.
	     */
	    PopupManager.prototype.add = function (popup) {
	        var e_1, _a;
	        popup = Array.isArray(popup) ? popup : [popup];
	        try {
	            for (var popup_1 = __values(popup), popup_1_1 = popup_1.next(); !popup_1_1.done; popup_1_1 = popup_1.next()) {
	                var p = popup_1_1.value;
	                if (!this.popups.has(p)) {
	                    this.popups.add(p);
	                    p.attach(this.map);
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (popup_1_1 && !popup_1_1.done && (_a = popup_1.return)) _a.call(popup_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	    };
	    /**
	     * Removes all popups from the map.
	     */
	    PopupManager.prototype.clear = function () {
	        var _this = this;
	        this.popups.forEach(function (popup) {
	            _this.popups.delete(popup);
	            popup.remove();
	        });
	    };
	    /**
	     * Removes a popup from the map
	     * @param popup The popup(s) to remove.
	     */
	    PopupManager.prototype.remove = function (popup) {
	        var e_2, _a;
	        popup = Array.isArray(popup) ? popup : [popup];
	        try {
	            for (var popup_2 = __values(popup), popup_2_1 = popup_2.next(); !popup_2_1.done; popup_2_1 = popup_2.next()) {
	                var p = popup_2_1.value;
	                if (this.popups.has(p)) {
	                    this.popups.delete(p);
	                    p.remove();
	                }
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (popup_2_1 && !popup_2_1.done && (_a = popup_2.return)) _a.call(popup_2);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	    };
	    /**
	     * Returns the popups currently attached to the map.
	     */
	    PopupManager.prototype.getPopups = function () {
	        return Array.from(this.popups);
	    };
	    /**
	     * Returns the div element that should contain all the popup containers.
	     * Creates it if it doesn't already exist.
	     * @internal
	     */
	    PopupManager.prototype._getCollectionDiv = function () {
	        var collection = this.map.getMapContainer()
	            .querySelector("." + PopupManager.Css.collection);
	        if (!collection) {
	            // If the collection div doesn't exist create it.
	            collection = document.createElement("div");
	            collection.classList.add(PopupManager.Css.collection);
	            collection.setAttribute("aria-label", "Map Information");
	            this.map.getMapContainer().appendChild(collection);
	        }
	        return collection;
	    };
	    /**
	     * Adds a popup to the set of popups actively being dragged.
	     * @internal
	     */
	    PopupManager.prototype._addDraggedPopup = function (popup) {
	        // If no popups are being dragged yet add the listeners.
	        if (this.draggedPopups.size === 0) {
	            this.map.getMapContainer().addEventListener("mousemove", this._onDrag);
	            this.map.getMapContainer().addEventListener("touchmove", this._onDrag);
	            this.map.getMapContainer().addEventListener("mouseup", this._onUp);
	            this.map.getMapContainer().addEventListener("touchend", this._onUp);
	        }
	        // Track the popups being dragged for the mousemove events.
	        this.draggedPopups.add(popup);
	    };
	    PopupManager.Css = {
	        collection: "popup-collection-container"
	    };
	    return PopupManager;
	}());

	/**
	 * Used to represent the fundamental map source.
	 * @private
	 */
	var FundamentalMapSource = /** @class */ (function (_super) {
	    __extends(FundamentalMapSource, _super);
	    /**
	     * Constructs a source from the contents of a layer resource file.
	     * @param id The source's id.
	     * @param sourceDef The sources entry of the resource file.
	     * @param options The query parameters to add to the urls listed in the resource file.
	     */
	    function FundamentalMapSource(id, sourceDef, options) {
	        var _this = _super.call(this, id) || this;
	        _this.source = _this._modifySource(sourceDef, options);
	        return _this;
	    }
	    /**
	     * @internal
	     */
	    FundamentalMapSource.prototype._buildSource = function () {
	        return this.source;
	    };
	    /**
	     * Updates the source info to convert the tiles to url strings.
	     * @param sourceDef The original source info.
	     * @param options The query parameters to add to the tile urls.
	     */
	    FundamentalMapSource.prototype._modifySource = function (sourceDef, options) {
	        if (sourceDef.tiles) {
	            var tileStrings = sourceDef.tiles.map(function (tile) {
	                if (typeof tile === "string") {
	                    return tile;
	                }
	                var tileUrl = new Url({
	                    domain: constants.domainPlaceHolder,
	                    path: tile.path,
	                    queryParams: __assign(__assign({}, options), tile.queryParams)
	                });
	                return tileUrl.toString();
	            });
	            sourceDef.tiles = tileStrings;
	        }
	        else if (sourceDef.url) {
	            sourceDef.url = (typeof sourceDef.url === "string") ?
	                sourceDef.url :
	                new Url({
	                    domain: constants.domainPlaceHolder,
	                    path: sourceDef.url.path,
	                    queryParams: __assign(__assign({}, options), sourceDef.url.queryParams)
	                }).toString();
	        }
	        else {
	            throw new Error("Source definition must define a TileJSON 'url' or a 'tiles' array.");
	        }
	        return sourceDef;
	    };
	    return FundamentalMapSource;
	}(Source));

	/**
	 * A manager for the map control's sources.
	 * Exposed through the sources property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var SourceManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function SourceManager(map) {
	        this.map = map;
	        this.sources = new Dictionary();
	    }
	    SourceManager.prototype.add = function (source, update) {
	        var e_1, _a;
	        if (update === void 0) { update = true; }
	        if (Array.isArray(source)) {
	            try {
	                for (var source_1 = __values(source), source_1_1 = source_1.next(); !source_1_1.done; source_1_1 = source_1.next()) {
	                    var singleSource = source_1_1.value;
	                    this._addSource(singleSource, update);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (source_1_1 && !source_1_1.done && (_a = source_1.return)) _a.call(source_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this._addSource(source, update);
	        }
	    };
	    /**
	     * Returns all rendered shape features in a source that match a specified filter. If the source is a vector tile source, a source layer name needs to be specified.
	     * @param source source to be queried
	     * @param filter a filter to limit the query
	     * @param sourceLayer the layer where shapes and features are matched
	     */
	    SourceManager.prototype.getRenderedShapes = function (source, filter, sourceLayer) {
	        var sourceID = typeof source === "string" ? source : source.getId();
	        var features = this.map._getMap().querySourceFeatures(sourceID, { sourceLayer: sourceLayer, filter: filter });
	        return this.map.sources._mapFeaturesToShapes(features, true, this.sources.get(sourceID));
	    };
	    // TODO: wait till the mapbox's bug is fixed
	    // /**
	    //  * Gets the state of a feature
	    //  * @param shape the ID of the shape
	    //  * @param source the ID of the source
	    //  * @param sourceLayer the ID of the layer
	    //  */
	    // public getFeatureState(shape: string | Shape | Feature<Geometry, any>, source: string | Source, sourceLayer?: string): object {
	    //     let featureID;
	    //     if (typeof shape === "string") {
	    //         featureID = shape;
	    //     } else {
	    //         featureID = shape instanceof Shape ? shape.getId() : shape.id;
	    //     }
	    //     const featureSource = typeof source === "string" ? source : source.getId();
	    //     return this.map._getMap().getFeatureState({ id: featureID, source: featureSource, sourceLayer: sourceLayer });
	    // }
	    // /**
	    //  * Removes the state or a single key value of the state of a feature.
	    //  * @param shape the ID of the shape
	    //  * @param source the ID of the source
	    //  * @param sourceLayer the ID of the layer
	    //  * @param key the key in the feature state to update
	    //  */
	    // public removeFeatureState(shape: string | Shape | Feature<Geometry, any>, source: string | Source, sourceLayer?: string, key?: string) {
	    //     let featureID;
	    //     if (typeof shape === "string") {
	    //         featureID = shape;
	    //     } else {
	    //         featureID = shape instanceof Shape ? shape.getId() : shape.id;
	    //     }
	    //     const featureSource = typeof source === "string" ? source : source.getId();
	    //     // TODO: update the method when the mapbox typing file is updated
	    //     (this.map._getMap() as any).removeFeatureState({ id: featureID, source: featureSource, sourceLayer: sourceLayer }, key);
	    // }
	    // /**
	    //  * Sets the state of the feature by passing in a key value pair object.
	    //  * @param shape the ID of the shape
	    //  * @param source the ID of the source
	    //  * @param sourceLayer the ID of the layer
	    //  * @param key the key in the feature state to update
	    //  */
	    // public setFeatureState(shape: string | Shape | Feature<Geometry, any>, source: string | Source, state: object, sourceLayer?: string) {
	    //     let featureID;
	    //     if (typeof shape === "string") {
	    //         featureID = shape;
	    //     } else {
	    //         featureID = shape instanceof Shape ? shape.getId() : shape.id;
	    //     }
	    //     const featureSource = typeof source === "string" ? source : source.getId();
	    //     // TODO: update the method when the mapbox typing file is updated
	    //     this.map._getMap().setFeatureState({ id: featureID, source: featureSource, sourceLayer: sourceLayer }, state);
	    // }
	    /**
	     * @internal
	     */
	    SourceManager.prototype._buildSources = function () {
	        var ret = {};
	        this.sources.forEach(function (source) {
	            ret[source.getId()] = source._buildSource();
	        });
	        return ret;
	    };
	    /**
	     * Removes all sources from the map.
	     */
	    SourceManager.prototype.clear = function () {
	        var _this = this;
	        this.sources.forEach(function (source) {
	            _this.remove(source);
	        });
	    };
	    /**
	     * Retrieves a source with the specified id.
	     * @param id
	     */
	    SourceManager.prototype.getById = function (id) {
	        return this.sources.get(id);
	    };
	    /**
	     * Retrieves all sources that have been added to the map.
	     */
	    SourceManager.prototype.getSources = function () {
	        return Array.from(this.sources.values());
	    };
	    /**
	     * Returns a boolean indicating if the source is loaded or not.
	     * @param source The id of a source or a Source object.
	     */
	    SourceManager.prototype.isSourceLoaded = function (source) {
	        var id = source instanceof Source ? source.getId() : source;
	        return this.map._getMap().isSourceLoaded(id);
	    };
	    SourceManager.prototype.remove = function (source, update) {
	        var e_2, _a;
	        if (update === void 0) { update = true; }
	        if (Array.isArray(source)) {
	            try {
	                for (var source_2 = __values(source), source_2_1 = source_2.next(); !source_2_1.done; source_2_1 = source_2.next()) {
	                    var singleSource = source_2_1.value;
	                    this._removeSource(singleSource, update);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (source_2_1 && !source_2_1.done && (_a = source_2.return)) _a.call(source_2);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        else {
	            this._removeSource(source, update);
	        }
	    };
	    SourceManager.prototype._removeSource = function (source, update) {
	        var id = source instanceof Source ? source.getId() : source;
	        if (this.sources.has(id)) {
	            if (this.map._getMap().getSource(id) && update) {
	                this.map._getMap().removeSource(id);
	            }
	            if (!this.map._getMap().getSource(id) || !update) {
	                this.sources.get(id)._setMap(null);
	                this.sources.delete(id);
	            }
	            else {
	                throw new Error("One or more layers have a dependency on the source '" + id + "'");
	            }
	            return;
	        }
	        throw new Error("'" + id + "' is not added to the map");
	    };
	    SourceManager.prototype._addSource = function (source, update) {
	        // If adding a source that shares an id with an existing source throw an error unless update is false.
	        // Update being false assumes that a call to map.setStyle(...) will occurs soon.
	        if (this.sources.has(source.getId())) {
	            if (update) {
	                throw new Error("'" + source.getId() + "' is already added to the map");
	            }
	            else {
	                this.sources.get(source.getId())._setMap(null);
	                this.sources.delete(source.getId());
	            }
	        }
	        if (update) {
	            // Check if the map is ready before adding any sources.
	            if (!this.map._isReady()) {
	                throw new Error("The source '" + source.getId() + "' could not be added to the map because " +
	                    "the map is not ready. Please use a ready event listener to guarantee " +
	                    "the map is ready before adding a source to it.");
	            }
	            this.map._getMap().addSource(source.getId(), source._buildSource());
	        }
	        this.sources.set(source.getId(), source);
	        source._setMap(this.map);
	    };
	    /**
	     * Converts an array of features as returned by one of Mapbox's query*Features(...) function
	     * to an array of our features or shapes if one is currently wrapping the feature.
	     * @internal
	     */
	    SourceManager.prototype._mapFeaturesToShapes = function (features, shapesOnly, dataSource) {
	        var e_3, _a;
	        var shapesOrFeatures = [];
	        try {
	            for (var features_1 = __values(features), features_1_1 = features_1.next(); !features_1_1.done; features_1_1 = features_1.next()) {
	                var feature = features_1_1.value;
	                if ((dataSource || typeof feature["source"] === "string") &&
	                    typeof feature.properties[Shape._shapeIdPropName] === "string") {
	                    var source_3 = dataSource || this.sources.get(feature["source"]);
	                    if (source_3 instanceof DataSource) {
	                        var shape = source_3.getShapeById(feature.properties[Shape._shapeIdPropName]);
	                        if (shape instanceof Shape) {
	                            shapesOrFeatures.push(shape);
	                            continue;
	                        }
	                    }
	                }
	                if (!shapesOnly) {
	                    // If the feature couldn't be matched to a shape in a DataSource
	                    // just return the feature data as provided by mapbox.
	                    shapesOrFeatures.push(feature);
	                }
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (features_1_1 && !features_1_1.done && (_a = features_1.return)) _a.call(features_1);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        return shapesOrFeatures;
	    };
	    /**
	     * Sync SourceManager with mapbox sources.
	     * @internal
	     */
	    SourceManager.prototype._syncSources = function (sources) {
	        var _this = this;
	        if (sources) {
	            Object.keys(sources).forEach(function (sourceId) {
	                if (!_this.sources.has(sourceId)) {
	                    var sourceToAdd = sources[sourceId];
	                    if (sourceToAdd.type === "vector") {
	                        var newSource = new FundamentalMapSource(sourceId, {
	                            name: sourceId,
	                            tiles: sourceToAdd.tiles,
	                            type: "vector",
	                            url: sourceToAdd.url
	                        });
	                        _this.sources.set(sourceId, newSource);
	                        newSource._setMap(_this.map);
	                    }
	                    else if (sourceToAdd.type === "raster") {
	                        var newSource = new FundamentalMapSource(sourceId, {
	                            name: sourceId,
	                            tiles: sourceToAdd.tiles,
	                            type: "raster",
	                            url: sourceToAdd.url
	                        });
	                        _this.sources.set(sourceId, newSource);
	                        newSource._setMap(_this.map);
	                    }
	                    else {
	                        throw new Error("Unable to construct source with ID " + sourceId + ".");
	                    }
	                }
	            });
	            Object.keys(this.sources).forEach(function (sourceId) {
	                if (!sources.hasOwnProperty(sourceId)) {
	                    _this.sources.get(sourceId)._setMap(null);
	                    _this.sources.delete(sourceId);
	                }
	            });
	        }
	    };
	    return SourceManager;
	}());

	/**
	 * The options for animating changes to the map control's camera.
	 */
	var AnimationOptions = /** @class */ (function (_super) {
	    __extends(AnimationOptions, _super);
	    function AnimationOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The duration of the animation in milliseconds.
	         * Default `1000`.
	         * @default 1000
	         */
	        _this.duration = 1000;
	        /**
	         * The type of animation.
	         * <p>"jump" is an immediate change.</p>
	         * <p>"ease" is a gradual change of the camera's settings.</p>
	         * <p>"fly" is a gradual change of the camera's settings following an arc resembling flight.</p>
	         * Default `"jump"`.
	         * @default "jump"
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        _this.type = "jump";
	        return _this;
	    }
	    return AnimationOptions;
	}(Options));

	/**
	 * Represent the amount of padding in pixels to add to the side of a BoundingBox when setting the camera of a map.
	 */
	var Padding = /** @class */ (function (_super) {
	    __extends(Padding, _super);
	    function Padding() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Amount of padding in pixels to add to the bottom.
	         * default `0`
	         * @default 0
	         */
	        _this.bottom = 0;
	        /**
	         * Amount of padding in pixels to add to the left.
	         * default `0`
	         * @default 0
	         */
	        _this.left = 0;
	        /**
	         * Amount of padding in pixels to add to the right.
	         * default `0`
	         * @default 0
	         */
	        _this.right = 0;
	        /**
	         * Amount of padding in pixels to add to the top.
	         * default `0`
	         * @default 0
	         */
	        _this.top = 0;
	        return _this;
	    }
	    return Padding;
	}(Options));

	/**
	 * The options for setting the bounds of the map control's camera.
	 */
	var CameraBoundsOptions = /** @class */ (function (_super) {
	    __extends(CameraBoundsOptions, _super);
	    function CameraBoundsOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The bounds of the map control's camera.
	         * Default `[-180, -89, 180, 90]`.
	         * @default [-180, -89, 180, 90]
	         */
	        _this.bounds = [-180, -89, 180, 90];
	        /**
	         * A bounding box in which to constrain the viewable map area to.
	         * Users won't be able to pan the center of the map outside of this bounding box.
	         * Set maxBounds to null or undefined to remove maxBounds
	         * Default `undefined`.
	         * @default undefined
	         */
	        _this.maxBounds = undefined;
	        /**
	         * The maximum zoom level to allow when the map view transitions to the specified bounds.
	         * Default `20`.
	         * @default 20
	         */
	        _this.maxZoom = 20;
	        /**
	         * An offset of the center of the given bounds relative to the map's center, measured in pixels.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.offset = new Pixel(0, 0);
	        /**
	         * The amount of padding in pixels to add to the given bounds.
	         * Default `{top: 0, bottom: 0, left: 0, right: 0}`.
	         * @default {top: 0, bottom: 0, left: 0, right: 0}
	         */
	        _this.padding = new Padding();
	        return _this;
	    }
	    /**
	     * overwriting merge to accept one value for padding
	     */
	    CameraBoundsOptions.prototype.merge = function () {
	        var e_1, _a;
	        var valuesList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valuesList[_i] = arguments[_i];
	        }
	        try {
	            for (var valuesList_1 = __values(valuesList), valuesList_1_1 = valuesList_1.next(); !valuesList_1_1.done; valuesList_1_1 = valuesList_1.next()) {
	                var value = valuesList_1_1.value;
	                if (value && typeof value.padding === "number") {
	                    value.padding = {
	                        top: value.padding,
	                        bottom: value.padding,
	                        left: value.padding,
	                        right: value.padding
	                    };
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (valuesList_1_1 && !valuesList_1_1.done && (_a = valuesList_1.return)) _a.call(valuesList_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return _super.prototype.merge.apply(this, __spread(valuesList));
	    };
	    return CameraBoundsOptions;
	}(Options));

	/**
	 * The options for setting the map control's camera.
	 */
	var CameraOptions = /** @class */ (function (_super) {
	    __extends(CameraOptions, _super);
	    function CameraOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The zoom level of the map view.
	         * Default `1`.
	         * @default 1
	         */
	        _this.zoom = 1;
	        /**
	         * The position to align the center of the map view with.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.center = new Position(0, 0);
	        /**
	         * A pixel offset to apply to the center of the map.
	         * This is useful if you want to programmatically pan the map to another location or if you want to center the map over a shape, then offset the maps view to make room for a popup.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.centerOffset = new Pixel(0, 0);
	        /**
	         * The bearing of the map (rotation) in degrees. When the bearing is 0, 90, 180, or 270 the top of the map container will be north, east, south or west respectively.
	         * Default `0`.
	         * @default 0
	         */
	        _this.bearing = 0;
	        /**
	         * The pitch (tilt) of the map in degrees between 0 and 60, where 0 is looking straight down on the map.
	         * Default `0`.
	         * @default 0
	         */
	        _this.pitch = 0;
	        /**
	         * The minimum zoom level that the map can be zoomed out to during the animation. Must be between 0 and 24, and less than or equal to `maxZoom`.
	         * Default `1`.
	         * @default 1
	         */
	        _this.minZoom = 1;
	        /**
	         * The maximum zoom level that the map can be zoomed into during the animation. Must be between 0 and 24, and greater than or equal to `minZoom`.
	         * Default `20`.
	         * @default 20
	         */
	        _this.maxZoom = 20;
	        /**
	         * A bounding box in which to constrain the viewable map area to.
	         * Users won't be able to pan the center of the map outside of this bounding box.
	         * Set maxBounds to null or undefined to remove maxBounds
	         * Default `undefined`.
	         * @default undefined
	         */
	        _this.maxBounds = undefined;
	        return _this;
	    }
	    return CameraOptions;
	}(Options));

	/**
	 * The options for a layer of the map.
	 */
	var LayerOptions$1 = /** @class */ (function (_super) {
	    __extends(LayerOptions, _super);
	    function LayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The name of the layer.
	         */
	        _this.name = undefined;
	        /**
	         * The name of the layer to place this layer before.  If not specified, the layer will be placed at the top of the
	         * layer list.
	         */
	        _this.before = undefined;
	        /**
	         * The minimum zoom at which the layer will display inclusive.
	         */
	        _this.minZoom = 1;
	        /**
	         * The maximum zoom at which the layer will display inclusive.
	         */
	        _this.maxZoom = 20;
	        /**
	         * Whether to overwrite previous data for the layer.
	         */
	        _this.overwrite = false;
	        /**
	         * The opacity of the layer.
	         */
	        _this.opacity = 1;
	        return _this;
	    }
	    return LayerOptions;
	}(Options));

	/**
	 * The options for a circle layer.
	 * @deprecated Use BubbleLayerOptions with atlas.layer.BubbleLayer instead.
	 */
	var CircleLayerOptions = /** @class */ (function (_super) {
	    __extends(CircleLayerOptions, _super);
	    function CircleLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The fill color of the circles for the layer. Is used as the default if a fill color is not specified for a
	         * circle.
	         */
	        _this.color = "rgba(0,0,0,.5)";
	        /**
	         * The outline color of the circles for the layer. Is used as the default if an outline color is not specified for
	         * a circle.
	         */
	        _this.outlineColor = "#000";
	        /**
	         * The radius in pixels of the circles for the layer. Is used as the default if a radius is not specified for a
	         * circle.
	         */
	        _this.radius = 1;
	        /**
	         * The outline stroke width of the circles for the layer. Is used as the default if outline width is not specified
	         * for a circle.
	         */
	        _this.outlineWidth = 5;
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-circles";
	        return _this;
	    }
	    return CircleLayerOptions;
	}(LayerOptions$1));

	/**
	 * The options for a linestring layer.
	 * @deprecated Use LineLayerOptions with atlas.layer.LineLayer instead.
	 */
	var LinestringLayerOptions = /** @class */ (function (_super) {
	    __extends(LinestringLayerOptions, _super);
	    function LinestringLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The type of cap to use for the ends of the linestrings:
	         * <p>"butt" is a squared ending that is drawn to the exact endpoint of the line.</p>
	         * <p>"round" is a circular ending that is drawn past the exact endpoint with a radius of half the linestring's
	         * width.</p>
	         * <p>"square" is a squared ending that is drawn past the exact endpoint by half the linestring's width.
	         */
	        _this.cap = "butt";
	        /**
	         * The type of join to use for the linestrings:
	         * <p>"bevel" is a squared join that cuts a corner flat at half the linestring's width from the vertex.</p>
	         * <p>"round" is a circular join that rounds a corner with a radius of half the linestring's width from the
	         * vertex.</p>
	         * <p>"miter" is a sharp join that extends the segments of the linestring past the vertex until they intersect.</p>
	         */
	        _this.join = "miter";
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-linestrings";
	        /**
	         * The color of the lines for the layer. Is used as the default if a specific color is not specified for a line.
	         */
	        _this.color = "#000";
	        /**
	         * The width of the lines for the layer. Is used as the default if a specific width is not specified for a line.
	         */
	        _this.width = 1;
	        return _this;
	    }
	    return LinestringLayerOptions;
	}(LayerOptions$1));

	/**
	 * The options for a pin layer.
	 * @deprecated Use SymbolLayerOptions with atlas.layer.SymbolLayer instead.
	 */
	var PinLayerOptions = /** @class */ (function (_super) {
	    __extends(PinLayerOptions, _super);
	    function PinLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The factor by which the icon should be scaled. A value of 1 is the original size; a value of 2 will double the
	         * size of the icon.
	         */
	        _this.iconSize = 1;
	        /**
	         * The size of the title text.
	         */
	        _this.fontSize = 14;
	        /**
	         * The color of the title text.
	         */
	        _this.fontColor = "#000";
	        /**
	         * The font for the title of the pin.
	         */
	        _this.textFont = "SegoeUi-Regular";
	        /**
	         * Whether the icons should cluster when they collide on the map, or stay separate.
	         */
	        _this.cluster = true;
	        /**
	         * The icon to use to represent a cluster.
	         */
	        _this.clusterIcon = undefined;
	        /**
	         * An array of [pixelsRight, pixelsDown] for how many pixels to the right and down the title text should be
	         * offset. Negative numbers can be used to offset the title left and up.
	         */
	        _this.textOffset = [0, 0];
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-pins";
	        /**
	         * The icon of the pins for the layer. Is used as the default if an icon is not specified for a pin.
	         */
	        _this.icon = "pin-darkblue";
	        /**
	         * The title of the pins for the layer. Is used as the default if a title is not specified for a pin.
	         */
	        _this.title = "";
	        return _this;
	    }
	    return PinLayerOptions;
	}(LayerOptions$1));

	/**
	 * The options for a polygon layer.
	 * @deprecated Use new PolygonLayerOptions with atlas.layer.PolygonLayer instead.
	 */
	var PolygonLayerOptions$1 = /** @class */ (function (_super) {
	    __extends(PolygonLayerOptions, _super);
	    function PolygonLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The fill color of the polygons for the layer. Is used as the default if a fill color is not specified for a
	         * polygon.
	         */
	        _this.color = "rgba(0,0,0,.5)";
	        /**
	         * The outline color of the polygons for the layer. Is used as the default if an outline color is not specified for
	         * a polygon.
	         * @deprecated Use `atlas.layer.LineLayer` to provide an outline for a polygon.
	         */
	        _this.outlineColor = "#000";
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-polygons";
	        return _this;
	    }
	    return PolygonLayerOptions;
	}(LayerOptions$1));

	/**
	 * The options for a raster layer.
	 * @deprecated Use TileLayerOptions with atlas.layer.TileLayer instead.
	 */
	var RasterLayerOptions = /** @class */ (function (_super) {
	    __extends(RasterLayerOptions, _super);
	    function RasterLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-raster";
	        return _this;
	    }
	    return RasterLayerOptions;
	}(LayerOptions$1));

	/**
	 * The options for the map's lighting.
	 */
	var LightOptions = /** @class */ (function (_super) {
	    __extends(LightOptions, _super);
	    function LightOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Specifies wether extruded geometries are lit relative to the map or viewport.
	         * Supported values:
	         * <p>`"map"`: The position of the light source is aligned to the rotation of the map.</p>
	         * <p>`"viewport"`: The position fo the light source is aligned to the rotation of the viewport.</p>
	         * Default: `"map"`
	         * @default "map"
	         */
	        _this.anchor = "map";
	        /**
	         * Color tint for lighting extruded geometries
	         * Default: `"#FFFFFF"`
	         * @default "#FFFFFF"
	         */
	        _this.color = "#FFFFFF";
	        /**
	         * Intensity of lighting (on a scale from 0 to 1).
	         * Higher numbers will present as more extreme contrast.
	         * Default `0.5`
	         * @default 0.5
	         */
	        _this.intensity = 0.5;
	        /**
	         * Position of the light source relative to lit (extruded) geometries,
	         * in [r radial coordinate, a azimuthal angle, p polar angle]
	         * where r indicates the distance from the center of the base of an object to its light,
	         * a indicates the position of the light relative to 0°
	         * (0° when `anchor` is set to viewport corresponds to the top of the viewport,
	         * or 0° when `anchor` is set to map corresponds to due north, and degrees proceed clockwise),
	         * and p indicates the height of the light (from 0°, directly above, to 180°, directly below).
	         */
	        _this.position = [1.15, 210, 30];
	        return _this;
	    }
	    return LightOptions;
	}(Options));

	/**
	 * The options for the map's style.
	 */
	var StyleOptions = /** @class */ (function (_super) {
	    __extends(StyleOptions, _super);
	    function StyleOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * If true the map will automatically resize whenever the window's size changes.
	         * Otherwise map.resize() must be called.
	         * Default `true`.
	         * @default true
	         */
	        _this.autoResize = true;
	        /**
	         * The language of the map labels.
	         * [Supported language]{@link https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages}.
	         * Default `atlas.getLanguage()`.
	         * @default atlas.getLanguage()
	         */
	        _this.language = getLanguage();
	        /**
	         * Sets the lighting options of the map.
	         */
	        _this.light = new LightOptions();
	        /**
	         * If true, the map's canvas can be exported to a PNG using map.getCanvas().toDataURL().
	         * This option may only be set when initializing the map.
	         * Default `false`
	         * @default false
	         */
	        _this.preserveDrawingBuffer = false;
	        /**
	         * Specifies if multiple copies of the world should be rendered when zoomed out.
	         * Default `true`
	         * @default true
	         */
	        _this.renderWorldCopies = true;
	        /**
	         * Specifies if buildings will be rendered with their models.
	         * If false all buildings will be rendered as just their footprints.
	         * Default `false`
	         * @default false
	         */
	        _this.showBuildingModels = false;
	        /**
	         * Specifies if the feedback link should be displayed on the map or not.
	         * Default `true`
	         * @default true
	         */
	        _this.showFeedbackLink = true;
	        /**
	         * Specifies if the Microsoft logo should be hidden or not.
	         * If set to true a Microsoft copyright string will be added to the map.
	         * Default `true`
	         * @default true
	         */
	        _this.showLogo = true;
	        /**
	         * Additional custom attribution appended to map attribution.
	         * Default `undefined`
	         * @default undefined
	         */
	        _this.customAttribution = undefined;
	        /**
	         * Specifies if the map should render an outline around each tile and the tile ID.
	         * These tile boundaries are useful for debugging.
	         * The uncompressed file size of the first vector source is drawn in the top left corner of each tile,
	         * next to the tile ID.
	         * Default `false`
	         * @default false
	         */
	        _this.showTileBoundaries = false;
	        /**
	         * The name of the style to use when rendering the map. Available styles can be found in the
	         * [supported styles]{@link https://docs.microsoft.com/en-us/azure/azure-maps/supported-map-styles} article. The
	         * default style is "road".
	         */
	        _this.style = "road";
	        /**
	         * Specifies which set of geopolitically disputed borders and labels are displayed on the map. The View parameter (also referred to as “user region parameter”) is a 2-letter ISO-3166 Country Code that will show the correct maps for that country/region. Country/Regions that are not on the View list or if unspecified will default to the “Unified” View.
	         * Please see the supported [Views]{@link https://aka.ms/AzureMapsLocalizationViews}
	         * It is your responsibility to determine the location of your users, and then set the View parameter correctly for that location. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the country where maps, images and other data and third party content that You are authorized to access via Azure Maps is made available.
	         * default: `undefined`
	         * @default undefined
	         */
	        _this.view = getView();
	        /**
	         * @deprecated use `view` instead.
	         */
	        _this.userRegion = _this.view;
	        return _this;
	    }
	    /**
	     * Override the standard merge behavior to first reassign the view property names to the new view one.
	     * Also converts the specified language to a best fit supported one.
	     * @internal
	     */
	    StyleOptions.prototype.merge = function () {
	        var e_1, _a;
	        var valueList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valueList[_i] = arguments[_i];
	        }
	        try {
	            for (var valueList_1 = __values(valueList), valueList_1_1 = valueList_1.next(); !valueList_1_1.done; valueList_1_1 = valueList_1.next()) {
	                var value = valueList_1_1.value;
	                if (value) {
	                    // Make sure both view and userRegion properties exist. Prefer view's value.
	                    if (value.hasOwnProperty("view")) {
	                        value.userRegion = value.view;
	                    }
	                    else if (value.hasOwnProperty("userRegion")) {
	                        value.view = value.userRegion;
	                    }
	                    // Make sure the language is converted to the best fit supported one.
	                    if (typeof value.language === "string") {
	                        value.language = Localizer.getCode(value.language);
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (valueList_1_1 && !valueList_1_1.done && (_a = valueList_1.return)) _a.call(valueList_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        // Then execute the standard merge behavior.
	        return _super.prototype.merge.apply(this, __spread(valueList));
	    };
	    return StyleOptions;
	}(Options));

	/**
	 * The options for setting traffic on the map.
	 */
	var TrafficOptions = /** @class */ (function (_super) {
	    __extends(TrafficOptions, _super);
	    function TrafficOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The type of traffic flow to display:
	         * <p>"none" is to display no traffic flow data</p>
	         * <p>"relative" is the speed of the road relative to free-flow</p>
	         * <p>"absolute" is the absolute speed of the road</p>
	         * <p>"relative-delay" displays relative speed only where they differ from free-flow;
	         * false to stop displaying the traffic flow.</p>
	         * default `"none"``
	         * @default "none"
	         */
	        _this.flow = "none";
	        /**
	         * Whether to display incidents on the map.
	         * default `false`
	         * @default false
	         */
	        _this.incidents = false;
	        return _this;
	    }
	    return TrafficOptions;
	}(Options));

	var composeTransformers = function (transformers) { return transformers.length == 0
	    ? undefined
	    : transformers.slice(1).reduce(function (chained, transform) {
	        return function (url, resourceType) {
	            var resourceParams = chained(url, resourceType);
	            return __assign(__assign({}, resourceParams), transform(resourceParams.url, resourceType));
	        };
	    }, transformers[0]); };
	/**
	 * Global properties used in all atlas service requests.
	 */
	var ServiceOptions = /** @class */ (function (_super) {
	    __extends(ServiceOptions, _super);
	    function ServiceOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The authentication options used to customize how the map control authenticates with Azure Maps services.
	         * If these authentication options are specified then ServiceOptions.subscriptionKey should not be.
	         * Recommend using the atlas.setAuthenticationOptions function instead.
	         */
	        _this.authOptions = getAuthenticationOptions();
	        /**
	         * Disable telemetry collection
	         * This option may only be set when initializing the map.
	         * default: false
	         * @default false
	         */
	        _this.disableTelemetry = false;
	        /**
	         * Disable telemetry collection
	         * This option may only be set when initializing the map.
	         * @deprecated Recommend using disableTelemetry instead.
	         */
	        _this["disable-telemetry"] = _this.disableTelemetry;
	        /**
	         * The domain to use when requesting map tiles and other Azure Maps services.
	         * If the protocol is not specified `https` is assumed.
	         * Recommend using atlas.setDomain function instead.
	         * @default "atlas.microsoft.com"
	         */
	        _this.domain = getDomain();
	        /**
	         * The domain to use when requesting style data and other static assets.
	         */
	        _this.staticAssetsDomain = getStaticAssetsDomain();
	        /**
	         * The styleDefinitionsPath to use for getting the map styles.
	         * Recommend using atlas.setStyleDefinitionsPath function instead.
	         * @default atlas.getStyleDefinitionsPath()
	         * @internal
	         */
	        _this.styleDefinitionsPath = getStyleDefinitionsPath();
	        /**
	         * The style definitions version to request when requesting styles
	         * from styleDefinitionsPath. Recommend using atlas.getStyleDefinitionsVersion
	         * function instead.
	         */
	        _this.styleDefinitionsVersion = getStyleDefinitionsVersion();
	        /**
	         * Enable accessibility
	         * default: true
	         * @default true
	         */
	        _this.enableAccessibility = true;
	        /**
	         * Enable accessibility
	         * @deprecated Recommend using enableAccessibility instead.
	         */
	        _this["enable-accessibility"] = _this.enableAccessibility;
	        /**
	         * Enable fallback to geocoder for accessibility location, if failed to extract location from vector data.
	         * default: true
	         * @default true
	         * @internal
	         */
	        _this.enableAccessibilityLocationFallback = true;
	        /**
	         * Maximum number of images (raster tiles, sprites, icons) to load in parallel,
	         * which affects performance in raster-heavy maps. 16 by default.
	         */
	        _this.maxParallelImageRequests = getMaxParallelImageRequests();
	        /**
	         * A boolean that specifies if vector and raster tiles should be reloaded when they expire (based on expires header).
	         * This is useful for data sets that update frequently. When set to false, each tile will be loaded once, when needed, and not reloaded when they expire.
	         * default: true
	         * @default true
	         */
	        _this.refreshExpiredTiles = true;
	        /**
	         * The customer subscription key used to authorize requests.
	         * This option may only be set when initializing the map.
	         * Recommend using the atlas.setSubscriptionKey function instead
	         */
	        _this.subscriptionKey = getSubscriptionKey();
	        /**
	         * The customer subscription key used to authorize requests.
	         * This option may only be set when initializing the map.
	         * @deprecated Recommend using the atlas.setSubscriptionKey function instead
	         */
	        _this["subscription-key"] = _this.subscriptionKey;
	        /**
	         * The session id to pass with requests.
	         * Recommend using atlas.setSessionId instead.
	         * @default Random UUID generated at runtime
	         */
	        _this.sessionId = getSessionId();
	        /**
	         * The session id to pass with requests.
	         * @deprecated Recommend using atlas.setSessionId instead.
	         */
	        _this["session-id"] = _this.sessionId;
	        _this._transformers = [];
	        /**
	         * If defined transformRequest will be called to provide custom request parameters for loading a tile.
	         */
	        _this.transformRequest = undefined;
	        /**
	         * Number of web workers instantiated on a page.
	         * By default, it is set to half the number of CPU cores (capped at 6).
	         */
	        _this.workerCount = getWorkerCount();
	        return _this;
	    }
	    /**
	     * Override the standard merge behavior to first reassign the old dash property names to the new camelCase ones.
	     * @internal
	     */
	    ServiceOptions.prototype.merge = function () {
	        var e_1, _a;
	        var valueList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valueList[_i] = arguments[_i];
	        }
	        try {
	            // Make sure both camel and dash case properties exist. Prefer the camel case ones.
	            for (var valueList_1 = __values(valueList), valueList_1_1 = valueList_1.next(); !valueList_1_1.done; valueList_1_1 = valueList_1.next()) {
	                var value = valueList_1_1.value;
	                if (value) {
	                    // authOptions can also have a subscription key so check for that first.
	                    // If authOptions are specified then they should be preferred over the previous ServiceOptions.subscriptionKey.
	                    if (value.authOptions) {
	                        if (typeof value.authOptions.subscriptionKey === "string") {
	                            value.subscriptionKey = value["subscription-key"] =
	                                value.authOptions.subscriptionKey;
	                        }
	                    }
	                    else {
	                        if (typeof value.subscriptionKey === "string") {
	                            value["subscription-key"] = value.subscriptionKey;
	                            value.authOptions = {
	                                authType: exports.AuthenticationType.subscriptionKey,
	                                subscriptionKey: value.subscriptionKey,
	                            };
	                        }
	                        else if (typeof value["subscription-key"] === "string") {
	                            value.subscriptionKey = value["subscription-key"];
	                            value.authOptions = {
	                                authType: exports.AuthenticationType.subscriptionKey,
	                                subscriptionKey: value["subscription-key"],
	                            };
	                        }
	                    }
	                    if (typeof value.sessionId === "string") {
	                        value["session-id"] = value.sessionId;
	                    }
	                    else if (typeof value["session-id"] === "string") {
	                        value.sessionId = value["session-id"];
	                    }
	                    if (typeof value.disableTelemetry === "boolean") {
	                        value["disable-telemetry"] = value.disableTelemetry;
	                    }
	                    else if (typeof value["disable-telemetry"] === "boolean") {
	                        value.disableTelemetry = value["disable-telemetry"];
	                    }
	                    if (typeof value.enableAccessibility === "boolean") {
	                        value["enable-accessibility"] = value.enableAccessibility;
	                    }
	                    else if (typeof value["enable-accessibility"] === "boolean") {
	                        value.enableAccessibility = value["enable-accessibility"];
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (valueList_1_1 && !valueList_1_1.done && (_a = valueList_1.return)) _a.call(valueList_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        // default merge behavior overrides _transformers
	        // won't change default behavior in Options as usually that's what desired
	        // instead capture it here and reassign.
	        var currentTransforms = this._transformers;
	        var transformersToMerge = valueList ? valueList.filter(function (value) { return value !== undefined; }).reduce(function (flattened, value) { return __spread(flattened, value._transformers || []); }, []) : [];
	        // Then execute the standard merge behavior.
	        // If subscription key auth method isn't being used then the subscription key property should be undefined.
	        var merged = _super.prototype.merge.apply(this, __spread(valueList));
	        if (merged.authOptions.authType !== exports.AuthenticationType.subscriptionKey) {
	            merged["subscription-key"] = merged.subscriptionKey = undefined;
	        }
	        this._transformers = __spread(currentTransforms || [], transformersToMerge.filter(function (toMerge) { return !currentTransforms.includes(toMerge); }));
	        if (this.transformRequest && !this._transformers.includes(this.transformRequest)) {
	            this._transformers.push(this.transformRequest);
	        }
	        // chain transformers in a middleware fashion
	        this.transformRequest = composeTransformers(this._transformers);
	        return merged;
	    };
	    /**
	     * Appends request transformer
	     */
	    ServiceOptions.prototype.addTransformer = function (transformer) {
	        if (!this._transformers) {
	            this._transformers = [];
	        }
	        this._transformers.push(transformer);
	        this.transformRequest = composeTransformers(this._transformers);
	    };
	    /**
	     * Removes request transformer
	     */
	    ServiceOptions.prototype.removeTransformer = function (transformer) {
	        if (!this._transformers) {
	            return;
	        }
	        this._transformers = this._transformers.filter(function (existing) { return transformer !== existing; });
	        this.transformRequest = composeTransformers(this._transformers);
	    };
	    /**
	     * Customizer for _.cloneDeep calls, allows objects to pass through with only a shallow cloning.
	     * Currently the only objects being cloned should be the `AuthenticationOptions`.
	     * @param value The value being cloned.
	     * @internal
	     */
	    ServiceOptions._cloneCustomizer = function (value) {
	        if (typeof value === "object") {
	            return Object.assign({}, value);
	        }
	    };
	    return ServiceOptions;
	}(Options));

	var LayerGroupComparator = /** @class */ (function () {
	    function LayerGroupComparator() {
	    }
	    /**
	     * Extract layer group name from layer id. This method assumes the layer group is
	     * the fourth token in a dotted string where the first token is "microsoft".
	     * @param layer Mapbox layer to extract layer group name from
	     * @returns layer group if present, undefined otherwise.
	     * @internal
	     */
	    LayerGroupComparator.getLayerGroup = function (layer) {
	        var _a, _b;
	        var layerId = (_b = (_a = layer) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : layer;
	        if (!layerId.startsWith("microsoft.")) {
	            return;
	        }
	        var idTokens = layerId.split('.');
	        if (idTokens.length >= 4) {
	            return idTokens[3];
	        }
	        return;
	    };
	    return LayerGroupComparator;
	}());

	/**
	 * @private
	 */
	var StyleManager = /** @class */ (function () {
	    /**
	     * Constructs the style manager to be exposed only through the styles property of the Map class.
	     * @param map The map whose styles are being managed by this.
	     * @param serviceOptions Service options contain domain to use for requesting style resources.
	     * @internal
	     */
	    function StyleManager(map, serviceOptions) {
	        this.apiVersion = "2.0";
	        this.map = map;
	        this.serviceOptions = serviceOptions;
	    }
	    /**
	     * If this method has been called before the original initialize promise is returned.
	     */
	    StyleManager.prototype.initialize = function () {
	        var _this = this;
	        if (!this.initPromise) {
	            this.initPromise = this._request(this.serviceOptions.staticAssetsDomain, constants.stylePath + "/" + constants.styleResourcePath, "StyleDefinitions")
	                .then(function (response) {
	                _this.definitions = response;
	            }).catch(function (reason) {
	                throw new Error("Failed to retrieve the style definitions: " + reason);
	            });
	        }
	        this.styleSet = "base";
	        return this.initPromise;
	    };
	    /**
	     * Gets the URL of a style listed in style definition. Style definition's default style is used if
	     * styleName is not provided or if styleName is not present in the style definition.
	     */
	    StyleManager.prototype.getStyleUrl = function (styleOptions) {
	        var _a;
	        var styleDefinition = this._lookUp(styleOptions);
	        var url = new Url({
	            domain: this.serviceOptions.staticAssetsDomain,
	            path: constants.stylePath + "/" + constants.styleResourcePath + "/" + styleDefinition.name,
	            queryParams: (_a = {},
	                _a[constants.apiVersionQueryParameter] = this.apiVersion,
	                _a["version"] = this.definitions.version,
	                _a),
	            protocol: "https"
	        });
	        return url.toString();
	    };
	    StyleManager.prototype.setStyleUrl = function (styleOptions) {
	        var styleUrl = this.getStyleUrl(styleOptions);
	        try {
	            this.map._getMap().setStyle(styleUrl, { diff: true, stylePatch: this._stylePatch.bind(this) });
	        }
	        catch (e) {
	            throw e;
	        }
	    };
	    /**
	     * Gets the color theme (light/dark) for the style type specified by the style options.
	     */
	    StyleManager.prototype.getTheme = function (styleOptions) {
	        var style = this._lookUp(styleOptions);
	        return style.theme.toLowerCase() || "light";
	    };
	    /**
	     * Bug: 9984684 - Remove this method.
	     * Switch to a different set of styles.
	     * @param styleSet Name of style set to select.
	     */
	    StyleManager.prototype.setStyleSet = function (styleSet) {
	        if (styleSet !== this.styleSet) {
	            this.styleSet = styleSet;
	            this.setStyleUrl(this.map.getStyle());
	        }
	    };
	    /**
	     * Bug: 9984684 - Remove this method.
	     * Get the current style set.
	     * @param name Name of module to add.
	     */
	    StyleManager.prototype.getStyleSet = function () {
	        return this.styleSet;
	    };
	    /**
	     *
	     * @param name Bug 9984684 - Remove this method.
	     * "Reset to base Style Set"
	     */
	    StyleManager.prototype.clearStyleSet = function () {
	        if ("base" !== this.styleSet) {
	            this.styleSet = "base";
	            this.setStyleUrl(this.map.getStyle());
	        }
	    };
	    /**
	     * Gets the full style definition object.
	     */
	    StyleManager.prototype.getDef = function () {
	        // return this.definitions; // TODO: Restore this line. Bug: 9984684
	        var result = Object.assign({}, this.definitions);
	        result.styles = result.styles.filter(function (style) { return (!style.name.endsWith("_indoor") && !style.name.endsWith("_indoor_dark")); });
	        return result;
	    };
	    /**
	     * Function invoked by mapbox after a style is fetched but before it is committed to the map state.
	     *
	     * @param previousStyle The current style.
	     * @param nextStyle The next style which is to be applied.
	     * @param preserveLayer Preserve a layer from the previous style in the next style.
	     * @param updatePaintProperty Modify paint properties of a layer in the next style before the style is applied.
	     * @param updateLayoutProperty Modify layout properties of a layer in the next style before the style is applied.
	     * @param updateFilter Modify filter property of a layer in the next style before the style is applied.
	     */
	    StyleManager.prototype._stylePatch = function (previousStyle, nextStyle, preserveLayer, updatePaintProperty, updateLayoutProperty, updateFilter) {
	        var _this = this;
	        // A FundamentalMapLayer (grouped layer) representation of the next style must be built.
	        var previousLayers = this.map.layers.getLayers();
	        var nextLayers = [];
	        var currentLayerGroupId = "";
	        var currentLayerGroupLayers = [];
	        var advanceLayerGroup = function (nextLayerGroup) {
	            nextLayers.push(_this._buildFundamentalLayerFrom(currentLayerGroupLayers, currentLayerGroupId));
	            currentLayerGroupId = nextLayerGroup;
	            currentLayerGroupLayers = [];
	        };
	        // Layers in the next style with default properties that do not align with current StyleOptions
	        // should be modified before they are applied to the map.
	        var styleOptions = this.map.getStyle();
	        var trafficOptions = this.map.getTraffic();
	        nextStyle.layers.forEach(function (nextLayer) {
	            var _a, _b, _c;
	            var layerGroup = LayerGroupComparator.getLayerGroup(nextLayer.id);
	            currentLayerGroupId = currentLayerGroupId ? currentLayerGroupId : layerGroup;
	            // Set visiblity of fill-extrusion layers according to StyleOptions.showBuildingModels
	            if (!styleOptions.showBuildingModels && nextLayer.type === "fill-extrusion") {
	                updateLayoutProperty(nextLayer.id, "visibility", "none");
	                nextLayer.layout = (_a = nextLayer.layout) !== null && _a !== void 0 ? _a : {};
	                nextLayer.layout.visibility = "none";
	            }
	            else if (nextLayer.type === "fill-extrusion") {
	                updateLayoutProperty(nextLayer.id, "visibility", "visible");
	                nextLayer.layout = (_b = nextLayer.layout) !== null && _b !== void 0 ? _b : {};
	                nextLayer.layout.visibility = "visible";
	            }
	            // Set visibility of traffic layers depending on traffic settings.
	            if (trafficOptions.flow !== "none" && layerGroup) {
	                if (layerGroup === "traffic_" + trafficOptions.flow && nextLayer.type == "line") {
	                    updateLayoutProperty(nextLayer.id, "visibility", "visible");
	                    nextLayer.layout = (_c = nextLayer.layout) !== null && _c !== void 0 ? _c : {};
	                    nextLayer.layout.visibility = "visible";
	                }
	            }
	            // Once this _stylePatch returns control to maplibre the next style will be applied immediately in the same context.
	            // To avoid potential data races update LayerManager with new a new set of FundamentalMapLayers from here instead of 
	            // waiting for a styledata.load event to trigger a sync in a different context.
	            if (layerGroup) {
	                if (currentLayerGroupLayers.length > 0 && layerGroup != currentLayerGroupId) {
	                    advanceLayerGroup(layerGroup);
	                }
	                currentLayerGroupLayers.push(nextLayer);
	            }
	            else if (currentLayerGroupLayers.length > 0) {
	                advanceLayerGroup(layerGroup);
	            }
	        });
	        if (currentLayerGroupLayers.length > 0) {
	            advanceLayerGroup("");
	        }
	        // Update FundamentalMapLayers in LayerManager
	        var userLayers = this.map.layers._getUserLayers();
	        var firstUserLayer = userLayers[0];
	        var layersToRemove = previousLayers.filter(function (c) {
	            return (nextLayers.findIndex(function (n) { return c.getId() === n.getId(); }) < 0 &&
	                userLayers.findIndex(function (n) { return c.getId() === n.layer.getId(); }) < 0);
	        });
	        var prevNextIntersection = nextLayers.filter(function (n) { return previousLayers.find(function (c) { return c.getId() === n.getId(); }); });
	        var ePrevNextIntersection = prevNextIntersection.entries();
	        var replace = ePrevNextIntersection.next();
	        nextLayers.forEach(function (newFundamentalLayer) {
	            if (replace.value && replace.value[1].getId() === newFundamentalLayer.getId()) {
	                // Replace the existing layer with this ID with the new one.
	                var insertBefore = previousLayers.findIndex(function (l) { return l.getId() === newFundamentalLayer.getId(); });
	                _this.map.layers.remove(newFundamentalLayer.getId());
	                _this.map.layers.add(newFundamentalLayer, previousLayers[insertBefore].getId());
	                replace = ePrevNextIntersection.next();
	            }
	            else {
	                if (replace.value) {
	                    // Insert new layer before the next common layer.
	                    _this.map.layers.add(newFundamentalLayer, replace.value[1]);
	                }
	                else {
	                    // Insert new layer underneath the first user layer, or the .
	                    _this.map.layers.add(newFundamentalLayer, firstUserLayer === null || firstUserLayer === void 0 ? void 0 : firstUserLayer.layer);
	                }
	            }
	        });
	        layersToRemove.forEach(function (layer) {
	            _this.map.layers.remove(layer);
	        });
	        // Layers added to mapbox through this SDK since loading the last style should be
	        // carried over to the next style.
	        userLayers.forEach(function (userLayer) {
	            var before = undefined;
	            if (_this.map.layers.getLayerById(userLayer.before)) {
	                var beforeCandidates = _this.map.layers.getLayerById(userLayer.before)._buildLayers();
	                before = (beforeCandidates.length > 0) ? beforeCandidates[0] : undefined;
	            }
	            preserveLayer(userLayer.layer.getId(), before === null || before === void 0 ? void 0 : before.id);
	        });
	        this.map.sources._syncSources(nextStyle.sources);
	        this.map.events.addOnce("styledata", function (eventData) {
	            _this.map.events.invoke("stylechanged", {
	                style: _this._lookUp(_this.map.getStyle()).name,
	                map: _this.map,
	                type: "stylechanged"
	            });
	        });
	    };
	    StyleManager.prototype._buildFundamentalLayerFrom = function (layers, id) {
	        if (layers && layers.length > 0) {
	            var newLayer = new FundamentalMapLayer(layers, id);
	            newLayer.onAdd(this.map);
	            return newLayer;
	        }
	        throw new Error("Unable to construct fundamental map layer for ID: " + id + ".");
	    };
	    /**
	     * Looks up the style type info from the style definition
	     */
	    StyleManager.prototype._lookUp = function (options) {
	        var e_1, _a;
	        // TODO: Remove indoor logic here. Bug: 9984684
	        var styleName = (options.style || this.definitions.defaultStyle)
	            .concat(this.styleSet === "indoor" ? "_indoor" : "")
	            .concat(this.styleSet === "indoor_dark" ? "_indoor_dark" : "");
	        var defaultStyleName = this.definitions.defaultStyle
	            .concat(this.styleSet === "indoor" ? "_indoor" : "")
	            .concat(this.styleSet === "indoor_dark" ? "_indoor_dark" : "");
	        var fallbackStyle;
	        try {
	            for (var _b = __values((this.definitions || {}).styles), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var style = _c.value;
	                if (style.name === styleName) {
	                    return style; // Safe when the definition missing requested styleName.
	                    // Makes silent decision to use first instance of a style if there are more than one with the same name.
	                }
	                else if (style.name === defaultStyleName) {
	                    fallbackStyle = style; // Assumes that the definition contains the default style.
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return fallbackStyle;
	    };
	    /**
	     * Replace URL placeholders and add StyleManager API version to requests made for style resources.
	     * @param params RequestParameters to modify.
	     * @returns Valid style RequestParameters.
	     * @internal
	     */
	    StyleManager.prototype._transformStyleRequest = function (url, params) {
	        if (url.includes(constants.domainPlaceHolder)) {
	            params.url = params.url.replace(constants.domainPlaceHolder, this.serviceOptions.staticAssetsDomain);
	        }
	        if (url.includes(constants.stylePathHolder)) {
	            params.url = params.url.replace(constants.stylePathHolder, constants.stylePath);
	        }
	        if (url.includes(constants.styleResourcePlaceholder)) {
	            params.url = params.url.replace(constants.styleResourcePlaceholder, constants.styleResourcePath);
	        }
	        params.url = params.url + ("" + (url.includes('?') ? '&' : '?') + constants.apiVersionQueryParameter + "=" + this.apiVersion);
	    };
	    /**
	     * Fetches a json resource at the specified domain and path.
	     */
	    StyleManager.prototype._request = function (domain, path, resourceType) {
	        return __awaiter(this, void 0, void 0, function () {
	            var requestParams, url, fetchOptions, request;
	            var _a;
	            return __generator(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        url = new Url({
	                            protocol: "https",
	                            domain: domain,
	                            path: path,
	                            queryParams: (_a = {},
	                                _a[constants.apiVersionQueryParameter] = this.apiVersion,
	                                _a["version"] = this.serviceOptions.styleDefinitionsVersion,
	                                _a)
	                        }).toString();
	                        if (typeof this.serviceOptions.transformRequest === "function" && resourceType) {
	                            // If a transformRequest(...) was specified use it.
	                            requestParams = this.serviceOptions.transformRequest(url, resourceType);
	                        }
	                        fetchOptions = {
	                            method: "GET",
	                            mode: "cors",
	                        };
	                        if (requestParams) {
	                            requestParams.credentials &&
	                                (fetchOptions.credentials = requestParams.credentials);
	                            requestParams.headers &&
	                                (fetchOptions.headers = requestParams.headers);
	                            url = requestParams.url || url;
	                        }
	                        request = new Request(url, fetchOptions);
	                        return [4 /*yield*/, fetch(request).then(function (response) {
	                                if (response.ok) {
	                                    return response.json();
	                                }
	                                else {
	                                    throw new Error("HTTP " + response.status + ": " + response.statusText + " ");
	                                }
	                            })];
	                    case 1: return [2 /*return*/, _b.sent()];
	                }
	            });
	        });
	    };
	    return StyleManager;
	}());

	/**
	 * @private
	 */
	var isHMREnabled = function () { return 'ENVIRONMENT' in window && !!window['ENVIRONMENT']['hmr']; };

	/**
	 * The control for a visual and interactive web map.
	 */
	var Map$2 = /** @class */ (function (_super) {
	    __extends(Map, _super);
	    /**
	     * Displays a map in the specified container.
	     * @param container The id of the element where the map should be displayed.
	     * @param options Options for the initial display and interactability with the map.
	     */
	    function Map(container, options) {
	        var _this = _super.call(this) || this;
	        _this.styleSourceIds = new Set();
	        // Map state trackers
	        _this.removed = false;
	        _this.loaded = false;
	        _this.ready = false;
	        /**
	         * The callback used when styleOptions.autoResize is true.
	         */
	        _this._windowResizeCallback = function () { return _this.resize(); };
	        var successfulLoad = true;
	        // Update global defaults based on which options were specified to this constructor.
	        _this._updateGlobalDefaults(options);
	        _this.serviceOptions = new ServiceOptions().merge(options);
	        _this.styleOptions = new StyleOptions().merge(options);
	        _this.trafficOptions = new TrafficOptions();
	        _this.styles = new StyleManager(_this, _this.serviceOptions);
	        {
	            _this.insights = new Insights(_this.serviceOptions);
	        }
	        if (_this.serviceOptions.authOptions.subscriptionKey) {
	            _this.serviceOptions.authOptions.subscriptionKey = encodeURIComponent(_this.serviceOptions.authOptions.subscriptionKey);
	        }
	        // If a client id is available use that for telemetry, fallback to subscription key if necessary.
	        // Only keep the last 3 characters of the subscription key.
	        var accountId;
	        if (_this.serviceOptions.authOptions.clientId) {
	            accountId = _this.serviceOptions.authOptions.clientId;
	        }
	        else if (_this.serviceOptions.authOptions.subscriptionKey) {
	            accountId = _this.serviceOptions.authOptions.subscriptionKey.replace(/.(?=.{3,}$)/g, "*");
	        }
	        else {
	            accountId = "invalid-setting";
	        }
	        if (_this.insights) {
	            _this.insights.setAuthenticatedUserContext(_this.serviceOptions.sessionId, accountId);
	        }
	        var mapboxMap;
	        if (arguments[2] && isHMREnabled()) {
	            mapboxMap = arguments[2];
	            _this.ready = true;
	            _this.loaded = true;
	        }
	        else {
	            var mapboxMapOptions = {
	                attributionControl: false,
	                container: container,
	                preserveDrawingBuffer: _this.styleOptions.preserveDrawingBuffer,
	                refreshExpiredTiles: _this.serviceOptions.refreshExpiredTiles,
	                renderWorldCopies: _this.styleOptions.renderWorldCopies,
	                trackResize: false,
	                transformRequest: function (url, resourceType) {
	                    var requestParams = {
	                        url: url
	                    };
	                    if (resourceType === "Tile" || resourceType === "Source") {
	                        // Note: if url includes legacyDomainPlaceHolder it will also include domainPlaceHolder
	                        //                       {azMapsDomain}                               {{azMapsDomain}}
	                        if (url.includes(constants.legacyDomainPlaceHolder) && _this.insights) {
	                            _this.insights.trackEvent({ name: "TileLoad" });
	                        }
	                        _this._substituteDomainLanguageViewAndSignInRequest(url, requestParams);
	                    }
	                    else if (resourceType === "SpriteJSON" || resourceType === "SpriteImage" || resourceType === "Glyphs") {
	                        _this.styles._transformStyleRequest(url, requestParams);
	                    }
	                    // Apply the users specified transform after ours
	                    if (_this.serviceOptions.transformRequest) {
	                        merge_1(requestParams, _this.serviceOptions.transformRequest(requestParams.url, resourceType));
	                    }
	                    return requestParams;
	                }
	            };
	            mapboxMap = new azuremapsMaplibreGlUnminified.Map(mapboxMapOptions);
	        }
	        try {
	            _this.map = mapboxMap;
	            // Initialize managers
	            {
	                _this.authentication = new AuthenticationManager(_this);
	            }
	            _this.controls = new ControlManager(_this);
	            _this.events = new EventManager(_this);
	            _this.imageSprite = new ImageSpriteManager(_this);
	            _this.layers = new LayerManager(_this);
	            _this.markers = new HtmlMarkerManager(_this);
	            _this.sources = new SourceManager(_this);
	            _this.popups = new PopupManager(_this);
	            // Add CSS classes and set attributes for DOM elements.
	            _this.map.getContainer().classList.add(Map.Css.container);
	            _this.map.getCanvasContainer().classList.add(Map.Css.canvasContainer);
	            _this.map.getCanvas().classList.add(Map.Css.canvas);
	            _this._detectHighContrast();
	            // Always add the copyright label.
	            _this.copyrightControl = new CopyrightControl({
	                showFeedbackLink: _this.styleOptions.showFeedbackLink,
	                showLogo: _this.styleOptions.showLogo,
	                customAttribution: _this.styleOptions.customAttribution
	            });
	            _this.controls.add(_this.copyrightControl, {
	                position: exports.ControlPosition.NonFixed
	            });
	            // Initialize state of map
	            // --> Initialize the authentication manager
	            var authManInit = _this.authentication ?
	                _this.authentication.initialize() : Promise.resolve();
	            if (_this.removed) {
	                return _this;
	            }
	            // --> Track if the map has completed its first load
	            var setLoaded_1 = function () {
	                _this.loaded = true;
	                _this.map.off("load", setLoaded_1);
	            };
	            _this.map.on("load", setLoaded_1);
	            // --> Track if the map has set its initial style
	            var setReady_1 = function () {
	                _this.ready = true;
	                _this.map.off("styledata", setReady_1);
	                // Manually invoke the ready event the first time styledata fires.
	                var readyData = { map: _this, type: "ready" };
	                _this.events.invoke("ready", readyData);
	            };
	            _this.map.on("styledata", setReady_1);
	            // --> Set initial style including downloading style definitions and restyle map
	            _this._setAutoResize(_this.styleOptions.autoResize);
	            _this.map.showTileBoundaries = _this.styleOptions.showTileBoundaries;
	            _this.localizedStringsPromise = Localizer.getStrings(_this.styleOptions.language);
	            var stylesInit = _this.styles.initialize();
	            Promise.all([authManInit, stylesInit]).then(function () {
	                // Check that the map hasn't been removed for any reason.
	                // If so no need to finish styling the map.
	                if (_this.removed) {
	                    return;
	                }
	                if (_this.authentication && !_this.authentication.getToken()) {
	                    throw new Error("AuthenticationManager finished initializing, but no token is available");
	                }
	                // Add the accessibility delegate to the map here
	                // so that the auth mechanism is setup before any calls are made.
	                if (_this.serviceOptions["enable-accessibility"]) {
	                    _this.accessibleMapDelegate.addToMap();
	                }
	                _this._setStyleComponents(_this.styleOptions);
	                _this.copyrightDelegate && _this.copyrightDelegate.addToMap();
	            }).catch(function (reason) {
	                var error = reason instanceof Error ? reason : new Error(reason);
	                if (_this.insights) {
	                    _this.insights.trackException({ error: error });
	                }
	                // Invoke the error event to report any errors initializing the styles or auth.
	                var errorData = {
	                    map: _this,
	                    type: "error",
	                    error: error
	                };
	                _this.events.invoke("error", errorData);
	            });
	            // --> Set initial camera state of map
	            _this.setCamera(__assign(__assign({}, options), { type: "jump", duration: 0 }));
	            // Add delegates to map
	            {
	                _this.incidentDelegate = new IncidentServiceDelegate(_this);
	            }
	            _this.flowDelegate = new FlowServiceDelegate(_this);
	            _this.accessibleMapDelegate = new AccessibleMapDelegate(_this);
	            _this.userInteractionDelegate = new UserInteractionDelegate(_this, options);
	            _this.userInteractionDelegate.addToMap();
	            {
	                _this.copyrightDelegate = new CopyrightDelegate(_this, _this.copyrightControl, _this.styleOptions);
	            }
	        }
	        catch (err) {
	            successfulLoad = false;
	            if (_this.insights) {
	                _this.insights.trackException({ error: err instanceof Error ? err : new Error(err) });
	            }
	            throw err;
	        }
	        finally {
	            // Track the successful session load
	            if (_this.insights) {
	                _this.insights.trackEvent({ name: "MapLoad" }, {
	                    success: successfulLoad,
	                    supported: isSupported(false),
	                    supportedWithPerformance: isSupported(true)
	                });
	                _this.insights.flush();
	            }
	        }
	        return _this;
	    }
	    /**
	     * Returns the HTMLCanvasElement that the map is drawn to.
	     */
	    Map.prototype.getCanvas = function () {
	        return this.map.getCanvas();
	    };
	    /**
	     * Returns the HTMLElement that contains the map's HTMLCanvasElement. The map's events (e.g. panning and zooming)
	     * are attached to this element.
	     */
	    Map.prototype.getCanvasContainer = function () {
	        return this.map.getCanvasContainer();
	    };
	    /**
	     * Returns the HTMLElement that contains the map.
	     */
	    Map.prototype.getMapContainer = function () {
	        return this.map.getContainer();
	    };
	    /**
	     * Returns the service options with which the map control was initialized.
	     */
	    Map.prototype.getServiceOptions = function () {
	        return cloneDeepWith_1(this.serviceOptions, ServiceOptions._cloneCustomizer);
	    };
	    /**
	     * Set the service options.
	     */
	    Map.prototype.setServiceOptions = function (options) {
	        this.serviceOptions = new ServiceOptions().merge(this.serviceOptions, options);
	        if (this.serviceOptions["enable-accessibility"]) {
	            this.accessibleMapDelegate.addToMap();
	        }
	        else {
	            this.accessibleMapDelegate.removeFromMap();
	        }
	    };
	    /**
	     * Adds request transformer
	     * @param transformer provides custom request parameters for loading a tile.
	     */
	    Map.prototype.addRequestTransformer = function (transformer) { this.serviceOptions.addTransformer(transformer); };
	    /**
	     * Removes request transformer
	     * @param transformer transformer to remove (provides custom request parameters for loading a tile)
	     */
	    Map.prototype.removeRequestTransformer = function (transformer) { this.serviceOptions.removeTransformer(transformer); };
	    Map.prototype.setCamera = function (options, fromControl) {
	        if (fromControl === void 0) { fromControl = false; }
	        var mapboxCameraOptions;
	        var maxBounds;
	        // Test between CameraOptions and CameraBoundsOptions
	        if ("padding" in options || "offset" in options || "bounds" in options) {
	            var cameraBoundsOptions = new CameraBoundsOptions()
	                .merge({ maxZoom: this.getCamera().maxZoom }, options);
	            var bounds = this._generateSafeBounds(cameraBoundsOptions.bounds);
	            mapboxCameraOptions = this.map.cameraForBounds(bounds, {
	                padding: cameraBoundsOptions.padding,
	                offset: cameraBoundsOptions.offset,
	                maxZoom: cameraBoundsOptions.maxZoom
	            });
	            if (!mapboxCameraOptions) {
	                throw new Error("The map cannot be fit to the current canvas with the given CameraBoundsOptions.");
	            }
	            this.map.setMaxZoom(cameraBoundsOptions.maxZoom);
	            this._invokeEvent("maxzoomchanged", this.map.getMaxZoom());
	            maxBounds = this._generateSafeBounds(cameraBoundsOptions.maxBounds);
	        }
	        else {
	            var cameraOptions = new CameraOptions().merge(this.getCamera(), options);
	            // adjust for center offset
	            if (cameraOptions.centerOffset && cameraOptions.centerOffset.length >= 2) {
	                var centerOffset = cameraOptions.centerOffset;
	                // Calculate a new center which accounts for the offset at the specified zoom level.
	                var p = mercatorPositionsToPixels([cameraOptions.center], cameraOptions.zoom);
	                p[0][0] += centerOffset[0];
	                p[0][1] += centerOffset[1];
	                cameraOptions.center = mercatorPixelsToPositions(p, cameraOptions.zoom)[0];
	            }
	            mapboxCameraOptions = {
	                center: cameraOptions.center,
	                zoom: cameraOptions.zoom,
	                bearing: cameraOptions.bearing,
	                pitch: cameraOptions.pitch,
	                around: undefined
	            };
	            this.map.setMinZoom(cameraOptions.minZoom);
	            this.map.setMaxZoom(cameraOptions.maxZoom);
	            this._invokeEvent("minzoomchanged", this.map.getMinZoom());
	            this._invokeEvent("maxzoomchanged", this.map.getMaxZoom());
	            maxBounds = this._generateSafeBounds(cameraOptions.maxBounds);
	        }
	        // set maxBounds. maxBounds will be removed if null or undefined is provided.
	        if (maxBounds) {
	            this.map.setMaxBounds(maxBounds);
	        }
	        else {
	            this.map.setMaxBounds(null);
	        }
	        var animOptions = new AnimationOptions().merge(options);
	        var mapboxAnimationOptions = {
	            duration: animOptions.duration,
	            easing: function (t) { return t; },
	            offset: [0, 0],
	            animate: true
	        };
	        // Supply event data regarding if a control caused this camera change.
	        var eventData = { fromControl: fromControl };
	        if (animOptions.type === "jump") {
	            this.map.jumpTo(mapboxCameraOptions, eventData);
	        }
	        else if (animOptions.type === "ease") {
	            this.map.easeTo(__assign(__assign({}, mapboxCameraOptions), mapboxAnimationOptions), eventData);
	        }
	        else if (animOptions.type === "fly") {
	            this.map.flyTo(__assign(__assign({}, mapboxCameraOptions), mapboxAnimationOptions), eventData);
	        }
	    };
	    /**
	     * Set the camera bounds of the map control.
	     * @param options The options for setting the map's camera bounds.
	     * @deprecated recommend setCamera.
	     */
	    Map.prototype.setCameraBounds = function (options) {
	        this.setCamera(options);
	    };
	    /**
	     * Returns the camera's current properties.
	     */
	    Map.prototype.getCamera = function () {
	        var southWest = this.map.getBounds().getSouthWest().toArray();
	        var northEast = this.map.getBounds().getNorthEast().toArray();
	        var cameraOptions = {
	            zoom: this.map.getZoom(),
	            center: this.map.getCenter().toArray(),
	            bearing: this.map.getBearing(),
	            pitch: this.map.getPitch(),
	            bounds: new BoundingBox(southWest, northEast),
	            minZoom: this.map.getMinZoom(),
	            maxZoom: this.map.getMaxZoom()
	        };
	        return cameraOptions;
	    };
	    /**
	     * Set the map control's style options. Any options not specified will default to their current values.
	     * @param options The options for setting the style of the map control.
	     */
	    Map.prototype.setStyle = function (options) {
	        // This option may only be set when initializing the map.
	        // The delete operation will handle non-exist property.
	        delete options.preserveDrawingBuffer;
	        var newOptions = new StyleOptions().merge(this.styleOptions, options);
	        // Add or remove the autoResize listener if needed.
	        if (newOptions.autoResize !== this.styleOptions.autoResize) {
	            this._setAutoResize(newOptions.autoResize);
	        }
	        // Update the localized strings promise if needed.
	        if (newOptions.language !== this.styleOptions.language) {
	            this.localizedStringsPromise = Localizer.getStrings(newOptions.language);
	        }
	        // Update rendering of world copies if needed.
	        if (newOptions.renderWorldCopies !== this.styleOptions.renderWorldCopies) {
	            this.map.setRenderWorldCopies(newOptions.renderWorldCopies);
	        }
	        // Add or remove the feedback link if needed.
	        if (newOptions.showFeedbackLink !== this.styleOptions.showFeedbackLink) {
	            this.copyrightControl.setOptions({ showFeedbackLink: newOptions.showFeedbackLink });
	        }
	        // Add or remove custom attribution if needed
	        if (newOptions.customAttribution !== this.styleOptions.customAttribution) {
	            this.copyrightControl.setOptions({ customAttribution: newOptions.customAttribution });
	        }
	        // Add or remove the logo if needed.
	        if (newOptions.showLogo !== this.styleOptions.showLogo) {
	            this.copyrightControl.setOptions({ showLogo: newOptions.showLogo });
	        }
	        // Update showing tile boundaries if needed.
	        if (newOptions.showTileBoundaries !== this.styleOptions.showTileBoundaries) {
	            this.map.showTileBoundaries = newOptions.showTileBoundaries;
	        }
	        // Some delegates may rely on a styledata event to know when to check if the language changes.
	        // If this function is restructured such that a styledata event won't always trigger
	        // if the language is changed, then either those delegates need changed
	        // or the styledata event manually invoked.
	        this.styleOptions = newOptions;
	        this._setStyleComponents(newOptions);
	    };
	    /**
	     * Returns the map control's current style settings.
	     */
	    Map.prototype.getStyle = function () {
	        return cloneDeep_1(this.styleOptions);
	    };
	    /**
	     * Add an icon to the map to use for pins.
	     * Map must be ready and the image must be fully loaded before the icon can be added.
	     * Use the events.add method with event type 'ready'.
	     * @param id The identifier of the icon.
	     * @param icon The icon image.
	     * @deprecated Use map.imageSprite.add instead.
	     */
	    Map.prototype.addIcon = function (id, icon) {
	        this.imageSprite.add(id, icon);
	    };
	    /**
	     * Add a collection of points to a layer of the map as pins. The layer and its options can be specified through a
	     * PinLayerOptions object. Options for the layer can
	     * only be specified upon the layer's initial creation. Map must be ready before the pins can be added. Use
	     * the events.add method with event type 'ready'.
	     * @param pins The points to add.
	     * @param options The layer options for the pins.
	     * @deprecated Use atlas.layer.SymbolLayer instead.
	     */
	    Map.prototype.addPins = function (pins, options) {
	        var layerOptions = new PinLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new SymbolLayer(layerOptions.name + "-source", layerOptions.name, {
	                source: layerOptions.name + "-source",
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                iconOptions: {
	                    anchor: "center",
	                    size: layerOptions.iconSize,
	                    image: ["case",
	                        ["has", "icon"], ["get", "icon"],
	                        layerOptions.icon
	                    ],
	                    ignorePlacement: !layerOptions.cluster,
	                    opacity: layerOptions.opacity
	                },
	                textOptions: {
	                    anchor: "center",
	                    textField: ["case",
	                        ["has", "point_count"], ["to-string", ["get", "point_count"]],
	                        ["has", "title"], ["to-string", ["get", "title"]],
	                        layerOptions.title
	                    ],
	                    font: ["case",
	                        ["has", "point_count"], ["literal", ["StandardFontCondensed-Bold"]],
	                        ["literal", [layerOptions.textFont]]
	                    ],
	                    size: ["case",
	                        ["has", "point_count"], 20,
	                        layerOptions.fontSize
	                    ],
	                    ignorePlacement: !layerOptions.cluster,
	                    opacity: layerOptions.opacity,
	                    offset: ["case",
	                        ["has", "point_count"], ["literal", [0.50, -0.45]],
	                        ["literal", [layerOptions.textOffset[0] / 16, layerOptions.textOffset[1] / 16]]
	                    ],
	                    color: layerOptions.fontColor
	                }
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof SymbolLayer)) {
	            throw new Error("A layer with name '" + layerOptions.name + "' already exists but it is not a SymbolLayer." +
	                "A SymbolLayer should be used for rendering pins.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId, {
	                cluster: layerOptions.cluster
	            });
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '" + sourceId + "' already exists but it is not a DataSource." +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        var pinCollection = new FeatureCollection(pins);
	        if (layerOptions.overwrite) {
	            source.setShapes(pinCollection);
	        }
	        else {
	            source.add(pinCollection);
	        }
	    };
	    /**
	     * Add a collection of points to a layer of the map as circles. The layer and its options can be specified through a
	     * CircleLayerOptions object. Options for the layer
	     * can only be specified upon the layer's initial creation. Map must be ready before the circles can be
	     * added. Use the events.add method with event type 'ready'.
	     * @param circles The circles to add.
	     * @param options The layer options for the circles.
	     * @deprecated Use atlas.layer.BubbleLayer instead.
	     */
	    Map.prototype.addCircles = function (circles, options) {
	        var layerOptions = new CircleLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new BubbleLayer(layerOptions.name + "-source", layerOptions.name, {
	                source: layerOptions.name + "-source",
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                opacity: layerOptions.opacity,
	                radius: ["case",
	                    ["has", "radius"], ["get", "radius"],
	                    layerOptions.radius
	                ],
	                color: ["case",
	                    ["has", "color"], ["get", "color"],
	                    layerOptions.color
	                ],
	                strokeColor: ["case",
	                    ["has", "outlineColor"], ["get", "outlineColor"],
	                    layerOptions.outlineColor
	                ],
	                strokeWidth: ["case",
	                    ["has", "outlineWidth"], ["get", "outlineWidth"],
	                    layerOptions.outlineWidth
	                ]
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof BubbleLayer)) {
	            throw new Error("A layer with name '" + layerOptions.name + "' already exists but it is not a BubbleLayer." +
	                "A BubbleLayer should be used for rendering circles.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId);
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '" + sourceId + "' already exists but it is not a DataSource." +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        var circleCollection = new FeatureCollection(circles);
	        if (layerOptions.overwrite) {
	            source.setShapes(circleCollection);
	        }
	        else {
	            source.add(circleCollection);
	        }
	    };
	    /**
	     * Add a collection of linestrings to a layer of the map. The layer and its options can be specified through a
	     * LinestringLayerOptions object. Options for
	     * the layer can only be specified upon the layer's initial creation. Map must be ready before the
	     * linestrings can be added. Use the events.add method with event type 'ready'.
	     * @param linestrings The linestrings to add.
	     * @param options The layer options for the linestrings.
	     * @deprecated Use atlas.layer.LineLayer instead.
	     */
	    Map.prototype.addLinestrings = function (linestrings, options) {
	        var layerOptions = new LinestringLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new LineLayer(layerOptions.name + "-source", layerOptions.name, {
	                source: layerOptions.name + "-source",
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                lineCap: layerOptions.cap,
	                lineJoin: layerOptions.join,
	                strokeOpacity: layerOptions.opacity,
	                strokeColor: ["case",
	                    ["has", "color"], ["get", "color"],
	                    layerOptions.color
	                ],
	                strokeWidth: ["case",
	                    ["has", "width"], ["get", "width"],
	                    layerOptions.width
	                ]
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof LineLayer)) {
	            throw new Error("A layer with name '" + layerOptions.name + "' already exists but it is not a LineLayer." +
	                "A LineLayer should be used for rendering linestrings.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId);
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '" + sourceId + "' already exists but it is not a DataSource." +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        var lineCollection = new FeatureCollection(linestrings);
	        if (layerOptions.overwrite) {
	            source.setShapes(lineCollection);
	        }
	        else {
	            source.add(lineCollection);
	        }
	    };
	    /**
	     * Add a collection of polygons to a layer of the map. The layer and its options can be specified through a
	     * PolygonLayerOptions object. Options for
	     * the layer can only be specified upon the layer's initial creation. Map must be ready before the polygons
	     * can be added. Use the events.add method with event type 'ready'.
	     * @param polygons The polygons to add.
	     * @param options The layer options for the polygons.
	     * @deprecated Use atlas.layer.PolygonLayer instead.
	     */
	    Map.prototype.addPolygons = function (polygons, options) {
	        var layerOptions = new PolygonLayerOptions$1().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new PolygonLayer(layerOptions.name + "-source", layerOptions.name, {
	                source: layerOptions.name + "-source",
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                fillOpacity: layerOptions.opacity,
	                fillColor: ["case",
	                    ["has", "color"], ["get", "color"],
	                    layerOptions.color
	                ]
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof PolygonLayer)) {
	            throw new Error("A layer with name '" + layerOptions.name + "' already exists but it is not a PolygonLayer." +
	                "A PolygonLayer should be used for rendering linestrings.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId);
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '" + sourceId + "' already exists but it is not a DataSource." +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        var polygonCollection = new FeatureCollection(polygons);
	        if (layerOptions.overwrite) {
	            source.setShapes(polygonCollection);
	        }
	        else {
	            source.add(polygonCollection);
	        }
	    };
	    /**
	     * Adds a raster layer to the map. The layer and its options can be specified through a
	     * RasterLayerOptions object. Options for
	     * the layer can only be specified upon the layer's initial creation.
	     * @param tileSources  A list of endpoints specified as strings from which raster images can be requested. The
	     * endpoints can be parameterized with the tags '{z}', '{x}' and '{y}' to specify the zoom, x-index, and y-index of
	     * the needed tile respectively. The map control will request and place the tiles that are contained in the map's
	     * viewport.
	     * @param options The options for the raster layer.
	     * @deprecated Use atlas.layer.TileLayer instead.
	     */
	    Map.prototype.addRaster = function (tileSources, options) {
	        var layerOptions = new RasterLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        if (!layer) {
	            layer = new TileLayer({
	                maxZoom: layerOptions.maxZoom,
	                minZoom: layerOptions.minZoom,
	                opacity: layerOptions.opacity,
	                tileSize: 256,
	                tileUrl: "{subdomain}"
	            }, layerOptions.name);
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof TileLayer)) {
	            throw new Error("A layer with name '" + layerOptions.name + "' already exists but it is not a TileLayer." +
	                "A TileLayer should be used for rendering raster images.");
	        }
	        // Multiple tile urls are made possible by the {subdomain} substitution
	        // If a layer doesn't use "{subdomain}" as its tileUrl it must have be created with new TileLayer(...)
	        // In that case throw an error.
	        if (layer.getOptions().tileUrl !== "{subdomain}") {
	            throw new Error("A TileLayer with name '" + layerOptions.name + "' already exists but was configured " +
	                "for a single tile url [default for new TileLayer(...)].");
	        }
	        // Get the new tile urls.
	        var urls;
	        if (layerOptions.overwrite) {
	            urls = [];
	        }
	        else {
	            urls = layer.getOptions().subdomains || [];
	        }
	        // Add the tile urls to the layer, but don't update the map yet.
	        urls.push.apply(urls, __spread(tileSources));
	        layer._setOptionsNoUpdate({
	            subdomains: urls
	        });
	        this.layers.add(layer, layerOptions.before);
	    };
	    /**
	     * Returns a list of the map's layers from bottom to top.
	     * @deprecated Use layers.getLayers() instead.
	     */
	    Map.prototype.getLayers = function () {
	        return this.layers.getLayers().map(function (l) { return l.getId(); });
	    };
	    /**
	     * Removes a collection of layers from the map.
	     * For each layer if a source by the name of "<layerName>-source" exists it will be removed too.
	     * @param layerNames An array of layer names to remove from the map.
	     * @deprecated Use layers.remove instead.
	     */
	    Map.prototype.removeLayers = function (layerNames) {
	        var e_1, _a;
	        try {
	            for (var layerNames_1 = __values(layerNames), layerNames_1_1 = layerNames_1.next(); !layerNames_1_1.done; layerNames_1_1 = layerNames_1.next()) {
	                var layerName = layerNames_1_1.value;
	                // Previously calling removeLayers for layers that didn't exist in the map just did nothing.
	                // Now, LayerManager will throw an error, so we need to check if the layer exists before calling remove.
	                if (this.layers.getLayerById(layerName)) {
	                    this.layers.remove(layerName);
	                    // Previously adding a layer also added a source with the name "<layerName>-source".
	                    // Calling removeLayers would also remove that source, so we attempt to do this too.
	                    var sourceName = layerName + "-source";
	                    if (this.sources.getById(sourceName)) {
	                        this.sources.remove(sourceName);
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (layerNames_1_1 && !layerNames_1_1.done && (_a = layerNames_1.return)) _a.call(layerNames_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	    };
	    /**
	     * @deprecated recommend map.markers.add
	     * Adds a custom HTMLElement to the map at a specified position.
	     * @param element The HTMLElement to add.
	     * @param position The position to place the element.
	     */
	    Map.prototype.addHtml = function (element, position) {
	        if (!element.id) {
	            element.id = "marker_" + uuidRandom();
	        }
	        var marker = new HtmlMarker({
	            htmlContent: element,
	        });
	        this.markers.add(marker, position);
	        return element.id;
	    };
	    /**
	     * @deprecated recommend map.markers.remove
	     * Removes a custom HTMLElement from the map.
	     * @param elementId The id of element to remove.
	     */
	    Map.prototype.removeHtml = function (elementId) {
	        this.markers.remove(elementId);
	    };
	    Map.prototype.addEventListener = function (eventType, layerOrCallback, callback) {
	        this.events._addLegacy(eventType, layerOrCallback, callback);
	    };
	    Map.prototype.removeEventListener = function (eventType, layerOrCallback, callback) {
	        this.events._removeLegacy(eventType, layerOrCallback, callback);
	    };
	    /**
	     * Set the map control's user interaction handlers. Any options not specified will default to their current values.
	     * @param options The options for enabling/disabling the user interaction handlers.
	     */
	    Map.prototype.setUserInteraction = function (options) {
	        this.userInteractionDelegate.setOptions(options);
	    };
	    /**
	     * Return the map control's current user interaction handler settings.
	     */
	    Map.prototype.getUserInteraction = function () {
	        return this.userInteractionDelegate.getOptions();
	    };
	    /**
	     * Add a control to the map.
	     * @param control The control to add.
	     * @param options The options for the added control.
	     * @deprecated Use map.controls.add instead.
	     */
	    Map.prototype.addControl = function (control, options) {
	        this.controls.add(control, options);
	    };
	    /**
	     * Remove a control from the map.
	     * @param control The control to remove.
	     * @deprecated Use map.controls.remove instead.
	     */
	    Map.prototype.removeControl = function (control) {
	        this.controls.remove(control);
	    };
	    /**
	     * Set the traffic options for the map. Any options not specified will default to their current values.
	     * @param options The options for defining the map's traffic display.
	     */
	    Map.prototype.setTraffic = function (options) {
	        var previousIncidentsOption = this.trafficOptions.incidents;
	        var previousFlowOption = this.trafficOptions.flow;
	        this.trafficOptions = new TrafficOptions().merge(this.trafficOptions, options);
	        if (this.incidentDelegate) {
	            if (this.trafficOptions.incidents) {
	                if (!previousIncidentsOption) {
	                    this.incidentDelegate.addToMap();
	                }
	            }
	            else {
	                this.incidentDelegate.removeFromMap();
	            }
	        }
	        if (this.trafficOptions.flow && this.trafficOptions.flow !== "none") {
	            try {
	                if (this.trafficOptions.flow !== previousFlowOption) {
	                    this.flowDelegate.addToMap();
	                }
	            }
	            catch (error) {
	                this.trafficOptions.flow = previousFlowOption;
	                throw error;
	            }
	        }
	        else {
	            this.flowDelegate.removeFromMap();
	        }
	    };
	    /**
	     * Return the map control's current traffic settings.
	     */
	    Map.prototype.getTraffic = function () {
	        return cloneDeep_1(this.trafficOptions);
	    };
	    /**
	     * Clean up the map's resources. Map will not function correctly after calling this method.
	     * @deprecated use map.dispose()
	     */
	    Map.prototype.remove = function () {
	        this.dispose();
	    };
	    /**
	     * Removes all user added sources, layers, markers, and popups from the map.
	     * User added images are preserved.
	     */
	    Map.prototype.clear = function () {
	        // Clear the layers, sources, and marker via their managers.
	        this.popups.clear();
	        this.layers.clear();
	        this.sources.clear();
	        this.markers.clear();
	    };
	    /**
	     * Clean up the map's resources. Map will not function correctly after calling this method.
	     */
	    Map.prototype.dispose = function () {
	        this.clear();
	        this.map.remove();
	        this.removed = true;
	        while (this.getMapContainer().firstChild) {
	            var currChild = this.getMapContainer().firstChild;
	            this.getMapContainer().removeChild(currChild);
	        }
	    };
	    Map.prototype.resize = function (heightOrData, width, eventData) {
	        if ((typeof heightOrData === "number" || typeof heightOrData === "string") &&
	            (typeof width === "number" || typeof width === "string")) {
	            var height = heightOrData;
	            this.getMapContainer().style.height = typeof height === "number" ? height + "px" : height;
	            this.getMapContainer().style.width = typeof width === "number" ? width + "px" : width;
	        }
	        else {
	            eventData = heightOrData;
	        }
	        // Occasionally, when resizing the window causes the map container to also resize, the canvas will re-resized
	        // as if expecting a scroll bar to be drawn for the canvas container.
	        // This leaves some whitespace gap on the bottom and right sides of the canvas.
	        // No actual scrollbars will be shown.
	        //
	        // This is because the canvas container and map container are resized before the canvas,
	        // so for a small fraction of time the canvas is bigger than its containers and a scroll bar would be required.
	        //
	        // To prevent this first the canvas container has overflow set to hidden.
	        // This ensures that scroll bars would never be needed.
	        // Then the Mapbox resize function is called, and the canvas should be the full, correct size.
	        // Finally the canvas container has overflow set back to the original value.
	        var oldOverflow = this.getMapContainer().style.overflow;
	        this.getMapContainer().style.overflow = "hidden";
	        this.map.resize(eventData);
	        this.getMapContainer().style.overflow = oldOverflow;
	    };
	    /**
	     * Converts an array of Pixel objects to an array of geographic Positions objects on the map.
	     * @param pixels The pixels to be converted.
	     */
	    Map.prototype.pixelsToPositions = function (pixels) {
	        var e_2, _a;
	        var positions = [];
	        try {
	            for (var pixels_1 = __values(pixels), pixels_1_1 = pixels_1.next(); !pixels_1_1.done; pixels_1_1 = pixels_1.next()) {
	                var pixel = pixels_1_1.value;
	                var lngLat = this.map.unproject(pixel);
	                positions.push(new Position(lngLat.lng, lngLat.lat));
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (pixels_1_1 && !pixels_1_1.done && (_a = pixels_1.return)) _a.call(pixels_1);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	        return positions;
	    };
	    /**
	     * Converts an array of Positions objects to an array of Pixel objects relative to the map container.
	     * @param positions The positions to be converted.
	     */
	    Map.prototype.positionsToPixels = function (positions) {
	        var e_3, _a;
	        var pixels = [];
	        try {
	            for (var positions_1 = __values(positions), positions_1_1 = positions_1.next(); !positions_1_1.done; positions_1_1 = positions_1.next()) {
	                var position = positions_1_1.value;
	                var point = this.map.project(position);
	                pixels.push(new Pixel(point.x, point.y));
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (positions_1_1 && !positions_1_1.done && (_a = positions_1.return)) _a.call(positions_1);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        return pixels;
	    };
	    /**
	     * Returns a boolean indicating if all tiles in the current viewport for all sources have loaded or not.
	     */
	    Map.prototype.areTilesLoaded = function () {
	        return this.map.areTilesLoaded();
	    };
	    /**
	     * Stops any animated transition that is currently underway.
	     */
	    Map.prototype.stop = function () {
	        this.map.stop();
	    };
	    /**
	     * @internal
	     */
	    Map.prototype._getMap = function () {
	        return this.map;
	    };
	    /**
	     * @internal
	     */
	    Map.prototype._rebuildStyle = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                this.styles.setStyleUrl(this.styleOptions);
	                this.imageSprite._restoreImages();
	                return [2 /*return*/];
	            });
	        });
	    };
	    /**
	     * Returns true if the map has completed loading for the first time.
	     * Will always return true after the initial load is completed.
	     * @internal
	     */
	    Map.prototype._isLoaded = function () {
	        return this.loaded;
	    };
	    /**
	     * Returns true if the map has set its style for the first time.
	     * Will always return true after the style has been set.
	     * @internal
	     */
	    Map.prototype._isReady = function () {
	        return this.ready;
	    };
	    /**
	     * Returns a promise which will resolve to a collection of localized strings based on the map's current language.
	     * @internal
	     */
	    Map.prototype._getLocalizedStrings = function () {
	        return this.localizedStringsPromise;
	    };
	    /**
	     * Sends a fetch request to the specified url with the specified headers.
	     * Processes the request through transformRequest(...) first before sending.
	     * @internal
	     */
	    Map.prototype._sendRequest = function (url, resourceType, headers) {
	        var requestParams;
	        if (typeof this.serviceOptions.transformRequest === "function") {
	            // If a transformRequest(...) was specified use it.
	            requestParams = this.serviceOptions.transformRequest(url, resourceType);
	        }
	        if (requestParams) {
	            // Send the fetch using the transformed parameters.
	            return fetch(requestParams.url || url, {
	                credentials: requestParams.credentials,
	                headers: __assign(__assign({}, headers), requestParams.headers),
	                method: "GET",
	                mode: "cors",
	            });
	        }
	        else {
	            // If not transformRequest has been supplied just make the request as specified.
	            return fetch(url, {
	                headers: headers,
	                method: "GET",
	                mode: "cors"
	            });
	        }
	    };
	    /**
	     * replaces the domain, view and language placeholders and signs request as needed
	     * @internal
	     */
	    Map.prototype._substituteDomainLanguageViewAndSignInRequest = function (url, requestParams) {
	        if (url.includes(constants.legacyDomainPlaceHolder) || url.includes(constants.domainPlaceHolder)) {
	            // Update legacy domain placeholder if found
	            var isLegacy = new RegExp("[^{]" + constants.legacyDomainPlaceHolder + "[^}]");
	            if (url.match(isLegacy)) {
	                requestParams.url = requestParams.url.replace(constants.legacyDomainPlaceHolder, constants.domainPlaceHolder);
	            }
	            if (Url.protoRegEx.test(this.serviceOptions.domain)) {
	                // If the user specified domain includes a protocol replace that in the url too.
	                var idx = requestParams.url.indexOf(constants.domainPlaceHolder);
	                requestParams.url = this.serviceOptions.domain +
	                    requestParams.url.substring(idx + constants.domainPlaceHolder.length);
	            }
	            else {
	                // If the user specified domain doesn't include a protocol keep the original.
	                requestParams.url = requestParams.url.replace(constants.domainPlaceHolder, this.serviceOptions.domain);
	            }
	        }
	        if (requestParams.url.toLocaleLowerCase().includes(this.serviceOptions.domain.toLocaleLowerCase())) {
	            this.authentication && this.authentication.signRequest(requestParams);
	        }
	        if (url.includes(constants.languagePlaceHolder)) {
	            requestParams.url = requestParams.url.replace(constants.languagePlaceHolder, this.styleOptions.language);
	        }
	        if (url.includes(constants.viewPlaceHolder)) {
	            requestParams.url = this.styleOptions.view ?
	                requestParams.url.replace(constants.viewPlaceHolder, this.styleOptions.view) :
	                requestParams.url.replace(constants.viewPlaceHolder, "").replace("&" + constants.viewParameter + "=", "");
	        }
	    };
	    /**
	     * Sets whether the map will automatically resize when the browser window resizes.
	     * @private
	     */
	    Map.prototype._setAutoResize = function (autoResize) {
	        if (autoResize) {
	            window.addEventListener("resize", this._windowResizeCallback);
	        }
	        else {
	            window.removeEventListener("resize", this._windowResizeCallback);
	        }
	    };
	    /**
	     * Adds or replaces the relevant fundamental map components (layers and sources) based on the input options.
	     * Removes sources and layers that aren't used by the new style or any remaining layers.
	     * @private
	     */
	    Map.prototype._setStyleComponents = function (styleOptions) {
	        if (this.removed) {
	            return;
	        }
	        this.styleOptions = styleOptions;
	        this._rebuildStyle();
	        return;
	    };
	    /**
	     * Set the default service/style options.
	     * Only set defaults if the users provided a value for them and no other default have been set.
	     */
	    Map.prototype._updateGlobalDefaults = function (options) {
	        if (options) {
	            // Must account for deprecated property names because these checks occur before the merge operations.
	            if (options.authOptions && !_hasSetAuthenticationOptions()) {
	                setAuthenticationOptions(options.authOptions);
	            }
	            if (options.domain && !_hasSetDomain()) {
	                setDomain(options.domain);
	            }
	            if (options.styleDefinitionsPath && !_hasSetStyleDefinitionsPath()) {
	                setStyleDefinitionsPath(options.styleDefinitionsPath);
	            }
	            if (options.styleDefinitionsVersion && !_hasSetStyleDefinitionsVersion()) {
	                setStyleDefinitionsVersion(options.styleDefinitionsVersion);
	            }
	            if (options.workerCount && !_hasWorkerCount()) {
	                setWorkerCount(options.workerCount);
	            }
	            if (options.maxParallelImageRequests && !_hasMaxParallelImageRequests()) {
	                setMaxParallelImageRequests(options.maxParallelImageRequests);
	            }
	            if ((options.subscriptionKey || options["subscription-key"]) && !_hasSetAuthenticationOptions()) {
	                setSubscriptionKey(options.subscriptionKey || options["subscription-key"]);
	            }
	            if ((options.sessionId || options["session-id"]) && !_hasSetSessionId()) {
	                setSessionId(options.sessionId || options["session-id"]);
	            }
	            if (options.language && !_hasSetLanguage()) {
	                setLanguage(options.language);
	            }
	            if ((options.userRegion || options.view) && !_hasSetView()) {
	                setUserRegion(options.userRegion || options.view);
	            }
	        }
	    };
	    Map.prototype._generateSafeBounds = function (bounds) {
	        if (bounds) {
	            var s = BoundingBox.getSouth(bounds);
	            var w = BoundingBox.getWest(bounds);
	            var n = BoundingBox.getNorth(bounds);
	            var e = BoundingBox.getEast(bounds);
	            if (isNaN(s) || isNaN(w) || isNaN(n) || isNaN(e)) {
	                throw new Error("The bounds specified are invalid: [" + bounds + "]");
	            }
	            while (w > e) {
	                e += 360;
	            }
	            return new BoundingBox([w, s, e, n]);
	        }
	        return bounds;
	    };
	    Map.prototype._detectHighContrast = function () {
	        var hcType = Media.getHighContrastMode();
	        var hcClass;
	        var hcStyle;
	        switch (hcType) {
	            case "invert":
	                hcClass = Map.Css.hcLight;
	                hcStyle = "high_contrast_light";
	                break;
	            case "light":
	                hcClass = Map.Css.hcLight;
	                hcStyle = "high_contrast_light";
	                break;
	            case "dark":
	                hcClass = Map.Css.hcDark;
	                hcStyle = "high_contrast_dark";
	                break;
	        }
	        if (hcClass) {
	            this.map.getContainer().classList.add(hcClass);
	        }
	        if (hcStyle && this.styleOptions.style === "road") {
	            this.styleOptions.style = hcStyle;
	        }
	    };
	    // Static CSS classes
	    Map.Css = {
	        canvasContainer: "atlas-map-canvas-container",
	        canvas: "atlas-map-canvas",
	        container: "atlas-map",
	        hcDark: "high-contrast-dark",
	        hcLight: "high-contrast-light"
	    };
	    return Map;
	}(EventEmitter));

	/** A layout template for a popup. */
	var PopupTemplate = /** @class */ (function () {
	    function PopupTemplate() {
	        //////////////////////
	        /// Properties
	        //////////////////////
	        /**
	         * Specifies if hyperlinks and email addresses should automatically be detected and rendered as clickable links.
	         * Default: `true`
	         * @default true
	         */
	        this.detectHyperlinks = true;
	        /**
	         * Specifies if property paths should be parsed using forward slashes "/" as sub-property dividers,
	         * or if the whole path should be treated as one property name.
	         * Default: `true`
	         * @default true
	         */
	        this.parsePropertyPaths = true;
	    }
	    //////////////////////
	    /// Public static functions
	    //////////////////////
	    /**
	     * Generates popup content by applying a template to a set of properties.
	     * If no template is specified, `title` or `name` properties will be used as fallbacks for the title if available.
	     * For content, a `description` property will be used or else all properties will be converted into a table.
	     * @param prop The properties object generate the popup content from.
	     * @param template The template to apply.
	     */
	    PopupTemplate.applyTemplate = function (prop, template) {
	        var _this = this;
	        var container = document.createElement("div");
	        container.classList.add(PopupTemplate.Css.template);
	        if (prop) {
	            if (!template) {
	                template = {};
	            }
	            if (typeof template.singleDescription !== "boolean") {
	                template.singleDescription = true;
	            }
	            template.sandboxContent = (typeof template.sandboxContent === "boolean") ? template.sandboxContent : true;
	            if (!(template.title && typeof template.content === "string" &&
	                (template.content.includes("{title}") || template.content.includes("{name}")))) {
	                if (prop.title) {
	                    template.title = "{title}";
	                }
	                else if (prop.name) {
	                    template.title = "{name}";
	                }
	            }
	            if (typeof template.detectHyperlinks !== "boolean") {
	                template.detectHyperlinks = true;
	            }
	            if (typeof template.parsePropertyPaths !== "boolean") {
	                template.parsePropertyPaths = true;
	            }
	            if (template.textColor) {
	                container.style.color = template.textColor;
	            }
	            if (template.fillColor) {
	                container.style.backgroundColor = template.fillColor;
	            }
	            if (template.title) {
	                // For security, strip out all HTML from the title and use the popup templates styling.
	                var c = this._applyStringTemplate(prop, template.title, template);
	                c.innerText = c.textContent || c.innerText || "";
	                this._appendChild(container, c, PopupTemplate.Css.title);
	            }
	            var contentItems_1 = document.createElement("div");
	            contentItems_1.classList.add(PopupTemplate.Css.content);
	            if (Array.isArray(template.content)) {
	                // Check to see if content is a PropertyInfo array.
	                if (template.content.length > 0 && template.content[0]["propertyPath"]) {
	                    this._appendChild(contentItems_1, this._generateContent(prop, template.content, template), PopupTemplate.Css.item);
	                }
	                else {
	                    template.content.forEach(function (x) {
	                        _this._appendChild(contentItems_1, _this._generateContent(prop, x, template), PopupTemplate.Css.item);
	                    });
	                }
	            }
	            else {
	                // If there is a description property, and no other properties, don't generate a table.
	                var propCount_1 = 0;
	                if (prop.description) {
	                    Object.keys(prop).forEach(function (k) {
	                        if (!_this._ignoreProperty(k, prop[k])) {
	                            propCount_1++;
	                        }
	                    });
	                }
	                var c = void 0;
	                // If there is only one property (description), or two (description + Snippet (KML)),
	                // or a flag to only display description, only add the description to the content.
	                if (propCount_1 === 1 ||
	                    (template.singleDescription && prop.description) ||
	                    (propCount_1 === 2 && prop.Snippet)) {
	                    c = document.createElement("div");
	                    c.innerHTML = prop.description;
	                }
	                else {
	                    c = this._generateContent(prop, template.content, template);
	                }
	                this._appendChild(contentItems_1, c, PopupTemplate.Css.item);
	            }
	            if (contentItems_1.innerHTML !== "") {
	                if (template.sandboxContent) {
	                    container.appendChild(PopupTemplate._createSandboxedIframe(contentItems_1, template));
	                }
	                else {
	                    container.appendChild(contentItems_1);
	                }
	            }
	        }
	        return container;
	    };
	    //////////////////////
	    /// Private functions
	    //////////////////////
	    /**
	     * Generates a sandboxed iframe that contains the specified content.
	     * @param content The content to sandbox.
	     */
	    PopupTemplate._createSandboxedIframe = function (content, template) {
	        var iframe = document.createElement("iframe");
	        iframe.sandbox.add("allow-popups");
	        var c = content.innerHTML;
	        // Need to estimate size of content and defined iframe size accordingly.
	        // Can't measure content in iframe without using cross-site scripting,
	        // so analyzing content HTML string instead for safety.
	        var hasMedia = false;
	        var lineLength = 100;
	        var width = 550;
	        var height = 10;
	        var longestStringLength = 0;
	        if (document.body.scrollWidth <= 340) {
	            width = 300;
	            lineLength = 50;
	        }
	        var lines = c.split(/<(tr|div|br|li|h[0-9]|p>)/);
	        longestStringLength = Math.max.apply(Math, __spread((lines.map(function (el) { return el.replace(/<[a-zA-Z0-9\s=\/]+>/g, "").length; })))) - 1;
	        var w = Math.ceil(longestStringLength * 3.5);
	        if (w < width) {
	            width = w;
	            lineLength = longestStringLength;
	        }
	        // Check to see if the content contains an image.
	        if (c.includes("<img") || c.includes("<video")) {
	            hasMedia = true;
	            iframe.width = "550px";
	        }
	        else {
	            var rowHeight = (c.indexOf(PopupTemplate.Css.table) > -1) ? 25 : 20;
	            height += Math.max(lines.length * 0.5 * rowHeight, Math.ceil(c.replace(/<[a-zA-Z0-9\s=\/]+>/g, "").length / lineLength) * rowHeight);
	        }
	        iframe.width = width + "px";
	        if (hasMedia || height > 280) {
	            // If there is an image in the content, then max out content height.
	            iframe.height = "280px";
	        }
	        else {
	            iframe.height = height + "px";
	        }
	        var textColor = (template.textColor) ? "color:" + template.textColor + ";" : "";
	        var bgColor = (template.fillColor) ? "background-color:" + template.fillColor + ";" : "";
	        // Wrap content with some HTML and CSS.
	        var doc = '<html><head><title></title><meta charset="utf-8" /><meta http-equiv="x-ua-compatible" content="IE=Edge" />' +
	            ("<link rel=\"stylesheet\" href=\"" + PopupTemplate._cssUrl + "\" type=\"text/css\"/>") +
	            ("<style>html, body{margin:0;padding:0;" + textColor + bgColor + "}</style></head>") +
	            ("<body><div class=\"" + PopupTemplate.Css.template + "\" style=\"padding:0;width:" + (width - 20) + "px\">" + c + "</div></body></html>");
	        // Check to see if srcdoc of iframe is supported (versions of Edge, pre-chromium, do not support srcdoc)
	        if (iframe.srcdoc === undefined) {
	            // Non-chromium versions of Edge do not support srcdoc property on iframes.
	            // In order to inject inline HTML into an iframe in a secure way, we have to pass in an encoded string.
	            // This has a limitation of only working with shorter strings
	            // (< 1,600 characters when encoded, assuming our CSS doesn't increase in size).
	            iframe.src = "data:text/html;charset=utf-8," + encodeURI(doc);
	        }
	        else {
	            iframe.srcdoc = doc;
	        }
	        return iframe;
	    };
	    /**
	     * Appends an HTML element as a child of another element and adds a class name to the child if specified.
	     * @param container The container to add the child element to.
	     * @param child The child element to add.
	     * @param className The class name to add to the child element.
	     */
	    PopupTemplate._appendChild = function (container, child, className) {
	        if (child) {
	            if (className) {
	                child.className = ((child.className) ? child.className + " " : "") + className;
	            }
	            container.appendChild(child);
	        }
	    };
	    /**
	     * Generates the popup content based on the template and available properties.
	     * @param properties The properties to apply to the template.
	     * @param content The template content.
	     * @param template The templates.
	     */
	    PopupTemplate._generateContent = function (properties, content, template) {
	        if (content) {
	            if (Array.isArray(content)) {
	                // Content is an array of PropertyInfo.
	                return this._generatePropertyInfoTable(properties, content, template);
	            }
	            else {
	                return this._applyStringTemplate(properties, content, template);
	            }
	        }
	        var t = this._generateDynamicTableHtml(properties, null, template);
	        if (t) {
	            var d = document.createElement("div");
	            d.innerHTML = t;
	            return d;
	        }
	        return null;
	    };
	    /**
	     * Replaces placeholders with the property values in a string template.
	     * @param properties The properties to use.
	     * @param stringTemplate The string template to apply.
	     * @param template The template.
	     */
	    PopupTemplate._applyStringTemplate = function (properties, stringTemplate, template) {
	        if (stringTemplate) {
	            var content = stringTemplate;
	            var matches = this._placeholderRx.exec(stringTemplate);
	            // Search the template string using a regular expression.
	            while (matches) {
	                if (matches.length >= 2) {
	                    // Get the property path within a placeholder.
	                    var propValue = this._getPropertyValue(properties, matches[1], template);
	                    content = content.replace(matches[0], propValue);
	                }
	                matches = this._placeholderRx.exec(stringTemplate);
	            }
	            if (content) {
	                content = content.trim();
	                // If there is no HTML tags, replace newline characters with HTML line breaks.
	                if (content.includes("<")) {
	                    content = content.replace(/[\r\n]+/g, "<br/>");
	                }
	                var d = document.createElement("div");
	                d.innerHTML = content;
	                return d;
	            }
	        }
	        return null;
	    };
	    /**
	     * Retrieves the value of a property using its path.
	     * @param properties The set of properties to search from.
	     * @param propertyPath The path of the property.
	     * @param template The template.
	     * @param propertyInfo Property info to apply which specifies how the values should be displayed.
	     */
	    PopupTemplate._getPropertyValue = function (properties, propertyPath, template, propertyInfo) {
	        var path = template.parsePropertyPaths ? propertyPath.split("/") : [propertyPath];
	        var len = path.length;
	        if (len > 0 && properties) {
	            var key = path[0];
	            var obj = properties[key];
	            // Special case where a link may be a flattened link value from a atom feed.
	            if (template.detectHyperlinks && propertyPath === "link" &&
	                (!propertyInfo || propertyInfo.hyperlinkFormat)) {
	                var links_1 = [];
	                if (Array.isArray(obj)) {
	                    obj.forEach(function (l) {
	                        if (l.href) {
	                            links_1.push(l);
	                        }
	                        else if (typeof l === "string") {
	                            links_1.push({
	                                href: l
	                            });
	                        }
	                    });
	                }
	                else if (obj.href) {
	                    links_1.push(obj);
	                }
	                if (links_1.length > 0) {
	                    var f_1;
	                    if (propertyInfo && propertyInfo.hyperlinkFormat) {
	                        f_1 = propertyInfo.hyperlinkFormat;
	                    }
	                    else if (template && template.hyperlinkFormat) {
	                        f_1 = template.hyperlinkFormat;
	                    }
	                    var t_1;
	                    if (f_1 && f_1.target) {
	                        t_1 = f_1.target;
	                    }
	                    else {
	                        t_1 = "_blank";
	                    }
	                    var html_1 = [];
	                    links_1.forEach(function (l) {
	                        if (!l.title && (!f_1 || !f_1.label) && l.rel) {
	                            html_1.push(l.rel, " - ");
	                        }
	                        html_1.push('<a href="', l.href, '" target="', t_1, '">');
	                        if (l.title) {
	                            html_1.push(l.title);
	                        }
	                        else if (f_1 && f_1.label) {
	                            html_1.push(f_1.label);
	                        }
	                        else {
	                            html_1.push(l.href);
	                        }
	                        html_1.push("</a>", "<br/>");
	                    });
	                    // Remove trailing <br/>
	                    html_1.pop();
	                    return html_1.join("");
	                }
	            }
	            if (obj != null) {
	                var i = void 0;
	                // Step through the property.
	                for (i = 1; i < len; i++) {
	                    obj = obj[path[i]];
	                    key = path[i];
	                    if (obj == null) {
	                        break;
	                    }
	                }
	                // Make sure that all properties were stepped through.
	                if (i === len && obj != null) {
	                    var propValue = void 0;
	                    if (typeof obj.value !== "undefined") {
	                        // Object is a SimpleField
	                        propValue = obj.value;
	                    }
	                    else {
	                        propValue = obj;
	                    }
	                    if (propValue instanceof Date) {
	                        if (propertyInfo && propertyInfo.dateFormat) {
	                            return propValue.toLocaleString(undefined, propertyInfo.dateFormat);
	                        }
	                        if (template.dateFormat) {
	                            return propValue.toLocaleString(undefined, template.dateFormat);
	                        }
	                        return propValue.toISOString();
	                    }
	                    else if (typeof propValue === "object") {
	                        // If the value of the property is an object, create a sub-table recursively.
	                        var t = this._generateDynamicTableHtml(propValue, path.slice(1), template);
	                        return (t) ? t : "";
	                    }
	                    else if (typeof propValue === "number") {
	                        if (propertyInfo) {
	                            if (propertyInfo.dateFormat) {
	                                // If the user assigned a date format to the field and the value is a number,
	                                // then assume that the number is the number of milliseconds.
	                                return new Date(propValue).toLocaleString(undefined, propertyInfo.dateFormat);
	                            }
	                            if (propertyInfo.numberFormat) {
	                                return propValue.toLocaleString(undefined, propertyInfo.numberFormat);
	                            }
	                        }
	                        else if (/(timestamp|date)/gi.test(key)) {
	                            // If the property name includes "timestamp" or "date" in it assume the number represents a Date object.
	                            return new Date(propValue).toISOString();
	                        }
	                        return propValue.toLocaleString(undefined, template.numberFormat);
	                    }
	                    else if (typeof propValue === "string" && propValue !== "" && !(/[\n\r<>\s]/g.test(propValue)) &&
	                        (template.detectHyperlinks || (propertyInfo && propertyInfo.hyperlinkFormat))) {
	                        // If the value is a string and doesn't include newline, spaces or xml <> characters,
	                        // then consider rendering as a hyperlink.
	                        propValue = propValue.trim();
	                        var isLink = this._isUrlRx.test(propValue) || (propertyInfo && propertyInfo.hyperlinkFormat);
	                        var isImage = this._isImageUrlRx.test(propValue) && (isLink || propValue.startsWith("data:image"));
	                        var isEmail = this._emailRx.test(propValue);
	                        if (isLink || isImage || isEmail) {
	                            var h = void 0;
	                            if (propertyInfo && propertyInfo.hyperlinkFormat) {
	                                h = propertyInfo.hyperlinkFormat;
	                            }
	                            else if (template && template.hyperlinkFormat) {
	                                h = template.hyperlinkFormat;
	                            }
	                            var t = void 0;
	                            if (h && h.target) {
	                                t = " target=\"" + h.target + "\"";
	                            }
	                            else {
	                                t = ' target="_blank"';
	                            }
	                            var c = "" + (h && h.label ? h.label : propValue);
	                            if (h && h.scheme) {
	                                propValue = h.scheme + propValue;
	                            }
	                            else if (isEmail) {
	                                propValue = "mailto:" + propValue;
	                            }
	                            var alt = h && h.label ? " alt=\"" + h.label + "\"" : "";
	                            if ((h && h.isImage) || isImage) {
	                                c = "<img src=\"" + propValue + "\" style=\"max-width:100%\"" + alt + "\"/>";
	                            }
	                            return "<a href=\"" + propValue + "\"" + t + ">" + c + "</a>";
	                        }
	                    }
	                    var p = propValue.toString();
	                    return p;
	                }
	            }
	        }
	        return "";
	    };
	    /**
	     * Generates a table from a set of properties filtered on an array of property info values.
	     * @param properties The properties.
	     * @param propertyInfo The property info values that specify which properties to display and how to display them.
	     * @param template The template.
	     */
	    PopupTemplate._generatePropertyInfoTable = function (properties, propertyInfo, template) {
	        if (properties && propertyInfo && propertyInfo.length > 0) {
	            var html_2 = [];
	            var self_1 = this;
	            // Create a HTML table from an objects property names and values.
	            html_2.push("<table class=\"" + self_1.Css.table + "\">");
	            propertyInfo.forEach(function (pi) {
	                var c = self_1._getPropertyValue(properties, pi.propertyPath, template, pi);
	                if (pi.hideLabel) {
	                    html_2.push('<tr><td colspan="2">', c, "</td></tr>");
	                }
	                else {
	                    var l = pi.label || pi.propertyPath.split("/")[0];
	                    html_2.push("<tr><th>", l, "</th><td>", c, "</td></tr>");
	                }
	            });
	            html_2.push("</table>");
	            var d = document.createElement("div");
	            d.innerHTML = html_2.join("");
	            return d;
	        }
	        return null;
	    };
	    /**
	     * Dynamically creates a table from the property information. Recursively steps through the property tree.
	     * @param properties The properties to generate a table for.
	     * @param subPath The sub-path within the properties to generate the table for.
	     * @param template The template.
	     */
	    PopupTemplate._generateDynamicTableHtml = function (properties, subPath, template) {
	        var _this = this;
	        if (properties) {
	            var html_3 = [];
	            var self_2 = this;
	            // Create a HTML table from an objects property names and values.
	            html_3.push("<table class=\"" + self_2.Css.table + "\">");
	            var sp_1 = (subPath && subPath.length > 0) ? subPath.join("/") + "/" : "";
	            // Count the number of rows actually added to table.
	            var cnt_1 = 0;
	            Object.keys(properties).forEach(function (key) {
	                // Ignore private properties which are commonly denoted using an underscore, and style properties.
	                if (!_this._ignoreProperty(key, properties[key])) {
	                    html_3.push("<tr><th>", key, "</th><td>", self_2._getPropertyValue(properties, sp_1 + key, template), "</td></tr>");
	                    cnt_1++;
	                }
	            });
	            // If no rows added, don't return a table.
	            if (cnt_1 === 0) {
	                return null;
	            }
	            html_3.push("</table>");
	            return html_3.join("");
	        }
	        return null;
	    };
	    /**
	     * Checks to see if the property should be ignored based on the key or value.
	     * @param key The property name key.
	     * @param value The value of the property.
	     */
	    PopupTemplate._ignoreProperty = function (key, value) {
	        switch (key) {
	            // Ignore style and title properties.
	            case "title":
	            case "name":
	            case "base":
	            case "popupTemplate":
	            case "anchor":
	            case "icon":
	            case "image":
	            case "imageUrl":
	            case "rotation":
	            case "color":
	            case "size":
	            case "offset":
	            case "strokeColor":
	            case "strokeWidth":
	            case "strokeOpacity":
	            case "subType":
	            case "fillColor":
	            case "fillOpacity":
	            case "visibility":
	            case "visible":
	                return true;
	            default:
	                if (key.indexOf("_") === 0 || value == null || value === "") {
	                    return true;
	                }
	                break;
	        }
	        return false;
	    };
	    //////////////////////
	    /// Private properties
	    //////////////////////
	    /** Regular expression for content property placeholders. */
	    PopupTemplate._placeholderRx = /\{([a-zA-Z0-9_\/\s]+)\}/gi;
	    /** Regular expression for external URLs. */
	    PopupTemplate._isUrlRx = /^(http|https|ftp|tel|mailto):\/\//i;
	    /** Regular expression for image urls. */
	    PopupTemplate._isImageUrlRx = /(^data:image|.png$|.jpg$|.jpeg$|.gif$|.bmp$|.svg|.tif|.tiff$)/i;
	    /** Regular expression for email addresses. */
	    PopupTemplate._emailRx = /^[^\.\s@:](?:[^\s@:]*[^\s@:\.])?@[^\.\s@]+(?:\.[^\.\s@]+)*$/;
	    /** The URL to load our CSS from for iframed popups. */
	    PopupTemplate._cssUrl = new Url({
	        domain: env.staticAssetsDomain,
	        path: "sdk/javascript/mapcontrol/" + Version.getEndpointVersion() + "/atlas.min.css"
	    }).toString();
	    PopupTemplate.Css = {
	        template: "azure-maps-control-popup-template",
	        title: "azure-maps-control-popup-template-title",
	        content: "azure-maps-control-popup-template-content",
	        item: "azure-maps-control-popup-template-content-item",
	        table: "azure-maps-control-popup-template-table"
	    };
	    return PopupTemplate;
	}());

	// Set the mapbox Right-To-Left Text Plugin
	var rtlPluginUrl = new Url({
	    domain: env.staticAssetsDomain,
	    path: "sdk/javascript/mapcontrol/" + Version.getEndpointVersion() + "/mapbox-gl-rtl-text.min.js"
	});
	azuremapsMaplibreGlUnminified_2(rtlPluginUrl.toString(), function (error) {
	    if (error) {
	        console.warn(error);
	    }
	}, true);

	exports.HtmlMarker = HtmlMarker;
	exports.Map = Map$2;
	exports.Pixel = Pixel;
	exports.Popup = Popup;
	exports.PopupTemplate = PopupTemplate;
	exports.Shape = Shape;
	exports._getAssetDomain = _getAssetDomain;
	exports._getDomain = _getDomain;
	exports._hasMaxParallelImageRequests = _hasMaxParallelImageRequests;
	exports._hasSetAuthenticationOptions = _hasSetAuthenticationOptions;
	exports._hasSetDomain = _hasSetDomain;
	exports._hasSetLanguage = _hasSetLanguage;
	exports._hasSetSessionId = _hasSetSessionId;
	exports._hasSetStyleDefinitionsPath = _hasSetStyleDefinitionsPath;
	exports._hasSetStyleDefinitionsVersion = _hasSetStyleDefinitionsVersion;
	exports._hasSetView = _hasSetView;
	exports._hasWorkerCount = _hasWorkerCount;
	exports.addImageTemplate = addImageTemplate;
	exports.clearPrewarmedResources = clearPrewarmedResources;
	exports.control = index$3;
	exports.data = index$2;
	exports.getAllImageTemplateNames = getAllImageTemplateNames;
	exports.getAuthenticationOptions = getAuthenticationOptions;
	exports.getDomain = getDomain;
	exports.getImageTemplate = getImageTemplate;
	exports.getLanguage = getLanguage;
	exports.getMaxParallelImageRequests = getMaxParallelImageRequests;
	exports.getSessionId = getSessionId;
	exports.getStaticAssetsDomain = getStaticAssetsDomain;
	exports.getStyleDefinitionsPath = getStyleDefinitionsPath;
	exports.getStyleDefinitionsVersion = getStyleDefinitionsVersion;
	exports.getSubscriptionKey = getSubscriptionKey;
	exports.getUserRegion = getUserRegion;
	exports.getVersion = getVersion;
	exports.getView = getView;
	exports.getWorkerCount = getWorkerCount;
	exports.internal = index;
	exports.isSupported = isSupported;
	exports.layer = index$5;
	exports.math = index$1;
	exports.prewarm = prewarm;
	exports.setAuthenticationOptions = setAuthenticationOptions;
	exports.setDomain = setDomain;
	exports.setLanguage = setLanguage;
	exports.setMaxParallelImageRequests = setMaxParallelImageRequests;
	exports.setSessionId = setSessionId;
	exports.setStyleDefinitionsPath = setStyleDefinitionsPath;
	exports.setStyleDefinitionsVersion = setStyleDefinitionsVersion;
	exports.setSubscriptionKey = setSubscriptionKey;
	exports.setUserRegion = setUserRegion;
	exports.setView = setView;
	exports.setWorkerCount = setWorkerCount;
	exports.source = index$4;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
